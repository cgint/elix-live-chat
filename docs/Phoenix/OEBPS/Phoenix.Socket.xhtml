<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Phoenix.Socket - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Phoenix.Socket <small>behaviour</small>
    </h1>


      <section id="moduledoc" class="docstring">
<p>A socket implementation that multiplexes messages over channels.</p><p><a href="Phoenix.Socket.xhtml"><code class="inline">Phoenix.Socket</code></a> is used as a module for establishing a connection
between client and server. Once the connection is established,
the initial state is stored in the <a href="Phoenix.Socket.xhtml"><code class="inline">Phoenix.Socket</code></a> struct.</p><p>The same socket can be used to receive events from different transports.
Phoenix supports <code class="inline">websocket</code> and <code class="inline">longpoll</code> options when invoking
<a href="Phoenix.Endpoint.xhtml#socket/3"><code class="inline">Phoenix.Endpoint.socket/3</code></a> in your endpoint. <code class="inline">websocket</code> is set by default
and <code class="inline">longpoll</code> can also be configured explicitly.</p><pre><code class="makeup elixir" translate="no"><samp class="n">socket</samp><samp class="w"> </samp><samp class="s">&quot;/socket&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">MyAppWeb.Socket</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">websocket</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">true</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">longpoll</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp></code></pre><p>The command above means incoming socket connections can be made via
a WebSocket connection. Incoming and outgoing events are routed to
channels by topic:</p><pre><code class="makeup elixir" translate="no"><samp class="n">channel</samp><samp class="w"> </samp><samp class="s">&quot;room:lobby&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">MyAppWeb.LobbyChannel</samp></code></pre><p>See <a href="Phoenix.Channel.xhtml"><code class="inline">Phoenix.Channel</code></a> for more information on channels.</p><h2 id="module-socket-behaviour" class="section-heading">
  <a href="#module-socket-behaviour" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Socket Behaviour</span>
</h2>
<p>Socket handlers are mounted in Endpoints and must define two callbacks:</p><ul><li><p><code class="inline">connect/3</code> - receives the socket params, connection info if any, and
authenticates the connection. Must return a <a href="Phoenix.Socket.xhtml"><code class="inline">Phoenix.Socket</code></a> struct,
often with custom assigns</p></li><li><p><code class="inline">id/1</code> - receives the socket returned by <code class="inline">connect/3</code> and returns the
id of this connection as a string. The <code class="inline">id</code> is used to identify socket
connections, often to a particular user, allowing us to force disconnections.
For sockets requiring no authentication, <code class="inline">nil</code> can be returned</p></li></ul><h2 id="module-examples" class="section-heading">
  <a href="#module-examples" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Examples</span>
</h2>
<pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">MyAppWeb.UserSocket</samp><samp class="w"> </samp><samp class="k" data-group-id="8305895206-1">do</samp><samp class="w">
  </samp><samp class="kn">use</samp><samp class="w"> </samp><samp class="nc">Phoenix.Socket</samp><samp class="w">

  </samp><samp class="n">channel</samp><samp class="w"> </samp><samp class="s">&quot;room:*&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">MyAppWeb.RoomChannel</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">connect</samp><samp class="p" data-group-id="8305895206-2">(</samp><samp class="n">params</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="c">_connect_info</samp><samp class="p" data-group-id="8305895206-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="8305895206-3">do</samp><samp class="w">
    </samp><samp class="p" data-group-id="8305895206-4">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">assign</samp><samp class="p" data-group-id="8305895206-5">(</samp><samp class="n">socket</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:user_id</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">params</samp><samp class="p" data-group-id="8305895206-6">[</samp><samp class="s">&quot;user_id&quot;</samp><samp class="p" data-group-id="8305895206-6">]</samp><samp class="p" data-group-id="8305895206-5">)</samp><samp class="p" data-group-id="8305895206-4">}</samp><samp class="w">
  </samp><samp class="k" data-group-id="8305895206-3">end</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">id</samp><samp class="p" data-group-id="8305895206-7">(</samp><samp class="n">socket</samp><samp class="p" data-group-id="8305895206-7">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;users_socket:</samp><samp class="si" data-group-id="8305895206-8">#{</samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">user_id</samp><samp class="si" data-group-id="8305895206-8">}</samp><samp class="s">&quot;</samp><samp class="w">
</samp><samp class="k" data-group-id="8305895206-1">end</samp><samp class="w">

</samp><samp class="c1"># Disconnect all user&#39;s socket connections and their multiplexed channels</samp><samp class="w">
</samp><samp class="nc">MyAppWeb.Endpoint</samp><samp class="o">.</samp><samp class="n">broadcast</samp><samp class="p" data-group-id="8305895206-9">(</samp><samp class="s">&quot;users_socket:&quot;</samp><samp class="w"> </samp><samp class="o">&lt;&gt;</samp><samp class="w"> </samp><samp class="n">user</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;disconnect&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8305895206-10">%{</samp><samp class="p" data-group-id="8305895206-10">}</samp><samp class="p" data-group-id="8305895206-9">)</samp></code></pre><h2 id="module-socket-fields" class="section-heading">
  <a href="#module-socket-fields" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Socket fields</span>
</h2>
<ul><li><code class="inline">:id</code> - The string id of the socket</li><li><code class="inline">:assigns</code> - The map of socket assigns, default: <code class="inline">%{}</code></li><li><code class="inline">:channel</code> - The current channel module</li><li><code class="inline">:channel_pid</code> - The channel pid</li><li><code class="inline">:endpoint</code> - The endpoint module where this socket originated, for example: <code class="inline">MyAppWeb.Endpoint</code></li><li><code class="inline">:handler</code> - The socket module where this socket originated, for example: <code class="inline">MyAppWeb.UserSocket</code></li><li><code class="inline">:joined</code> - If the socket has effectively joined the channel</li><li><code class="inline">:join_ref</code> - The ref sent by the client when joining</li><li><code class="inline">:ref</code> - The latest ref sent by the client</li><li><code class="inline">:pubsub_server</code> - The registered name of the socket's pubsub server</li><li><code class="inline">:topic</code> - The string topic, for example <code class="inline">&quot;room:123&quot;</code></li><li><code class="inline">:transport</code> - An identifier for the transport, used for logging</li><li><code class="inline">:transport_pid</code> - The pid of the socket's transport process</li><li><code class="inline">:serializer</code> - The serializer for socket messages</li></ul><h2 id="module-using-options" class="section-heading">
  <a href="#module-using-options" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using options</span>
</h2>
<p>On <code class="inline">use Phoenix.Socket</code>, the following options are accepted:</p><ul><li><p><code class="inline">:log</code> - the default level to log socket actions. Defaults
to <code class="inline">:info</code>. May be set to <code class="inline">false</code> to disable it</p></li><li><p><code class="inline">:partitions</code> - each channel is spawned under a supervisor.
This option controls how many supervisors will be spawned
to handle channels. Defaults to the number of cores.</p></li></ul><h2 id="module-garbage-collection" class="section-heading">
  <a href="#module-garbage-collection" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Garbage collection</span>
</h2>
<p>It's possible to force garbage collection in the transport process after
processing large messages. For example, to trigger such from your channels,
run:</p><pre><code class="makeup elixir" translate="no"><samp class="n">send</samp><samp class="p" data-group-id="0086826979-1">(</samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">transport_pid</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:garbage_collect</samp><samp class="p" data-group-id="0086826979-1">)</samp></code></pre><p>Alternatively, you can configure your endpoint socket to trigger more
fullsweep garbage collections more frequently, by setting the <code class="inline">:fullsweep_after</code>
option for websockets. See <a href="Phoenix.Endpoint.xhtml#socket/3"><code class="inline">Phoenix.Endpoint.socket/3</code></a> for more info.</p><h2 id="module-client-server-communication" class="section-heading">
  <a href="#module-client-server-communication" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Client-server communication</span>
</h2>
<p>The encoding of server data and the decoding of client data is done
according to a serializer, defined in <a href="Phoenix.Socket.Serializer.xhtml"><code class="inline">Phoenix.Socket.Serializer</code></a>.
By default, JSON encoding is used to broker messages to and from clients.</p><p>The serializer <code class="inline">decode!</code> function must return a <a href="Phoenix.Socket.Message.xhtml"><code class="inline">Phoenix.Socket.Message</code></a>
which is forwarded to channels except:</p><ul><li><code class="inline">&quot;heartbeat&quot;</code> events in the &quot;phoenix&quot; topic - should just emit an OK reply</li><li><code class="inline">&quot;phx_join&quot;</code> on any topic - should join the topic</li><li><code class="inline">&quot;phx_leave&quot;</code> on any topic - should leave the topic</li></ul><p>Each message also has a <code class="inline">ref</code> field which is used to track responses.</p><p>The server may send messages or replies back. For messages, the
ref uniquely identifies the message. For replies, the ref matches
the original message. Both data-types also include a join_ref that
uniquely identifies the currently joined channel.</p><p>The <a href="Phoenix.Socket.xhtml"><code class="inline">Phoenix.Socket</code></a> implementation may also send special messages
and replies:</p><ul><li><p><code class="inline">&quot;phx_error&quot;</code> - in case of errors, such as a channel process
crashing, or when attempting to join an already joined channel</p></li><li><p><code class="inline">&quot;phx_close&quot;</code> - the channel was gracefully closed</p></li></ul><p>Phoenix ships with a JavaScript implementation of both websocket
and long polling that interacts with Phoenix.Socket and can be
used as reference for those interested in implementing custom clients.</p><h2 id="module-custom-sockets-and-transports" class="section-heading">
  <a href="#module-custom-sockets-and-transports" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Custom sockets and transports</span>
</h2>
<p>See the <a href="Phoenix.Socket.Transport.xhtml"><code class="inline">Phoenix.Socket.Transport</code></a> documentation for more information on
writing your own socket that does not leverage channels or for writing
your own transports that interacts with other sockets.</p><h2 id="module-custom-channels" class="section-heading">
  <a href="#module-custom-channels" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Custom channels</span>
</h2>
<p>You can list any module as a channel as long as it implements
a <code class="inline">child_spec/1</code> function. The <code class="inline">child_spec/1</code> function receives
the caller as argument and it must return a child spec that
initializes a process.</p><p>Once the process is initialized, it will receive the following
message:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="2369644132-1">{</samp><samp class="nc">Phoenix.Channel</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">auth_payload</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">from</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="2369644132-1">}</samp></code></pre><p>A custom channel implementation MUST invoke
<code class="inline">GenServer.reply(from, {:ok | :error, reply_payload})</code> during its
initialization with a custom <code class="inline">reply_payload</code> that will be sent as
a reply to the client. Failing to do so will block the socket forever.</p><p>A custom channel receives <a href="Phoenix.Socket.Message.xhtml"><code class="inline">Phoenix.Socket.Message</code></a> structs as regular
messages from the transport. Replies to those messages and custom
messages can be sent to the socket at any moment by building an
appropriate <a href="Phoenix.Socket.Reply.xhtml"><code class="inline">Phoenix.Socket.Reply</code></a> and <a href="Phoenix.Socket.Message.xhtml"><code class="inline">Phoenix.Socket.Message</code></a>
structs, encoding them with the serializer and dispatching the
serialized result to the transport.</p><p>For example, to handle &quot;phx_leave&quot; messages, which is recommended
to be handled by all channel implementations, one may do:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_info</samp><samp class="p" data-group-id="6388694331-1">(</samp><samp class="w">
      </samp><samp class="p" data-group-id="6388694331-2">%</samp><samp class="nc" data-group-id="6388694331-2">Message</samp><samp class="p" data-group-id="6388694331-2">{</samp><samp class="ss">topic</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">topic</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">event</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;phx_leave&quot;</samp><samp class="p" data-group-id="6388694331-2">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">message</samp><samp class="p">,</samp><samp class="w">
      </samp><samp class="p" data-group-id="6388694331-3">%{</samp><samp class="ss">topic</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">topic</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">serializer</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">serializer</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">transport_pid</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">transport_pid</samp><samp class="p" data-group-id="6388694331-3">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="w">
    </samp><samp class="p" data-group-id="6388694331-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="6388694331-4">do</samp><samp class="w">
  </samp><samp class="n">send</samp><samp class="w"> </samp><samp class="n">transport_pid</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">serializer</samp><samp class="o">.</samp><samp class="n">encode!</samp><samp class="p" data-group-id="6388694331-5">(</samp><samp class="n">build_leave_reply</samp><samp class="p" data-group-id="6388694331-6">(</samp><samp class="n">message</samp><samp class="p" data-group-id="6388694331-6">)</samp><samp class="p" data-group-id="6388694331-5">)</samp><samp class="w">
  </samp><samp class="p" data-group-id="6388694331-7">{</samp><samp class="ss">:stop</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6388694331-8">{</samp><samp class="ss">:shutdown</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:left</samp><samp class="p" data-group-id="6388694331-8">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="6388694331-7">}</samp><samp class="w">
</samp><samp class="k" data-group-id="6388694331-4">end</samp></code></pre><p>A special message delivered to all channels is a Broadcast with
event &quot;phx_drain&quot;, which is sent when draining the socket during
application shutdown. Typically it is handled by sending a drain
message to the transport, causing it to shutdown:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_info</samp><samp class="p" data-group-id="9107343794-1">(</samp><samp class="w">
      </samp><samp class="p" data-group-id="9107343794-2">%</samp><samp class="nc" data-group-id="9107343794-2">Broadcast</samp><samp class="p" data-group-id="9107343794-2">{</samp><samp class="ss">event</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;phx_drain&quot;</samp><samp class="p" data-group-id="9107343794-2">}</samp><samp class="p">,</samp><samp class="w">
      </samp><samp class="p" data-group-id="9107343794-3">%{</samp><samp class="ss">transport_pid</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">transport_pid</samp><samp class="p" data-group-id="9107343794-3">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="w">
    </samp><samp class="p" data-group-id="9107343794-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="9107343794-4">do</samp><samp class="w">
  </samp><samp class="n">send</samp><samp class="p" data-group-id="9107343794-5">(</samp><samp class="n">transport_pid</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:socket_drain</samp><samp class="p" data-group-id="9107343794-5">)</samp><samp class="w">
  </samp><samp class="p" data-group-id="9107343794-6">{</samp><samp class="ss">:stop</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="9107343794-7">{</samp><samp class="ss">:shutdown</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:draining</samp><samp class="p" data-group-id="9107343794-7">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="9107343794-6">}</samp><samp class="w">
</samp><samp class="k" data-group-id="9107343794-4">end</samp></code></pre><p>We also recommend all channels to monitor the <code class="inline">transport_pid</code>
on <code class="inline">init</code> and exit if the transport exits. We also advise to rewrite
<code class="inline">:normal</code> exit reasons (usually due to the socket being closed)
to the <code class="inline">{:shutdown, :closed}</code> to guarantee links are broken on
the channel exit (as a <code class="inline">:normal</code> exit does not break links):</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_info</samp><samp class="p" data-group-id="3440454469-1">(</samp><samp class="p" data-group-id="3440454469-2">{</samp><samp class="ss">:DOWN</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="bp">_</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="bp">_</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">transport_pid</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">reason</samp><samp class="p" data-group-id="3440454469-2">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3440454469-3">%{</samp><samp class="ss">transport_pid</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">transport_pid</samp><samp class="p" data-group-id="3440454469-3">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="3440454469-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="3440454469-4">do</samp><samp class="w">
  </samp><samp class="n">reason</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="k">if</samp><samp class="w"> </samp><samp class="n">reason</samp><samp class="w"> </samp><samp class="o">==</samp><samp class="w"> </samp><samp class="ss">:normal</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="3440454469-5">{</samp><samp class="ss">:shutdown</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:closed</samp><samp class="p" data-group-id="3440454469-5">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">else</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">reason</samp><samp class="w">
  </samp><samp class="p" data-group-id="3440454469-6">{</samp><samp class="ss">:stop</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">reason</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="3440454469-6">}</samp><samp class="w">
</samp><samp class="k" data-group-id="3440454469-4">end</samp></code></pre><p>Any process exit is treated as an error by the socket layer unless
a <code class="inline">{:socket_close, pid, reason}</code> message is sent to the socket before
shutdown.</p><p>Custom channel implementations cannot be tested with <a href="Phoenix.ChannelTest.xhtml"><code class="inline">Phoenix.ChannelTest</code></a>.</p>
      </section>


      <section id="summary" class="details-list">
        <h1 class="section-heading">Summary</h1>
<div class="summary-types summary">
  <h2>
    <a href="#types">Types</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#t:t/0" data-no-tooltip="" translate="no">t()</a>

      </div>

    </div>

</div>
<div class="summary-callbacks summary">
  <h2>
    <a href="#callbacks">Callbacks</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#c:connect/2" data-no-tooltip="" translate="no">connect(params, t)</a>

      </div>

        <div class="summary-synopsis"><p>Shortcut version of <code class="inline">connect/3</code> which does not receive <code class="inline">connect_info</code>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#c:connect/3" data-no-tooltip="" translate="no">connect(params, t, connect_info)</a>

      </div>

        <div class="summary-synopsis"><p>Receives the socket params and authenticates the connection.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#c:id/1" data-no-tooltip="" translate="no">id(t)</a>

      </div>

        <div class="summary-synopsis"><p>Identifies the socket connection.</p></div>

    </div>

</div>
<div class="summary-functions summary">
  <h2>
    <a href="#functions">Functions</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#assign/2" data-no-tooltip="" translate="no">assign(socket, attrs)</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#assign/3" data-no-tooltip="" translate="no">assign(socket, key, value)</a>

      </div>

        <div class="summary-synopsis"><p>Adds key-value pairs to socket assigns.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#channel/3" data-no-tooltip="" translate="no">channel(topic_pattern, module, opts \\ [])</a>

      </div>

        <div class="summary-synopsis"><p>Defines a channel matching the given topic and transports.</p></div>

    </div>

</div>

      </section>


      <section id="types" class="details-list">
        <h1 class="section-heading">Types</h1>
        <div class="types-list">
<section class="detail" id="t:t/0">

  <div class="detail-header">
    <a href="#t:t/0" class="detail-link" data-no-tooltip="" aria-label="Link to this type">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">t()</h1>


        <a href="https://github.com/phoenixframework/phoenix/blob/v1.7.21/lib/phoenix/socket.ex#L274" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@type</span> t() :: %Phoenix.Socket{
  assigns: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(),
  channel: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  channel_pid: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">pid</a>(),
  endpoint: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  handler: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  id: <a href="https://hexdocs.pm/elixir/String.html#t:t/0">String.t</a>() | nil,
  join_ref: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(),
  joined: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">boolean</a>(),
  private: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(),
  pubsub_server: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  ref: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(),
  serializer: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  topic: <a href="https://hexdocs.pm/elixir/String.html#t:t/0">String.t</a>(),
  transport: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
  transport_pid: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">pid</a>()
}</pre>

      </div>


  </section>
</section>

        </div>
      </section>

      <section id="callbacks" class="details-list">
        <h1 class="section-heading">Callbacks</h1>
        <div class="callbacks-list">
<section class="detail" id="c:connect/2">

  <div class="detail-header">
    <a href="#c:connect/2" class="detail-link" data-no-tooltip="" aria-label="Link to this callback">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">connect(params, t)</h1>

        <span class="note">(optional)</span>


        <a href="https://github.com/phoenixframework/phoenix/blob/v1.7.21/lib/phoenix/socket.ex#L231" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@callback</span> connect(params :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), <a href="#t:t/0">t</a>()) :: {:ok, <a href="#t:t/0">t</a>()} | {:error, <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()} | :error</pre>

      </div>

<p>Shortcut version of <code class="inline">connect/3</code> which does not receive <code class="inline">connect_info</code>.</p><p>Provided for backwards compatibility.</p>
  </section>
</section>
<section class="detail" id="c:connect/3">

  <div class="detail-header">
    <a href="#c:connect/3" class="detail-link" data-no-tooltip="" aria-label="Link to this callback">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">connect(params, t, connect_info)</h1>

        <span class="note">(optional)</span>


        <a href="https://github.com/phoenixframework/phoenix/blob/v1.7.21/lib/phoenix/socket.ex#L223" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@callback</span> connect(params :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), <a href="#t:t/0">t</a>(), connect_info :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} | {:error, <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()} | :error</pre>

      </div>

<p>Receives the socket params and authenticates the connection.</p><h2 id="c:connect/3-socket-params-and-assigns" class="section-heading">
  <a href="#c:connect/3-socket-params-and-assigns" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Socket params and assigns</span>
</h2>
<p>Socket params are passed from the client and can
be used to verify and authenticate a user. After
verification, you can put default assigns into
the socket that will be set for all channels, ie</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="3972300164-1">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">assign</samp><samp class="p" data-group-id="3972300164-2">(</samp><samp class="n">socket</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:user_id</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">verified_user_id</samp><samp class="p" data-group-id="3972300164-2">)</samp><samp class="p" data-group-id="3972300164-1">}</samp></code></pre><p>To deny connection, return <code class="inline">:error</code> or <code class="inline">{:error, term}</code>. To control the
response the client receives in that case, <a href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#socket/3-websocket-configuration">define an error handler in the
websocket
configuration</a>.</p><p>See <a href="Phoenix.Token.xhtml"><code class="inline">Phoenix.Token</code></a> documentation for examples in
performing token verification on connect.</p>
  </section>
</section>
<section class="detail" id="c:id/1">

  <div class="detail-header">
    <a href="#c:id/1" class="detail-link" data-no-tooltip="" aria-label="Link to this callback">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">id(t)</h1>


        <a href="https://github.com/phoenixframework/phoenix/blob/v1.7.21/lib/phoenix/socket.ex#L247" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@callback</span> id(<a href="#t:t/0">t</a>()) :: <a href="https://hexdocs.pm/elixir/String.html#t:t/0">String.t</a>() | nil</pre>

      </div>

<p>Identifies the socket connection.</p><p>Socket IDs are topics that allow you to identify all sockets for a given user:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">id</samp><samp class="p" data-group-id="3665721803-1">(</samp><samp class="n">socket</samp><samp class="p" data-group-id="3665721803-1">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;users_socket:</samp><samp class="si" data-group-id="3665721803-2">#{</samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">user_id</samp><samp class="si" data-group-id="3665721803-2">}</samp><samp class="s">&quot;</samp></code></pre><p>Would allow you to broadcast a <code class="inline">&quot;disconnect&quot;</code> event and terminate
all active sockets and channels for a given user:</p><pre><code class="makeup elixir" translate="no"><samp class="nc">MyAppWeb.Endpoint</samp><samp class="o">.</samp><samp class="n">broadcast</samp><samp class="p" data-group-id="5764700269-1">(</samp><samp class="s">&quot;users_socket:&quot;</samp><samp class="w"> </samp><samp class="o">&lt;&gt;</samp><samp class="w"> </samp><samp class="n">user</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;disconnect&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5764700269-2">%{</samp><samp class="p" data-group-id="5764700269-2">}</samp><samp class="p" data-group-id="5764700269-1">)</samp></code></pre><p>Returning <code class="inline">nil</code> makes this socket anonymous.</p>
  </section>
</section>

        </div>
      </section>

      <section id="functions" class="details-list">
        <h1 class="section-heading">Functions</h1>
        <div class="functions-list">
<section class="detail" id="assign/2">

  <div class="detail-header">
    <a href="#assign/2" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">assign(socket, attrs)</h1>


        <a href="https://github.com/phoenixframework/phoenix/blob/v1.7.21/lib/phoenix/socket.ex#L350" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">


  </section>
</section>
<section class="detail" id="assign/3">

  <div class="detail-header">
    <a href="#assign/3" class="detail-link" data-no-tooltip="" aria-label="Link to this function">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">assign(socket, key, value)</h1>


        <a href="https://github.com/phoenixframework/phoenix/blob/v1.7.21/lib/phoenix/socket.ex#L346" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Adds key-value pairs to socket assigns.</p><p>A single key-value pair may be passed, a keyword list or map
of assigns may be provided to be merged into existing socket
assigns.</p><h2 id="assign/3-examples" class="section-heading">
  <a href="#assign/3-examples" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Examples</span>
</h2>
<pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">assign</samp><samp class="p" data-group-id="7427262539-1">(</samp><samp class="n">socket</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:name</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;Elixir&quot;</samp><samp class="p" data-group-id="7427262539-1">)</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">assign</samp><samp class="p" data-group-id="7427262539-2">(</samp><samp class="n">socket</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">name</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;Elixir&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">logo</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;💧&quot;</samp><samp class="p" data-group-id="7427262539-2">)</samp></code></pre>
  </section>
</section>
<section class="detail" id="channel/3">

    <span id="channel/2"></span>

  <div class="detail-header">
    <a href="#channel/3" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">channel(topic_pattern, module, opts \\ [])</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/phoenixframework/phoenix/blob/v1.7.21/lib/phoenix/socket.ex#L381" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Defines a channel matching the given topic and transports.</p><ul><li><code class="inline">topic_pattern</code> - The string pattern, for example <code class="inline">&quot;room:*&quot;</code>, <code class="inline">&quot;users:*&quot;</code>,
or <code class="inline">&quot;system&quot;</code></li><li><code class="inline">module</code> - The channel module handler, for example <code class="inline">MyAppWeb.RoomChannel</code></li><li><code class="inline">opts</code> - The optional list of options, see below</li></ul><h2 id="channel/3-options" class="section-heading">
  <a href="#channel/3-options" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Options</span>
</h2>
<ul><li><code class="inline">:assigns</code> - the map of socket assigns to merge into the socket on join</li></ul><h2 id="channel/3-examples" class="section-heading">
  <a href="#channel/3-examples" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Examples</span>
</h2>
<pre><code class="makeup elixir" translate="no"><samp class="n">channel</samp><samp class="w"> </samp><samp class="s">&quot;topic1:*&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">MyChannel</samp></code></pre><h2 id="channel/3-topic-patterns" class="section-heading">
  <a href="#channel/3-topic-patterns" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Topic Patterns</span>
</h2>
<p>The <code class="inline">channel</code> macro accepts topic patterns in two flavors. A splat (the <code class="inline">*</code>
character) argument can be provided as the last character to indicate a
<code class="inline">&quot;topic:subtopic&quot;</code> match. If a plain string is provided, only that topic will
match the channel handler. Most use-cases will use the <code class="inline">&quot;topic:*&quot;</code> pattern to
allow more versatile topic scoping.</p><p>See <a href="Phoenix.Channel.xhtml"><code class="inline">Phoenix.Channel</code></a> for more information</p>
  </section>
</section>

        </div>
      </section>


  </body>
</html>
