<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Controllers - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Controllers
    </h1>
<blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="installation.html">introductory guides</a> and got a Phoenix application <a href="up_and_running.html">up and running</a>.</p></blockquote><blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="request_lifecycle.html">request life-cycle guide</a>.</p></blockquote><p>Phoenix controllers act as intermediary modules. Their functions — called actions — are invoked from the router in response to HTTP requests. The actions, in turn, gather all the necessary data and perform all the necessary steps before invoking the view layer to render a template or returning a JSON response.</p><p>Phoenix controllers also build on the Plug package, and are themselves plugs. Controllers provide the functions to do almost anything we need to in an action. If we do find ourselves looking for something that Phoenix controllers don't provide, we might find what we're looking for in Plug itself. Please see the <a href="plug.html">Plug guide</a> or the <a href="https://hexdocs.pm/plug/1.15.3/Plug.html">Plug documentation</a> for more information.</p><p>A newly generated Phoenix app will have a single controller named <code class="inline">PageController</code>, which can be found at <code class="inline">lib/hello_web/controllers/page_controller.ex</code> which looks like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.PageController</span><span class="w"> </span><span class="k" data-group-id="9740096144-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:controller</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="9740096144-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="9740096144-2">)</span><span class="w"> </span><span class="k" data-group-id="9740096144-3">do</span><span class="w">
    </span><span class="n">render</span><span class="p" data-group-id="9740096144-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="p">,</span><span class="w"> </span><span class="ss">layout</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="9740096144-4">)</span><span class="w">
  </span><span class="k" data-group-id="9740096144-3">end</span><span class="w">
</span><span class="k" data-group-id="9740096144-1">end</span></code></pre><p>The first line below the module definition invokes the <code class="inline">__using__/1</code> macro of the <code class="inline">HelloWeb</code> module, which imports some useful modules.</p><p><code class="inline">PageController</code> gives us the <code class="inline">home</code> action to display the Phoenix <a href="http://localhost:4000/" title="">welcome page</a> associated with the default route Phoenix defines in the router.</p><h2 id="actions" class="section-heading">
  <a href="#actions" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Actions</span>
</h2>
<p>Controller actions are just functions. We can name them anything we like as long as they follow Elixir's naming rules. The only requirement we must fulfill is that the action name matches a route defined in the router.</p><p>For example, in <code class="inline">lib/hello_web/router.ex</code> we could change the action name in the default route that Phoenix gives us in a new app from <code class="inline">home</code>:</p><pre><code class="makeup elixir" translate="no"><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span></code></pre><p>to <code class="inline">index</code>:</p><pre><code class="makeup elixir" translate="no"><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:index</span></code></pre><p>as long as we change the action name in <code class="inline">PageController</code> to <code class="inline">index</code> as well, the <a href="http://localhost:4000/" title="">welcome page</a> will load as before.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.PageController</span><span class="w"> </span><span class="k" data-group-id="0158131565-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">index</span><span class="p" data-group-id="0158131565-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="0158131565-2">)</span><span class="w"> </span><span class="k" data-group-id="0158131565-3">do</span><span class="w">
    </span><span class="n">render</span><span class="p" data-group-id="0158131565-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:index</span><span class="p" data-group-id="0158131565-4">)</span><span class="w">
  </span><span class="k" data-group-id="0158131565-3">end</span><span class="w">
</span><span class="k" data-group-id="0158131565-1">end</span></code></pre><p>While we can name our actions whatever we like, there are conventions for action names which we should follow whenever possible. We went over these in the <a href="routing.html">routing guide</a>, but we'll take another quick look here.</p><ul><li>index   - renders a list of all items of the given resource type</li><li>show    - renders an individual item by ID</li><li>new     - renders a form for creating a new item</li><li>create  - receives parameters for one new item and saves it in a data store</li><li>edit    - retrieves an individual item by ID and displays it in a form for editing</li><li>update  - receives parameters for one edited item and saves the item to a data store</li><li>delete  - receives an ID for an item to be deleted and deletes it from a data store</li></ul><p>Each of these actions takes two parameters, which will be provided by Phoenix behind the scenes.</p><p>The first parameter is always <code class="inline">conn</code>, a struct which holds information about the request such as the host, path elements, port, query string, and much more. <code class="inline">conn</code> comes to Phoenix via Elixir's Plug middleware framework. More detailed information about <code class="inline">conn</code> can be found in the <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html">Plug.Conn documentation</a>.</p><p>The second parameter is <code class="inline">params</code>. Not surprisingly, this is a map which holds any parameters passed along in the HTTP request. It is a good practice to pattern match against parameters in the function signature to provide data in a simple package we can pass on to rendering. We saw this in the <a href="request_lifecycle.html">request life-cycle guide</a> when we added a messenger parameter to our <code class="inline">show</code> route in <code class="inline">lib/hello_web/controllers/hello_controller.ex</code>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.HelloController</span><span class="w"> </span><span class="k" data-group-id="8650422037-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">show</span><span class="p" data-group-id="8650422037-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8650422037-3">%{</span><span class="s">&quot;messenger&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="8650422037-3">}</span><span class="p" data-group-id="8650422037-2">)</span><span class="w"> </span><span class="k" data-group-id="8650422037-4">do</span><span class="w">
    </span><span class="n">render</span><span class="p" data-group-id="8650422037-5">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:show</span><span class="p">,</span><span class="w"> </span><span class="ss">messenger</span><span class="p">:</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="8650422037-5">)</span><span class="w">
  </span><span class="k" data-group-id="8650422037-4">end</span><span class="w">
</span><span class="k" data-group-id="8650422037-1">end</span></code></pre><p>In some cases — often in <code class="inline">index</code> actions, for instance — we don't care about parameters because our behavior doesn't depend on them. In those cases, we don't use the incoming parameters, and simply prefix the variable name with an underscore, calling it <code class="inline">_params</code>. This will keep the compiler from complaining about the unused variable while still keeping the correct arity.</p><h2 id="rendering" class="section-heading">
  <a href="#rendering" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Rendering</span>
</h2>
<p>Controllers can render content in several ways. The simplest is to render some plain text using the <a href="Phoenix.Controller.xhtml#text/2" title=""><code class="inline">text/2</code></a> function which Phoenix provides.</p><p>For example, let's rewrite the <code class="inline">show</code> action from <code class="inline">HelloController</code> to return text instead. For that, we could do the following.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">show</span><span class="p" data-group-id="6590734045-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6590734045-2">%{</span><span class="s">&quot;messenger&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="6590734045-2">}</span><span class="p" data-group-id="6590734045-1">)</span><span class="w"> </span><span class="k" data-group-id="6590734045-3">do</span><span class="w">
  </span><span class="n">text</span><span class="p" data-group-id="6590734045-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;From messenger </span><span class="si" data-group-id="6590734045-5">#{</span><span class="n">messenger</span><span class="si" data-group-id="6590734045-5">}</span><span class="s">&quot;</span><span class="p" data-group-id="6590734045-4">)</span><span class="w">
</span><span class="k" data-group-id="6590734045-3">end</span></code></pre><p>Now <a href="http://localhost:4000/hello/Frank" title=""><code class="inline">/hello/Frank</code></a> in your browser should display <code class="inline">From messenger Frank</code> as plain text without any HTML.</p><p>A step beyond this is rendering pure JSON with the <a href="Phoenix.Controller.xhtml#json/2" title=""><code class="inline">json/2</code></a> function. We need to pass it something that the <a href="https://hexdocs.pm/jason/1.4.0/Jason.html">Jason library</a> can decode into JSON, such as a map. (Jason is one of Phoenix's dependencies.)</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">show</span><span class="p" data-group-id="1461199196-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1461199196-2">%{</span><span class="s">&quot;messenger&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="1461199196-2">}</span><span class="p" data-group-id="1461199196-1">)</span><span class="w"> </span><span class="k" data-group-id="1461199196-3">do</span><span class="w">
  </span><span class="n">json</span><span class="p" data-group-id="1461199196-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1461199196-5">%{</span><span class="ss">id</span><span class="p">:</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="1461199196-5">}</span><span class="p" data-group-id="1461199196-4">)</span><span class="w">
</span><span class="k" data-group-id="1461199196-3">end</span></code></pre><p>If we again visit <a href="http://localhost:4000/hello/Frank" title=""><code class="inline">/hello/Frank</code></a> in the browser, we should see a block of JSON with the key <code class="inline">id</code> mapped to the string <code class="inline">&quot;Frank&quot;</code>.</p><pre><code class="makeup json" translate="no"><span class="p">{</span><span class="p">&quot;</span><span class="s2">id</span><span class="p">&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">&quot;</span><span class="s2">Frank</span><span class="p">&quot;</span><span class="p">}</span></code></pre><p>The <a href="Phoenix.Controller.xhtml#json/2" title=""><code class="inline">json/2</code></a> function is useful for writing APIs and there is also the <a href="Phoenix.Controller.xhtml#html/2" title=""><code class="inline">html/2</code></a> function for rendering HTML, but most of the times we use Phoenix views to build our responses. For this, Phoenix includes the <a href="Phoenix.Controller.xhtml#render/3" title=""><code class="inline">render/3</code></a> function. It is specially important for HTML responses, as Phoenix Views provide performance and security benefits.</p><p>Let's rollback our <code class="inline">show</code> action to what we originally wrote in the <a href="request_lifecycle.html">request life-cycle guide</a>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.HelloController</span><span class="w"> </span><span class="k" data-group-id="5506412239-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:controller</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">show</span><span class="p" data-group-id="5506412239-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5506412239-3">%{</span><span class="s">&quot;messenger&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="5506412239-3">}</span><span class="p" data-group-id="5506412239-2">)</span><span class="w"> </span><span class="k" data-group-id="5506412239-4">do</span><span class="w">
    </span><span class="n">render</span><span class="p" data-group-id="5506412239-5">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:show</span><span class="p">,</span><span class="w"> </span><span class="ss">messenger</span><span class="p">:</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="5506412239-5">)</span><span class="w">
  </span><span class="k" data-group-id="5506412239-4">end</span><span class="w">
</span><span class="k" data-group-id="5506412239-1">end</span></code></pre><p>In order for the <a href="Phoenix.Controller.xhtml#render/3" title=""><code class="inline">render/3</code></a> function to work correctly, the controller and view must share the same root name (in this case <code class="inline">Hello</code>), and the <code class="inline">HelloHTML</code> module must include an <code class="inline">embed_templates</code> definition specifying where its templates live. By default the controller, view module, and templates are collocated together in the same controller directory. In other words, <code class="inline">HelloController</code> requires <code class="inline">HelloHTML</code>, and <code class="inline">HelloHTML</code> requires the existence of the <code class="inline">lib/hello_web/controllers/hello_html/</code> directory, which must contain the <code class="inline">show.html.heex</code> template.</p><p><a href="Phoenix.Controller.xhtml#render/3" title=""><code class="inline">render/3</code></a> will also pass the value which the <code class="inline">show</code> action received for <code class="inline">messenger</code> from the parameters as an assign.</p><p>If we need to pass values into the template when using <code class="inline">render</code>, that's easy. We can pass a keyword like we've seen with <code class="inline">messenger: messenger</code>, or we can use <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html#assign/3"><code class="inline">Plug.Conn.assign/3</code></a>, which conveniently returns <code class="inline">conn</code>.</p><pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="nf">show</span><span class="p" data-group-id="5671346354-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5671346354-2">%{</span><span class="s">&quot;messenger&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="5671346354-2">}</span><span class="p" data-group-id="5671346354-1">)</span><span class="w"> </span><span class="k" data-group-id="5671346354-3">do</span><span class="w">
    </span><span class="n">conn</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Plug.Conn</span><span class="o">.</span><span class="n">assign</span><span class="p" data-group-id="5671346354-4">(</span><span class="ss">:messenger</span><span class="p">,</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="5671346354-4">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">render</span><span class="p" data-group-id="5671346354-5">(</span><span class="ss">:show</span><span class="p" data-group-id="5671346354-5">)</span><span class="w">
  </span><span class="k" data-group-id="5671346354-3">end</span></code></pre><p>Note: Using <a href="Phoenix.Controller.xhtml"><code class="inline">Phoenix.Controller</code></a> imports <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html"><code class="inline">Plug.Conn</code></a>, so shortening the call to <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html#assign/3" title=""><code class="inline">assign/3</code></a> works just fine.</p><p>Passing more than one value to our template is as simple as connecting <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html#assign/3" title=""><code class="inline">assign/3</code></a> functions together:</p><pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="nf">show</span><span class="p" data-group-id="9543941477-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9543941477-2">%{</span><span class="s">&quot;messenger&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="9543941477-2">}</span><span class="p" data-group-id="9543941477-1">)</span><span class="w"> </span><span class="k" data-group-id="9543941477-3">do</span><span class="w">
    </span><span class="n">conn</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="9543941477-4">(</span><span class="ss">:messenger</span><span class="p">,</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="9543941477-4">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="9543941477-5">(</span><span class="ss">:receiver</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Dweezil&quot;</span><span class="p" data-group-id="9543941477-5">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">render</span><span class="p" data-group-id="9543941477-6">(</span><span class="ss">:show</span><span class="p" data-group-id="9543941477-6">)</span><span class="w">
  </span><span class="k" data-group-id="9543941477-3">end</span></code></pre><p>Or you can pass the assigns directly to <code class="inline">render</code> instead:</p><pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="nf">show</span><span class="p" data-group-id="6292268080-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6292268080-2">%{</span><span class="s">&quot;messenger&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="6292268080-2">}</span><span class="p" data-group-id="6292268080-1">)</span><span class="w"> </span><span class="k" data-group-id="6292268080-3">do</span><span class="w">
    </span><span class="n">render</span><span class="p" data-group-id="6292268080-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:show</span><span class="p">,</span><span class="w"> </span><span class="ss">messenger</span><span class="p">:</span><span class="w"> </span><span class="n">messenger</span><span class="p">,</span><span class="w"> </span><span class="ss">receiver</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Dweezil&quot;</span><span class="p" data-group-id="6292268080-4">)</span><span class="w">
  </span><span class="k" data-group-id="6292268080-3">end</span></code></pre><p>Generally speaking, once all assigns are configured, we invoke the view layer. The view layer (<code class="inline">HelloWeb.HelloHTML</code>) then renders <code class="inline">show.html</code> alongside the layout and a response is sent back to the browser.</p><p><a href="components.html">Components and HEEx templates</a> have their own guide, so we won't spend much time on them here. What we will look at is how to render different formats from inside a controller action.</p><h2 id="new-rendering-formats" class="section-heading">
  <a href="#new-rendering-formats" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">New rendering formats</span>
</h2>
<p>Rendering HTML through a template is fine, but what if we need to change the rendering format on the fly? Let's say that sometimes we need HTML, sometimes we need plain text, and sometimes we need JSON. Then what?</p><p>The view's job is not only to render HTML templates. Views are about data presentation. Given a bag of data, the view's purpose is to present that in a meaningful way given some format, be it HTML, JSON, CSV, or others. Many web apps today return JSON to remote clients, and Phoenix views are <em>great</em> for JSON rendering.</p><p>As an example, let's take <code class="inline">PageController</code>'s <code class="inline">home</code> action from a newly generated app. Out of the box, this has the right view <code class="inline">PageHTML</code>, the embedded templates from (<code class="inline">lib/hello_web/controllers/page_html</code>), and the right template for rendering HTML (<code class="inline">home.html.heex</code>.)</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="0197355451-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="0197355451-1">)</span><span class="w"> </span><span class="k" data-group-id="0197355451-2">do</span><span class="w">
  </span><span class="n">render</span><span class="p" data-group-id="0197355451-3">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="p">,</span><span class="w"> </span><span class="ss">layout</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="0197355451-3">)</span><span class="w">
</span><span class="k" data-group-id="0197355451-2">end</span></code></pre><p>What it doesn't have is a view for rendering JSON. Phoenix Controller hands off to a view module to render templates, and it does so per format. We already have a view for the HTML format, but we need to instruct Phoenix how to render the JSON format as well. By default, you can see which formats your controllers support in <code class="inline">lib/hello_web.ex</code>:</p><pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="nf">controller</span><span class="w"> </span><span class="k" data-group-id="8280943709-1">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8280943709-2">do</span><span class="w">
      </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Controller</span><span class="p">,</span><span class="w">
        </span><span class="ss">formats</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8280943709-3">[</span><span class="ss">:html</span><span class="p">,</span><span class="w"> </span><span class="ss">:json</span><span class="p" data-group-id="8280943709-3">]</span><span class="p">,</span><span class="w">
        </span><span class="ss">layouts</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="8280943709-4">[</span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="nc">HelloWeb.Layouts</span><span class="p" data-group-id="8280943709-4">]</span><span class="w">
      </span><span class="n">...</span><span class="w">
    </span><span class="k" data-group-id="8280943709-2">end</span><span class="w">
  </span><span class="k" data-group-id="8280943709-1">end</span></code></pre><p>So out of the box Phoenix will look for a <code class="inline">HTML</code> and <a href="https://hexdocs.pm/elixir/JSON.html"><code class="inline">JSON</code></a> view modules based on the request format and the controller name. We can also explicitly tell Phoenix in our controller which view(s) to use for each format. For example, what Phoenix does by default can be explicitly set with the following in your controller:</p><pre><code class="makeup elixir" translate="no"><span class="n">plug</span><span class="w"> </span><span class="ss">:put_view</span><span class="p">,</span><span class="w"> </span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="nc">HelloWeb.PageHTML</span><span class="p">,</span><span class="w"> </span><span class="ss">json</span><span class="p">:</span><span class="w"> </span><span class="nc">HelloWeb.PageJSON</span></code></pre><p>Let's add a <code class="inline">PageJSON</code> view module at <code class="inline">lib/hello_web/controllers/page_json.ex</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.PageJSON</span><span class="w"> </span><span class="k" data-group-id="1531025536-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="1531025536-2">(</span><span class="c">_assigns</span><span class="p" data-group-id="1531025536-2">)</span><span class="w"> </span><span class="k" data-group-id="1531025536-3">do</span><span class="w">
    </span><span class="p" data-group-id="1531025536-4">%{</span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;this is some JSON&quot;</span><span class="p" data-group-id="1531025536-4">}</span><span class="w">
  </span><span class="k" data-group-id="1531025536-3">end</span><span class="w">
</span><span class="k" data-group-id="1531025536-1">end</span></code></pre><p>Since the Phoenix View layer is simply a function that the controller renders, passing connection assigns, we can define a regular <code class="inline">home/1</code> function and return a map to be serialized as JSON.</p><p>There are just a few more things we need to do to make this work. Because we want to render both HTML and JSON from the same controller, we need to tell our router that it should accept the <code class="inline">json</code> format. We do that by adding <code class="inline">json</code> to the list of accepted formats in the <code class="inline">:browser</code> pipeline. Let's open up <code class="inline">lib/hello_web/router.ex</code> and change <code class="inline">plug :accepts</code> to include <code class="inline">json</code> as well as <code class="inline">html</code> like this.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="k" data-group-id="9962199801-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:router</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:browser</span><span class="w"> </span><span class="k" data-group-id="9962199801-2">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:accepts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9962199801-3">[</span><span class="s">&quot;html&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;json&quot;</span><span class="p" data-group-id="9962199801-3">]</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_session</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_live_flash</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_root_layout</span><span class="p">,</span><span class="w"> </span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9962199801-4">{</span><span class="nc">HelloWeb.LayoutView</span><span class="p">,</span><span class="w"> </span><span class="ss">:root</span><span class="p" data-group-id="9962199801-4">}</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:protect_from_forgery</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_secure_browser_headers</span><span class="w">
  </span><span class="k" data-group-id="9962199801-2">end</span><span class="w">
</span><span class="n">...</span></code></pre><p>Phoenix allows us to change formats on the fly with the <code class="inline">_format</code> query string parameter. If we go to <a href="http://localhost:4000/?_format=json"><code class="inline">http://localhost:4000/?_format=json</code></a>, we will see <code class="inline">%{&quot;message&quot;: &quot;this is some JSON&quot;}</code>.</p><p>In practice, however, applications that need to render both formats typically use two distinct pipelines for each, such as the <code class="inline">pipeline :api</code> already defined in your router file. To learn more, see <a href="json_and_apis.xhtml">our JSON and APIs guide</a>.</p><h3 id="sending-responses-directly" class="section-heading">
  <a href="#sending-responses-directly" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Sending responses directly</span>
</h3>
<p>If none of the rendering options above quite fits our needs, we can compose our own using some of the functions that <a href="https://hexdocs.pm/plug/1.15.3/Plug.html"><code class="inline">Plug</code></a> gives us. Let's say we want to send a response with a status of &quot;201&quot; and no body whatsoever. We can do that with the <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html#send_resp/3"><code class="inline">Plug.Conn.send_resp/3</code></a> function.</p><p>Edit the <code class="inline">home</code> action of <code class="inline">PageController</code> in <code class="inline">lib/hello_web/controllers/page_controller.ex</code> to look like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="0140735714-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="0140735714-1">)</span><span class="w"> </span><span class="k" data-group-id="0140735714-2">do</span><span class="w">
  </span><span class="n">send_resp</span><span class="p" data-group-id="0140735714-3">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="mi">201</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p" data-group-id="0140735714-3">)</span><span class="w">
</span><span class="k" data-group-id="0140735714-2">end</span></code></pre><p>Reloading <a href="http://localhost:4000">http://localhost:4000</a> should show us a completely blank page. The network tab of our browser's developer tools should show a response status of &quot;201&quot; (Created). Some browsers (Safari) will download the response, as the content type is not set.</p><p>To be specific about the content type, we can use <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html#put_resp_content_type/2" title=""><code class="inline">put_resp_content_type/2</code></a> in conjunction with <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html#send_resp/3" title=""><code class="inline">send_resp/3</code></a>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="9701213398-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="9701213398-1">)</span><span class="w"> </span><span class="k" data-group-id="9701213398-2">do</span><span class="w">
  </span><span class="n">conn</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">put_resp_content_type</span><span class="p" data-group-id="9701213398-3">(</span><span class="s">&quot;text/plain&quot;</span><span class="p" data-group-id="9701213398-3">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">send_resp</span><span class="p" data-group-id="9701213398-4">(</span><span class="mi">201</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p" data-group-id="9701213398-4">)</span><span class="w">
</span><span class="k" data-group-id="9701213398-2">end</span></code></pre><p>Using <a href="https://hexdocs.pm/plug/1.15.3/Plug.html"><code class="inline">Plug</code></a> functions in this way, we can craft just the response we need.</p><h3 id="setting-the-content-type" class="section-heading">
  <a href="#setting-the-content-type" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Setting the content type</span>
</h3>
<p>Analogous to the <code class="inline">_format</code> query string param, we can render any sort of format we want by modifying the HTTP Content-Type Header and providing the appropriate template.</p><p>If we wanted to render an XML version of our <code class="inline">home</code> action, we might implement the action like this in <code class="inline">lib/hello_web/page_controller.ex</code>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="3602808542-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="3602808542-1">)</span><span class="w"> </span><span class="k" data-group-id="3602808542-2">do</span><span class="w">
  </span><span class="n">conn</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">put_resp_content_type</span><span class="p" data-group-id="3602808542-3">(</span><span class="s">&quot;text/xml&quot;</span><span class="p" data-group-id="3602808542-3">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">render</span><span class="p" data-group-id="3602808542-4">(</span><span class="ss">:home</span><span class="p">,</span><span class="w"> </span><span class="ss">content</span><span class="p">:</span><span class="w"> </span><span class="n">some_xml_content</span><span class="p" data-group-id="3602808542-4">)</span><span class="w">
</span><span class="k" data-group-id="3602808542-2">end</span></code></pre><p>We would then need to provide an <code class="inline">home.xml.eex</code> template which created valid XML, and we would be done.</p><p>For a list of valid content mime-types, please see the <a href="https://hexdocs.pm/mime/2.0.6/MIME.html"><code class="inline">MIME</code></a> library.</p><h3 id="setting-the-http-status" class="section-heading">
  <a href="#setting-the-http-status" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Setting the HTTP Status</span>
</h3>
<p>We can also set the HTTP status code of a response similarly to the way we set the content type. The <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html"><code class="inline">Plug.Conn</code></a> module, imported into all controllers, has a <code class="inline">put_status/2</code> function to do this.</p><p><a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.html#put_status/2"><code class="inline">Plug.Conn.put_status/2</code></a> takes <code class="inline">conn</code> as the first parameter and as the second parameter either an integer or a &quot;friendly name&quot; used as an atom for the status code we want to set. The list of status code atom representations can be found in <a href="https://hexdocs.pm/plug/1.15.3/Plug.Conn.Status.html#code/1"><code class="inline">Plug.Conn.Status.code/1</code></a> documentation.</p><p>Let's change the status in our <code class="inline">PageController</code> <code class="inline">home</code> action.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="2758700815-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="2758700815-1">)</span><span class="w"> </span><span class="k" data-group-id="2758700815-2">do</span><span class="w">
  </span><span class="n">conn</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">put_status</span><span class="p" data-group-id="2758700815-3">(</span><span class="mi">202</span><span class="p" data-group-id="2758700815-3">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">render</span><span class="p" data-group-id="2758700815-4">(</span><span class="ss">:home</span><span class="p">,</span><span class="w"> </span><span class="ss">layout</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="2758700815-4">)</span><span class="w">
</span><span class="k" data-group-id="2758700815-2">end</span></code></pre><p>The status code we provide must be a valid number.</p><h2 id="redirection" class="section-heading">
  <a href="#redirection" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Redirection</span>
</h2>
<p>Often, we need to redirect to a new URL in the middle of a request. A successful <code class="inline">create</code> action, for instance, will usually redirect to the <code class="inline">show</code> action for the resource we just created. Alternately, it could redirect to the <code class="inline">index</code> action to show all the things of that same type. There are plenty of other cases where redirection is useful as well.</p><p>Whatever the circumstance, Phoenix controllers provide the handy <a href="Phoenix.Controller.xhtml#redirect/2" title=""><code class="inline">redirect/2</code></a> function to make redirection easy. Phoenix differentiates between redirecting to a path within the application and redirecting to a URL — either within our application or external to it.</p><p>In order to try out <a href="Phoenix.Controller.xhtml#redirect/2" title=""><code class="inline">redirect/2</code></a>, let's create a new route in <code class="inline">lib/hello_web/router.ex</code>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="k" data-group-id="3520669138-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="3520669138-2">do</span><span class="w">
    </span><span class="n">...</span><span class="w">
    </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="w">
    </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/redirect_test&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:redirect_test</span><span class="w">
    </span><span class="n">...</span><span class="w">
  </span><span class="k" data-group-id="3520669138-2">end</span><span class="w">
</span><span class="k" data-group-id="3520669138-1">end</span></code></pre><p>Then we'll change <code class="inline">PageController</code>'s <code class="inline">home</code> action of our controller to do nothing but to redirect to our new route.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.PageController</span><span class="w"> </span><span class="k" data-group-id="9996090099-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:controller</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="9996090099-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="9996090099-2">)</span><span class="w"> </span><span class="k" data-group-id="9996090099-3">do</span><span class="w">
    </span><span class="n">redirect</span><span class="p" data-group-id="9996090099-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="sx">~p&quot;/redirect_test&quot;</span><span class="p" data-group-id="9996090099-4">)</span><span class="w">
  </span><span class="k" data-group-id="9996090099-3">end</span><span class="w">
</span><span class="k" data-group-id="9996090099-1">end</span><span class="w">
</span></code></pre><p>We made use of <a href="Phoenix.VerifiedRoutes.xhtml#sigil_p/2"><code class="inline">Phoenix.VerifiedRoutes.sigil_p/2</code></a> to build our redirect path, which is the preferred approach to reference any path within our application. We learned about verified routes in the <a href="routing.html">routing guide</a>.</p><p>Finally, let's define in the same file the action we redirect to, which simply renders the home, but now under a new address:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">redirect_test</span><span class="p" data-group-id="5418223057-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="5418223057-1">)</span><span class="w"> </span><span class="k" data-group-id="5418223057-2">do</span><span class="w">
  </span><span class="n">render</span><span class="p" data-group-id="5418223057-3">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="p">,</span><span class="w"> </span><span class="ss">layout</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="5418223057-3">)</span><span class="w">
</span><span class="k" data-group-id="5418223057-2">end</span></code></pre><p>When we reload our <a href="http://localhost:4000/" title="">welcome page</a>, we see that we've been redirected to <code class="inline">/redirect_test</code> which shows the original welcome page. It works!</p><p>If we care to, we can open up our developer tools, click on the network tab, and visit our root route again. We see two main requests for this page - a get to <code class="inline">/</code> with a status of <code class="inline">302</code>, and a get to <code class="inline">/redirect_test</code> with a status of <code class="inline">200</code>.</p><p>Notice that the redirect function takes <code class="inline">conn</code> as well as a string representing a relative path within our application. For security reasons, the <code class="inline">:to</code> option can only redirect to paths within your application. If you want to redirect to a fully-qualified path or an external URL, you should use <code class="inline">:external</code> instead:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="3305097495-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="3305097495-1">)</span><span class="w"> </span><span class="k" data-group-id="3305097495-2">do</span><span class="w">
  </span><span class="n">redirect</span><span class="p" data-group-id="3305097495-3">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">external</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;https://elixir-lang.org/&quot;</span><span class="p" data-group-id="3305097495-3">)</span><span class="w">
</span><span class="k" data-group-id="3305097495-2">end</span></code></pre><h2 id="flash-messages" class="section-heading">
  <a href="#flash-messages" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Flash messages</span>
</h2>
<p>Sometimes we need to communicate with users during the course of an action. Maybe there was an error updating a schema, or maybe we just want to welcome them back to the application. For this, we have flash messages.</p><p>The <a href="Phoenix.Controller.xhtml"><code class="inline">Phoenix.Controller</code></a> module provides the <a href="Phoenix.Controller.xhtml#put_flash/3" title=""><code class="inline">put_flash/3</code></a> to set flash messages as a key-value pair and placing them into a <code class="inline">@flash</code> assign in the connection. Let's set two flash messages in our <code class="inline">HelloWeb.PageController</code> to try this out.</p><p>To do this we modify the <code class="inline">home</code> action as follows:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.PageController</span><span class="w"> </span><span class="k" data-group-id="8749930141-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="8749930141-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="8749930141-2">)</span><span class="w"> </span><span class="k" data-group-id="8749930141-3">do</span><span class="w">
    </span><span class="n">conn</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">put_flash</span><span class="p" data-group-id="8749930141-4">(</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Let&#39;s pretend we have an error.&quot;</span><span class="p" data-group-id="8749930141-4">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">render</span><span class="p" data-group-id="8749930141-5">(</span><span class="ss">:home</span><span class="p">,</span><span class="w"> </span><span class="ss">layout</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="8749930141-5">)</span><span class="w">
  </span><span class="k" data-group-id="8749930141-3">end</span><span class="w">
</span><span class="k" data-group-id="8749930141-1">end</span></code></pre><p>In order to see our flash messages, we need to be able to retrieve them and display them in a template layout. We can do that using <a href="Phoenix.Flash.xhtml#get/2" title=""><code class="inline">Phoenix.Flash.get/2</code></a> which takes the flash data and the key we care about. It then returns the value for that key.</p><p>For our convenience, a <code class="inline">flash_group</code> component is already available and added to the beginning of our <a href="http://localhost:4000/" title="">welcome page</a></p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">.flash_group</span><span class="w"> </span><span class="ni">flash</span><span class="p">=</span><span class="p" data-group-id="6420739502-1">{</span><span class="na">@flash</span><span class="p" data-group-id="6420739502-1">}</span><span class="w"> </span><span class="p">/&gt;</span></code></pre><p>When we reload the <a href="http://localhost:4000/" title="">welcome page</a>, our message should appear in the top right corner of the page.</p><p>The flash functionality is handy when mixed with redirects. Perhaps you want to redirect to a page with some extra information. If we reuse the redirect action from the previous section, we can do:</p><pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="nf">home</span><span class="p" data-group-id="2658503114-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="2658503114-1">)</span><span class="w"> </span><span class="k" data-group-id="2658503114-2">do</span><span class="w">
    </span><span class="n">conn</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">put_flash</span><span class="p" data-group-id="2658503114-3">(</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Let&#39;s pretend we have an error.&quot;</span><span class="p" data-group-id="2658503114-3">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">redirect</span><span class="p" data-group-id="2658503114-4">(</span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="sx">~p&quot;/redirect_test&quot;</span><span class="p" data-group-id="2658503114-4">)</span><span class="w">
  </span><span class="k" data-group-id="2658503114-2">end</span></code></pre><p>Now if you reload the <a href="http://localhost:4000/" title="">welcome page</a>, you will be redirected and the flash message will be shown once more.</p><p>Besides <a href="Phoenix.Controller.xhtml#put_flash/3" title=""><code class="inline">put_flash/3</code></a>, the <a href="Phoenix.Controller.xhtml"><code class="inline">Phoenix.Controller</code></a> module has another useful function worth knowing about. <a href="Phoenix.Controller.xhtml#clear_flash/1" title=""><code class="inline">clear_flash/1</code></a> takes only <code class="inline">conn</code> and removes any flash messages which might be stored in the session.</p><p>Phoenix does not enforce which keys are stored in the flash. As long as we are internally consistent, all will be well. <code class="inline">:info</code> and <code class="inline">:error</code>, however, are common and are handled by default in our templates.</p><h2 id="error-pages" class="section-heading">
  <a href="#error-pages" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Error pages</span>
</h2>
<p>Phoenix has two views called <code class="inline">ErrorHTML</code> and <code class="inline">ErrorJSON</code> which live in <code class="inline">lib/hello_web/controllers/</code>. The purpose of these views is to handle errors in a general way for incoming HTML or JSON requests. Similar to the views we built in this guide, error views can return both HTML and JSON responses. See the <a href="custom_error_pages.html">Custom Error Pages How-To</a> for more information.</p>

  </body>
</html>
