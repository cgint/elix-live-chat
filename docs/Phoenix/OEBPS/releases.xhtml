<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Deploying with Releases - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Deploying with Releases
    </h1>
<h2 id="what-we-ll-need" class="section-heading">
  <a href="#what-we-ll-need" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">What we'll need</span>
</h2>
<p>The only thing we'll need for this guide is a working Phoenix application. For those of us who need a simple application to deploy, please follow the <a href="up_and_running.html">Up and Running guide</a>.</p><h2 id="goals" class="section-heading">
  <a href="#goals" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Goals</span>
</h2>
<p>Our main goal for this guide is to package your Phoenix application into a self-contained directory that includes the Erlang VM, Elixir, all of your code and dependencies. This package can then be dropped into a production machine.</p><h2 id="releases-assemble" class="section-heading">
  <a href="#releases-assemble" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Releases, assemble!</span>
</h2>
<p>If you are not familiar with Elixir releases yet, we recommend you to read <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html">Elixir's excellent docs</a> before continuing.</p><p>Once that is done, you can assemble a release by going through all of the steps in our general <a href="deployment.html">deployment guide</a> with <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html"><code class="inline">mix release</code></a> at the end. Let's recap.</p><p>First set the environment variables:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.gen.secret
</span><span class="">REALLY_LONG_SECRET
</span><span class="gp unselectable">$ </span><span class="">export SECRET_KEY_BASE=REALLY_LONG_SECRET
</span><span class="gp unselectable">$ </span><span class="">export DATABASE_URL=ecto://USER:PASS@HOST/database
</span></code></pre><p>Then load dependencies to compile code and assets:</p><pre><code class="makeup console" translate="no"><span class=""># Initial setup
</span><span class="gp unselectable">$ </span><span class="">mix deps.get --only prod
</span><span class="gp unselectable">$ </span><span class="">MIX_ENV=prod mix compile
</span><span class="">
</span><span class=""># Compile assets
</span><span class="gp unselectable">$ </span><span class="">MIX_ENV=prod mix assets.deploy
</span></code></pre><p>And now run <a href="Mix.Tasks.Phx.Gen.Release.xhtml"><code class="inline">mix phx.gen.release</code></a>:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.gen.release
</span><span class="">==&gt; my_app
</span><span class="">* creating rel/overlays/bin/server
</span><span class="">* creating rel/overlays/bin/server.bat
</span><span class="">* creating rel/overlays/bin/migrate
</span><span class="">* creating rel/overlays/bin/migrate.bat
</span><span class="">* creating lib/my_app/release.ex
</span><span class="">
</span><span class="">Your application is ready to be deployed in a release!
</span><span class="">
</span><span class="">    # To start your system
</span><span class="">    _build/dev/rel/my_app/bin/my_app start
</span><span class="">
</span><span class="">    # To start your system with the Phoenix server running
</span><span class="">    _build/dev/rel/my_app/bin/server
</span><span class="">
</span><span class="">    # To run migrations
</span><span class="">    _build/dev/rel/my_app/bin/migrate
</span><span class="">
</span><span class="">Once the release is running:
</span><span class="">
</span><span class="">    # To connect to it remotely
</span><span class="">    _build/dev/rel/my_app/bin/my_app remote
</span><span class="">
</span><span class="">    # To stop it gracefully (you may also send SIGINT/SIGTERM)
</span><span class="">    _build/dev/rel/my_app/bin/my_app stop
</span><span class="">
</span><span class="">To list all commands:
</span><span class="">
</span><span class="">    _build/dev/rel/my_app/bin/my_app
</span><span class="">
</span></code></pre><p>The <code class="inline">phx.gen.release</code> task generated a few files for us to assist in releases. First, it created <code class="inline">server</code> and <code class="inline">migrate</code> <em>overlay</em> scripts for conveniently running the phoenix server inside a release or invoking migrations from a release. The files in the <code class="inline">rel/overlays</code> directory are copied into every release environment. Next, it generated a <code class="inline">release.ex</code> file which is used to invoke Ecto migrations without a dependency on <code class="inline">mix</code> itself.</p><p><em>Note</em>: If you are a Docker user, you can pass the <code class="inline">--docker</code> flag to <a href="Mix.Tasks.Phx.Gen.Release.xhtml"><code class="inline">mix phx.gen.release</code></a> to generate a Dockerfile ready for deployment.</p><p>Next, we can invoke <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html"><code class="inline">mix release</code></a> to build the release:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">MIX_ENV=prod mix release
</span><span class="">Generated my_app app
</span><span class="">* assembling my_app-0.1.0 on MIX_ENV=prod
</span><span class="">* using config/runtime.exs to configure the release at runtime
</span><span class="">
</span><span class="">Release created at _build/prod/rel/my_app!
</span><span class="">
</span><span class="">    # To start your system
</span><span class="">    _build/prod/rel/my_app/bin/my_app start
</span><span class="">
</span><span class="">...
</span></code></pre><p>You can start the release by calling <code class="inline">_build/prod/rel/my_app/bin/my_app start</code>, or boot your webserver by calling <code class="inline">_build/prod/rel/my_app/bin/server</code>, where you have to replace <code class="inline">my_app</code> by your current application name.</p><p>Now you can get all of the files under the <code class="inline">_build/prod/rel/my_app</code> directory, package it, and run it in any production machine with the same OS and architecture as the one that assembled the release. For more details, check the <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html">docs for <code class="inline">mix release</code></a>.</p><p>But before we finish this guide, there is one more feature from releases that most Phoenix application will use, so let's talk about that.</p><h2 id="ecto-migrations-and-custom-commands" class="section-heading">
  <a href="#ecto-migrations-and-custom-commands" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Ecto migrations and custom commands</span>
</h2>
<p>A common need in production systems is to execute custom commands required to set up the production environment. One of such commands is precisely migrating the database. Since we don't have <a href="https://hexdocs.pm/mix/Mix.html"><code class="inline">Mix</code></a>, a <em>build</em> tool, inside releases, which are a production artifact, we need to bring said commands directly into the release.</p><p>The <code class="inline">phx.gen.release</code> command created the following <code class="inline">release.ex</code> file in your project <code class="inline">lib/my_app/release.ex</code>, with the following content:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.Release</span><span class="w"> </span><span class="k" data-group-id="2740700766-1">do</span><span class="w">
  </span><span class="na">@app</span><span class="w"> </span><span class="ss">:my_app</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">migrate</span><span class="w"> </span><span class="k" data-group-id="2740700766-2">do</span><span class="w">
    </span><span class="n">load_app</span><span class="p" data-group-id="2740700766-3">(</span><span class="p" data-group-id="2740700766-3">)</span><span class="w">

    </span><span class="k">for</span><span class="w"> </span><span class="n">repo</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">repos</span><span class="p" data-group-id="2740700766-4">(</span><span class="p" data-group-id="2740700766-4">)</span><span class="w"> </span><span class="k" data-group-id="2740700766-5">do</span><span class="w">
      </span><span class="p" data-group-id="2740700766-6">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="2740700766-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ecto.Migrator</span><span class="o">.</span><span class="n">with_repo</span><span class="p" data-group-id="2740700766-7">(</span><span class="n">repo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">Ecto.Migrator</span><span class="o">.</span><span class="n">run</span><span class="p" data-group-id="2740700766-8">(</span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="ss">:up</span><span class="p">,</span><span class="w"> </span><span class="ss">all</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="2740700766-8">)</span><span class="p" data-group-id="2740700766-7">)</span><span class="w">
    </span><span class="k" data-group-id="2740700766-5">end</span><span class="w">
  </span><span class="k" data-group-id="2740700766-2">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">rollback</span><span class="p" data-group-id="2740700766-9">(</span><span class="n">repo</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="p" data-group-id="2740700766-9">)</span><span class="w"> </span><span class="k" data-group-id="2740700766-10">do</span><span class="w">
    </span><span class="n">load_app</span><span class="p" data-group-id="2740700766-11">(</span><span class="p" data-group-id="2740700766-11">)</span><span class="w">
    </span><span class="p" data-group-id="2740700766-12">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="2740700766-12">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ecto.Migrator</span><span class="o">.</span><span class="n">with_repo</span><span class="p" data-group-id="2740700766-13">(</span><span class="n">repo</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">Ecto.Migrator</span><span class="o">.</span><span class="n">run</span><span class="p" data-group-id="2740700766-14">(</span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="ss">:down</span><span class="p">,</span><span class="w"> </span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">version</span><span class="p" data-group-id="2740700766-14">)</span><span class="p" data-group-id="2740700766-13">)</span><span class="w">
  </span><span class="k" data-group-id="2740700766-10">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">repos</span><span class="w"> </span><span class="k" data-group-id="2740700766-15">do</span><span class="w">
    </span><span class="nc">Application</span><span class="o">.</span><span class="n">fetch_env!</span><span class="p" data-group-id="2740700766-16">(</span><span class="na">@app</span><span class="p">,</span><span class="w"> </span><span class="ss">:ecto_repos</span><span class="p" data-group-id="2740700766-16">)</span><span class="w">
  </span><span class="k" data-group-id="2740700766-15">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">load_app</span><span class="w"> </span><span class="k" data-group-id="2740700766-17">do</span><span class="w">
    </span><span class="nc">Application</span><span class="o">.</span><span class="n">load</span><span class="p" data-group-id="2740700766-18">(</span><span class="na">@app</span><span class="p" data-group-id="2740700766-18">)</span><span class="w">
  </span><span class="k" data-group-id="2740700766-17">end</span><span class="w">
</span><span class="k" data-group-id="2740700766-1">end</span></code></pre><p>Where you replace the first two lines by your application names.</p><p>Now you can assemble a new release with <code class="inline">MIX_ENV=prod mix release</code> and you can invoke any code, including the functions in the module above, by calling the <code class="inline">eval</code> command:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">_build/prod/rel/my_app/bin/my_app eval &quot;MyApp.Release.migrate&quot;
</span></code></pre><p>And that's it! If you peek inside the <code class="inline">migrate</code> script, you'll see it wraps exactly this invocation.</p><p>You can use this approach to create any custom command to run in production. In this case, we used <code class="inline">load_app</code>, which calls <a href="https://hexdocs.pm/elixir/Application.html#load/1"><code class="inline">Application.load/1</code></a> to load the current application without starting it. However, you may want to write a custom command that starts the whole application. In such cases, <a href="https://hexdocs.pm/elixir/Application.html#ensure_all_started/1"><code class="inline">Application.ensure_all_started/1</code></a> must be used. Keep in mind, starting the application will start all processes for the current application, including the Phoenix endpoint. This can be circumvented by changing your supervision tree to not start certain children under certain conditions. For example, in the release commands file you could do:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defp</span><span class="w"> </span><span class="nf">start_app</span><span class="w"> </span><span class="k" data-group-id="0296645535-1">do</span><span class="w">
  </span><span class="n">load_app</span><span class="p" data-group-id="0296645535-2">(</span><span class="p" data-group-id="0296645535-2">)</span><span class="w">
  </span><span class="nc">Application</span><span class="o">.</span><span class="n">put_env</span><span class="p" data-group-id="0296645535-3">(</span><span class="na">@app</span><span class="p">,</span><span class="w"> </span><span class="ss">:minimal</span><span class="p">,</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="0296645535-3">)</span><span class="w">
  </span><span class="nc">Application</span><span class="o">.</span><span class="n">ensure_all_started</span><span class="p" data-group-id="0296645535-4">(</span><span class="na">@app</span><span class="p" data-group-id="0296645535-4">)</span><span class="w">
</span><span class="k" data-group-id="0296645535-1">end</span></code></pre><p>And then in your application you check <code class="inline">Application.get_env(@app, :minimal)</code> and start only part of the children when it is set.</p><h2 id="containers" class="section-heading">
  <a href="#containers" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Containers</span>
</h2>
<p>Elixir releases work well with container technologies, such as Docker. The idea is that you assemble the release inside the Docker container and then build an image based on the release artifacts.</p><p>If you call <code class="inline">mix phx.gen.release --docker</code> you'll see a new file with these contents:</p><pre><code class="makeup Dockerfile" translate="no"><span class="c">#</span><span class="c"> Find eligible builder and runner images on Docker Hub. We use Ubuntu/Debian
</span><span class="c">#</span><span class="c"> instead of Alpine to avoid DNS resolution issues in production.
</span><span class="c">#</span><span class="w">
</span><span class="c">#</span><span class="c"> https://hub.docker.com/r/hexpm/elixir/tags?page=1&amp;name=ubuntu
</span><span class="c">#</span><span class="c"> https://hub.docker.com/_/ubuntu?tab=tags
</span><span class="c">#</span><span class="w">
</span><span class="c">#</span><span class="c"> This file is based on these images:
</span><span class="c">#</span><span class="w">
</span><span class="c">#</span><span class="c">   - https://hub.docker.com/r/hexpm/elixir/tags - for the build image
</span><span class="c">#</span><span class="c">   - https://hub.docker.com/_/debian?tab=tags&amp;page=1&amp;name=bullseye-20230612-slim - for the release image
</span><span class="c">#</span><span class="c">   - https://pkgs.org/ - resource for finding needed packages
</span><span class="c">#</span><span class="c">   - Ex: hexpm/elixir:1.14.5-erlang-25.3.2.4-debian-bullseye-20230612-slim
</span><span class="c">#</span><span class="w">
</span><span class="k">ARG </span><span class="n">ELIXIR_VERSION=1.14.5
</span><span class="k">ARG </span><span class="n">OTP_VERSION=25.3.2.4
</span><span class="k">ARG </span><span class="n">DEBIAN_VERSION=bullseye-20230612-slim
</span><span class="w">
</span><span class="k">ARG </span><span class="n">BUILDER_IMAGE=&quot;hexpm/elixir:${ELIXIR_VERSION}-erlang-${OTP_VERSION}-debian-${DEBIAN_VERSION}&quot;
</span><span class="k">ARG </span><span class="n">RUNNER_IMAGE=&quot;debian:${DEBIAN_VERSION}&quot;
</span><span class="w">
</span><span class="k">FROM</span><span class="n"> ${BUILDER_IMAGE} </span><span class="k">as</span><span class="w"> </span><span class="nv">builder</span><span class="w">
</span><span class="w">
</span><span class="c">#</span><span class="c"> install build dependencies
</span><span class="k">RUN </span><span class="n">apt-get update -y &amp;&amp; apt-get install -y build-essential git \
</span><span class="n">    &amp;&amp; apt-get clean &amp;&amp; rm -f /var/lib/apt/lists/*_*
</span><span class="w">
</span><span class="c">#</span><span class="c"> prepare build dir
</span><span class="k">WORKDIR </span><span class="n">/app
</span><span class="w">
</span><span class="c">#</span><span class="c"> install hex + rebar
</span><span class="k">RUN </span><span class="n">mix local.hex --force &amp;&amp; \
</span><span class="n">    mix local.rebar --force
</span><span class="w">
</span><span class="c">#</span><span class="c"> set build ENV
</span><span class="k">ENV </span><span class="n">MIX_ENV=</span><span class="p">&quot;</span><span class="s2">prod</span><span class="p">&quot;</span><span class="w">
</span><span class="w">
</span><span class="c">#</span><span class="c"> install mix dependencies
</span><span class="k">COPY</span><span class="n"> mix.exs mix.lock ./
</span><span class="k">RUN </span><span class="n">mix deps.get --only $MIX_ENV
</span><span class="k">RUN </span><span class="n">mkdir config
</span><span class="w">
</span><span class="c">#</span><span class="c"> copy compile-time config files before we compile dependencies
</span><span class="c">#</span><span class="c"> to ensure any relevant config change will trigger the dependencies
</span><span class="c">#</span><span class="c"> to be re-compiled.
</span><span class="k">COPY</span><span class="n"> config/config.exs config/${MIX_ENV}.exs config/
</span><span class="k">RUN </span><span class="n">mix deps.compile
</span><span class="w">
</span><span class="k">COPY</span><span class="n"> priv priv
</span><span class="w">
</span><span class="k">COPY</span><span class="n"> lib lib
</span><span class="w">
</span><span class="k">COPY</span><span class="n"> assets assets
</span><span class="w">
</span><span class="c">#</span><span class="c"> compile assets
</span><span class="k">RUN </span><span class="n">mix assets.deploy
</span><span class="w">
</span><span class="c">#</span><span class="c"> Compile the release
</span><span class="k">RUN </span><span class="n">mix compile
</span><span class="w">
</span><span class="c">#</span><span class="c"> Changes to config/runtime.exs don&#39;t require recompiling the code
</span><span class="k">COPY</span><span class="n"> config/runtime.exs config/
</span><span class="w">
</span><span class="k">COPY</span><span class="n"> rel rel
</span><span class="k">RUN </span><span class="n">mix release
</span><span class="w">
</span><span class="c">#</span><span class="c"> start a new build stage so that the final image will only contain
</span><span class="c">#</span><span class="c"> the compiled release and other runtime necessities
</span><span class="k">FROM</span><span class="n"> ${RUNNER_IMAGE}
</span><span class="w">
</span><span class="k">RUN </span><span class="n">apt-get update -y &amp;&amp; \
</span><span class="n">  apt-get install -y libstdc++6 openssl libncurses5 locales ca-certificates \
</span><span class="n">  &amp;&amp; apt-get clean &amp;&amp; rm -f /var/lib/apt/lists/*_*
</span><span class="w">
</span><span class="c">#</span><span class="c"> Set the locale
</span><span class="k">RUN </span><span class="n">sed -i </span><span class="p">&#39;</span><span class="s1">/en_US.UTF-8/s/^# //g</span><span class="p">&#39;</span><span class="n"> /etc/locale.gen &amp;&amp; locale-gen
</span><span class="w">
</span><span class="k">ENV </span><span class="n">LANG en_US.UTF-8
</span><span class="k">ENV </span><span class="n">LANGUAGE en_US:en
</span><span class="k">ENV </span><span class="n">LC_ALL en_US.UTF-8
</span><span class="w">
</span><span class="k">WORKDIR </span><span class="p">&quot;</span><span class="s2">/app</span><span class="p">&quot;</span><span class="w">
</span><span class="k">RUN </span><span class="n">chown nobody /app
</span><span class="w">
</span><span class="c">#</span><span class="c"> set runner ENV
</span><span class="k">ENV </span><span class="n">MIX_ENV=</span><span class="p">&quot;</span><span class="s2">prod</span><span class="p">&quot;</span><span class="w">
</span><span class="w">
</span><span class="c">#</span><span class="c"> Only copy the final release from the build stage
</span><span class="k">COPY</span><span class="n"> --from=</span><span class="nv">builder</span><span class="n"> --chown=nobody:root /app/_build/${MIX_ENV}/rel/my_app ./
</span><span class="w">
</span><span class="k">USER </span><span class="n">nobody
</span><span class="w">
</span><span class="c">#</span><span class="c"> If using an environment that doesn&#39;t automatically reap zombie processes, it is
</span><span class="c">#</span><span class="c"> advised to add an init process such as tini via `apt-get install`
</span><span class="c">#</span><span class="c"> above and adding an entrypoint. See https://github.com/krallin/tini for details
</span><span class="c">#</span><span class="c"> ENTRYPOINT [&quot;/tini&quot;, &quot;--&quot;]
</span><span class="w">
</span><span class="o">CMD </span><span class="n">[</span><span class="p">&quot;</span><span class="s2">/app/bin/server</span><span class="p">&quot;</span><span class="n">]</span></code></pre><p>Where <code class="inline">my_app</code> is the name of your app. At the end, you will have an application in <code class="inline">/app</code> ready to run as <code class="inline">/app/bin/server</code>.</p><p>A few points about configuring a containerized application:</p><ul><li>If you run your app in a container, the <code class="inline">Endpoint</code> needs to be configured to listen on a &quot;public&quot; <code class="inline">:ip</code> address (like <code class="inline">0.0.0.0</code>) so that the app can be reached from outside the container. Whether the host should publish the container's ports to its own public IP or to localhost depends on your needs.</li><li>The more configuration you can provide at runtime (using <code class="inline">config/runtime.exs</code>), the more reusable your images will be across environments. In particular, secrets like database credentials and API keys should not be compiled into the image, but rather should be provided when creating containers based on that image. This is why the <code class="inline">Endpoint</code>'s <code class="inline">:secret_key_base</code> is configured in <code class="inline">config/runtime.exs</code> by default.</li><li>If possible, any environment variables that are needed at runtime should be read in <code class="inline">config/runtime.exs</code>, not scattered throughout your code. Having them all visible in one place will make it easier to ensure the containers get what they need, especially if the person doing the infrastructure work does not work on the Elixir code. Libraries in particular should never directly read environment variables; all their configuration should be handed to them by the top-level application, preferably <a href="https://hexdocs.pm/elixir/library-guidelines.html#avoid-application-configuration">without using the application environment</a>.</li></ul>

  </body>
</html>
