<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Testing Channels - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Testing Channels
    </h1>
<blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="installation.html">introductory guides</a> and got a Phoenix application <a href="up_and_running.html">up and running</a>.</p></blockquote><blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="testing.html">Introduction to Testing guide</a>.</p></blockquote><blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="channels.html">Channels guide</a>.</p></blockquote><p>In the Channels guide, we saw that a &quot;Channel&quot; is a layered system with different components. Given this, there would be cases when writing unit tests for our Channel functions may not be enough. We may want to verify that its different moving parts are working together as we expect. This integration testing would assure us that we correctly defined our channel route, the channel module, and its callbacks; and that the lower-level layers such as the PubSub and Transport are configured correctly and are working as intended.</p><h2 id="generating-channels" class="section-heading">
  <a href="#generating-channels" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Generating channels</span>
</h2>
<p>As we progress through this guide, it would help to have a concrete example we could work off of. Phoenix comes with a Mix task for generating a basic channel and tests. These generated files serve as a good reference for writing channels and their corresponding tests. Let's go ahead and generate our Channel:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.gen.channel Room
</span><span class="">* creating lib/hello_web/channels/room_channel.ex
</span><span class="">* creating test/hello_web/channels/room_channel_test.exs
</span><span class="">* creating test/support/channel_case.ex
</span><span class="">
</span><span class="">The default socket handler - HelloWeb.UserSocket - was not found.
</span><span class="">
</span><span class="">Do you want to create it? [Yn]  
</span><span class="">* creating lib/hello_web/channels/user_socket.ex
</span><span class="">* creating assets/js/user_socket.js
</span><span class="">
</span><span class="">Add the socket handler to your `lib/hello_web/endpoint.ex`, for example:
</span><span class="">
</span><span class="">    socket &quot;/socket&quot;, HelloWeb.UserSocket,
</span><span class="">      websocket: true,
</span><span class="">      longpoll: false
</span><span class="">
</span><span class="">For the front-end integration, you need to import the `user_socket.js`
</span><span class="">in your `assets/js/app.js` file:
</span><span class="">
</span><span class="">    import &quot;./user_socket.js&quot;
</span></code></pre><p>This creates a channel, its test and instructs us to add a channel route in <code class="inline">lib/hello_web/channels/user_socket.ex</code>. It is important to add the channel route or our channel won't function at all!</p><h2 id="the-channelcase" class="section-heading">
  <a href="#the-channelcase" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">The ChannelCase</span>
</h2>
<p>Open up <code class="inline">test/hello_web/channels/room_channel_test.exs</code> and you will find this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.RoomChannelTest</span><span class="w"> </span><span class="k" data-group-id="2664290112-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb.ChannelCase</span></code></pre><p>Similar to <code class="inline">ConnCase</code> and <code class="inline">DataCase</code>, we now have a <code class="inline">ChannelCase</code>. All three of them have been generated for us when we started our Phoenix application. Let's take a look at it. Open up <code class="inline">test/support/channel_case.ex</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.ChannelCase</span><span class="w"> </span><span class="k" data-group-id="0809805457-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">ExUnit.CaseTemplate</span><span class="w">

  </span><span class="n">using</span><span class="w"> </span><span class="k" data-group-id="0809805457-2">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="0809805457-3">do</span><span class="w">
      </span><span class="c1"># Import conveniences for testing with channels</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Phoenix.ChannelTest</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">HelloWeb.ChannelCase</span><span class="w">

      </span><span class="c1"># The default endpoint for testing</span><span class="w">
      </span><span class="na">@endpoint</span><span class="w"> </span><span class="nc">HelloWeb.Endpoint</span><span class="w">
    </span><span class="k" data-group-id="0809805457-3">end</span><span class="w">
  </span><span class="k" data-group-id="0809805457-2">end</span><span class="w">

  </span><span class="n">setup</span><span class="w"> </span><span class="c">_tags</span><span class="w"> </span><span class="k" data-group-id="0809805457-4">do</span><span class="w">
    </span><span class="nc">Hello.DataCase</span><span class="o">.</span><span class="n">setup_sandbox</span><span class="p" data-group-id="0809805457-5">(</span><span class="n">tags</span><span class="p" data-group-id="0809805457-5">)</span><span class="w">
    </span><span class="ss">:ok</span><span class="w">
  </span><span class="k" data-group-id="0809805457-4">end</span><span class="w">
</span><span class="k" data-group-id="0809805457-1">end</span></code></pre><p>It is very straight-forward. It sets up a case template that imports all of <a href="Phoenix.ChannelTest.xhtml"><code class="inline">Phoenix.ChannelTest</code></a> on use. In the <code class="inline">setup</code> block, it starts the SQL Sandbox, which we discussed in the <a href="testing_contexts.html">Testing contexts guide</a>.</p><h2 id="subscribe-and-joining" class="section-heading">
  <a href="#subscribe-and-joining" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Subscribe and joining</span>
</h2>
<p>Now that we know that Phoenix provides with a custom Test Case just for channels and what it
provides, we can move on to understanding the rest of <code class="inline">test/hello_web/channels/room_channel_test.exs</code>.</p><p>First off, is the setup block:</p><pre><code class="makeup elixir" translate="no"><span class="n">setup</span><span class="w"> </span><span class="k" data-group-id="1195125873-1">do</span><span class="w">
  </span><span class="p" data-group-id="1195125873-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="1195125873-2">}</span><span class="w"> </span><span class="o">=</span><span class="w">
    </span><span class="nc">HelloWeb.UserSocket</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="1195125873-3">(</span><span class="s">&quot;user_id&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1195125873-4">%{</span><span class="ss">some</span><span class="p">:</span><span class="w"> </span><span class="ss">:assign</span><span class="p" data-group-id="1195125873-4">}</span><span class="p" data-group-id="1195125873-3">)</span><span class="w">
    </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">subscribe_and_join</span><span class="p" data-group-id="1195125873-5">(</span><span class="nc">HelloWeb.RoomChannel</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;room:lobby&quot;</span><span class="p" data-group-id="1195125873-5">)</span><span class="w">

  </span><span class="p" data-group-id="1195125873-6">%{</span><span class="ss">socket</span><span class="p">:</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="1195125873-6">}</span><span class="w">
</span><span class="k" data-group-id="1195125873-1">end</span></code></pre><p>The <code class="inline">setup</code> block sets up a <a href="Phoenix.Socket.xhtml"><code class="inline">Phoenix.Socket</code></a> based on the <code class="inline">UserSocket</code> module, which you can find at <code class="inline">lib/hello_web/channels/user_socket.ex</code>. Then it says we want to subscribe and join the <code class="inline">RoomChannel</code>, accessible as <code class="inline">&quot;room:lobby&quot;</code> in the <code class="inline">UserSocket</code>. At the end of the test, we return the <code class="inline">%{socket: socket}</code> as metadata, so we can reuse it on every test.</p><p>In a nutshell, <code class="inline">subscribe_and_join/3</code> emulates the client joining a channel and subscribes the test process to the given topic. This is a necessary step since clients need to join a channel before they can send and receive events on that channel.</p><h2 id="testing-a-synchronous-reply" class="section-heading">
  <a href="#testing-a-synchronous-reply" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Testing a synchronous reply</span>
</h2>
<p>The first test block in our generated channel test looks like:</p><pre><code class="makeup elixir" translate="no"><span class="n">test</span><span class="w"> </span><span class="s">&quot;ping replies with status ok&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3455361234-1">%{</span><span class="ss">socket</span><span class="p">:</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="3455361234-1">}</span><span class="w"> </span><span class="k" data-group-id="3455361234-2">do</span><span class="w">
  </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">push</span><span class="p" data-group-id="3455361234-3">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ping&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3455361234-4">%{</span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;there&quot;</span><span class="p" data-group-id="3455361234-4">}</span><span class="p" data-group-id="3455361234-3">)</span><span class="w">
  </span><span class="n">assert_reply</span><span class="w"> </span><span class="n">ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3455361234-5">%{</span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;there&quot;</span><span class="p" data-group-id="3455361234-5">}</span><span class="w">
</span><span class="k" data-group-id="3455361234-2">end</span></code></pre><p>This tests the following code in our <code class="inline">HelloWeb.RoomChannel</code>:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># Channels can be used in a request/response fashion</span><span class="w">
</span><span class="c1"># by sending replies to requests from the client</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_in</span><span class="p" data-group-id="8513190386-1">(</span><span class="s">&quot;ping&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">payload</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="8513190386-1">)</span><span class="w"> </span><span class="k" data-group-id="8513190386-2">do</span><span class="w">
  </span><span class="p" data-group-id="8513190386-3">{</span><span class="ss">:reply</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8513190386-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">payload</span><span class="p" data-group-id="8513190386-4">}</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="8513190386-3">}</span><span class="w">
</span><span class="k" data-group-id="8513190386-2">end</span></code></pre><p>As is stated in the comment above, we see that a <code class="inline">reply</code> is synchronous since it mimics the request/response pattern we are familiar with in HTTP. This synchronous reply is best used when we only want to send an event back to the client when we are done processing the message on the server. For example, when we save something to the database and then send a message to the client only once that's done.</p><p>In the <code class="inline">test &quot;ping replies with status ok&quot;, %{socket: socket} do</code> line, we see that we have the map <code class="inline">%{socket: socket}</code>. This gives us access to the <code class="inline">socket</code> in the setup block.</p><p>We emulate the client pushing a message to the channel with <code class="inline">push/3</code>. In the line <code class="inline">ref = push(socket, &quot;ping&quot;, %{&quot;hello&quot; =&gt; &quot;there&quot;})</code>, we push the event <code class="inline">&quot;ping&quot;</code> with the payload <code class="inline">%{&quot;hello&quot; =&gt; &quot;there&quot;}</code> to the channel. This triggers the <code class="inline">handle_in/3</code> callback we have for the <code class="inline">&quot;ping&quot;</code> event in our channel. Note that we store the <code class="inline">ref</code> since we need that on the next line for asserting the reply. With <code class="inline">assert_reply ref, :ok, %{&quot;hello&quot; =&gt; &quot;there&quot;}</code>, we assert that the server sends a synchronous reply <code class="inline">:ok, %{&quot;hello&quot; =&gt; &quot;there&quot;}</code>. This is how we check that the <code class="inline">handle_in/3</code> callback for the <code class="inline">&quot;ping&quot;</code> was triggered.</p><h3 id="testing-a-broadcast" class="section-heading">
  <a href="#testing-a-broadcast" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Testing a Broadcast</span>
</h3>
<p>It is common to receive messages from the client and broadcast to everyone subscribed to a current topic. This common pattern is simple to express in Phoenix and is one of the generated <code class="inline">handle_in/3</code> callbacks in our <code class="inline">HelloWeb.RoomChannel</code>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">handle_in</span><span class="p" data-group-id="8116364898-1">(</span><span class="s">&quot;shout&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">payload</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="8116364898-1">)</span><span class="w"> </span><span class="k" data-group-id="8116364898-2">do</span><span class="w">
  </span><span class="n">broadcast</span><span class="p" data-group-id="8116364898-3">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shout&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">payload</span><span class="p" data-group-id="8116364898-3">)</span><span class="w">
  </span><span class="p" data-group-id="8116364898-4">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="8116364898-4">}</span><span class="w">
</span><span class="k" data-group-id="8116364898-2">end</span></code></pre><p>Its corresponding test looks like:</p><pre><code class="makeup elixir" translate="no"><span class="n">test</span><span class="w"> </span><span class="s">&quot;shout broadcasts to room:lobby&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1507787721-1">%{</span><span class="ss">socket</span><span class="p">:</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="1507787721-1">}</span><span class="w"> </span><span class="k" data-group-id="1507787721-2">do</span><span class="w">
  </span><span class="n">push</span><span class="p" data-group-id="1507787721-3">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shout&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1507787721-4">%{</span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;all&quot;</span><span class="p" data-group-id="1507787721-4">}</span><span class="p" data-group-id="1507787721-3">)</span><span class="w">
  </span><span class="n">assert_broadcast</span><span class="w"> </span><span class="s">&quot;shout&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1507787721-5">%{</span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;all&quot;</span><span class="p" data-group-id="1507787721-5">}</span><span class="w">
</span><span class="k" data-group-id="1507787721-2">end</span></code></pre><p>We notice that we access the same <code class="inline">socket</code> that is from the setup block. How handy! We also do the same <code class="inline">push/3</code> as we did in the synchronous reply test. So we <code class="inline">push</code> the <code class="inline">&quot;shout&quot;</code> event with the payload <code class="inline">%{&quot;hello&quot; =&gt; &quot;all&quot;}</code>.</p><p>Since the <code class="inline">handle_in/3</code> callback for the <code class="inline">&quot;shout&quot;</code> event just broadcasts the same event and payload, all subscribers in the <code class="inline">&quot;room:lobby&quot;</code> should receive the message. To check that, we do <code class="inline">assert_broadcast &quot;shout&quot;, %{&quot;hello&quot; =&gt; &quot;all&quot;}</code>.</p><p><strong>NOTE:</strong> <code class="inline">assert_broadcast/3</code> tests that the message was broadcast in the PubSub system. For testing if a client receives a message, use <code class="inline">assert_push/3</code>.</p><h3 id="testing-an-asynchronous-push-from-the-server" class="section-heading">
  <a href="#testing-an-asynchronous-push-from-the-server" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Testing an asynchronous push from the server</span>
</h3>
<p>The last test in our <code class="inline">HelloWeb.RoomChannelTest</code> verifies that broadcasts from the server are pushed to the client. Unlike the previous tests discussed, we are indirectly testing that the channel's <code class="inline">handle_out/3</code> callback is triggered. By default, <code class="inline">handle_out/3</code> is implemented for us and simply pushes the message on to the client.</p><p>Since the <code class="inline">handle_out/3</code> event is only triggered when we call <code class="inline">broadcast/3</code> from our channel, we will need to emulate that in our test. We do that by calling <code class="inline">broadcast_from</code> or <code class="inline">broadcast_from!</code>. Both serve the same purpose with the only difference of <code class="inline">broadcast_from!</code> raising an error when broadcast fails.</p><p>The line <code class="inline">broadcast_from!(socket, &quot;broadcast&quot;, %{&quot;some&quot; =&gt; &quot;data&quot;})</code> will trigger the <code class="inline">handle_out/3</code> callback which pushes the same event and payload back to the client. To test this, we do <code class="inline">assert_push &quot;broadcast&quot;, %{&quot;some&quot; =&gt; &quot;data&quot;}</code>.</p><p>That's it. Now you are ready to develop and fully test real-time applications. To learn more about other functionality provided when testing channels, check out the documentation for <a href="https://hexdocs.pm/phoenix/Phoenix.ChannelTest.html"><code class="inline">Phoenix.ChannelTest</code></a>.</p>

  </body>
</html>
