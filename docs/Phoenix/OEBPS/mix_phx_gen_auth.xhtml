<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>mix phx.gen.auth - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
mix phx.gen.auth
    </h1>
<p>The <a href="Mix.Tasks.Phx.Gen.Auth.xhtml"><code class="inline">mix phx.gen.auth</code></a> command generates a flexible, pre-built authentication system into your Phoenix app. This generator allows you to quickly move past the task of adding authentication to your codebase and stay focused on the real-world problem your application is trying to solve.</p><h2 id="getting-started" class="section-heading">
  <a href="#getting-started" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Getting started</span>
</h2>
<blockquote><p>Before running this command, consider committing your work as it generates multiple files.</p></blockquote><p>Let's start by running the following command from the root of our app (or <code class="inline">apps/my_app_web</code> in an umbrella app):</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.gen.auth Accounts User users
</span><span class="">
</span><span class="">An authentication system can be created in two different ways:
</span><span class="">- Using Phoenix.LiveView (default)
</span><span class="">- Using Phoenix.Controller only
</span><span class="">
</span><span class="">Do you want to create a LiveView based authentication system? [Y/n] Y
</span></code></pre><p>The authentication generators support Phoenix LiveView, for enhanced UX, so we'll answer <code class="inline">Y</code> here. You may also answer <code class="inline">n</code> for a controller based authentication system.</p><p>Either approach will create an <code class="inline">Accounts</code> context with an <code class="inline">Accounts.User</code> schema module. The final argument is the plural version of the schema module, which is used for generating database table names and route paths. The <a href="Mix.Tasks.Phx.Gen.Auth.xhtml"><code class="inline">mix phx.gen.auth</code></a> generator is similar to <a href="Mix.Tasks.Phx.Gen.Html.xhtml"><code class="inline">mix phx.gen.html</code></a> except it does not accept a list of additional fields to add to the schema, and it generates many more context functions.</p><p>Since this generator installed additional dependencies in <code class="inline">mix.exs</code>, let's fetch those:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix deps.get
</span></code></pre><p>Now we need to verify the database connection details for the development and test environments in <code class="inline">config/</code> so the migrator and tests can run properly. Then run the following to create the database:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix ecto.setup
</span></code></pre><p>Let's run the tests to make sure our new authentication system works as expected.</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix test
</span></code></pre><p>And finally, let's start our Phoenix server and try it out.</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.server
</span></code></pre><h2 id="developer-responsibilities" class="section-heading">
  <a href="#developer-responsibilities" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Developer responsibilities</span>
</h2>
<p>Since Phoenix generates this code into your application instead of building these modules into Phoenix itself, you now have complete freedom to modify the authentication system, so it works best with your use case. The one caveat with using a generated authentication system is it will not be updated after it's been generated. Therefore, as improvements are made to the output of <a href="Mix.Tasks.Phx.Gen.Auth.xhtml"><code class="inline">mix phx.gen.auth</code></a>, it becomes your responsibility to determine if these changes need to be ported into your application. Security-related and other important improvements will be explicitly and clearly marked in the <code class="inline">CHANGELOG.md</code> file and upgrade notes.</p><h2 id="generated-code" class="section-heading">
  <a href="#generated-code" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Generated code</span>
</h2>
<p>The following are notes about the generated authentication system.</p><h3 id="password-hashing" class="section-heading">
  <a href="#password-hashing" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Password hashing</span>
</h3>
<p>The password hashing mechanism defaults to <code class="inline">bcrypt</code> for Unix systems and <code class="inline">pbkdf2</code> for Windows systems. Both systems use the <a href="https://hexdocs.pm/comeonin/">Comeonin interface</a>.</p><p>The password hashing mechanism can be overridden with the <code class="inline">--hashing-lib</code> option. The following values are supported:</p><ul><li><code class="inline">bcrypt</code> - <a href="https://hex.pm/packages/bcrypt_elixir">bcrypt_elixir</a></li><li><code class="inline">pbkdf2</code> - <a href="https://hex.pm/packages/pbkdf2_elixir">pbkdf2_elixir</a></li><li><code class="inline">argon2</code> - <a href="https://hex.pm/packages/argon2_elixir">argon2_elixir</a></li></ul><p>We recommend developers to consider using <code class="inline">argon2</code>, which is the most robust of all 3. The downside is that <code class="inline">argon2</code> is quite CPU and memory intensive, and you will need more powerful instances to run your applications on.</p><p>For more information about choosing these libraries, see the <a href="https://github.com/riverrun/comeonin">Comeonin project</a>.</p><h3 id="forbidding-access" class="section-heading">
  <a href="#forbidding-access" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Forbidding access</span>
</h3>
<p>The generated code ships with an authentication module with a handful of plugs that fetch the current user, require authentication and so on. For instance, in an app named Demo which had <code class="inline">mix phx.gen.auth Accounts User users</code> run on it, you will find a module named <code class="inline">DemoWeb.UserAuth</code> with plugs such as:</p><ul><li><code class="inline">fetch_current_user</code> - fetches the current user information if available</li><li><code class="inline">require_authenticated_user</code> - must be invoked after <code class="inline">fetch_current_user</code> and requires that a current user exists and is authenticated</li><li><code class="inline">redirect_if_user_is_authenticated</code> - used for the few pages that must not be available to authenticated users</li></ul><h3 id="confirmation" class="section-heading">
  <a href="#confirmation" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Confirmation</span>
</h3>
<p>The generated functionality ships with an account confirmation mechanism, where users have to confirm their account, typically by email. However, the generated code does not forbid users from using the application if their accounts have not yet been confirmed. You can add this functionality by customizing the <code class="inline">require_authenticated_user</code> in the <code class="inline">Auth</code> module to check for the <code class="inline">confirmed_at</code> field (and any other property you desire).</p><h3 id="notifiers" class="section-heading">
  <a href="#notifiers" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Notifiers</span>
</h3>
<p>The generated code is not integrated with any system to send SMSes or emails for confirming accounts, resetting passwords, etc. Instead, it simply logs a message to the terminal. It is your responsibility to integrate with the proper system after generation.</p><p>Note that if you generated your Phoenix project with <a href="https://hexdocs.pm/phx_new/1.8.0-rc.3/Mix.Tasks.Phx.New.html"><code class="inline">mix phx.new</code></a>, your project is configured to use <a href="https://hexdocs.pm/swoosh/Swoosh.html">Swoosh</a> mailer by default. To view notifier emails during development with Swoosh, navigate to <code class="inline">/dev/mailbox</code>.</p><h3 id="tracking-sessions" class="section-heading">
  <a href="#tracking-sessions" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Tracking sessions</span>
</h3>
<p>All sessions and tokens are tracked in a separate table. This allows you to track how many sessions are active for each account. You could even expose this information to users if desired.</p><p>Note that whenever the password changes (either via reset password or directly), all tokens are deleted, and the user has to log in again on all devices.</p><h3 id="user-enumeration-attacks" class="section-heading">
  <a href="#user-enumeration-attacks" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">User Enumeration attacks</span>
</h3>
<p>A user enumeration attack allows someone to check if an email is registered in the application. The generated authentication code does not attempt to protect from such checks. For instance, when you register an account, if the email is already registered, the code will notify the user the email is already registered.</p><p>If your application is sensitive to enumeration attacks, you need to implement your own workflows, which tends to be very different from most applications, as you need to carefully balance security and user experience.</p><p>Furthermore, if you are concerned about enumeration attacks, beware of timing attacks too. For example, registering a new account typically involves additional work (such as writing to the database, sending emails, etc) compared to when an account already exists. Someone could measure the time taken to execute those additional tasks to enumerate emails. This applies to all endpoints (registration, confirmation, password recovery, etc.) that may send email, in-app notifications, etc.</p><h3 id="case-sensitiveness" class="section-heading">
  <a href="#case-sensitiveness" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Case sensitiveness</span>
</h3>
<p>The email lookup is made to be case-insensitive. Case-insensitive lookups are the default in MySQL and MSSQL. In SQLite3 we use <a href="https://www.sqlite.org/datatype3.html#collating_sequences"><code class="inline">COLLATE NOCASE</code></a> in the column definition to support it. In PostgreSQL, we use the <a href="https://www.postgresql.org/docs/current/citext.html"><code class="inline">citext</code> extension</a>.</p><p>Note <code class="inline">citext</code> is part of PostgreSQL itself and is bundled with it in most operating systems and package managers. <a href="Mix.Tasks.Phx.Gen.Auth.xhtml"><code class="inline">mix phx.gen.auth</code></a> takes care of creating the extension and no extra work is necessary in the majority of cases. If by any chance your package manager splits <code class="inline">citext</code> into a separate package, you will get an error while migrating, and you can most likely solve it by installing the <code class="inline">postgres-contrib</code> package.</p><h3 id="concurrent-tests" class="section-heading">
  <a href="#concurrent-tests" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Concurrent tests</span>
</h3>
<p>The generated tests run concurrently if you are using a database that supports concurrent tests, which is the case of PostgreSQL.</p><h2 id="more-about-mix-phx-gen-auth" class="section-heading">
  <a href="#more-about-mix-phx-gen-auth" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">More about <a href="Mix.Tasks.Phx.Gen.Auth.xhtml"><code class="inline">mix phx.gen.auth</code></a></span>
</h2>
<p>Check out <a href="Mix.Tasks.Phx.Gen.Auth.xhtml"><code class="inline">mix phx.gen.auth</code></a> for more details, such as using a different password hashing library, customizing the web module namespace, generating binary id type, configuring the default options, and using custom table names.</p><h2 id="additional-resources" class="section-heading">
  <a href="#additional-resources" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Additional resources</span>
</h2>
<p>The following links have more information regarding the motivation and design of the code this generates.</p><ul><li>Berenice Medel's blog post on generating LiveViews for authentication (rather than conventional Controllers &amp; Views) - <a href="https://fly.io/phoenix-files/phx-gen-auth/">Bringing Phoenix Authentication to Life</a></li><li>José Valim's blog post - <a href="https://dashbit.co/blog/a-new-authentication-solution-for-phoenix">An upcoming authentication solution for Phoenix</a></li><li>The <a href="https://github.com/aaronrenner/phx_gen_auth" title="">original <code class="inline">phx_gen_auth</code> repo</a> (for Phoenix 1.5 applications) - This is a great resource to see discussions around decisions that have been made in earlier versions of the project.</li><li><a href="https://github.com/dashbitco/mix_phx_gen_auth_demo/pull/1" title="">Original pull request on bare Phoenix app</a></li><li><a href="https://github.com/dashbitco/mix_phx_gen_auth_demo/blob/auth/README.md">Original design spec</a></li></ul>

  </body>
</html>
