<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Deploying on Heroku - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Deploying on Heroku
    </h1>
<h2 id="what-we-ll-need" class="section-heading">
  <a href="#what-we-ll-need" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">What we'll need</span>
</h2>
<p>The only thing we'll need for this guide is a working Phoenix application. For those of us who need a simple application to deploy, please follow the <a href="https://hexdocs.pm/phoenix/up_and_running.html">Up and Running guide</a>.</p><h2 id="goals" class="section-heading">
  <a href="#goals" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Goals</span>
</h2>
<p>Our main goal for this guide is to get a Phoenix application running on Heroku.</p><h2 id="limitations" class="section-heading">
  <a href="#limitations" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Limitations</span>
</h2>
<p>Heroku is a great platform and Elixir performs well on it. However, you may run into limitations if you plan to leverage advanced features provided by Elixir and Phoenix, such as:</p><ul><li><p>Connections are limited.</p><ul><li>Heroku <a href="https://devcenter.heroku.com/articles/http-routing#request-concurrency">limits the number of simultaneous connections</a> as well as the <a href="https://devcenter.heroku.com/articles/limits#http-timeouts">duration of each connection</a>. It is common to use Elixir for real-time apps which need lots of concurrent, persistent connections, and Phoenix is capable of <a href="https://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections">handling over 2 million connections on a single server</a>.</li></ul></li><li><p>Distributed clustering is not possible.</p><ul><li>Heroku <a href="https://devcenter.heroku.com/articles/dynos#networking">firewalls dynos off from one another</a>. This means things like <a href="https://dockyard.com/blog/2016/01/28/running-elixir-and-phoenix-projects-on-a-cluster-of-nodes">distributed Phoenix channels</a> and <a href="https://hexdocs.pm/elixir/distributed-tasks.html">distributed tasks</a> will need to rely on something like Redis instead of Elixir's built-in distribution.</li></ul></li><li><p>In-memory state such as those in <a href="https://hexdocs.pm/elixir/agents.html">Agents</a>, <a href="https://hexdocs.pm/elixir/genservers.html">GenServers</a>, and <a href="https://hexdocs.pm/elixir/erlang-term-storage.html">ETS</a> will be lost every 24 hours.</p><ul><li>Heroku <a href="https://devcenter.heroku.com/articles/dynos#restarting">restarts dynos</a> every 24 hours regardless of whether the node is healthy.</li></ul></li><li><p><a href="https://hexdocs.pm/elixir/debugging.html#observer">The built-in observer</a> can't be used with Heroku.</p><ul><li>Heroku does allow for connection into your dyno, but you won't be able to use the observer to watch the state of your dyno.</li></ul></li></ul><p>If you are just getting started, or you don't expect to use the features above, Heroku should be enough for your needs. For instance, if you are migrating an existing application running on Heroku to Phoenix, keeping a similar set of features, Elixir will perform just as well or even better than your current stack.</p><p>If you want a platform-as-a-service without these limitations, try <a href="gigalixir.html">Gigalixir</a>. If you would rather deploy to a cloud platform, such as EC2, Google Cloud, etc, consider using <a href="https://hexdocs.pm/mix/Mix.Tasks.Release.html"><code class="inline">mix release</code></a>.</p><h2 id="steps" class="section-heading">
  <a href="#steps" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Steps</span>
</h2>
<p>Let's separate this process into a few steps, so we can keep track of where we are.</p><ul><li>Initialize Git repository</li><li>Sign up for Heroku</li><li>Install the Heroku Toolbelt</li><li>Create and set up Heroku application</li><li>Make our project ready for Heroku</li><li>Deploy time!</li><li>Useful Heroku commands</li></ul><h2 id="initializing-git-repository" class="section-heading">
  <a href="#initializing-git-repository" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Initializing Git repository</span>
</h2>
<p><a href="https://git-scm.com/">Git</a> is a popular decentralized revision control system and is also used to deploy apps to Heroku.</p><p>Before we can push to Heroku, we'll need to initialize a local Git repository and commit our files to it. We can do so by running the following commands in our project directory:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">git init
</span><span class="gp unselectable">$ </span><span class="">git add .
</span><span class="gp unselectable">$ </span><span class="">git commit -m &quot;Initial commit&quot;
</span></code></pre><p>Heroku offers some great information on how it is using Git <a href="https://devcenter.heroku.com/articles/git#prerequisites-install-git-and-the-heroku-cli">here</a>.</p><h2 id="signing-up-for-heroku" class="section-heading">
  <a href="#signing-up-for-heroku" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Signing up for Heroku</span>
</h2>
<p>Signing up to Heroku is very simple, just head over to <a href="https://signup.heroku.com/">https://signup.heroku.com/</a> and fill in the form.</p><p>The Free plan will give us one web <a href="https://devcenter.heroku.com/articles/dynos">dyno</a> and one worker dyno, as well as a PostgreSQL and Redis instance for free.</p><p>These are meant to be used for testing and development, and come with some limitations. In order to run a production application, please consider upgrading to a paid plan.</p><h2 id="installing-the-heroku-toolbelt" class="section-heading">
  <a href="#installing-the-heroku-toolbelt" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Installing the Heroku Toolbelt</span>
</h2>
<p>Once we have signed up, we can download the correct version of the Heroku Toolbelt for our system <a href="https://toolbelt.heroku.com/">here</a>.</p><p>The Heroku CLI, part of the Toolbelt, is useful to create Heroku applications, list currently running dynos for an existing application, tail logs or run one-off commands (mix tasks for instance).</p><h2 id="create-and-set-up-heroku-application" class="section-heading">
  <a href="#create-and-set-up-heroku-application" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Create and Set Up Heroku Application</span>
</h2>
<p>There are two different ways to deploy a Phoenix app on Heroku. We could use Heroku buildpacks or their container stack. The difference between these two approaches is in how we tell Heroku to treat our build. In buildpack case, we need to update our apps configuration on Heroku to use Phoenix/Elixir specific buildpacks. On container approach, we have more control on how we want to set up our app, and we can define our container image using <code class="inline">Dockerfile</code> and <code class="inline">heroku.yml</code>. This section will explore the buildpack approach. In order to use Dockerfile, it is often recommended to convert our app to use releases, which we will describe later on.</p><h3 id="create-application" class="section-heading">
  <a href="#create-application" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Create Application</span>
</h3>
<p>A <a href="https://devcenter.heroku.com/articles/buildpacks">buildpack</a> is a convenient way of packaging framework and/or runtime support. Phoenix requires 2 buildpacks to run on Heroku, the first adds basic Elixir support and the second adds Phoenix specific commands.</p><p>With the Toolbelt installed, let's create the Heroku application. We will do so using the latest available version of the <a href="https://github.com/HashNuke/heroku-buildpack-elixir">Elixir buildpack</a>:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku create --buildpack hashnuke/elixir
</span><span class="">Creating app... done, â¬¢ mysterious-meadow-6277
</span><span class="">Setting buildpack to hashnuke/elixir... done
</span><span class="">https://mysterious-meadow-6277.herokuapp.com/ | https://git.heroku.com/mysterious-meadow-6277.git
</span></code></pre><blockquote><p>Note: the first time we use a Heroku command, it may prompt us to log in. If this happens, just enter the email and password you specified during signup.</p></blockquote><blockquote><p>Note: the name of the Heroku application is the random string after &quot;Creating&quot; in the output above (mysterious-meadow-6277). This will be unique, so expect to see a different name from &quot;mysterious-meadow-6277&quot;.</p></blockquote><blockquote><p>Note: the URL in the output is the URL to our application. If we open it in our browser now, we will get the default Heroku welcome page.</p></blockquote><blockquote><p>Note: if we hadn't initialized our Git repository before we ran the <code class="inline">heroku create</code> command, we wouldn't have our Heroku remote repository properly set up at this point. We can set that up manually by running: <code class="inline">heroku git:remote -a [our-app-name].</code></p></blockquote><p>The buildpack uses a predefined Elixir and Erlang version, but to avoid surprises when deploying, it is best to explicitly list the Elixir and Erlang version we want in production to be the same we are using during development or in your continuous integration servers. This is done by creating a config file named <code class="inline">elixir_buildpack.config</code> in the root directory of your project with your target version of Elixir and Erlang:</p><pre><code class="makeup console" translate="no"><span class=""># Elixir version
</span><span class="">elixir_version=1.14.0
</span><span class="">
</span><span class=""># Erlang version
</span><span class=""># https://github.com/HashNuke/heroku-buildpack-elixir-otp-builds/blob/master/otp-versions
</span><span class="">erlang_version=24.3
</span><span class="">
</span><span class=""># Invoke assets.deploy defined in your mix.exs to deploy assets with esbuild
</span><span class=""># Note we nuke the esbuild executable from the image
</span><span class="">hook_post_compile=&quot;eval mix assets.deploy &amp;&amp; rm -f _build/esbuild*&quot;
</span></code></pre><p>Finally, let's tell the build pack how to start our webserver. Create a file named <code class="inline">Procfile</code> at the root of your project:</p><pre><code class="makeup console" translate="no"><span class="">web: mix phx.server
</span></code></pre><h3 id="optional-node-npm-and-the-phoenix-static-buildpack" class="section-heading">
  <a href="#optional-node-npm-and-the-phoenix-static-buildpack" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Optional: Node, npm, and the Phoenix Static buildpack</span>
</h3>
<p>By default, Phoenix uses <code class="inline">esbuild</code> and manages all assets for you. However, if you are using <code class="inline">node</code> and <code class="inline">npm</code>, you will need to install the <a href="https://github.com/gigalixir/gigalixir-buildpack-phoenix-static">Phoenix Static buildpack</a> to handle them:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku buildpacks:add https://github.com/gigalixir/gigalixir-buildpack-phoenix-static.git
</span><span class="">Buildpack added. Next release on mysterious-meadow-6277 will use:
</span><span class="">  1. https://github.com/HashNuke/heroku-buildpack-elixir.git
</span><span class="">  2. https://github.com/gigalixir/gigalixir-heroku-buildpack-phoenix-static.git
</span></code></pre><p>When using this buildpack, you want to delegate all asset bundling to <code class="inline">npm</code>. So you must remove the <code class="inline">hook_post_compile</code> configuration from your <code class="inline">elixir_buildpack.config</code> and move it to the deploy script of your <code class="inline">assets/package.json</code>. Something like this:</p><pre><code class="makeup javascript" translate="no"><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="o">...</span><span class="w">
</span><span class="w">  </span><span class="p">&quot;</span><span class="s2">scripts</span><span class="p">&quot;</span><span class="n">: </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="p">&quot;</span><span class="s2">deploy</span><span class="p">&quot;</span><span class="n">: </span><span class="p">&quot;</span><span class="s2">cd .. &amp;&amp; mix assets.deploy &amp;&amp; rm -f _build/esbuild*</span><span class="p">&quot;</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w">  </span><span class="o">...</span><span class="w">
</span><span class="p">}</span></code></pre><p>The Phoenix Static buildpack uses a predefined Node.js version, but to avoid surprises when deploying, it is best to explicitly list the Node.js version we want in production to be the same we are using during development or in your continuous integration servers. This is done by creating a config file named <code class="inline">phoenix_static_buildpack.config</code> in the root directory of your project with your target version of Node.js:</p><pre><code class="text"># Node.js version
node_version=10.20.1</code></pre><p>Please refer to the <a href="https://github.com/gigalixir/gigalixir-buildpack-phoenix-static#configuration">configuration section</a> for full details. You can make your own custom build script, but for now we will use the <a href="https://github.com/gigalixir/gigalixir-buildpack-phoenix-static/blob/master/compile">default one provided</a>.</p><p>Finally, note that since we are using multiple buildpacks, you might run into an issue where the sequence is out of order (the Elixir buildpack needs to run before the Phoenix Static buildpack). <a href="https://devcenter.heroku.com/articles/using-multiple-buildpacks-for-an-app">Heroku's docs</a> explain this better, but you will need to make sure the Phoenix Static buildpack comes last.</p><h2 id="making-our-project-ready-for-heroku" class="section-heading">
  <a href="#making-our-project-ready-for-heroku" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Making our Project ready for Heroku</span>
</h2>
<p>Every new Phoenix project ships with a config file <code class="inline">config/runtime.exs</code> (formerly <code class="inline">config/prod.secret.exs</code>) which loads configuration and secrets from <a href="https://devcenter.heroku.com/articles/config-vars">environment variables</a>. This aligns well with Heroku best practices (<a href="https://12factor.net/">12-factor apps</a>), so the only work left for us to do is to configure URLs and SSL.</p><p>First let's tell Phoenix to only use the SSL version of the website. Find the endpoint config in your <code class="inline">config/prod.exs</code>:</p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:scaffold</span><span class="p">,</span><span class="w"> </span><span class="nc">ScaffoldWeb.Endpoint</span><span class="p">,</span><span class="w">
  </span><span class="ss">url</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5261763061-1">[</span><span class="ss">port</span><span class="p">:</span><span class="w"> </span><span class="mi">443</span><span class="p">,</span><span class="w"> </span><span class="ss">scheme</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;https&quot;</span><span class="p" data-group-id="5261763061-1">]</span><span class="p">,</span></code></pre><p>... and add <code class="inline">force_ssl</code></p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:scaffold</span><span class="p">,</span><span class="w"> </span><span class="nc">ScaffoldWeb.Endpoint</span><span class="p">,</span><span class="w">
  </span><span class="ss">url</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4881301689-1">[</span><span class="ss">port</span><span class="p">:</span><span class="w"> </span><span class="mi">443</span><span class="p">,</span><span class="w"> </span><span class="ss">scheme</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;https&quot;</span><span class="p" data-group-id="4881301689-1">]</span><span class="p">,</span><span class="w">
  </span><span class="ss">force_ssl</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4881301689-2">[</span><span class="ss">rewrite_on</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4881301689-3">[</span><span class="ss">:x_forwarded_proto</span><span class="p" data-group-id="4881301689-3">]</span><span class="p" data-group-id="4881301689-2">]</span><span class="p">,</span></code></pre><p><code class="inline">force_ssl</code> need to be set here because it is a <em>compile</em> time config. It will not work when set from <code class="inline">runtime.exs</code>.</p><p>Then in your <code class="inline">config/runtime.exs</code> (formerly <code class="inline">config/prod.secret.exs</code>):</p><p>... add <code class="inline">host</code></p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:scaffold</span><span class="p">,</span><span class="w"> </span><span class="nc">ScaffoldWeb.Endpoint</span><span class="p">,</span><span class="w">
  </span><span class="ss">url</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4356719737-1">[</span><span class="ss">host</span><span class="p">:</span><span class="w"> </span><span class="n">host</span><span class="p">,</span><span class="w"> </span><span class="ss">port</span><span class="p">:</span><span class="w"> </span><span class="mi">443</span><span class="p">,</span><span class="w"> </span><span class="ss">scheme</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;https&quot;</span><span class="p" data-group-id="4356719737-1">]</span></code></pre><p>and uncomment the <code class="inline"># ssl: true,</code> line in your repository configuration. It will look like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="nc">Hello.Repo</span><span class="p">,</span><span class="w">
  </span><span class="ss">ssl</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">
  </span><span class="ss">url</span><span class="p">:</span><span class="w"> </span><span class="n">database_url</span><span class="p">,</span><span class="w">
  </span><span class="ss">pool_size</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">to_integer</span><span class="p" data-group-id="0077787217-1">(</span><span class="nc">System</span><span class="o">.</span><span class="n">get_env</span><span class="p" data-group-id="0077787217-2">(</span><span class="s">&quot;POOL_SIZE&quot;</span><span class="p" data-group-id="0077787217-2">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s">&quot;10&quot;</span><span class="p" data-group-id="0077787217-1">)</span></code></pre><p>Finally, if you plan on using websockets, then we will need to decrease the timeout for the websocket transport in <code class="inline">lib/hello_web/endpoint.ex</code>. If you do not plan on using websockets, then leaving it set to false is fine. You can find further explanation of the options available at the <a href="https://hexdocs.pm/phoenix/Phoenix.Endpoint.html#socket/3-websocket-configuration">documentation</a>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Endpoint</span><span class="w"> </span><span class="k" data-group-id="0237787150-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="ss">otp_app</span><span class="p">:</span><span class="w"> </span><span class="ss">:hello</span><span class="w">

  </span><span class="n">socket</span><span class="w"> </span><span class="s">&quot;/socket&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb.UserSocket</span><span class="p">,</span><span class="w">
    </span><span class="ss">websocket</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0237787150-2">[</span><span class="ss">timeout</span><span class="p">:</span><span class="w"> </span><span class="mi">45_000</span><span class="p" data-group-id="0237787150-2">]</span><span class="w">

  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="0237787150-1">end</span></code></pre><p>Also set the host in Heroku:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku config:set PHX_HOST=&quot;mysterious-meadow-6277.herokuapp.com&quot;
</span></code></pre><p>This ensures that any idle connections are closed by Phoenix before they reach Heroku's 55-second timeout window.</p><h2 id="creating-environment-variables-in-heroku" class="section-heading">
  <a href="#creating-environment-variables-in-heroku" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Creating Environment Variables in Heroku</span>
</h2>
<p>The <code class="inline">DATABASE_URL</code> config var is automatically created by Heroku when we add the <a href="https://elements.heroku.com/addons/heroku-postgresql">Heroku Postgres add-on</a>. We can create the database via the Heroku toolbelt:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku addons:create heroku-postgresql:mini
</span></code></pre><p>Now we set the <code class="inline">POOL_SIZE</code> config var:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku config:set POOL_SIZE=18
</span></code></pre><p>This value should be just under the number of available connections, leaving a couple open for migrations and mix tasks. The mini database allows 20 connections, so we set this number to 18. If additional dynos will share the database, reduce the <code class="inline">POOL_SIZE</code> to give each dyno an equal share.</p><p>When running a mix task later (after we have pushed the project to Heroku) you will also want to limit its pool size like so:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku run &quot;POOL_SIZE=2 mix hello.task&quot;
</span></code></pre><p>So that Ecto does not attempt to open more than the available connections.</p><p>We still have to create the <code class="inline">SECRET_KEY_BASE</code> config based on a random string. First, use <a href="Mix.Tasks.Phx.Gen.Secret.xhtml"><code class="inline">mix phx.gen.secret</code></a> to get a new secret:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.gen.secret
</span><span class="">xvafzY4y01jYuzLm3ecJqo008dVnU3CN4f+MamNd1Zue4pXvfvUjbiXT8akaIF53
</span></code></pre><p>Your random string will be different; don't use this example value.</p><p>Now set it in Heroku:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku config:set SECRET_KEY_BASE=&quot;xvafzY4y01jYuzLm3ecJqo008dVnU3CN4f+MamNd1Zue4pXvfvUjbiXT8akaIF53&quot;
</span><span class="">Setting config vars and restarting mysterious-meadow-6277... done, v3
</span><span class="">SECRET_KEY_BASE: xvafzY4y01jYuzLm3ecJqo008dVnU3CN4f+MamNd1Zue4pXvfvUjbiXT8akaIF53
</span></code></pre><h2 id="deploy-time" class="section-heading">
  <a href="#deploy-time" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Deploy Time!</span>
</h2>
<p>Our project is now ready to be deployed on Heroku.</p><p>Let's commit all our changes:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">git add elixir_buildpack.config
</span><span class="gp unselectable">$ </span><span class="">git commit -a -m &quot;Use production config from Heroku ENV variables and decrease socket timeout&quot;
</span></code></pre><p>And deploy:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">git push heroku main
</span><span class="">Counting objects: 55, done.
</span><span class="">Delta compression using up to 8 threads.
</span><span class="">Compressing objects: 100% (49/49), done.
</span><span class="">Writing objects: 100% (55/55), 48.48 KiB | 0 bytes/s, done.
</span><span class="">Total 55 (delta 1), reused 0 (delta 0)
</span><span class="">remote: Compressing source files... done.
</span><span class="">remote: Building source:
</span><span class="">remote:
</span><span class="">remote: -----&gt; Multipack app detected
</span><span class="">remote: -----&gt; Fetching custom git buildpack... done
</span><span class="">remote: -----&gt; elixir app detected
</span><span class="">remote: -----&gt; Checking Erlang and Elixir versions
</span><span class="">remote:        WARNING: elixir_buildpack.config wasn&#39;t found in the app
</span><span class="">remote:        Using default config from Elixir buildpack
</span><span class="">remote:        Will use the following versions:
</span><span class="">remote:        * Stack cedar-14
</span><span class="">remote:        * Erlang 17.5
</span><span class="">remote:        * Elixir 1.0.4
</span><span class="">remote:        Will export the following config vars:
</span><span class="">remote:        * Config vars DATABASE_URL
</span><span class="">remote:        * MIX_ENV=prod
</span><span class="">remote: -----&gt; Stack changed, will rebuild
</span><span class="">remote: -----&gt; Fetching Erlang 17.5
</span><span class="">remote: -----&gt; Installing Erlang 17.5 (changed)
</span><span class="">remote:
</span><span class="">remote: -----&gt; Fetching Elixir v1.0.4
</span><span class="">remote: -----&gt; Installing Elixir v1.0.4 (changed)
</span><span class="">remote: -----&gt; Installing Hex
</span><span class="">remote: 2015-07-07 00:04:00 URL:https://s3.amazonaws.com/s3.hex.pm/installs/1.0.0/hex.ez [262010/262010] -&gt;
</span><span class="">&quot;/app/.mix/archives/hex.ez&quot; [1]
</span><span class="">remote: * creating /app/.mix/archives/hex.ez
</span><span class="">remote: -----&gt; Installing rebar
</span><span class="">remote: * creating /app/.mix/rebar
</span><span class="">remote: -----&gt; Fetching app dependencies with mix
</span><span class="">remote: Running dependency resolution
</span><span class="">remote: Dependency resolution completed successfully
</span><span class="">remote: [...]
</span><span class="">remote: -----&gt; Compiling
</span><span class="">remote: [...]
</span><span class="">remote: Generated phoenix_heroku app
</span><span class="">remote: [...]
</span><span class="">remote: Consolidated protocols written to _build/prod/consolidated
</span><span class="">remote: -----&gt; Creating .profile.d with env vars
</span><span class="">remote: -----&gt; Fetching custom git buildpack... done
</span><span class="">remote: -----&gt; Phoenix app detected
</span><span class="">remote:
</span><span class="">remote: -----&gt; Loading configuration and environment
</span><span class="">remote:        Loading config...
</span><span class="">remote:        [...]
</span><span class="">remote:        Will export the following config vars:
</span><span class="">remote:        * Config vars DATABASE_URL
</span><span class="">remote:        * MIX_ENV=prod
</span><span class="">remote:
</span><span class="">remote: -----&gt; Compressing... done, 82.1MB
</span><span class="">remote: -----&gt; Launching... done, v5
</span><span class="">remote:        https://mysterious-meadow-6277.herokuapp.com/ deployed to Heroku
</span><span class="">remote:
</span><span class="">remote: Verifying deploy... done.
</span><span class="">To https://git.heroku.com/mysterious-meadow-6277.git
</span><span class=""> * [new branch]      master -&gt; master
</span></code></pre><p>Typing <code class="inline">heroku open</code> in the terminal should launch a browser with the Phoenix welcome page opened. In the event that you are using Ecto to access a database, you will also need to run migrations after the first deploy:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku run &quot;POOL_SIZE=2 mix ecto.migrate&quot;
</span></code></pre><p>And that's it!</p><h2 id="deploying-to-heroku-using-the-container-stack" class="section-heading">
  <a href="#deploying-to-heroku-using-the-container-stack" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Deploying to Heroku using the container stack</span>
</h2>
<h3 id="create-heroku-application" class="section-heading">
  <a href="#create-heroku-application" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Create Heroku application</span>
</h3>
<p>Set the stack of your app to <code class="inline">container</code>, this allows us to use <code class="inline">Dockerfile</code> to define our app setup.</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku create
</span><span class="">Creating app... done, â¬¢ mysterious-meadow-6277
</span><span class="gp unselectable">$ </span><span class="">heroku stack:set container
</span></code></pre><p>Add a new <code class="inline">heroku.yml</code> file to your root folder. In this file you can define addons used by your app, how to build the image and what configs are passed to the image. You can learn more about Heroku's <code class="inline">heroku.yml</code> options <a href="https://devcenter.heroku.com/articles/build-docker-images-heroku-yml">here</a>. Here is a sample:</p><pre><code class="makeup yaml" translate="no"><span class="nt">setup</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">addons</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="p">-</span><span class="w"> </span><span class="nt">plan</span><span class="p">:</span><span class="w"> </span><span class="s">heroku-postgresql</span><span class="w">
</span><span class="w">      </span><span class="nt">as</span><span class="p">:</span><span class="w"> </span><span class="s">DATABASE</span><span class="w">
</span><span class="nt">build</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="nt">docker</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">web</span><span class="p">:</span><span class="w"> </span><span class="s">Dockerfile</span><span class="w">
</span><span class="w">  </span><span class="nt">config</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">MIX_ENV</span><span class="p">:</span><span class="w"> </span><span class="s">prod</span><span class="w">
</span><span class="w">    </span><span class="nt">SECRET_KEY_BASE</span><span class="p">:</span><span class="w"> </span><span class="s">$SECRET_KEY_BASE</span><span class="w">
</span><span class="w">    </span><span class="nt">DATABASE_URL</span><span class="p">:</span><span class="w"> </span><span class="s">$DATABASE_URL</span></code></pre><h3 id="set-up-releases-and-dockerfile" class="section-heading">
  <a href="#set-up-releases-and-dockerfile" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Set up releases and Dockerfile</span>
</h3>
<p>Now we need to define a <code class="inline">Dockerfile</code> at the root folder of your project that contains your application. We recommend to use releases when doing so, as the release will allow us to build a container with only the parts of Erlang and Elixir we actually use. Follow the <a href="releases.html">releases docs</a>. At the end of the guide, there is a sample Dockerfile file you can use.</p><p>Once you have the image definition set up, you can push your app to heroku and you can see it starts building the image and deploy it.</p><h2 id="useful-heroku-commands" class="section-heading">
  <a href="#useful-heroku-commands" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Useful Heroku Commands</span>
</h2>
<p>We can look at the logs of our application by running the following command in our project directory:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku logs # use --tail if you want to tail them
</span></code></pre><p>We can also start an IEx session attached to our terminal for experimenting in our app's environment:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku run &quot;POOL_SIZE=2 iex -S mix&quot;
</span></code></pre><p>In fact, we can run anything using the <code class="inline">heroku run</code> command, like the Ecto migration task from above:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">heroku run &quot;POOL_SIZE=2 mix ecto.migrate&quot;
</span></code></pre><h2 id="connecting-to-your-dyno" class="section-heading">
  <a href="#connecting-to-your-dyno" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Connecting to your dyno</span>
</h2>
<p>Heroku gives you the ability to connect to your dyno with an IEx shell which allows running Elixir code such as database queries.</p><ul><li><p>Modify the <code class="inline">web</code> process in your Procfile to run a named node:</p><pre><code class="text">web: elixir --sname server -S mix phx.server</code></pre></li><li><p>Redeploy to Heroku</p></li><li><p>Connect to the dyno with <code class="inline">heroku ps:exec</code> (if you have several applications on the same repository you will need to specify the app name or the remote name with <code class="inline">--app APP_NAME</code> or <code class="inline">--remote REMOTE_NAME</code>)</p></li><li><p>Launch an iex session with <code class="inline">iex --sname console --remsh server</code></p></li></ul><p>You have an iex session into your dyno!</p><h2 id="troubleshooting" class="section-heading">
  <a href="#troubleshooting" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Troubleshooting</span>
</h2>
<h3 id="compilation-error" class="section-heading">
  <a href="#compilation-error" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Compilation Error</span>
</h3>
<p>Occasionally, an application will compile locally, but not on Heroku. The compilation error on Heroku will look something like this:</p><pre><code class="makeup console" translate="no"><span class="">remote: == Compilation error on file lib/postgrex/connection.ex ==
</span><span class="">remote: could not compile dependency :postgrex, &quot;mix compile&quot; failed. You can recompile this dependency with &quot;mix deps.compile postgrex&quot;, update it with &quot;mix deps.update postgrex&quot; or clean it with &quot;mix deps.clean postgrex&quot;
</span><span class="">remote: ** (CompileError) lib/postgrex/connection.ex:207: Postgrex.Connection.__struct__/0 is undefined, cannot expand struct Postgrex.Connection
</span><span class="">remote:     (elixir) src/elixir_map.erl:58: :elixir_map.translate_struct/4
</span><span class="">remote:     (stdlib) lists.erl:1353: :lists.mapfoldl/3
</span><span class="">remote:     (stdlib) lists.erl:1354: :lists.mapfoldl/3
</span><span class="">remote:
</span><span class="">remote:
</span><span class="">remote:  !     Push rejected, failed to compile elixir app
</span><span class="">remote:
</span><span class="">remote: Verifying deploy...
</span><span class="">remote:
</span><span class="">remote: !   Push rejected to mysterious-meadow-6277.
</span><span class="">remote:
</span><span class="">To https://git.heroku.com/mysterious-meadow-6277.git
</span></code></pre><p>This has to do with stale dependencies which are not getting recompiled properly. It's possible to force Heroku to recompile all dependencies on each deploy, which should fix this problem. The way to do it is to add a new file called <code class="inline">elixir_buildpack.config</code> at the root of the application. The file should contain this line:</p><pre><code class="text">always_rebuild=true</code></pre><p>Commit this file to the repository and try to push again to Heroku.</p><h3 id="connection-timeout-error" class="section-heading">
  <a href="#connection-timeout-error" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Connection Timeout Error</span>
</h3>
<p>If you are constantly getting connection timeouts while running <code class="inline">heroku run</code> this could mean that your internet provider has blocked port number 5000:</p><pre><code class="makeup console" translate="no"><span class="">heroku run &quot;POOL_SIZE=2 mix myapp.task&quot;
</span><span class="">Running POOL_SIZE=2 mix myapp.task on mysterious-meadow-6277... !
</span><span class="">ETIMEDOUT: connect ETIMEDOUT 50.19.103.36:5000
</span></code></pre><p>You can overcome this by adding <code class="inline">detached</code> option to run command:</p><pre><code class="makeup console" translate="no"><span class="">heroku run:detached &quot;POOL_SIZE=2 mix ecto.migrate&quot;
</span><span class="">Running POOL_SIZE=2 mix ecto.migrate on mysterious-meadow-6277... done, run.8089 (Free)
</span></code></pre>

  </body>
</html>
