<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Channels - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Channels
    </h1>
<blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="installation.html">introductory guides</a> and got a Phoenix application <a href="up_and_running.html">up and running</a>.</p></blockquote><p>Channels are an exciting part of Phoenix that enable soft real-time communication with and between millions of connected clients.</p><p>Some possible use cases include:</p><ul><li>Chat rooms and APIs for messaging apps</li><li>Breaking news, like &quot;a goal was scored&quot; or &quot;an earthquake is coming&quot;</li><li>Tracking trains, trucks, or race participants on a map</li><li>Events in multiplayer games</li><li>Monitoring sensors and controlling lights</li><li>Notifying a browser that a page's CSS or JavaScript has changed (this is handy in development)</li></ul><p>Conceptually, Channels are pretty simple.</p><p>First, clients connect to the server using some transport, like WebSocket. Once connected, they join one or more topics. For example, to interact with a public chat room clients may join a topic called <code class="inline">public_chat</code>, and to receive updates from a product with ID 7, they may need to join a topic called <code class="inline">product_updates:7</code>.</p><p>Clients can push messages to the topics they've joined, and can also receive messages from them. The other way around, Channel servers receive messages from their connected clients, and can push messages to them too.</p><p>Servers are able to broadcast messages to all clients subscribed to a certain topic. This is illustrated in the following diagram:</p><pre><code class="plaintext">                                                                  +----------------+
                                                     +--Topic X--&gt;| Mobile Client  |
                                                     |            +----------------+
                              +-------------------+  |
+----------------+            |                   |  |            +----------------+
| Browser Client |--Topic X--&gt;| Phoenix Server(s) |--+--Topic X--&gt;| Desktop Client |
+----------------+            |                   |  |            +----------------+
                              +-------------------+  |
                                                     |            +----------------+
                                                     +--Topic X--&gt;|   IoT Client   |
                                                                  +----------------+</code></pre><p>Broadcasts work even if the application runs on several nodes/computers. That is, if two clients have their socket connected to different application nodes and are subscribed to the same topic <code class="inline">T</code>, both of them will receive messages broadcasted to <code class="inline">T</code>. That is possible thanks to an internal PubSub mechanism.</p><p>Channels can support any kind of client: a browser, native app, smart watch, embedded device, or anything else that can connect to a network.
All the client needs is a suitable library; see the <a href="#client-libraries">Client Libraries</a> section below.
Each client library communicates using one of the &quot;transports&quot; that Channels understand.
Currently, that's either Websockets or long polling, but other transports may be added in the future.</p><p>Unlike stateless HTTP connections, Channels support long-lived connections, each backed by a lightweight BEAM process, working in parallel and maintaining its own state.</p><p>This architecture scales well; Phoenix Channels <a href="https://phoenixframework.org/blog/the-road-to-2-million-websocket-connections">can support millions of subscribers with reasonable latency on a single box</a>, passing hundreds of thousands of messages per second.
And that capacity can be multiplied by adding more nodes to the cluster.</p><h2 id="the-moving-parts" class="section-heading">
  <a href="#the-moving-parts" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">The Moving Parts</span>
</h2>
<p>Although Channels are simple to use from a client perspective, there are a number of components involved in routing messages to clients across a cluster of servers.
Let's take a look at them.</p><h3 id="overview" class="section-heading">
  <a href="#overview" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Overview</span>
</h3>
<p>To start communicating, a client connects to a node (a Phoenix server) using a transport (e.g., Websockets or long polling) and joins one or more channels using that single network connection.
One channel server lightweight process is created per client, per topic. Each channel holds onto the <code class="inline">%Phoenix.Socket{}</code> and can maintain any state it needs within its <code class="inline">socket.assigns</code>.</p><p>Once the connection is established, each incoming message from a client is routed, based on its topic, to the correct channel server.
If the channel server asks to broadcast a message, that message is sent to the local PubSub, which sends it out to any clients connected to the same server and subscribed to that topic.</p><p>If there are other nodes in the cluster, the local PubSub also forwards the message to their PubSubs, which send it out to their own subscribers.
Because only one message has to be sent per additional node, the performance cost of adding nodes is negligible, while each new node supports many more subscribers.</p><p>The message flow looks something like this:</p><pre><code class="plaintext">                                 Channel   +-------------------------+      +--------+
                                  route    | Sending Client, Topic 1 |      | Local  |
                              +-----------&gt;|     Channel.Server      |-----&gt;| PubSub |--+
+----------------+            |            +-------------------------+      +--------+  |
| Sending Client |-Transport--+                                                  |      |
+----------------+                         +-------------------------+           |      |
                                           | Sending Client, Topic 2 |           |      |
                                           |     Channel.Server      |           |      |
                                           +-------------------------+           |      |
                                                                                 |      |
                                           +-------------------------+           |      |
+----------------+                         | Browser Client, Topic 1 |           |      |
| Browser Client |&lt;-------Transport--------|     Channel.Server      |&lt;----------+      |
+----------------+                         +-------------------------+                  |
                                                                                        |
                                                                                        |
                                                                                        |
                                           +-------------------------+                  |
+----------------+                         |  Phone Client, Topic 1  |                  |
|  Phone Client  |&lt;-------Transport--------|     Channel.Server      |&lt;-+               |
+----------------+                         +-------------------------+  |   +--------+  |
                                                                        |   | Remote |  |
                                           +-------------------------+  +---| PubSub |&lt;-+
+----------------+                         |  Watch Client, Topic 1  |  |   +--------+  |
|  Watch Client  |&lt;-------Transport--------|     Channel.Server      |&lt;-+               |
+----------------+                         +-------------------------+                  |
                                                                                        |
                                                                                        |
                                           +-------------------------+      +--------+  |
+----------------+                         |   IoT Client, Topic 1   |      | Remote |  |
|   IoT Client   |&lt;-------Transport--------|     Channel.Server      |&lt;-----| PubSub |&lt;-+
+----------------+                         +-------------------------+      +--------+</code></pre><h3 id="endpoint" class="section-heading">
  <a href="#endpoint" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Endpoint</span>
</h3>
<p>In your Phoenix app's <code class="inline">Endpoint</code> module, a <code class="inline">socket</code> declaration specifies which socket handler will receive connections on a given URL.</p><pre><code class="makeup elixir" translate="no"><span class="n">socket</span><span class="w"> </span><span class="s">&quot;/socket&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb.UserSocket</span><span class="p">,</span><span class="w">
  </span><span class="ss">websocket</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">
  </span><span class="ss">longpoll</span><span class="p">:</span><span class="w"> </span><span class="no">false</span></code></pre><p>Phoenix comes with two default transports: websocket and longpoll. You can configure them directly via the <code class="inline">socket</code> declaration.</p><h3 id="socket-handlers" class="section-heading">
  <a href="#socket-handlers" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Socket Handlers</span>
</h3>
<p>On the client side, you will establish a socket connection to the route above:</p><pre><code class="makeup javascript" translate="no"><span class="kt">let</span><span class="w"> </span><span class="nv">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nv">Socket</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">/socket</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">params</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="n">token</span><span class="p">:</span><span class="w"> </span><span class="nb">window</span><span class="p">.</span><span class="n">userToken</span><span class="p">}</span><span class="p">}</span><span class="p">)</span></code></pre><p>On the server, Phoenix will invoke <code class="inline">HelloWeb.UserSocket.connect/2</code>, passing your parameters and the initial socket state. Within the socket, you can authenticate and identify a socket connection and set default socket assigns. The socket is also where you define your channel routes.</p><h3 id="channel-routes" class="section-heading">
  <a href="#channel-routes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Channel Routes</span>
</h3>
<p>Channel routes match on the topic string and dispatch matching requests to the given Channel module.</p><p>The star character <code class="inline">*</code> acts as a wildcard matcher, so in the following example route, requests for <code class="inline">room:lobby</code> and <code class="inline">room:123</code> would both be dispatched to the <code class="inline">RoomChannel</code>. In your <code class="inline">UserSocket</code>, you would have:</p><pre><code class="makeup elixir" translate="no"><span class="n">channel</span><span class="w"> </span><span class="s">&quot;room:*&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb.RoomChannel</span></code></pre><h3 id="channels" class="section-heading">
  <a href="#channels" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Channels</span>
</h3>
<p>Channels handle events from clients, so they are similar to Controllers, but there are two key differences. Channel events can go both directions - incoming and outgoing. Channel connections also persist beyond a single request/response cycle. Channels are the highest level abstraction for real-time communication components in Phoenix.</p><p>Each Channel will implement one or more clauses of each of these four callback functions - <code class="inline">join/3</code>, <code class="inline">terminate/2</code>, <code class="inline">handle_in/3</code>, and <code class="inline">handle_out/3</code>.</p><h3 id="topics" class="section-heading">
  <a href="#topics" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Topics</span>
</h3>
<p>Topics are string identifiers - names that the various layers use in order to make sure messages end up in the right place. As we saw above, topics can use wildcards. This allows for a useful <code class="inline">&quot;topic:subtopic&quot;</code> convention. Often, you'll compose topics using record IDs from your application layer, such as <code class="inline">&quot;users:123&quot;</code>.</p><h3 id="messages" class="section-heading">
  <a href="#messages" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Messages</span>
</h3>
<p>The <a href="Phoenix.Socket.Message.xhtml"><code class="inline">Phoenix.Socket.Message</code></a> module defines a struct with the following keys which denotes a valid message. From the <a href="https://hexdocs.pm/phoenix/Phoenix.Socket.Message.html">Phoenix.Socket.Message docs</a>.</p><ul><li><code class="inline">topic</code> - The string topic or <code class="inline">&quot;topic:subtopic&quot;</code> pair namespace, such as <code class="inline">&quot;messages&quot;</code> or <code class="inline">&quot;messages:123&quot;</code></li><li><code class="inline">event</code> - The string event name, for example <code class="inline">&quot;phx_join&quot;</code></li><li><code class="inline">payload</code> - The message payload</li><li><code class="inline">ref</code> - The unique string ref</li></ul><h3 id="pubsub" class="section-heading">
  <a href="#pubsub" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">PubSub</span>
</h3>
<p>PubSub is provided by the <a href="https://hexdocs.pm/phoenix_pubsub/2.1.3/Phoenix.PubSub.html"><code class="inline">Phoenix.PubSub</code></a> module. Interested parties can receive events by subscribing to topics. Other processes can broadcast events to certain topics.</p><p>This is useful to broadcast messages on channel and also for application development in general. For instance, letting all connected <a href="https://github.com/phoenixframework/phoenix_live_view">live views</a> to know that a new comment has been added to a post.</p><p>The PubSub system takes care of getting messages from one node to another so that they can be sent to all subscribers across the cluster.
By default, this is done using <a href="https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.PG2.html">Phoenix.PubSub.PG2</a>, which uses native BEAM messaging.</p><p>If your deployment environment does not support distributed Elixir or direct communication between servers, Phoenix also ships with a <a href="https://hexdocs.pm/phoenix_pubsub_redis/Phoenix.PubSub.Redis.html">Redis Adapter</a> that uses Redis to exchange PubSub data. Please see the <a href="https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html">Phoenix.PubSub docs</a> for more information.</p><h3 id="client-libraries" class="section-heading">
  <a href="#client-libraries" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Client Libraries</span>
</h3>
<p>Any networked device can connect to Phoenix Channels as long as it has a client library.
The following libraries exist today, and new ones are always welcome; to write your own, see our how-to guide <a href="writing_a_channels_client.xhtml">Writing a Channels Client</a>.</p><h4>Official</h4><p>Phoenix ships with a JavaScript client that is available when generating a new Phoenix project. The documentation for the JavaScript module is available at <a href="https://hexdocs.pm/phoenix/js/">https://hexdocs.pm/phoenix/js/</a>; the code is in <a href="https://github.com/phoenixframework/phoenix/blob/main/assets/js/phoenix/">multiple js files</a>.</p><h4>3rd Party</h4><ul><li>Swift (iOS)<ul><li><a href="https://github.com/davidstump/SwiftPhoenixClient">SwiftPhoenix</a></li></ul></li><li>Java (Android)<ul><li><a href="https://github.com/eoinsha/JavaPhoenixChannels">JavaPhoenixChannels</a></li></ul></li><li>Kotlin (Android)<ul><li><a href="https://github.com/dsrees/JavaPhoenixClient">JavaPhoenixClient</a></li></ul></li><li>C#<ul><li><a href="https://github.com/Mazyod/PhoenixSharp">PhoenixSharp</a></li></ul></li><li>Elixir<ul><li><a href="https://github.com/Aircloak/phoenix_gen_socket_client">phoenix_gen_socket_client</a></li><li><a href="https://hexdocs.pm/slipstream/Slipstream.html">slipstream</a></li></ul></li><li>GDScript (Godot Game Engine)<ul><li><a href="https://github.com/alfredbaudisch/GodotPhoenixChannels">GodotPhoenixChannels</a></li></ul></li></ul><h2 id="tying-it-all-together" class="section-heading">
  <a href="#tying-it-all-together" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Tying it all together</span>
</h2>
<p>Let's tie all these ideas together by building a simple chat application. Make sure <a href="https://hexdocs.pm/phoenix/up_and_running.html">you created a new Phoenix application</a> and now we are ready to generate the <code class="inline">UserSocket</code>.</p><h3 id="generating-a-socket" class="section-heading">
  <a href="#generating-a-socket" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Generating a socket</span>
</h3>
<p>Let's invoke the socket generator to get started:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.gen.socket User
</span></code></pre><p>It will create two files, the client code in <code class="inline">assets/js/user_socket.js</code> and the server counter-part in <code class="inline">lib/hello_web/channels/user_socket.ex</code>. After running, the generator will also ask to add the following line to <code class="inline">lib/hello_web/endpoint.ex</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Endpoint</span><span class="w"> </span><span class="k" data-group-id="7389628941-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="ss">otp_app</span><span class="p">:</span><span class="w"> </span><span class="ss">:hello</span><span class="w">

  </span><span class="n">socket</span><span class="w"> </span><span class="s">&quot;/socket&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb.UserSocket</span><span class="p">,</span><span class="w">
    </span><span class="ss">websocket</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">
    </span><span class="ss">longpoll</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w">

  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="7389628941-1">end</span></code></pre><p>The generator also asks us to import the client code, we will do that later.</p><p>Next, we will configure our socket to ensure messages get routed to the correct channel. To do that, we'll uncomment the <code class="inline">&quot;room:*&quot;</code> channel definition:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.UserSocket</span><span class="w"> </span><span class="k" data-group-id="4077307462-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Socket</span><span class="w">

  </span><span class="c1">## Channels</span><span class="w">
  </span><span class="n">channel</span><span class="w"> </span><span class="s">&quot;room:*&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb.RoomChannel</span><span class="w">
  </span><span class="n">...</span></code></pre><p>Now, whenever a client sends a message whose topic starts with <code class="inline">&quot;room:&quot;</code>, it will be routed to our RoomChannel. Next, we'll define a <code class="inline">HelloWeb.RoomChannel</code> module to manage our chat room messages.</p><h3 id="joining-channels" class="section-heading">
  <a href="#joining-channels" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Joining Channels</span>
</h3>
<p>The first priority of your channels is to authorize clients to join a given topic. For authorization, we must implement <code class="inline">join/3</code> in <code class="inline">lib/hello_web/channels/room_channel.ex</code>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.RoomChannel</span><span class="w"> </span><span class="k" data-group-id="8065392843-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Channel</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">join</span><span class="p" data-group-id="8065392843-2">(</span><span class="s">&quot;room:lobby&quot;</span><span class="p">,</span><span class="w"> </span><span class="c">_message</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="8065392843-2">)</span><span class="w"> </span><span class="k" data-group-id="8065392843-3">do</span><span class="w">
    </span><span class="p" data-group-id="8065392843-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="8065392843-4">}</span><span class="w">
  </span><span class="k" data-group-id="8065392843-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">join</span><span class="p" data-group-id="8065392843-5">(</span><span class="s">&quot;room:&quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="c">_private_room_id</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p">,</span><span class="w"> </span><span class="c">_socket</span><span class="p" data-group-id="8065392843-5">)</span><span class="w"> </span><span class="k" data-group-id="8065392843-6">do</span><span class="w">
    </span><span class="p" data-group-id="8065392843-7">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8065392843-8">%{</span><span class="ss">reason</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;unauthorized&quot;</span><span class="p" data-group-id="8065392843-8">}</span><span class="p" data-group-id="8065392843-7">}</span><span class="w">
  </span><span class="k" data-group-id="8065392843-6">end</span><span class="w">
</span><span class="k" data-group-id="8065392843-1">end</span></code></pre><p>For our chat app, we'll allow anyone to join the <code class="inline">&quot;room:lobby&quot;</code> topic, but any other room will be considered private and special authorization, say from a database, will be required.
(We won't worry about private chat rooms for this exercise, but feel free to explore after we finish.)</p><p>With our channel in place, let's get the client and server talking.</p><p>The generated <code class="inline">assets/js/user_socket.js</code> defines a simple client based on the socket implementation that ships with Phoenix.</p><p>We can use that library to connect to our socket and join our channel, we just need to set our room name to <code class="inline">&quot;room:lobby&quot;</code> in that file.</p><pre><code class="makeup javascript" translate="no"><span class="c1">//</span><span class="c1"> assets/js/user_socket.js
</span><span class="c1">//</span><span class="c1"> ...
</span><span class="nv">socket</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="c1">//</span><span class="c1"> Now that you are connected, you can join channels with a topic:
</span><span class="kt">let</span><span class="w"> </span><span class="nv">channel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">socket</span><span class="p">.</span><span class="nf">channel</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">room:lobby</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="nv">channel</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="p">.</span><span class="nf">receive</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">ok</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">Joined successfully</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="p">.</span><span class="nf">receive</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">error</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">Unable to join</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nv">socket</span></code></pre><p>After that, we need to make sure <code class="inline">assets/js/user_socket.js</code> gets imported into our application JavaScript file. To do that, uncomment this line in <code class="inline">assets/js/app.js</code>.</p><pre><code class="makeup javascript" translate="no"><span class="c1">//</span><span class="c1"> ...
</span><span class="k">import</span><span class="w"> </span><span class="p">&quot;</span><span class="s2">./user_socket.js</span><span class="p">&quot;</span></code></pre><p>Save the file and your browser should auto refresh, thanks to the Phoenix live reloader. If everything worked, we should see &quot;Joined successfully&quot; in the browser's JavaScript console. Our client and server are now talking over a persistent connection. Now let's make it useful by enabling chat.</p><p>In <code class="inline">lib/hello_web/controllers/page_html/home.html.heex</code>, we'll replace the existing code with a container to hold our chat messages, and an input field to send them:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="ni">id</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">messages</span><span class="p">&quot;</span><span class="w"> </span><span class="ni">role</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">log</span><span class="p">&quot;</span><span class="w"> </span><span class="ni">aria-live</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">polite</span><span class="p">&quot;</span><span class="p">&gt;</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;</span><span class="nt">input</span><span class="w"> </span><span class="ni">id</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">chat-input</span><span class="p">&quot;</span><span class="w"> </span><span class="ni">type</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">text</span><span class="p">&quot;</span><span class="p">&gt;</span></code></pre><p>Now let's add a couple of event listeners to <code class="inline">assets/js/user_socket.js</code>:</p><pre><code class="makeup javascript" translate="no"><span class="c1">//</span><span class="c1"> ...
</span><span class="kt">let</span><span class="w"> </span><span class="nv">channel</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="nv">socket</span><span class="p">.</span><span class="nf">channel</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">room:lobby</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="kt">let</span><span class="w"> </span><span class="nv">chatInput</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">#chat-input</span><span class="p">&quot;</span><span class="p">)</span><span class="w">
</span><span class="kt">let</span><span class="w"> </span><span class="nv">messagesContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">#messages</span><span class="p">&quot;</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="nv">chatInput</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">keypress</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">event</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="nv">event</span><span class="p">.</span><span class="n">key</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="p">&#39;</span><span class="s1">Enter</span><span class="p">&#39;</span><span class="p">)</span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nv">channel</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">new_msg</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">body</span><span class="p">:</span><span class="w"> </span><span class="nv">chatInput</span><span class="p">.</span><span class="n">value</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="nv">chatInput</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&quot;</span><span class="p">&quot;</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="nv">channel</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="p">.</span><span class="nf">receive</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">ok</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">Joined successfully</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="p">.</span><span class="nf">receive</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">error</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">Unable to join</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nv">socket</span></code></pre><p>All we had to do is detect that enter was pressed and then <code class="inline">push</code> an event over the channel with the message body. We named the event <code class="inline">&quot;new_msg&quot;</code>. With this in place, let's handle the other piece of a chat application, where we listen for new messages and append them to our messages container.</p><pre><code class="makeup javascript" translate="no"><span class="c1">//</span><span class="c1"> ...
</span><span class="kt">let</span><span class="w"> </span><span class="nv">channel</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="nv">socket</span><span class="p">.</span><span class="nf">channel</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">room:lobby</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="kt">let</span><span class="w"> </span><span class="nv">chatInput</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">#chat-input</span><span class="p">&quot;</span><span class="p">)</span><span class="w">
</span><span class="kt">let</span><span class="w"> </span><span class="nv">messagesContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">#messages</span><span class="p">&quot;</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="nv">chatInput</span><span class="p">.</span><span class="nf">addEventListener</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">keypress</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">event</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="nv">event</span><span class="p">.</span><span class="n">key</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="p">&#39;</span><span class="s1">Enter</span><span class="p">&#39;</span><span class="p">)</span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nv">channel</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">new_msg</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">body</span><span class="p">:</span><span class="w"> </span><span class="nv">chatInput</span><span class="p">.</span><span class="n">value</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">    </span><span class="nv">chatInput</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&quot;</span><span class="p">&quot;</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="nv">channel</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">new_msg</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">payload</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="kt">let</span><span class="w"> </span><span class="nv">messageItem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">document</span><span class="p">.</span><span class="nf">createElement</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">p</span><span class="p">&quot;</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="nv">messageItem</span><span class="p">.</span><span class="n">innerText</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">`</span><span class="s">[</span><span class="si">${</span><span class="bp">Date</span><span class="si">(</span><span class="si">)</span><span class="si">}</span><span class="s">] </span><span class="si">${</span><span class="nv">payload</span><span class="si">.</span><span class="n">body</span><span class="si">}</span><span class="p">`</span><span class="w">
</span><span class="w">  </span><span class="nv">messagesContainer</span><span class="p">.</span><span class="nf">appendChild</span><span class="p">(</span><span class="nv">messageItem</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="nv">channel</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="p">.</span><span class="nf">receive</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">ok</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">Joined successfully</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="p">.</span><span class="nf">receive</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">error</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">Unable to join</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nv">socket</span></code></pre><p>We listen for the <code class="inline">&quot;new_msg&quot;</code> event using <code class="inline">channel.on</code>, and then append the message body to the DOM. Now let's handle the incoming and outgoing events on the server to complete the picture.</p><h3 id="incoming-events" class="section-heading">
  <a href="#incoming-events" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Incoming Events</span>
</h3>
<p>We handle incoming events with <code class="inline">handle_in/3</code>. We can pattern match on the event names, like <code class="inline">&quot;new_msg&quot;</code>, and then grab the payload that the client passed over the channel. For our chat application, we simply need to notify all other <code class="inline">room:lobby</code> subscribers of the new message with <code class="inline">broadcast!/3</code>.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.RoomChannel</span><span class="w"> </span><span class="k" data-group-id="3182875762-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Channel</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">join</span><span class="p" data-group-id="3182875762-2">(</span><span class="s">&quot;room:lobby&quot;</span><span class="p">,</span><span class="w"> </span><span class="c">_message</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="3182875762-2">)</span><span class="w"> </span><span class="k" data-group-id="3182875762-3">do</span><span class="w">
    </span><span class="p" data-group-id="3182875762-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="3182875762-4">}</span><span class="w">
  </span><span class="k" data-group-id="3182875762-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">join</span><span class="p" data-group-id="3182875762-5">(</span><span class="s">&quot;room:&quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="c">_private_room_id</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p">,</span><span class="w"> </span><span class="c">_socket</span><span class="p" data-group-id="3182875762-5">)</span><span class="w"> </span><span class="k" data-group-id="3182875762-6">do</span><span class="w">
    </span><span class="p" data-group-id="3182875762-7">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3182875762-8">%{</span><span class="ss">reason</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;unauthorized&quot;</span><span class="p" data-group-id="3182875762-8">}</span><span class="p" data-group-id="3182875762-7">}</span><span class="w">
  </span><span class="k" data-group-id="3182875762-6">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_in</span><span class="p" data-group-id="3182875762-9">(</span><span class="s">&quot;new_msg&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3182875762-10">%{</span><span class="s">&quot;body&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="3182875762-10">}</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="3182875762-9">)</span><span class="w"> </span><span class="k" data-group-id="3182875762-11">do</span><span class="w">
    </span><span class="n">broadcast!</span><span class="p" data-group-id="3182875762-12">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;new_msg&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3182875762-13">%{</span><span class="ss">body</span><span class="p">:</span><span class="w"> </span><span class="n">body</span><span class="p" data-group-id="3182875762-13">}</span><span class="p" data-group-id="3182875762-12">)</span><span class="w">
    </span><span class="p" data-group-id="3182875762-14">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="3182875762-14">}</span><span class="w">
  </span><span class="k" data-group-id="3182875762-11">end</span><span class="w">
</span><span class="k" data-group-id="3182875762-1">end</span></code></pre><p><code class="inline">broadcast!/3</code> will notify all joined clients on this <code class="inline">socket</code>'s topic and invoke their <code class="inline">handle_out/3</code> callbacks. <code class="inline">handle_out/3</code> isn't a required callback, but it allows us to customize and filter broadcasts before they reach each client. By default, <code class="inline">handle_out/3</code> is implemented for us and simply pushes the message on to the client. Hooking into outgoing events allows for powerful message customization and filtering. Let's see how.</p><h3 id="intercepting-outgoing-events" class="section-heading">
  <a href="#intercepting-outgoing-events" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Intercepting Outgoing Events</span>
</h3>
<p>We won't implement this for our application, but imagine our chat app allowed users to ignore messages about new users joining a room. We could implement that behavior like this, where we explicitly tell Phoenix which outgoing event we want to intercept and then define a <code class="inline">handle_out/3</code> callback for those events. (Of course, this assumes that we have an <code class="inline">Accounts</code> context with an <code class="inline">ignoring_user?/2</code> function, and that we pass a user in via the <code class="inline">assigns</code> map). It is important to note that the <code class="inline">handle_out/3</code> callback will be called for every recipient of a message, so more expensive operations like hitting the database should be considered carefully before being included in <code class="inline">handle_out/3</code>.</p><pre><code class="makeup elixir" translate="no"><span class="n">intercept</span><span class="w"> </span><span class="p" data-group-id="5699962006-1">[</span><span class="s">&quot;user_joined&quot;</span><span class="p" data-group-id="5699962006-1">]</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_out</span><span class="p" data-group-id="5699962006-2">(</span><span class="s">&quot;user_joined&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="5699962006-2">)</span><span class="w"> </span><span class="k" data-group-id="5699962006-3">do</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="nc">Accounts</span><span class="o">.</span><span class="n">ignoring_user?</span><span class="p" data-group-id="5699962006-4">(</span><span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="p" data-group-id="5699962006-5">[</span><span class="ss">:user</span><span class="p" data-group-id="5699962006-5">]</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="o">.</span><span class="n">user_id</span><span class="p" data-group-id="5699962006-4">)</span><span class="w"> </span><span class="k" data-group-id="5699962006-6">do</span><span class="w">
    </span><span class="p" data-group-id="5699962006-7">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="5699962006-7">}</span><span class="w">
  </span><span class="k" data-group-id="5699962006-6">else</span><span class="w">
    </span><span class="n">push</span><span class="p" data-group-id="5699962006-8">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;user_joined&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p" data-group-id="5699962006-8">)</span><span class="w">
    </span><span class="p" data-group-id="5699962006-9">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="5699962006-9">}</span><span class="w">
  </span><span class="k" data-group-id="5699962006-6">end</span><span class="w">
</span><span class="k" data-group-id="5699962006-3">end</span></code></pre><p>That's all there is to our basic chat app. Fire up multiple browser tabs and you should see your messages being pushed and broadcasted to all windows!</p><h2 id="using-token-authentication" class="section-heading">
  <a href="#using-token-authentication" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Using Token Authentication</span>
</h2>
<p>When we connect, we'll often need to authenticate the client. Fortunately, this is a 4-step process with <a href="https://hexdocs.pm/phoenix/Phoenix.Token.html">Phoenix.Token</a>.</p><h3 id="step-1-assign-a-token-in-the-connection" class="section-heading">
  <a href="#step-1-assign-a-token-in-the-connection" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Step 1 - Assign a Token in the Connection</span>
</h3>
<p>Let's say we have an authentication plug in our app called <code class="inline">OurAuth</code>. When <code class="inline">OurAuth</code> authenticates a user, it sets a value for the <code class="inline">:current_user</code> key in <code class="inline">conn.assigns</code>. Since the <code class="inline">current_user</code> exists, we can simply assign the user's token in the connection for use in the layout. We can wrap that behavior up in a private function plug, <code class="inline">put_user_token/2</code>. This could also be put in its own module as well. To make this all work, we just add <code class="inline">OurAuth</code> and <code class="inline">put_user_token/2</code> to the browser pipeline.</p><pre><code class="makeup elixir" translate="no"><span class="n">pipeline</span><span class="w"> </span><span class="ss">:browser</span><span class="w"> </span><span class="k" data-group-id="3515054627-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="nc">OurAuth</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_user_token</span><span class="w">
</span><span class="k" data-group-id="3515054627-1">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">put_user_token</span><span class="p" data-group-id="3515054627-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="3515054627-2">)</span><span class="w"> </span><span class="k" data-group-id="3515054627-3">do</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="n">current_user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">conn</span><span class="o">.</span><span class="n">assigns</span><span class="p" data-group-id="3515054627-4">[</span><span class="ss">:current_user</span><span class="p" data-group-id="3515054627-4">]</span><span class="w"> </span><span class="k" data-group-id="3515054627-5">do</span><span class="w">
    </span><span class="n">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Phoenix.Token</span><span class="o">.</span><span class="n">sign</span><span class="p" data-group-id="3515054627-6">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;user socket&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">current_user</span><span class="o">.</span><span class="n">id</span><span class="p" data-group-id="3515054627-6">)</span><span class="w">
    </span><span class="n">assign</span><span class="p" data-group-id="3515054627-7">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:user_token</span><span class="p">,</span><span class="w"> </span><span class="n">token</span><span class="p" data-group-id="3515054627-7">)</span><span class="w">
  </span><span class="k" data-group-id="3515054627-5">else</span><span class="w">
    </span><span class="n">conn</span><span class="w">
  </span><span class="k" data-group-id="3515054627-5">end</span><span class="w">
</span><span class="k" data-group-id="3515054627-3">end</span></code></pre><p>Now our <code class="inline">conn.assigns</code> contains the <code class="inline">current_user</code> and <code class="inline">user_token</code>.</p><h3 id="step-2-pass-the-token-to-the-javascript" class="section-heading">
  <a href="#step-2-pass-the-token-to-the-javascript" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Step 2 - Pass the Token to the JavaScript</span>
</h3>
<p>Next, we need to pass this token to JavaScript. We can do so inside a script tag in <code class="inline">lib/hello_web/components/layouts/app.html.heex</code> right above the app.js script, as follows:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span><span class="nb">window</span><span class="o">.</span><span class="nv">userToken</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">&quot;</span><span class="p" data-group-id="2889889174-1">&lt;%=</span><span class="w"> </span><span class="n">assigns</span><span class="p" data-group-id="2889889174-ex-1">[</span><span class="ss">:user_token</span><span class="p" data-group-id="2889889174-ex-1">]</span><span class="w"> </span><span class="p" data-group-id="2889889174-1">%&gt;</span><span class="p">&quot;</span><span class="p">;</span><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;</span><span class="nt">script</span><span class="w"> </span><span class="ni">src</span><span class="p">=</span><span class="p" data-group-id="2889889174-2">{</span><span class="sx">~p&quot;/assets/app.js&quot;</span><span class="p" data-group-id="2889889174-2">}</span><span class="p">&gt;</span><span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span></code></pre><h3 id="step-3-pass-the-token-to-the-socket-constructor-and-verify" class="section-heading">
  <a href="#step-3-pass-the-token-to-the-socket-constructor-and-verify" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Step 3 - Pass the Token to the Socket Constructor and Verify</span>
</h3>
<p>We also need to pass the <code class="inline">:params</code> to the socket constructor and verify the user token in the <code class="inline">connect/3</code> function. To do so, edit <code class="inline">lib/hello_web/channels/user_socket.ex</code>, as follows:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">connect</span><span class="p" data-group-id="7531135192-1">(</span><span class="p" data-group-id="7531135192-2">%{</span><span class="s">&quot;token&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">token</span><span class="p" data-group-id="7531135192-2">}</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="c">_connect_info</span><span class="p" data-group-id="7531135192-1">)</span><span class="w"> </span><span class="k" data-group-id="7531135192-3">do</span><span class="w">
  </span><span class="c1"># max_age: 1209600 is equivalent to two weeks in seconds</span><span class="w">
  </span><span class="k">case</span><span class="w"> </span><span class="nc">Phoenix.Token</span><span class="o">.</span><span class="n">verify</span><span class="p" data-group-id="7531135192-4">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;user socket&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">token</span><span class="p">,</span><span class="w"> </span><span class="ss">max_age</span><span class="p">:</span><span class="w"> </span><span class="mi">1209600</span><span class="p" data-group-id="7531135192-4">)</span><span class="w"> </span><span class="k" data-group-id="7531135192-5">do</span><span class="w">
    </span><span class="p" data-group-id="7531135192-6">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">user_id</span><span class="p" data-group-id="7531135192-6">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="p" data-group-id="7531135192-7">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="7531135192-8">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="ss">:current_user</span><span class="p">,</span><span class="w"> </span><span class="n">user_id</span><span class="p" data-group-id="7531135192-8">)</span><span class="p" data-group-id="7531135192-7">}</span><span class="w">
    </span><span class="p" data-group-id="7531135192-9">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="n">reason</span><span class="p" data-group-id="7531135192-9">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="ss">:error</span><span class="w">
  </span><span class="k" data-group-id="7531135192-5">end</span><span class="w">
</span><span class="k" data-group-id="7531135192-3">end</span></code></pre><p>In our JavaScript, we can use the token set previously when constructing the Socket:</p><pre><code class="makeup javascript" translate="no"><span class="kt">let</span><span class="w"> </span><span class="nv">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nv">Socket</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">/socket</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">params</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="n">token</span><span class="p">:</span><span class="w"> </span><span class="nb">window</span><span class="p">.</span><span class="n">userToken</span><span class="p">}</span><span class="p">}</span><span class="p">)</span></code></pre><p>We used <a href="Phoenix.Token.xhtml#verify/4"><code class="inline">Phoenix.Token.verify/4</code></a> to verify the user token provided by the client. <a href="Phoenix.Token.xhtml#verify/4"><code class="inline">Phoenix.Token.verify/4</code></a> returns either <code class="inline">{:ok, user_id}</code> or <code class="inline">{:error, reason}</code>. We can pattern match on that return in a <code class="inline">case</code> statement. With a verified token, we set the user's id as the value to <code class="inline">:current_user</code> in the socket. Otherwise, we return <code class="inline">:error</code>.</p><h3 id="step-4-connect-to-the-socket-in-javascript" class="section-heading">
  <a href="#step-4-connect-to-the-socket-in-javascript" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Step 4 - Connect to the socket in JavaScript</span>
</h3>
<p>With authentication set up, we can connect to sockets and channels from JavaScript.</p><pre><code class="makeup javascript" translate="no"><span class="kt">let</span><span class="w"> </span><span class="nv">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nv">Socket</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">/socket</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">params</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="n">token</span><span class="p">:</span><span class="w"> </span><span class="nb">window</span><span class="p">.</span><span class="n">userToken</span><span class="p">}</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="nv">socket</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="p">)</span></code></pre><p>Now that we are connected, we can join channels with a topic:</p><pre><code class="makeup javascript" translate="no"><span class="kt">let</span><span class="w"> </span><span class="nv">channel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">socket</span><span class="p">.</span><span class="nf">channel</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">topic:subtopic</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="nv">channel</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="p">.</span><span class="nf">receive</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">ok</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">Joined successfully</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">  </span><span class="p">.</span><span class="nf">receive</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">error</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="w"> </span><span class="kt">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nb">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="p">&quot;</span><span class="s2">Unable to join</span><span class="p">&quot;</span><span class="p">,</span><span class="w"> </span><span class="nv">resp</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nv">socket</span></code></pre><p>Note that token authentication is preferable since it's transport agnostic and well-suited for long running-connections like channels, as opposed to using sessions or other authentication approaches.</p><h2 id="fault-tolerance-and-reliability-guarantees" class="section-heading">
  <a href="#fault-tolerance-and-reliability-guarantees" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Fault Tolerance and Reliability Guarantees</span>
</h2>
<p>Servers restart, networks split, and clients lose connectivity. In order to design robust systems, we need to understand how Phoenix responds to these events and what guarantees it offers.</p><h3 id="handling-reconnection" class="section-heading">
  <a href="#handling-reconnection" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Handling Reconnection</span>
</h3>
<p>Clients subscribe to topics, and Phoenix stores those subscriptions in an in-memory ETS table. If a channel crashes, the clients will need to reconnect to the topics they had previously subscribed to. Fortunately, the Phoenix JavaScript client knows how to do this. The server will notify all the clients of the crash. This will trigger each client's <code class="inline">Channel.onError</code> callback. The clients will attempt to reconnect to the server using an exponential backoff strategy. Once they reconnect, they'll attempt to rejoin the topics they had previously subscribed to. If they are successful, they'll start receiving messages from those topics as before.</p><h3 id="resending-client-messages" class="section-heading">
  <a href="#resending-client-messages" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Resending Client Messages</span>
</h3>
<p>Channel clients queue outgoing messages into a <code class="inline">PushBuffer</code>, and send them to the server when there is a connection. If no connection is available, the client holds on to the messages until it can establish a new connection. With no connection, the client will hold the messages in memory until it establishes a connection, or until it receives a <code class="inline">timeout</code> event. The default timeout is set to 5000 milliseconds. The client won't persist the messages in the browser's local storage, so if the browser tab closes, the messages will be gone.</p><h3 id="resending-server-messages" class="section-heading">
  <a href="#resending-server-messages" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Resending Server Messages</span>
</h3>
<p>Phoenix uses an at-most-once strategy when sending messages to clients. If the client is offline and misses the message, Phoenix won't resend it. Phoenix doesn't persist messages on the server. If the server restarts, unsent messages will be gone. If our application needs stronger guarantees around message delivery, we'll need to write that code ourselves. Common approaches involve persisting messages on the server and having clients request missing messages. For an example, see Chris McCord's Phoenix training: <a href="https://github.com/chrismccord/elixirconf_training/blob/master/web/static/js/app.js#L38-L39">client code</a> and <a href="https://github.com/chrismccord/elixirconf_training/blob/master/web/channels/document_channel.ex#L13-L19">server code</a>.</p><h2 id="example-application" class="section-heading">
  <a href="#example-application" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Example Application</span>
</h2>
<p>To see an example of the application we just built, checkout the project <a href="https://github.com/chrismccord/phoenix_chat_example">phoenix_chat_example</a>.</p>

  </body>
</html>
