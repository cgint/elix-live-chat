<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Request life-cycle - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Request life-cycle
    </h1>
<blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="installation.html">introductory guides</a> and got a Phoenix application <a href="up_and_running.html">up and running</a>.</p></blockquote><p>The goal of this guide is to talk about Phoenix's request life-cycle. This guide will take a practical approach where we will learn by doing: we will add two new pages to our Phoenix project and comment on how the pieces fit together along the way.</p><p>Let's get on with our first new Phoenix page!</p><h2 id="adding-a-new-page" class="section-heading">
  <a href="#adding-a-new-page" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Adding a new page</span>
</h2>
<p>When your browser accesses <a href="http://localhost:4000/">http://localhost:4000/</a>, it sends a HTTP request to whatever service is running on that address, in this case our Phoenix application. The HTTP request is made of a verb and a path. For example, the following browser requests translate into:</p><table><thead><tr><th style="text-align: left;">Browser address bar</th><th style="text-align: left;">Verb</th><th style="text-align: left;">Path</th></tr></thead><tbody><tr><td style="text-align: left;"><a href="http://localhost:4000/">http://localhost:4000/</a></td><td style="text-align: left;">GET</td><td style="text-align: left;">/</td></tr><tr><td style="text-align: left;"><a href="http://localhost:4000/hello">http://localhost:4000/hello</a></td><td style="text-align: left;">GET</td><td style="text-align: left;">/hello</td></tr><tr><td style="text-align: left;"><a href="http://localhost:4000/hello/world">http://localhost:4000/hello/world</a></td><td style="text-align: left;">GET</td><td style="text-align: left;">/hello/world</td></tr></tbody></table><p>There are other HTTP verbs. For example, submitting a form typically uses the POST verb.</p><p>Web applications typically handle requests by mapping each verb/path pair into a specific part of your application. This matching in Phoenix is done by the router. For example, we may map &quot;/articles&quot; to a portion of our application that shows all articles. Therefore, to add a new page, our first task is to add a new route.</p><h3 id="a-new-route" class="section-heading">
  <a href="#a-new-route" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">A new route</span>
</h3>
<p>The router maps unique HTTP verb/path pairs to controller/action pairs which will handle them. Controllers in Phoenix are simply Elixir modules. Actions are functions that are defined within these controllers.</p><p>Phoenix generates a router file for us in new applications at <code class="inline">lib/hello_web/router.ex</code>. This is where we will be working for this section.</p><p>The route for our &quot;Welcome to Phoenix!&quot; page from the previous <a href="up_and_running.html">Up And Running Guide</a> looks like this.</p><pre><code class="makeup elixir" translate="no"><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span></code></pre><p>Let's digest what this route is telling us. Visiting <a href="http://localhost:4000/">http://localhost:4000/</a> issues an HTTP <code class="inline">GET</code> request to the root path. All requests like this will be handled by the <code class="inline">home/2</code> function in the <code class="inline">HelloWeb.PageController</code> module defined in <code class="inline">lib/hello_web/controllers/page_controller.ex</code>.</p><p>The page we are going to build will say &quot;Hello World, from Phoenix!&quot; when we point our browser to <a href="http://localhost:4000/hello">http://localhost:4000/hello</a>.</p><p>The first thing we need to do is to create the page route for a new page. Let's open up <code class="inline">lib/hello_web/router.ex</code> in a text editor. For a brand new application, it looks like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="k" data-group-id="3287861226-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:router</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:browser</span><span class="w"> </span><span class="k" data-group-id="3287861226-2">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:accepts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3287861226-3">[</span><span class="s">&quot;html&quot;</span><span class="p" data-group-id="3287861226-3">]</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_session</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_live_flash</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_root_layout</span><span class="p">,</span><span class="w"> </span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3287861226-4">{</span><span class="nc">HelloWeb.Layouts</span><span class="p">,</span><span class="w"> </span><span class="ss">:root</span><span class="p" data-group-id="3287861226-4">}</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:protect_from_forgery</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_secure_browser_headers</span><span class="w">
  </span><span class="k" data-group-id="3287861226-2">end</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:api</span><span class="w"> </span><span class="k" data-group-id="3287861226-5">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:accepts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3287861226-6">[</span><span class="s">&quot;json&quot;</span><span class="p" data-group-id="3287861226-6">]</span><span class="w">
  </span><span class="k" data-group-id="3287861226-5">end</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="3287861226-7">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

    </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="w">
  </span><span class="k" data-group-id="3287861226-7">end</span><span class="w">

  </span><span class="c1"># Other scopes may use custom stacks.</span><span class="w">
  </span><span class="c1"># scope &quot;/api&quot;, HelloWeb do</span><span class="w">
  </span><span class="c1">#   pipe_through :api</span><span class="w">
  </span><span class="c1"># end</span><span class="w">

  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="3287861226-1">end</span></code></pre><p>For now, we'll ignore the pipelines and the use of <code class="inline">scope</code> here and just focus on adding a route. We will discuss those in the <a href="routing.html">Routing guide</a>.</p><p>Let's add a new route to the router that maps a <code class="inline">GET</code> request for <code class="inline">/hello</code> to the <code class="inline">index</code> action of a soon-to-be-created <code class="inline">HelloWeb.HelloController</code> inside the <code class="inline">scope &quot;/&quot; do</code> block of the router:</p><pre><code class="makeup elixir" translate="no"><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="4337246284-1">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="w">
  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloController</span><span class="p">,</span><span class="w"> </span><span class="ss">:index</span><span class="w">
</span><span class="k" data-group-id="4337246284-1">end</span></code></pre><h3 id="a-new-controller" class="section-heading">
  <a href="#a-new-controller" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">A new controller</span>
</h3>
<p>Controllers are Elixir modules, and actions are Elixir functions defined in them. The purpose of actions is to gather the data and perform the tasks needed for rendering. Our route specifies that we need a <code class="inline">HelloWeb.HelloController</code> module with an <code class="inline">index/2</code> function.</p><p>To make the <code class="inline">index</code> action happen, let's create a new <code class="inline">lib/hello_web/controllers/hello_controller.ex</code> file, and make it look like the following:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.HelloController</span><span class="w"> </span><span class="k" data-group-id="6598438386-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:controller</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">index</span><span class="p" data-group-id="6598438386-2">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="6598438386-2">)</span><span class="w"> </span><span class="k" data-group-id="6598438386-3">do</span><span class="w">
    </span><span class="n">render</span><span class="p" data-group-id="6598438386-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:index</span><span class="p" data-group-id="6598438386-4">)</span><span class="w">
  </span><span class="k" data-group-id="6598438386-3">end</span><span class="w">
</span><span class="k" data-group-id="6598438386-1">end</span></code></pre><p>We'll save a discussion of <code class="inline">use HelloWeb, :controller</code> for the <a href="controllers.html">Controllers guide</a>. For now, let's focus on the <code class="inline">index</code> action.</p><p>All controller actions take two arguments. The first is <code class="inline">conn</code>, a struct which holds a ton of data about the request. The second is <code class="inline">params</code>, which are the request parameters. Here, we are not using <code class="inline">params</code>, and we avoid compiler warnings by prefixing it with <code class="inline">_</code>.</p><p>The core of this action is <code class="inline">render(conn, :index)</code>. It tells Phoenix to render the <code class="inline">index</code> template. The modules responsible for rendering are called views. By default, Phoenix views are named after the controller (<code class="inline">HelloController</code>) and format (<code class="inline">HTML</code> in this case), so Phoenix is expecting a <code class="inline">HelloWeb.HelloHTML</code> to exist and define an <code class="inline">index/1</code> function.</p><h3 id="a-new-view" class="section-heading">
  <a href="#a-new-view" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">A new view</span>
</h3>
<p>Phoenix views act as the presentation layer. For example, we expect the output of rendering <code class="inline">index</code> to be a complete HTML page. To make our lives easier, we often use templates for creating those HTML pages.</p><p>Let's create a new view. Create <code class="inline">lib/hello_web/controllers/hello_html.ex</code> and make it look like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.HelloHTML</span><span class="w"> </span><span class="k" data-group-id="5392947283-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:html</span><span class="w">
</span><span class="k" data-group-id="5392947283-1">end</span></code></pre><p>To add templates to this view, we can define them as function components in the module or in separate files.</p><p>Let's start by defining a function component:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.HelloHTML</span><span class="w"> </span><span class="k" data-group-id="9506252480-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:html</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">index</span><span class="p" data-group-id="9506252480-2">(</span><span class="n">assigns</span><span class="p" data-group-id="9506252480-2">)</span><span class="w"> </span><span class="k" data-group-id="9506252480-3">do</span><span class="w">
    </span><span class="sx">~H&quot;&quot;&quot;</span><span class="w">
</span><span class="n">    Hello!
</span><span class="w">    </span><span class="sx">&quot;&quot;&quot;</span><span class="w">
  </span><span class="k" data-group-id="9506252480-3">end</span><span class="w">
</span><span class="k" data-group-id="9506252480-1">end</span></code></pre><p>We defined a function that receives <code class="inline">assigns</code> as arguments and use <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#sigil_H/2">the <code class="inline">~H</code> sigil</a> to put the contents we want to render. Inside the <code class="inline">~H</code> sigil, we use a templating language called HEEx, which stands for &quot;HTML+EEx&quot;. <a href="https://hexdocs.pm/eex/EEx.html"><code class="inline">EEx</code></a> is a library for embedding Elixir that ships as part of Elixir itself. &quot;HTML+EEx&quot; is a Phoenix extension of EEx that is HTML aware, with support for HTML validation, components, and automatic escaping of values. The latter protects you from security vulnerabilities like Cross-Site-Scripting with no extra work on your part.</p><p>A template file works in the same way. Function components are great for smaller templates and separate files are a good choice when you have a lot of markup or your functions start to feel unmanageable.</p><p>Let's give it a try by defining a template in its own file. First delete our <code class="inline">def index(assigns)</code> function from above and replace it with an <code class="inline">embed_templates</code> declaration:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.HelloHTML</span><span class="w"> </span><span class="k" data-group-id="9203483280-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:html</span><span class="w">

  </span><span class="n">embed_templates</span><span class="w"> </span><span class="s">&quot;hello_html/*&quot;</span><span class="w">
</span><span class="k" data-group-id="9203483280-1">end</span></code></pre><p>Here we are telling <code class="inline">Phoenix.Component</code> to embed all <code class="inline">.heex</code> templates found in the sibling <code class="inline">hello_html</code> directory into our module as function definitions.</p><p>Next, we need to add files to the <code class="inline">lib/hello_web/controllers/hello_html</code> directory.</p><p>Note the controller name (<code class="inline">HelloController</code>), the view name (<code class="inline">HelloHTML</code>), and the template directory (<code class="inline">hello_html</code>) all follow the same naming convention and are named after each other. They are also collocated together in the directory tree:</p><blockquote><p><strong>Note</strong>: We can rename the <code class="inline">hello_html</code> directory to whatever we want and put it in a subdirectory of <code class="inline">lib/hello_web/controllers</code>, as long as we update the <code class="inline">embed_templates</code> setting accordingly. However, it's best to keep the same naming convention to prevent any confusion.</p></blockquote><pre><code class="makeup elixir" translate="no"><span class="n">lib</span><span class="o">/</span><span class="n">hello_web</span><span class="w">
</span><span class="err">├</span><span class="err">─</span><span class="err">─</span><span class="w"> </span><span class="n">controllers</span><span class="w">
</span><span class="err">│</span><span class="w">   </span><span class="err">├</span><span class="err">─</span><span class="err">─</span><span class="w"> </span><span class="n">hello_controller</span><span class="o">.</span><span class="n">ex</span><span class="w">
</span><span class="err">│</span><span class="w">   </span><span class="err">├</span><span class="err">─</span><span class="err">─</span><span class="w"> </span><span class="n">hello_html</span><span class="o">.</span><span class="n">ex</span><span class="w">
</span><span class="err">│</span><span class="w">   </span><span class="err">├</span><span class="err">─</span><span class="err">─</span><span class="w"> </span><span class="n">hello_html</span><span class="w">
</span><span class="o">|</span><span class="w">       </span><span class="err">├</span><span class="err">─</span><span class="err">─</span><span class="w"> </span><span class="n">index</span><span class="o">.</span><span class="n">html</span><span class="o">.</span><span class="n">heex</span></code></pre><p>A template file has the following structure: <code class="inline">NAME.FORMAT.TEMPLATING_LANGUAGE</code>. In our case, let's create an <code class="inline">index.html.heex</code> file at <code class="inline">lib/hello_web/controllers/hello_html/index.html.heex</code>:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">section</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span><span class="n">Hello World, from Phoenix!</span><span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span></code></pre><p>Template files are compiled into the module as function components themselves, there is no runtime or performance difference between the two styles.</p><p>Now that we've got the route, controller, view, and template, we should be able to point our browsers at <a href="http://localhost:4000/hello">http://localhost:4000/hello</a> and see our greeting from Phoenix! (In case you stopped the server along the way, the task to restart it is <a href="Mix.Tasks.Phx.Server.xhtml"><code class="inline">mix phx.server</code></a>.)</p><p><img src="assets/images/hello-from-phoenix.png" alt="Phoenix Greets Us"/></p><p>There are a couple of interesting things to notice about what we just did. We didn't need to stop and restart the server while we made these changes. Yes, Phoenix has hot code reloading! Also, even though our <code class="inline">index.html.heex</code> file consists of only a single <code class="inline">section</code> tag, the page we get is a full HTML document. Our index template is actually rendered into layouts: first it renders <code class="inline">lib/hello_web/components/layouts/root.html.heex</code> which renders <code class="inline">lib/hello_web/components/layouts/app.html.heex</code> which finally includes our contents. If you open those files, you'll see a line that looks like this at the bottom:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="8008434439-1">{</span><span class="na">@inner_content</span><span class="p" data-group-id="8008434439-1">}</span></code></pre><p>Which injects our template into the layout before the HTML is sent off to the browser. We will talk more about layouts in the Controllers guide.</p><blockquote><p>A note on hot code reloading: Some editors with their automatic linters may prevent hot code reloading from working. If it's not working for you, please see the discussion in <a href="https://github.com/phoenixframework/phoenix/issues/1165">this issue</a>.</p></blockquote><h2 id="from-endpoint-to-views" class="section-heading">
  <a href="#from-endpoint-to-views" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">From endpoint to views</span>
</h2>
<p>As we built our first page, we could start to understand how the request life-cycle is put together. Now let's take a more holistic look at it.</p><p>All HTTP requests start in our application endpoint. You can find it as a module named <code class="inline">HelloWeb.Endpoint</code> in <code class="inline">lib/hello_web/endpoint.ex</code>. Once you open up the endpoint file, you will see that, similar to the router, the endpoint has many calls to <code class="inline">plug</code>. <a href="https://hexdocs.pm/plug/1.15.3/Plug.html"><code class="inline">Plug</code></a> is a library and a specification for stitching web applications together. It is an essential part of how Phoenix handles requests and we will discuss it in detail in the <a href="plug.html">Plug guide</a> coming next.</p><p>For now, it suffices to say that each plug defines a slice of request processing. In the endpoint you will find a skeleton roughly like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Endpoint</span><span class="w"> </span><span class="k" data-group-id="2628401123-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Endpoint</span><span class="p">,</span><span class="w"> </span><span class="ss">otp_app</span><span class="p">:</span><span class="w"> </span><span class="ss">:hello</span><span class="w">

  </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Static</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.RequestId</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Telemetry</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Parsers</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.MethodOverride</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Head</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="nc">Plug.Session</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w">
</span><span class="k" data-group-id="2628401123-1">end</span></code></pre><p>Each of these plugs have a specific responsibility that we will learn later. The last plug is precisely the <code class="inline">HelloWeb.Router</code> module. This allows the endpoint to delegate all further request processing to the router. As we now know, its main responsibility is to map verb/path pairs to controllers. The controller then tells a view to render a template.</p><p>At this moment, you may be thinking this can be a lot of steps to simply render a page. However, as our application grows in complexity, we will see that each layer serves a distinct purpose:</p><ul><li><p>endpoint (<a href="Phoenix.Endpoint.xhtml"><code class="inline">Phoenix.Endpoint</code></a>) - the endpoint contains the common and initial path that all requests go through. If you want something to happen on all requests, it goes to the endpoint.</p></li><li><p>router (<a href="Phoenix.Router.xhtml"><code class="inline">Phoenix.Router</code></a>) - the router is responsible for dispatching verb/path to controllers. The router also allows us to scope functionality. For example, some pages in your application may require user authentication, others may not.</p></li><li><p>controller (<a href="Phoenix.Controller.xhtml"><code class="inline">Phoenix.Controller</code></a>) - the job of the controller is to retrieve request information, talk to your business domain, and prepare data for the presentation layer.</p></li><li><p>view - the view handles the structured data from the controller and converts it to a presentation to be shown to users. Views are often named after the content format they are rendering.</p></li></ul><p>Let's do a quick recap on how the last three components work together by adding another page.</p><h2 id="another-new-page" class="section-heading">
  <a href="#another-new-page" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Another new page</span>
</h2>
<p>Let's add just a little complexity to our application. We're going to add a new page that will recognize a piece of the URL, label it as a &quot;messenger&quot; and pass it through the controller into the template so our messenger can say hello.</p><p>As we did last time, the first thing we'll do is create a new route.</p><h3 id="another-new-route" class="section-heading">
  <a href="#another-new-route" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Another new route</span>
</h3>
<p>For this exercise, we're going to reuse <code class="inline">HelloController</code> created at the <a href="request_lifecycle.html#a-new-controller">previous step</a> and add a new <code class="inline">show</code> action. We'll add a line just below our last route, like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="4216415476-1">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="w">
  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloController</span><span class="p">,</span><span class="w"> </span><span class="ss">:index</span><span class="w">
  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/hello/:messenger&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloController</span><span class="p">,</span><span class="w"> </span><span class="ss">:show</span><span class="w">
</span><span class="k" data-group-id="4216415476-1">end</span></code></pre><p>Notice that we use the <code class="inline">:messenger</code> syntax in the path. Phoenix will take whatever value that appears in that position in the URL and convert it into a parameter. For example, if we point the browser at: <code class="inline">http://localhost:4000/hello/Frank</code>, the value of <code class="inline">&quot;messenger&quot;</code> will be <code class="inline">&quot;Frank&quot;</code>.</p><h3 id="another-new-action" class="section-heading">
  <a href="#another-new-action" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Another new action</span>
</h3>
<p>Requests to our new route will be handled by the <code class="inline">HelloWeb.HelloController</code> <code class="inline">show</code> action. We already have the controller at <code class="inline">lib/hello_web/controllers/hello_controller.ex</code>, so all we need to do is edit that controller and add a <code class="inline">show</code> action to it. This time, we'll need to extract the messenger from the parameters so that we can pass it (the messenger) to the template. To do that, we add this show function to the controller:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">show</span><span class="p" data-group-id="4217720189-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4217720189-2">%{</span><span class="s">&quot;messenger&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="4217720189-2">}</span><span class="p" data-group-id="4217720189-1">)</span><span class="w"> </span><span class="k" data-group-id="4217720189-3">do</span><span class="w">
  </span><span class="n">render</span><span class="p" data-group-id="4217720189-4">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:show</span><span class="p">,</span><span class="w"> </span><span class="ss">messenger</span><span class="p">:</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="4217720189-4">)</span><span class="w">
</span><span class="k" data-group-id="4217720189-3">end</span></code></pre><p>Within the body of the <code class="inline">show</code> action, we also pass a third argument to the render function, a key-value pair where <code class="inline">:messenger</code> is the key, and the <code class="inline">messenger</code> variable is passed as the value.</p><p>If the body of the action needs access to the full map of parameters bound to the <code class="inline">params</code> variable, in addition to the bound messenger variable, we could define <code class="inline">show/2</code> like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">show</span><span class="p" data-group-id="5504534729-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5504534729-2">%{</span><span class="s">&quot;messenger&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">messenger</span><span class="p" data-group-id="5504534729-2">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">params</span><span class="p" data-group-id="5504534729-1">)</span><span class="w"> </span><span class="k" data-group-id="5504534729-3">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="5504534729-3">end</span></code></pre><p>It's good to remember that the keys of the <code class="inline">params</code> map will always be strings, and that the equals sign does not represent assignment, but is instead a <a href="https://hexdocs.pm/elixir/pattern-matching.html">pattern match</a> assertion.</p><h3 id="another-new-template" class="section-heading">
  <a href="#another-new-template" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Another new template</span>
</h3>
<p>For the last piece of this puzzle, we'll need a new template. Since it is for the <code class="inline">show</code> action of <code class="inline">HelloController</code>, it will go into the <code class="inline">lib/hello_web/controllers/hello_html</code> directory and be called <code class="inline">show.html.heex</code>. It will look surprisingly like our <code class="inline">index.html.heex</code> template, except that we will need to display the name of our messenger.</p><p>To do that, we'll use the special HEEx tags for executing Elixir expressions: <code class="inline">{...}</code> and <code class="inline">&lt;%= %&gt;</code>. Notice that EEx tag has an equals sign like this: <code class="inline">&lt;%=</code> . That means that any Elixir code that goes between those tags will be executed, and the resulting value will replace the tag in the HTML output. If the equals sign were missing, the code would still be executed, but the value would not appear on the page.</p><p>Remember our templates are written in HEEx (HTML+EEx). HEEx is a superset of EEx, and thereby supports the EEx <code class="inline">&lt;%= %&gt;</code> interpolation syntax for interpolating arbitrary blocks of code. In general, the HEEx <code class="inline">{...}</code> interpolation syntax is preferred anytime there is HTML-aware intepolation to be done – such as within attributes or inline values with a body.</p><p>The only times <a href="https://hexdocs.pm/eex/EEx.html"><code class="inline">EEx</code></a> <code class="inline">&lt;%= %&gt;</code> interpolation is necessary is for interpolationg arbitrary blocks of markup, such as branching logic that inects separate markup trees, or for interpolating values within <code class="inline">&lt;script&gt;</code> or <code class="inline">&lt;style&gt;</code> tags.</p><p>This is what the <code class="inline">hello_html/show.html.heex</code> template should look like:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">section</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span><span class="n">Hello World, from </span><span class="p" data-group-id="0327342022-1">{</span><span class="na">@messenger</span><span class="p" data-group-id="0327342022-1">}</span><span class="n">!</span><span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span></code></pre><p>Our messenger appears as <code class="inline">@messenger</code>.</p><p>The values we passed to the view from the controller are collectively called our &quot;assigns&quot;. We could access our messenger value via <code class="inline">assigns.messenger</code> but through some metaprogramming, Phoenix gives us the much cleaner <code class="inline">@</code> syntax for use in templates.</p><p>We're done. If you point your browser to <a href="http://localhost:4000/hello/Frank">http://localhost:4000/hello/Frank</a>, you should see a page that looks like this:</p><p><img src="assets/images/hello-world-from-frank.png" alt="Frank Greets Us from Phoenix"/></p><p>Play around a bit. Whatever you put after <code class="inline">/hello/</code> will appear on the page as your messenger.</p>

  </body>
</html>
