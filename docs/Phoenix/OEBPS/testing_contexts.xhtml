<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Testing Contexts - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Testing Contexts
    </h1>
<blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="installation.html">introductory guides</a> and got a Phoenix application <a href="up_and_running.html">up and running</a>.</p></blockquote><blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="testing.html">Introduction to Testing guide</a>.</p></blockquote><blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="contexts.html">Contexts guide</a>.</p></blockquote><p>At the end of the Introduction to Testing guide, we generated an HTML resource for posts using the following command:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.gen.html Blog Post posts title body:text
</span></code></pre><p>This gave us a number of modules for free, including a Blog context and a Post schema, alongside their respective test files. As we have learned in the Context guide, the Blog context is simply a module with functions to a particular area of our business domain, while Post schema maps to a particular table in our database.</p><p>In this guide, we are going to explore the tests generated for our contexts and schemas. Before we do anything else, let's run <a href="https://hexdocs.pm/mix/Mix.Tasks.Test.html"><code class="inline">mix test</code></a> to make sure our test suite runs cleanly.</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix test
</span><span class="">................
</span><span class="">
</span><span class="">Finished in 0.6 seconds
</span><span class="">21 tests, 0 failures
</span><span class="">
</span><span class="">Randomized with seed 638414
</span></code></pre><p>Great. We've got twenty-one tests and they are all passing!</p><h2 id="testing-posts" class="section-heading">
  <a href="#testing-posts" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Testing posts</span>
</h2>
<p>If you open up <code class="inline">test/hello/blog_test.exs</code>, you will see a file with the following:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Hello.BlogTest</span><span class="w"> </span><span class="k" data-group-id="6513025994-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Hello.DataCase</span><span class="w">

  </span><span class="kn">alias</span><span class="w"> </span><span class="nc">Hello.Blog</span><span class="w">

  </span><span class="n">describe</span><span class="w"> </span><span class="s">&quot;posts&quot;</span><span class="w"> </span><span class="k" data-group-id="6513025994-2">do</span><span class="w">
    </span><span class="kn">alias</span><span class="w"> </span><span class="nc">Hello.Blog.Post</span><span class="w">

    </span><span class="kn">import</span><span class="w"> </span><span class="nc">Hello.BlogFixtures</span><span class="w">

    </span><span class="na">@invalid_attrs</span><span class="w"> </span><span class="p" data-group-id="6513025994-3">%{</span><span class="ss">body</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">title</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="6513025994-3">}</span><span class="w">

    </span><span class="n">test</span><span class="w"> </span><span class="s">&quot;list_posts/0 returns all posts&quot;</span><span class="w"> </span><span class="k" data-group-id="6513025994-4">do</span><span class="w">
      </span><span class="n">post</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">post_fixture</span><span class="p" data-group-id="6513025994-5">(</span><span class="p" data-group-id="6513025994-5">)</span><span class="w">
      </span><span class="n">assert</span><span class="w"> </span><span class="nc">Blog</span><span class="o">.</span><span class="n">list_posts</span><span class="p" data-group-id="6513025994-6">(</span><span class="p" data-group-id="6513025994-6">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p" data-group-id="6513025994-7">[</span><span class="n">post</span><span class="p" data-group-id="6513025994-7">]</span><span class="w">
    </span><span class="k" data-group-id="6513025994-4">end</span><span class="w">

    </span><span class="n">...</span></code></pre><p>As the top of the file we import <code class="inline">Hello.DataCase</code>, which as we will see soon, it is similar to <code class="inline">HelloWeb.ConnCase</code>. While <code class="inline">HelloWeb.ConnCase</code> sets up helpers for working with connections, which is useful when testing controllers and views, <code class="inline">Hello.DataCase</code> provides functionality for working with contexts and schemas.</p><p>Next, we define an alias, so we can refer to <code class="inline">Hello.Blog</code> simply as <code class="inline">Blog</code>.</p><p>Then we start a <code class="inline">describe &quot;posts&quot;</code> block. A <code class="inline">describe</code> block is a feature in ExUnit that allows us to group similar tests. The reason why we have grouped all post related tests together is because contexts in Phoenix are capable of grouping multiple schemas together. For example, if we ran this command:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.gen.html Blog Comment comments post_id:references:posts body:text
</span></code></pre><p>We will get a bunch of new functions in the <code class="inline">Hello.Blog</code> context, plus a whole new <code class="inline">describe &quot;comments&quot;</code> block in our test file.</p><p>The tests defined for our context are very straight-forward. They call the functions in our context and assert on their results. As you can see, some of those tests even create entries in the database:</p><pre><code class="makeup elixir" translate="no"><span class="n">test</span><span class="w"> </span><span class="s">&quot;create_post/1 with valid data creates a post&quot;</span><span class="w"> </span><span class="k" data-group-id="1722125232-1">do</span><span class="w">
  </span><span class="n">valid_attrs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1722125232-2">%{</span><span class="ss">body</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;some body&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">title</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;some title&quot;</span><span class="p" data-group-id="1722125232-2">}</span><span class="w">

  </span><span class="n">assert</span><span class="w"> </span><span class="p" data-group-id="1722125232-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1722125232-4">%</span><span class="nc" data-group-id="1722125232-4">Post</span><span class="p" data-group-id="1722125232-4">{</span><span class="p" data-group-id="1722125232-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">post</span><span class="p" data-group-id="1722125232-3">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Blog</span><span class="o">.</span><span class="n">create_post</span><span class="p" data-group-id="1722125232-5">(</span><span class="n">valid_attrs</span><span class="p" data-group-id="1722125232-5">)</span><span class="w">
  </span><span class="n">assert</span><span class="w"> </span><span class="n">post</span><span class="o">.</span><span class="n">body</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;some body&quot;</span><span class="w">
  </span><span class="n">assert</span><span class="w"> </span><span class="n">post</span><span class="o">.</span><span class="n">title</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;some title&quot;</span><span class="w">
</span><span class="k" data-group-id="1722125232-1">end</span></code></pre><p>At this point, you may wonder: how can Phoenix make sure the data created in one of the tests do not affect other tests? We are glad you asked. To answer this question, let's talk about the <code class="inline">DataCase</code>.</p><h2 id="the-datacase" class="section-heading">
  <a href="#the-datacase" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">The DataCase</span>
</h2>
<p>If you open up <code class="inline">test/support/data_case.ex</code>, you will find the following:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Hello.DataCase</span><span class="w"> </span><span class="k" data-group-id="8588119987-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">ExUnit.CaseTemplate</span><span class="w">

  </span><span class="n">using</span><span class="w"> </span><span class="k" data-group-id="8588119987-2">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8588119987-3">do</span><span class="w">
      </span><span class="kn">alias</span><span class="w"> </span><span class="nc">Hello.Repo</span><span class="w">

      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Ecto</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Ecto.Changeset</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Ecto.Query</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Hello.DataCase</span><span class="w">
    </span><span class="k" data-group-id="8588119987-3">end</span><span class="w">
  </span><span class="k" data-group-id="8588119987-2">end</span><span class="w">

  </span><span class="n">setup</span><span class="w"> </span><span class="n">tags</span><span class="w"> </span><span class="k" data-group-id="8588119987-4">do</span><span class="w">
    </span><span class="nc">Hello.DataCase</span><span class="o">.</span><span class="n">setup_sandbox</span><span class="p" data-group-id="8588119987-5">(</span><span class="n">tags</span><span class="p" data-group-id="8588119987-5">)</span><span class="w">
    </span><span class="ss">:ok</span><span class="w">
  </span><span class="k" data-group-id="8588119987-4">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">setup_sandbox</span><span class="p" data-group-id="8588119987-6">(</span><span class="n">tags</span><span class="p" data-group-id="8588119987-6">)</span><span class="w"> </span><span class="k" data-group-id="8588119987-7">do</span><span class="w">
    </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ecto.Adapters.SQL.Sandbox</span><span class="o">.</span><span class="n">start_owner!</span><span class="p" data-group-id="8588119987-8">(</span><span class="nc">Hello.Repo</span><span class="p">,</span><span class="w"> </span><span class="ss">shared</span><span class="p">:</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">tags</span><span class="p" data-group-id="8588119987-9">[</span><span class="ss">:async</span><span class="p" data-group-id="8588119987-9">]</span><span class="p" data-group-id="8588119987-8">)</span><span class="w">
    </span><span class="n">on_exit</span><span class="p" data-group-id="8588119987-10">(</span><span class="k" data-group-id="8588119987-11">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Ecto.Adapters.SQL.Sandbox</span><span class="o">.</span><span class="n">stop_owner</span><span class="p" data-group-id="8588119987-12">(</span><span class="n">pid</span><span class="p" data-group-id="8588119987-12">)</span><span class="w"> </span><span class="k" data-group-id="8588119987-11">end</span><span class="p" data-group-id="8588119987-10">)</span><span class="w">
  </span><span class="k" data-group-id="8588119987-7">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">errors_on</span><span class="p" data-group-id="8588119987-13">(</span><span class="n">changeset</span><span class="p" data-group-id="8588119987-13">)</span><span class="w"> </span><span class="k" data-group-id="8588119987-14">do</span><span class="w">
    </span><span class="n">...</span><span class="w">
  </span><span class="k" data-group-id="8588119987-14">end</span><span class="w">
</span><span class="k" data-group-id="8588119987-1">end</span></code></pre><p><code class="inline">Hello.DataCase</code> is another <a href="https://hexdocs.pm/ex_unit/ExUnit.CaseTemplate.html"><code class="inline">ExUnit.CaseTemplate</code></a>. In the <code class="inline">using</code> block, we can see all of the aliases and imports <code class="inline">DataCase</code> brings into our tests. The <code class="inline">setup</code> chunk for <code class="inline">DataCase</code> is very similar to the one from <code class="inline">ConnCase</code>. As we can see, most of the <code class="inline">setup</code> block revolves around setting up a SQL Sandbox.</p><p>The SQL Sandbox is precisely what allows our tests to write to the database without affecting any of the other tests. In a nutshell, at the beginning of every test, we start a transaction in the database. When the test is over, we automatically rollback the transaction, effectively erasing all of the data created in the test.</p><p>Furthermore, the SQL Sandbox allows multiple tests to run concurrently, even if they talk to the database. This feature is provided for PostgreSQL databases and it can be used to further speed up your contexts and controllers tests by adding a <code class="inline">async: true</code> flag when using them:</p><pre><code class="makeup elixir" translate="no"><span class="kn">use</span><span class="w"> </span><span class="nc">Hello.DataCase</span><span class="p">,</span><span class="w"> </span><span class="ss">async</span><span class="p">:</span><span class="w"> </span><span class="no">true</span></code></pre><p>There are some considerations you need to have in mind when running asynchronous tests with the sandbox, so please refer to the <a href="https://hexdocs.pm/ecto_sql/Ecto.Adapters.SQL.Sandbox.html"><code class="inline">Ecto.Adapters.SQL.Sandbox</code></a> for more information.</p><p>Finally at the end of the of the <code class="inline">DataCase</code> module we can find a function named <code class="inline">errors_on</code> with some examples of how to use it. This function is used for testing any validation we may want to add to our schemas. Let's give it a try by adding our own validations and then testing them.</p><h2 id="testing-schemas" class="section-heading">
  <a href="#testing-schemas" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Testing schemas</span>
</h2>
<p>When we generate our HTML Post resource, Phoenix generated a Blog context and a Post schema. It generated a test file for the context, but no test file for the schema. However, this doesn't mean we don't need to test the schema, it just means we did not have to test the schema so far.</p><p>You may be wondering then: when do we test the context directly and when do we test the schema directly? The answer to this question is the same answer to the question of when do we add code to a context and when do we add it to the schema?</p><p>The general guideline is to keep all side-effect free code in the schema. In other words, if you are simply working with data structures, schemas and changesets, put it in the schema. The context will typically have the code that creates and updates schemas and then write them to a database or an API.</p><p>We'll be adding additional validations to the schema module, so that's a great opportunity to write some schema specific tests. Open up <code class="inline">lib/hello/blog/post.ex</code> and add the following validation to <code class="inline">def changeset</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">changeset</span><span class="p" data-group-id="9283052524-1">(</span><span class="n">post</span><span class="p">,</span><span class="w"> </span><span class="n">attrs</span><span class="p" data-group-id="9283052524-1">)</span><span class="w"> </span><span class="k" data-group-id="9283052524-2">do</span><span class="w">
  </span><span class="n">post</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">cast</span><span class="p" data-group-id="9283052524-3">(</span><span class="n">attrs</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9283052524-4">[</span><span class="ss">:title</span><span class="p">,</span><span class="w"> </span><span class="ss">:body</span><span class="p" data-group-id="9283052524-4">]</span><span class="p" data-group-id="9283052524-3">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">validate_required</span><span class="p" data-group-id="9283052524-5">(</span><span class="p" data-group-id="9283052524-6">[</span><span class="ss">:title</span><span class="p">,</span><span class="w"> </span><span class="ss">:body</span><span class="p" data-group-id="9283052524-6">]</span><span class="p" data-group-id="9283052524-5">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">validate_length</span><span class="p" data-group-id="9283052524-7">(</span><span class="ss">:title</span><span class="p">,</span><span class="w"> </span><span class="ss">min</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="9283052524-7">)</span><span class="w">
</span><span class="k" data-group-id="9283052524-2">end</span></code></pre><p>The new validation says the title needs to have at least 2 characters. Let's write a test for this. Create a new file at <code class="inline">test/hello/blog/post_test.exs</code> with this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Hello.Blog.PostTest</span><span class="w"> </span><span class="k" data-group-id="4438587159-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Hello.DataCase</span><span class="p">,</span><span class="w"> </span><span class="ss">async</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kn">alias</span><span class="w"> </span><span class="nc">Hello.Blog.Post</span><span class="w">

  </span><span class="n">test</span><span class="w"> </span><span class="s">&quot;title must be at least two characters long&quot;</span><span class="w"> </span><span class="k" data-group-id="4438587159-2">do</span><span class="w">
    </span><span class="n">changeset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Post</span><span class="o">.</span><span class="n">changeset</span><span class="p" data-group-id="4438587159-3">(</span><span class="p" data-group-id="4438587159-4">%</span><span class="nc" data-group-id="4438587159-4">Post</span><span class="p" data-group-id="4438587159-4">{</span><span class="p" data-group-id="4438587159-4">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4438587159-5">%{</span><span class="ss">title</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;I&quot;</span><span class="p" data-group-id="4438587159-5">}</span><span class="p" data-group-id="4438587159-3">)</span><span class="w">
    </span><span class="n">assert</span><span class="w"> </span><span class="p" data-group-id="4438587159-6">%{</span><span class="ss">title</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4438587159-7">[</span><span class="s">&quot;should be at least 2 character(s)&quot;</span><span class="p" data-group-id="4438587159-7">]</span><span class="p" data-group-id="4438587159-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">errors_on</span><span class="p" data-group-id="4438587159-8">(</span><span class="n">changeset</span><span class="p" data-group-id="4438587159-8">)</span><span class="w">
  </span><span class="k" data-group-id="4438587159-2">end</span><span class="w">
</span><span class="k" data-group-id="4438587159-1">end</span></code></pre><p>And that's it. As our business domain grows, we have well-defined places to test our contexts and schemas.</p>

  </body>
</html>
