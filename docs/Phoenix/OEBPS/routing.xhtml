<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Routing - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Routing
    </h1>
<blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="installation.html">introductory guides</a> and got a Phoenix application <a href="up_and_running.html">up and running</a>.</p></blockquote><blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="request_lifecycle.html">Request life-cycle guide</a>.</p></blockquote><p>Routers are the main hubs of Phoenix applications. They match HTTP requests to controller actions, wire up real-time channel handlers, and define a series of pipeline transformations scoped to a set of routes.</p><p>The router file that Phoenix generates, <code class="inline">lib/hello_web/router.ex</code>, will look something like this one:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="k" data-group-id="4909325904-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:router</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:browser</span><span class="w"> </span><span class="k" data-group-id="4909325904-2">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:accepts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4909325904-3">[</span><span class="s">&quot;html&quot;</span><span class="p" data-group-id="4909325904-3">]</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_session</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_live_flash</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_root_layout</span><span class="p">,</span><span class="w"> </span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4909325904-4">{</span><span class="nc">HelloWeb.Layouts</span><span class="p">,</span><span class="w"> </span><span class="ss">:root</span><span class="p" data-group-id="4909325904-4">}</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:protect_from_forgery</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_secure_browser_headers</span><span class="w">
  </span><span class="k" data-group-id="4909325904-2">end</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:api</span><span class="w"> </span><span class="k" data-group-id="4909325904-5">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:accepts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4909325904-6">[</span><span class="s">&quot;json&quot;</span><span class="p" data-group-id="4909325904-6">]</span><span class="w">
  </span><span class="k" data-group-id="4909325904-5">end</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="4909325904-7">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

    </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="w">
  </span><span class="k" data-group-id="4909325904-7">end</span><span class="w">

  </span><span class="c1"># Other scopes may use custom stacks.</span><span class="w">
  </span><span class="c1"># scope &quot;/api&quot;, HelloWeb do</span><span class="w">
  </span><span class="c1">#   pipe_through :api</span><span class="w">
  </span><span class="c1"># end</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="4909325904-1">end</span></code></pre><p>Both the router and controller module names will be prefixed with the name you gave your application suffixed with <code class="inline">Web</code>.</p><p>The first line of this module, <code class="inline">use HelloWeb, :router</code>, simply makes Phoenix router functions available in our particular router.</p><p>Scopes have their own section in this guide, so we won't spend time on the <code class="inline">scope &quot;/&quot;, HelloWeb do</code> block here. The <code class="inline">pipe_through :browser</code> line will get a full treatment in the &quot;Pipelines&quot; section of this guide. For now, you only need to know that pipelines allow a set of plugs to be applied to different sets of routes.</p><p>Inside the scope block, however, we have our first actual route:</p><pre><code class="makeup elixir" translate="no"><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span></code></pre><p><code class="inline">get</code> is a Phoenix macro that corresponds to the HTTP verb GET. Similar macros exist for other HTTP verbs, including POST, PUT, PATCH, DELETE, OPTIONS, CONNECT, TRACE, and HEAD.</p><section role="note" class="admonition info"><h4 class="admonition-title info">Why the macros?</h4><p>Phoenix does its best to keep the usage of macros low. You may have noticed, however, that the <a href="Phoenix.Router.xhtml"><code class="inline">Phoenix.Router</code></a> relies heavily on macros. Why is that?</p><p>We use <code class="inline">get</code>, <code class="inline">post</code>, <code class="inline">put</code>, and <code class="inline">delete</code> to define your routes. We use macros for two purposes:</p><ul><li><p>They define the routing engine, used on every request, to choose which controller to dispatch the request to. Thanks to macros, Phoenix compiles all of your routes to a huge case-statement with pattern matching rules, which is heavily optimized by the Erlang VM</p></li><li><p>For each route you define, we also define metadata to implement <a href="Phoenix.VerifiedRoutes.xhtml"><code class="inline">Phoenix.VerifiedRoutes</code></a>. As we will soon learn, verified routes allow us to reference any route as if it were a plain looking string, except that it is verified by the compiler to be valid (making it much harder to ship broken links, forms, mails, etc to production)</p></li></ul><p>In other words, the router relies on macros to build applications that are faster and safer. Also remember that macros in Elixir are compile-time only, which gives plenty of stability after the code is compiled. As we will learn next, Phoenix also provides introspection for all defined routes via <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a>.</p></section><h2 id="examining-routes" class="section-heading">
  <a href="#examining-routes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Examining routes</span>
</h2>
<p>Phoenix provides an excellent tool for investigating routes in an application: <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a>.</p><p>Let's see how this works. Go to the root of a newly-generated Phoenix application and run <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a>. You should see something like the following, generated with all routes you currently have:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">mix phx.routes
</span><span class="">GET  /  HelloWeb.PageController :home
</span><span class="">...
</span></code></pre><p>The route above tells us that any HTTP GET request for the root of the application will be handled by the <code class="inline">home</code> action of the <code class="inline">HelloWeb.PageController</code>.</p><h2 id="resources" class="section-heading">
  <a href="#resources" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Resources</span>
</h2>
<p>The router supports other macros besides those for HTTP verbs like <a href="Phoenix.Router.xhtml#get/3"><code class="inline">get</code></a>, <a href="Phoenix.Router.xhtml#post/3"><code class="inline">post</code></a>, and <a href="Phoenix.Router.xhtml#put/3"><code class="inline">put</code></a>. The most important among them is <a href="Phoenix.Router.xhtml#resources/4"><code class="inline">resources</code></a>. Let's add a resource to our <code class="inline">lib/hello_web/router.ex</code> file like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="2151245817-1">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="w">
  </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/users&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">UserController</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="2151245817-1">end</span></code></pre><p>For now it doesn't matter that we don't actually have a <code class="inline">HelloWeb.UserController</code>.</p><p>Run <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a> once again at the root of your project. You should see something like the following:</p><pre><code class="makeup console" translate="no"><span class="">...
</span><span class="">GET     /users           HelloWeb.UserController :index
</span><span class="">GET     /users/:id/edit  HelloWeb.UserController :edit
</span><span class="">GET     /users/new       HelloWeb.UserController :new
</span><span class="">GET     /users/:id       HelloWeb.UserController :show
</span><span class="">POST    /users           HelloWeb.UserController :create
</span><span class="">PATCH   /users/:id       HelloWeb.UserController :update
</span><span class="">PUT     /users/:id       HelloWeb.UserController :update
</span><span class="">DELETE  /users/:id       HelloWeb.UserController :delete
</span><span class="">...
</span></code></pre><p>This is the standard matrix of HTTP verbs, paths, and controller actions. For a while, this was known as RESTful routes, but most consider this a misnomer nowadays. Let's look at them individually.</p><ul><li>A GET request to <code class="inline">/users</code> will invoke the <code class="inline">index</code> action to show all the users.</li><li>A GET request to <code class="inline">/users/:id/edit</code> will invoke the <code class="inline">edit</code> action with an ID to retrieve an individual user from the data store and present the information in a form for editing.</li><li>A GET request to <code class="inline">/users/new</code> will invoke the <code class="inline">new</code> action to present a form for creating a new user.</li><li>A GET request to <code class="inline">/users/:id</code> will invoke the <code class="inline">show</code> action with an id to show an individual user identified by that ID.</li><li>A POST request to <code class="inline">/users</code> will invoke the <code class="inline">create</code> action to save a new user to the data store.</li><li>A PATCH request to <code class="inline">/users/:id</code> will invoke the <code class="inline">update</code> action with an ID to save the updated user to the data store.</li><li>A PUT request to <code class="inline">/users/:id</code> will also invoke the <code class="inline">update</code> action with an ID to save the updated user to the data store.</li><li>A DELETE request to <code class="inline">/users/:id</code> will invoke the <code class="inline">delete</code> action with an ID to remove the individual user from the data store.</li></ul><p>If we don't need all these routes, we can be selective using the <code class="inline">:only</code> and <code class="inline">:except</code> options to filter specific actions.</p><p>Let's say we have a read-only posts resource. We could define it like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/posts&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PostController</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5926261747-1">[</span><span class="ss">:index</span><span class="p">,</span><span class="w"> </span><span class="ss">:show</span><span class="p" data-group-id="5926261747-1">]</span></code></pre><p>Running <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a> shows that we now only have the routes to the index and show actions defined.</p><pre><code class="makeup console" translate="no"><span class="">GET     /posts      HelloWeb.PostController :index
</span><span class="">GET     /posts/:id  HelloWeb.PostController :show
</span></code></pre><p>Similarly, if we have a comments resource, and we don't want to provide a route to delete one, we could define a route like this.</p><pre><code class="makeup elixir" translate="no"><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/comments&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">CommentController</span><span class="p">,</span><span class="w"> </span><span class="ss">except</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6779541977-1">[</span><span class="ss">:delete</span><span class="p" data-group-id="6779541977-1">]</span></code></pre><p>Running <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a> now shows that we have all the routes except the DELETE request to the delete action.</p><pre><code class="makeup console" translate="no"><span class="">GET    /comments           HelloWeb.CommentController :index
</span><span class="">GET    /comments/:id/edit  HelloWeb.CommentController :edit
</span><span class="">GET    /comments/new       HelloWeb.CommentController :new
</span><span class="">GET    /comments/:id       HelloWeb.CommentController :show
</span><span class="">POST   /comments           HelloWeb.CommentController :create
</span><span class="">PATCH  /comments/:id       HelloWeb.CommentController :update
</span><span class="">PUT    /comments/:id       HelloWeb.CommentController :update
</span></code></pre><p>The <a href="Phoenix.Router.xhtml#resources/4"><code class="inline">Phoenix.Router.resources/4</code></a> macro describes additional options for customizing resource routes.</p><h2 id="verified-routes" class="section-heading">
  <a href="#verified-routes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Verified Routes</span>
</h2>
<p>Phoenix includes <a href="Phoenix.VerifiedRoutes.xhtml"><code class="inline">Phoenix.VerifiedRoutes</code></a> module which provides compile-time checks of router paths against your router by using the <code class="inline">~p</code> sigil. For example, you can write paths in controllers, tests, and templates and the compiler will make sure those actually match routes defined in your router.</p><p>Let's see it in action. Run <code class="inline">iex -S mix</code> at the root of the project. We'll define a throwaway example module that builds a couple <code class="inline">~p</code> route paths.</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">RouteExample</span><span class="w"> </span><span class="k" data-group-id="6677719789-1">do</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:verified_routes</span><span class="w">
</span><span class="gp unselectable">...&gt;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="nf">example</span><span class="w"> </span><span class="k" data-group-id="6677719789-2">do</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">    </span><span class="sx">~p&quot;/comments&quot;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">    </span><span class="sx">~p&quot;/unknown/123&quot;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="k" data-group-id="6677719789-2">end</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="6677719789-1">end</span><span class="w">
</span><span class="ss">warning</span><span class="p">:</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">route</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="n">matches</span><span class="w"> </span><span class="s">&quot;/unknown/123&quot;</span><span class="w">
  </span><span class="n">iex</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="w"> </span><span class="nc">RouteExample</span><span class="o">.</span><span class="n">example</span><span class="o">/</span><span class="mi">0</span><span class="w">

</span><span class="p" data-group-id="6677719789-3">{</span><span class="ss">:module</span><span class="p">,</span><span class="w"> </span><span class="nc">RouteExample</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="6677719789-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt;</span></code></pre><p>Notice how the first call to an existing route, <code class="inline">~p&quot;/comments&quot;</code> gave no warning, but a bad route path <code class="inline">~p&quot;/unknown/123&quot;</code> produced a compiler warning, just as it should. This is significant because it allows us to write otherwise hard-coded paths in our application and the compiler will let us know whenever we write a bad route or change our routing structure.</p><p>Phoenix projects are set up out of the box to allow use of verified routes throughout your web layer, including tests. For example in your templates you can render <code class="inline">~p</code> links:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">.link</span><span class="w"> </span><span class="ni">href</span><span class="p">=</span><span class="p" data-group-id="2006984682-1">{</span><span class="sx">~p&quot;/&quot;</span><span class="p" data-group-id="2006984682-1">}</span><span class="p">&gt;</span><span class="n">Welcome Page!</span><span class="p">&lt;/</span><span class="nt">.link</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;</span><span class="nt">.link</span><span class="w"> </span><span class="ni">href</span><span class="p">=</span><span class="p" data-group-id="2006984682-2">{</span><span class="sx">~p&quot;/comments&quot;</span><span class="p" data-group-id="2006984682-2">}</span><span class="p">&gt;</span><span class="n">View Comments</span><span class="p">&lt;/</span><span class="nt">.link</span><span class="p">&gt;</span></code></pre><p>Or in a controller, issue a redirect:</p><pre><code class="makeup elixir" translate="no"><span class="n">redirect</span><span class="p" data-group-id="6715952431-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="sx">~p&quot;/comments/</span><span class="si" data-group-id="6715952431-2">#{</span><span class="n">comment</span><span class="si" data-group-id="6715952431-2">}</span><span class="sx">&quot;</span><span class="p" data-group-id="6715952431-1">)</span></code></pre><p>Using <code class="inline">~p</code> for route paths ensures our application paths and URLs stay up to date with the router definitions. The compiler will catch bugs for us, and let us know when we change routes that are referenced elsewhere in our application.</p><h3 id="more-on-verified-routes" class="section-heading">
  <a href="#more-on-verified-routes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">More on verified routes</span>
</h3>
<p>What about paths with query strings? You can either add query string key values directly, or provide a dictionary of key-value pairs, for example:</p><pre><code class="makeup elixir" translate="no"><span class="sx">~p&quot;/users/17?admin=true&amp;active=false&quot;</span><span class="w">
</span><span class="s">&quot;/users/17?admin=true&amp;active=false&quot;</span><span class="w">

</span><span class="sx">~p&quot;/users/17?</span><span class="si" data-group-id="6756600856-1">#{</span><span class="p" data-group-id="6756600856-2">[</span><span class="ss">admin</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="6756600856-2">]</span><span class="si" data-group-id="6756600856-1">}</span><span class="sx">&quot;</span><span class="w">
</span><span class="s">&quot;/users/17?admin=true&quot;</span></code></pre><p>What if we need a full URL instead of a path? Just wrap your path with a call to <a href="Phoenix.VerifiedRoutes.xhtml#url/1"><code class="inline">Phoenix.VerifiedRoutes.url/1</code></a>, which is imported everywhere that <code class="inline">~p</code> is available:</p><pre><code class="makeup elixir" translate="no"><span class="n">url</span><span class="p" data-group-id="5267110659-1">(</span><span class="sx">~p&quot;/users&quot;</span><span class="p" data-group-id="5267110659-1">)</span><span class="w">
</span><span class="s">&quot;http://localhost:4000/users&quot;</span></code></pre><p>The <code class="inline">url</code> calls will get the host, port, proxy port, and SSL information needed to construct the full URL from the configuration parameters set for each environment. We'll talk about configuration in more detail in its own guide. For now, you can take a look at <code class="inline">config/dev.exs</code> file in your own project to see those values.</p><h2 id="nested-resources" class="section-heading">
  <a href="#nested-resources" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Nested resources</span>
</h2>
<p>It is also possible to nest resources in a Phoenix router. Let's say we also have a <code class="inline">posts</code> resource that has a many-to-one relationship with <code class="inline">users</code>. That is to say, a user can create many posts, and an individual post belongs to only one user. We can represent that by adding a nested route in <code class="inline">lib/hello_web/router.ex</code> like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/users&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">UserController</span><span class="w"> </span><span class="k" data-group-id="9505286537-1">do</span><span class="w">
  </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/posts&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PostController</span><span class="w">
</span><span class="k" data-group-id="9505286537-1">end</span></code></pre><p>When we run <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a> now, in addition to the routes we saw for <code class="inline">users</code> above, we get the following set of routes:</p><pre><code class="makeup elixir" translate="no"><span class="n">...</span><span class="w">
</span><span class="nc">GET</span><span class="w">     </span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="ss">:user_id</span><span class="o">/</span><span class="n">posts</span><span class="w">           </span><span class="nc">HelloWeb.PostController</span><span class="w"> </span><span class="ss">:index</span><span class="w">
</span><span class="nc">GET</span><span class="w">     </span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="ss">:user_id</span><span class="o">/</span><span class="n">posts</span><span class="o">/</span><span class="ss">:id</span><span class="o">/</span><span class="n">edit</span><span class="w">  </span><span class="nc">HelloWeb.PostController</span><span class="w"> </span><span class="ss">:edit</span><span class="w">
</span><span class="nc">GET</span><span class="w">     </span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="ss">:user_id</span><span class="o">/</span><span class="n">posts</span><span class="o">/</span><span class="n">new</span><span class="w">       </span><span class="nc">HelloWeb.PostController</span><span class="w"> </span><span class="ss">:new</span><span class="w">
</span><span class="nc">GET</span><span class="w">     </span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="ss">:user_id</span><span class="o">/</span><span class="n">posts</span><span class="o">/</span><span class="ss">:id</span><span class="w">       </span><span class="nc">HelloWeb.PostController</span><span class="w"> </span><span class="ss">:show</span><span class="w">
</span><span class="nc">POST</span><span class="w">    </span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="ss">:user_id</span><span class="o">/</span><span class="n">posts</span><span class="w">           </span><span class="nc">HelloWeb.PostController</span><span class="w"> </span><span class="ss">:create</span><span class="w">
</span><span class="nc">PATCH</span><span class="w">   </span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="ss">:user_id</span><span class="o">/</span><span class="n">posts</span><span class="o">/</span><span class="ss">:id</span><span class="w">       </span><span class="nc">HelloWeb.PostController</span><span class="w"> </span><span class="ss">:update</span><span class="w">
</span><span class="nc">PUT</span><span class="w">     </span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="ss">:user_id</span><span class="o">/</span><span class="n">posts</span><span class="o">/</span><span class="ss">:id</span><span class="w">       </span><span class="nc">HelloWeb.PostController</span><span class="w"> </span><span class="ss">:update</span><span class="w">
</span><span class="nc">DELETE</span><span class="w">  </span><span class="o">/</span><span class="n">users</span><span class="o">/</span><span class="ss">:user_id</span><span class="o">/</span><span class="n">posts</span><span class="o">/</span><span class="ss">:id</span><span class="w">       </span><span class="nc">HelloWeb.PostController</span><span class="w"> </span><span class="ss">:delete</span><span class="w">
</span><span class="n">...</span></code></pre><p>We see that each of these routes scopes the posts to a user ID. For the first one, we will invoke <code class="inline">PostController</code>'s <code class="inline">index</code> action, but we will pass in a <code class="inline">user_id</code>. This implies that we would display all the posts for that individual user only. The same scoping applies for all these routes.</p><p>When building paths for nested routes, we will need to interpolate the IDs where they belong in route definition. For the following <code class="inline">show</code> route, <code class="inline">42</code> is the <code class="inline">user_id</code>, and <code class="inline">17</code> is the <code class="inline">post_id</code>.</p><pre><code class="makeup elixir" translate="no"><span class="n">user_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="w">
</span><span class="n">post_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="w">
</span><span class="sx">~p&quot;/users/</span><span class="si" data-group-id="8583589520-1">#{</span><span class="n">user_id</span><span class="si" data-group-id="8583589520-1">}</span><span class="sx">/posts/</span><span class="si" data-group-id="8583589520-2">#{</span><span class="n">post_id</span><span class="si" data-group-id="8583589520-2">}</span><span class="sx">&quot;</span><span class="w">
</span><span class="s">&quot;/users/42/posts/17&quot;</span></code></pre><p>Verified routes also support the <a href="Phoenix.Param.xhtml"><code class="inline">Phoenix.Param</code></a> protocol, but we don't need to concern ourselves with Elixir protocols just yet. Just know that once we start building our application with structs like <code class="inline">%User{}</code> and <code class="inline">%Post{}</code>, we'll be able to interpolate those data structures directly into our <code class="inline">~p</code> paths and Phoenix will pluck out the correct fields to use in the route.</p><pre><code class="makeup elixir" translate="no"><span class="sx">~p&quot;/users/</span><span class="si" data-group-id="9416836000-1">#{</span><span class="n">user</span><span class="si" data-group-id="9416836000-1">}</span><span class="sx">/posts/</span><span class="si" data-group-id="9416836000-2">#{</span><span class="n">post</span><span class="si" data-group-id="9416836000-2">}</span><span class="sx">&quot;</span><span class="w">
</span><span class="s">&quot;/users/42/posts/17&quot;</span></code></pre><p>Notice how we didn't need to interpolate <code class="inline">user.id</code> or <code class="inline">post.id</code>? This is particularly nice if we decide later we want to make our URLs a little nicer and start using slugs instead. We don't need to change any of our <code class="inline">~p</code>'s!</p><h2 id="scoped-routes" class="section-heading">
  <a href="#scoped-routes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Scoped routes</span>
</h2>
<p>Scopes are a way to group routes under a common path prefix and scoped set of plugs. We might want to do this for admin functionality, APIs, and especially for versioned APIs. Let's say we have user-generated reviews on a site, and that those reviews first need to be approved by an administrator. The semantics of these resources are quite different, and they might not share the same controller. Scopes enable us to segregate these routes.</p><p>The paths to the user-facing reviews would look like a standard resource.</p><pre><code class="makeup console" translate="no"><span class="">/reviews
</span><span class="">/reviews/1234
</span><span class="">/reviews/1234/edit
</span><span class="">...
</span></code></pre><p>The administration review paths can be prefixed with <code class="inline">/admin</code>.</p><pre><code class="makeup console" translate="no"><span class="">/admin/reviews
</span><span class="">/admin/reviews/1234
</span><span class="">/admin/reviews/1234/edit
</span><span class="">...
</span></code></pre><p>We accomplish this with a scoped route that sets a path option to <code class="inline">/admin</code> like this one. We can nest this scope inside another scope, but instead, let's set it by itself at the root, by adding to <code class="inline">lib/hello_web/router.ex</code> the following:</p><pre><code class="makeup elixir" translate="no"><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/admin&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb.Admin</span><span class="w"> </span><span class="k" data-group-id="8806516781-1">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

  </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">ReviewController</span><span class="w">
</span><span class="k" data-group-id="8806516781-1">end</span></code></pre><p>We define a new scope where all routes are prefixed with <code class="inline">/admin</code> and all controllers are under the <code class="inline">HelloWeb.Admin</code> namespace.</p><p>Running <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a> again, in addition to the previous set of routes we get the following:</p><pre><code class="makeup console" translate="no"><span class="">...
</span><span class="">GET     /admin/reviews           HelloWeb.Admin.ReviewController :index
</span><span class="">GET     /admin/reviews/:id/edit  HelloWeb.Admin.ReviewController :edit
</span><span class="">GET     /admin/reviews/new       HelloWeb.Admin.ReviewController :new
</span><span class="">GET     /admin/reviews/:id       HelloWeb.Admin.ReviewController :show
</span><span class="">POST    /admin/reviews           HelloWeb.Admin.ReviewController :create
</span><span class="">PATCH   /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
</span><span class="">PUT     /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
</span><span class="">DELETE  /admin/reviews/:id       HelloWeb.Admin.ReviewController :delete
</span><span class="">...
</span></code></pre><p>This looks good, but there is a problem here. Remember that we wanted both user-facing review routes <code class="inline">/reviews</code> and the admin ones <code class="inline">/admin/reviews</code>. If we now include the user-facing reviews in our router under the root scope like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="1640763576-1">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

  </span><span class="n">...</span><span class="w">
  </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">ReviewController</span><span class="w">
</span><span class="k" data-group-id="1640763576-1">end</span><span class="w">

</span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/admin&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb.Admin</span><span class="w"> </span><span class="k" data-group-id="1640763576-2">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

  </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">ReviewController</span><span class="w">
</span><span class="k" data-group-id="1640763576-2">end</span></code></pre><p>and we run <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a>, we get output for each scoped route:</p><pre><code class="makeup console" translate="no"><span class="">...
</span><span class="">GET     /reviews                 HelloWeb.ReviewController :index
</span><span class="">GET     /reviews/:id/edit        HelloWeb.ReviewController :edit
</span><span class="">GET     /reviews/new             HelloWeb.ReviewController :new
</span><span class="">GET     /reviews/:id             HelloWeb.ReviewController :show
</span><span class="">POST    /reviews                 HelloWeb.ReviewController :create
</span><span class="">PATCH   /reviews/:id             HelloWeb.ReviewController :update
</span><span class="">PUT     /reviews/:id             HelloWeb.ReviewController :update
</span><span class="">DELETE  /reviews/:id             HelloWeb.ReviewController :delete
</span><span class="">...
</span><span class="">GET     /admin/reviews           HelloWeb.Admin.ReviewController :index
</span><span class="">GET     /admin/reviews/:id/edit  HelloWeb.Admin.ReviewController :edit
</span><span class="">GET     /admin/reviews/new       HelloWeb.Admin.ReviewController :new
</span><span class="">GET     /admin/reviews/:id       HelloWeb.Admin.ReviewController :show
</span><span class="">POST    /admin/reviews           HelloWeb.Admin.ReviewController :create
</span><span class="">PATCH   /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
</span><span class="">PUT     /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
</span><span class="">DELETE  /admin/reviews/:id       HelloWeb.Admin.ReviewController :delete
</span></code></pre><p>What if we had a number of resources that were all handled by admins? We could put all of them inside the same scope like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/admin&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb.Admin</span><span class="w"> </span><span class="k" data-group-id="5631247133-1">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

  </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/images&quot;</span><span class="p">,</span><span class="w">  </span><span class="nc">ImageController</span><span class="w">
  </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">ReviewController</span><span class="w">
  </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/users&quot;</span><span class="p">,</span><span class="w">   </span><span class="nc">UserController</span><span class="w">
</span><span class="k" data-group-id="5631247133-1">end</span></code></pre><p>Here's what <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a> tells us:</p><pre><code class="makeup console" translate="no"><span class="">...
</span><span class="">GET     /admin/images            HelloWeb.Admin.ImageController :index
</span><span class="">GET     /admin/images/:id/edit   HelloWeb.Admin.ImageController :edit
</span><span class="">GET     /admin/images/new        HelloWeb.Admin.ImageController :new
</span><span class="">GET     /admin/images/:id        HelloWeb.Admin.ImageController :show
</span><span class="">POST    /admin/images            HelloWeb.Admin.ImageController :create
</span><span class="">PATCH   /admin/images/:id        HelloWeb.Admin.ImageController :update
</span><span class="">PUT     /admin/images/:id        HelloWeb.Admin.ImageController :update
</span><span class="">DELETE  /admin/images/:id        HelloWeb.Admin.ImageController :delete
</span><span class="">GET     /admin/reviews           HelloWeb.Admin.ReviewController :index
</span><span class="">GET     /admin/reviews/:id/edit  HelloWeb.Admin.ReviewController :edit
</span><span class="">GET     /admin/reviews/new       HelloWeb.Admin.ReviewController :new
</span><span class="">GET     /admin/reviews/:id       HelloWeb.Admin.ReviewController :show
</span><span class="">POST    /admin/reviews           HelloWeb.Admin.ReviewController :create
</span><span class="">PATCH   /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
</span><span class="">PUT     /admin/reviews/:id       HelloWeb.Admin.ReviewController :update
</span><span class="">DELETE  /admin/reviews/:id       HelloWeb.Admin.ReviewController :delete
</span><span class="">GET     /admin/users             HelloWeb.Admin.UserController :index
</span><span class="">GET     /admin/users/:id/edit    HelloWeb.Admin.UserController :edit
</span><span class="">GET     /admin/users/new         HelloWeb.Admin.UserController :new
</span><span class="">GET     /admin/users/:id         HelloWeb.Admin.UserController :show
</span><span class="">POST    /admin/users             HelloWeb.Admin.UserController :create
</span><span class="">PATCH   /admin/users/:id         HelloWeb.Admin.UserController :update
</span><span class="">PUT     /admin/users/:id         HelloWeb.Admin.UserController :update
</span><span class="">DELETE  /admin/users/:id         HelloWeb.Admin.UserController :delete
</span></code></pre><p>This is great, exactly what we want. Note how every route and controller is properly namespaced.</p><p>Scopes can also be arbitrarily nested, but you should do it carefully as nesting can sometimes make our code confusing and less clear. With that said, suppose that we had a versioned API with resources defined for images, reviews, and users. Then technically, we could set up routes for the versioned API like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/api&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb.Api</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="ss">:api</span><span class="w"> </span><span class="k" data-group-id="3958850112-1">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:api</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/v1&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">V1</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="ss">:v1</span><span class="w"> </span><span class="k" data-group-id="3958850112-2">do</span><span class="w">
    </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/images&quot;</span><span class="p">,</span><span class="w">  </span><span class="nc">ImageController</span><span class="w">
    </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">ReviewController</span><span class="w">
    </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/users&quot;</span><span class="p">,</span><span class="w">   </span><span class="nc">UserController</span><span class="w">
  </span><span class="k" data-group-id="3958850112-2">end</span><span class="w">
</span><span class="k" data-group-id="3958850112-1">end</span></code></pre><p>You can run <a href="Mix.Tasks.Phx.Routes.xhtml"><code class="inline">mix phx.routes</code></a> to see how these definitions will look like.</p><p>Interestingly, we can use multiple scopes with the same path as long as we are careful not to duplicate routes. The following router is perfectly fine with two scopes defined for the same path:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="k" data-group-id="1923527092-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Phoenix.Router</span><span class="w">
  </span><span class="n">...</span><span class="w">
  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="1923527092-2">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

    </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/users&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">UserController</span><span class="w">
  </span><span class="k" data-group-id="1923527092-2">end</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">AnotherAppWeb</span><span class="w"> </span><span class="k" data-group-id="1923527092-3">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

    </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/posts&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PostController</span><span class="w">
  </span><span class="k" data-group-id="1923527092-3">end</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="1923527092-1">end</span></code></pre><p>If we do duplicate a route — which means two routes having the same path — we'll get this familiar warning:</p><pre><code class="makeup console" translate="no"><span class="">warning: this clause cannot match because a previous clause at line 16 always matches
</span></code></pre><h2 id="pipelines" class="section-heading">
  <a href="#pipelines" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Pipelines</span>
</h2>
<p>We have come quite a long way in this guide without talking about one of the first lines we saw in the router: <code class="inline">pipe_through :browser</code>. It's time to fix that.</p><p>Pipelines are a series of plugs that can be attached to specific scopes. If you are not familiar with plugs, we have an <a href="plug.html">in-depth guide about them</a>.</p><p>Routes are defined inside scopes and scopes may pipe through multiple pipelines. Once a route matches, Phoenix invokes all plugs defined in all pipelines associated to that route. For example, accessing <code class="inline">/</code> will pipe through the <code class="inline">:browser</code> pipeline, consequently invoking all of its plugs.</p><p>Phoenix defines two pipelines by default, <code class="inline">:browser</code> and <code class="inline">:api</code>, which can be used for a number of common tasks. In turn we can customize them as well as create new pipelines to meet our needs.</p><h3 id="the-browser-and-api-pipelines" class="section-heading">
  <a href="#the-browser-and-api-pipelines" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">The <code class="inline">:browser</code> and <code class="inline">:api</code> pipelines</span>
</h3>
<p>As their names suggest, the <code class="inline">:browser</code> pipeline prepares for routes which render requests for a browser, and the <code class="inline">:api</code> pipeline prepares for routes which produce data for an API.</p><p>The <code class="inline">:browser</code> pipeline has six plugs: The <code class="inline">plug :accepts, [&quot;html&quot;]</code> defines the accepted request format or formats. <code class="inline">:fetch_session</code>, which, naturally, fetches the session data and makes it available in the connection. <code class="inline">:fetch_live_flash</code>, which fetches any flash messages from LiveView and merges them with the controller flash messages. Then, the plug <code class="inline">:put_root_layout</code> will store the root layout for rendering purposes. Later <code class="inline">:protect_from_forgery</code> and <code class="inline">:put_secure_browser_headers</code>, protects form posts from cross-site forgery.</p><p>Currently, the <code class="inline">:api</code> pipeline only defines <code class="inline">plug :accepts, [&quot;json&quot;]</code>.</p><p>The router invokes a pipeline on a route defined within a scope. Routes outside of a scope have no pipelines. Although the use of nested scopes is discouraged (see above the versioned API example), if we call <code class="inline">pipe_through</code> within a nested scope, the router will invoke all <code class="inline">pipe_through</code>'s from parent scopes, followed by the nested one.</p><p>Those are a lot of words bunched up together. Let's take a look at some examples to untangle their meaning.</p><p>Here's another look at the router from a newly generated Phoenix application, this time with the <code class="inline">/api</code> scope uncommented back in and a route added.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="k" data-group-id="9892380617-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:router</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:browser</span><span class="w"> </span><span class="k" data-group-id="9892380617-2">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:accepts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9892380617-3">[</span><span class="s">&quot;html&quot;</span><span class="p" data-group-id="9892380617-3">]</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_session</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_live_flash</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_root_layout</span><span class="p">,</span><span class="w"> </span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9892380617-4">{</span><span class="nc">HelloWeb.Layouts</span><span class="p">,</span><span class="w"> </span><span class="ss">:root</span><span class="p" data-group-id="9892380617-4">}</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:protect_from_forgery</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_secure_browser_headers</span><span class="w">
  </span><span class="k" data-group-id="9892380617-2">end</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:api</span><span class="w"> </span><span class="k" data-group-id="9892380617-5">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:accepts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9892380617-6">[</span><span class="s">&quot;json&quot;</span><span class="p" data-group-id="9892380617-6">]</span><span class="w">
  </span><span class="k" data-group-id="9892380617-5">end</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="9892380617-7">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:browser</span><span class="w">

    </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PageController</span><span class="p">,</span><span class="w"> </span><span class="ss">:home</span><span class="w">
  </span><span class="k" data-group-id="9892380617-7">end</span><span class="w">

  </span><span class="c1"># Other scopes may use custom stacks.</span><span class="w">
  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/api&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="9892380617-8">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:api</span><span class="w">

    </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">ReviewController</span><span class="w">
  </span><span class="k" data-group-id="9892380617-8">end</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="9892380617-1">end</span></code></pre><p>When the server accepts a request, the request will always first pass through the plugs in our endpoint, after which it will attempt to match on the path and HTTP verb.</p><p>Let's say that the request matches our first route: a GET to <code class="inline">/</code>. The router will first pipe that request through the <code class="inline">:browser</code> pipeline - which will fetch the session data, fetch the flash, and execute forgery protection - before it dispatches the request to <code class="inline">PageController</code>'s <code class="inline">home</code> action.</p><p>Conversely, suppose the request matches any of the routes defined by the <a href="Phoenix.Router.xhtml#resources/2"><code class="inline">resources/2</code></a> macro. In that case, the router will pipe it through the <code class="inline">:api</code> pipeline — which currently only performs content negotiation — before it dispatches further to the correct action of the <code class="inline">HelloWeb.ReviewController</code>.</p><p>If no route matches, no pipeline is invoked and a 404 error is raised.</p><h3 id="creating-new-pipelines" class="section-heading">
  <a href="#creating-new-pipelines" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Creating new pipelines</span>
</h3>
<p>Phoenix allows us to create our own custom pipelines anywhere in the router. To do so, we call the <a href="Phoenix.Router.xhtml#pipeline/2"><code class="inline">pipeline/2</code></a> macro with these arguments: an atom for the name of our new pipeline and a block with all the plugs we want in it.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="k" data-group-id="9300062553-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:router</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:browser</span><span class="w"> </span><span class="k" data-group-id="9300062553-2">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:accepts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9300062553-3">[</span><span class="s">&quot;html&quot;</span><span class="p" data-group-id="9300062553-3">]</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_session</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:fetch_live_flash</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_root_layout</span><span class="p">,</span><span class="w"> </span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9300062553-4">{</span><span class="nc">HelloWeb.Layouts</span><span class="p">,</span><span class="w"> </span><span class="ss">:root</span><span class="p" data-group-id="9300062553-4">}</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:protect_from_forgery</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:put_secure_browser_headers</span><span class="w">
  </span><span class="k" data-group-id="9300062553-2">end</span><span class="w">

  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:auth</span><span class="w"> </span><span class="k" data-group-id="9300062553-5">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="nc">HelloWeb.Authentication</span><span class="w">
  </span><span class="k" data-group-id="9300062553-5">end</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="9300062553-6">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="p" data-group-id="9300062553-7">[</span><span class="ss">:browser</span><span class="p">,</span><span class="w"> </span><span class="ss">:auth</span><span class="p" data-group-id="9300062553-7">]</span><span class="w">

    </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">ReviewController</span><span class="w">
  </span><span class="k" data-group-id="9300062553-6">end</span><span class="w">
</span><span class="k" data-group-id="9300062553-1">end</span></code></pre><p>The above assumes there is a plug called <code class="inline">HelloWeb.Authentication</code> that performs authentication and is now part of the <code class="inline">:auth</code> pipeline.</p><p>Note that pipelines themselves are plugs, so we can plug a pipeline inside another pipeline. For example, we could rewrite the <code class="inline">auth</code> pipeline above to automatically invoke <code class="inline">browser</code>, simplifying the downstream pipeline call:</p><pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:auth</span><span class="w"> </span><span class="k" data-group-id="2555258841-1">do</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:browser</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:ensure_authenticated_user</span><span class="w">
    </span><span class="n">plug</span><span class="w"> </span><span class="ss">:ensure_user_owns_review</span><span class="w">
  </span><span class="k" data-group-id="2555258841-1">end</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="2555258841-2">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="ss">:auth</span><span class="w">

    </span><span class="n">resources</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">ReviewController</span><span class="w">
  </span><span class="k" data-group-id="2555258841-2">end</span></code></pre><h2 id="how-to-organize-my-routes" class="section-heading">
  <a href="#how-to-organize-my-routes" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">How to organize my routes?</span>
</h2>
<p>In Phoenix, we tend to define several pipelines, that provide specific functionality. For example, the <code class="inline">:browser</code> and <code class="inline">:api</code> pipelines are meant to be accessed by specific clients, browsers and http clients respectively.</p><p>Perhaps more importantly, it is also very common to define pipelines specific to authentication and authorization. For example, you might have a pipeline that requires all users are authenticated. Another pipeline may enforce only admin users can access certain routes.</p><p>Once your pipelines are defined, you reuse the pipelines in the desired scopes, grouping your routes around their pipelines. For example, going back to our reviews example. Let's say anyone can read a review, but only authenticated users can create them. Your routes could look like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">pipeline</span><span class="w"> </span><span class="ss">:browser</span><span class="w"> </span><span class="k" data-group-id="5284575111-1">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="5284575111-1">end</span><span class="w">

</span><span class="n">pipeline</span><span class="w"> </span><span class="ss">:auth</span><span class="w"> </span><span class="k" data-group-id="5284575111-2">do</span><span class="w">
  </span><span class="n">plug</span><span class="w"> </span><span class="nc">HelloWeb.Authentication</span><span class="w">
</span><span class="k" data-group-id="5284575111-2">end</span><span class="w">

</span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="k" data-group-id="5284575111-3">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="p" data-group-id="5284575111-4">[</span><span class="ss">:browser</span><span class="p" data-group-id="5284575111-4">]</span><span class="w">

  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PostController</span><span class="p">,</span><span class="w"> </span><span class="ss">:index</span><span class="w">
  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/reviews/:id&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PostController</span><span class="p">,</span><span class="w"> </span><span class="ss">:show</span><span class="w">
</span><span class="k" data-group-id="5284575111-3">end</span><span class="w">

</span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="k" data-group-id="5284575111-5">do</span><span class="w">
  </span><span class="n">pipe_through</span><span class="w"> </span><span class="p" data-group-id="5284575111-6">[</span><span class="ss">:browser</span><span class="p">,</span><span class="w"> </span><span class="ss">:auth</span><span class="p" data-group-id="5284575111-6">]</span><span class="w">

  </span><span class="n">get</span><span class="w"> </span><span class="s">&quot;/reviews/new&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PostController</span><span class="p">,</span><span class="w"> </span><span class="ss">:new</span><span class="w">
  </span><span class="n">post</span><span class="w"> </span><span class="s">&quot;/reviews&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">PostController</span><span class="p">,</span><span class="w"> </span><span class="ss">:create</span><span class="w">
</span><span class="k" data-group-id="5284575111-5">end</span></code></pre><p>Note in the above how the routes are split across different scopes. While the separation can be confusing at first, it has one big upside: it is very easy to inspect your routes and see all routes that, for example, require authentication and which ones do not. This helps with auditing and making sure your routes have the proper scope.</p><p>You can create as few or as many scopes as you want. Because pipelines are reusable across scopes, they help encapsulate common functionality and you can compose them as necessary on each scope you define.</p><h2 id="forward" class="section-heading">
  <a href="#forward" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Forward</span>
</h2>
<p>The <a href="Phoenix.Router.xhtml#forward/4"><code class="inline">Phoenix.Router.forward/4</code></a> macro can be used to send all requests that start with a particular path to a particular plug. Let's say we have a part of our system that is responsible (it could even be a separate application or library) for running jobs in the background, it could have its own web interface for checking the status of the jobs. We can forward to this admin interface using:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="k" data-group-id="5124323890-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:router</span><span class="w">

  </span><span class="n">...</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="w"> </span><span class="k" data-group-id="5124323890-2">do</span><span class="w">
    </span><span class="n">...</span><span class="w">
  </span><span class="k" data-group-id="5124323890-2">end</span><span class="w">

  </span><span class="n">forward</span><span class="w"> </span><span class="s">&quot;/jobs&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">BackgroundJob.Plug</span><span class="w">
</span><span class="k" data-group-id="5124323890-1">end</span></code></pre><p>This means that all routes starting with <code class="inline">/jobs</code> will be sent to the <code class="inline">HelloWeb.BackgroundJob.Plug</code> module. Inside the plug, you can match on subroutes, such as <code class="inline">/pending</code> and <code class="inline">/active</code> that shows the status of certain jobs.</p><p>We can even mix the <a href="Phoenix.Router.xhtml#forward/4"><code class="inline">forward/4</code></a> macro with pipelines. If we wanted to ensure that the user was authenticated and was an administrator in order to see the jobs page, we could use the following in our router.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.Router</span><span class="w"> </span><span class="k" data-group-id="4211804966-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:router</span><span class="w">

  </span><span class="n">...</span><span class="w">

  </span><span class="n">scope</span><span class="w"> </span><span class="s">&quot;/&quot;</span><span class="w"> </span><span class="k" data-group-id="4211804966-2">do</span><span class="w">
    </span><span class="n">pipe_through</span><span class="w"> </span><span class="p" data-group-id="4211804966-3">[</span><span class="ss">:authenticate_user</span><span class="p">,</span><span class="w"> </span><span class="ss">:ensure_admin</span><span class="p" data-group-id="4211804966-3">]</span><span class="w">
    </span><span class="n">forward</span><span class="w"> </span><span class="s">&quot;/jobs&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">BackgroundJob.Plug</span><span class="w">
  </span><span class="k" data-group-id="4211804966-2">end</span><span class="w">
</span><span class="k" data-group-id="4211804966-1">end</span></code></pre><p>This means the plugs in the <code class="inline">authenticate_user</code> and <code class="inline">ensure_admin</code> pipelines will be called before the <code class="inline">BackgroundJob.Plug</code> allowing them to send an appropriate response and halt the request accordingly.</p><p>The <code class="inline">opts</code> that are received in the <code class="inline">init/1</code> callback of the Module Plug can be passed as a third argument. For example, maybe the background job lets you set the name of your application to be displayed on the page. This could be passed with:</p><pre><code class="makeup elixir" translate="no"><span class="n">forward</span><span class="w"> </span><span class="s">&quot;/jobs&quot;</span><span class="p">,</span><span class="w"> </span><span class="nc">BackgroundJob.Plug</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Hello Phoenix&quot;</span></code></pre><p>There is a fourth <code class="inline">router_opts</code> argument that can be passed. These options are outlined in the <a href="Phoenix.Router.xhtml#scope/2"><code class="inline">Phoenix.Router.scope/2</code></a> documentation.</p><p><code class="inline">BackgroundJob.Plug</code> can be implemented as any Module Plug discussed in the <a href="plug.html">Plug guide</a>. Note though it is not advised to forward to another Phoenix endpoint. This is because plugs defined by your app and the forwarded endpoint would be invoked twice, which may lead to errors.</p><h2 id="summary" class="section-heading">
  <a href="#summary" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Summary</span>
</h2>
<p>Routing is a big topic, and we have covered a lot of ground here. The important points to take away from this guide are:</p><ul><li>Routes which begin with an HTTP verb name expand to a single clause of the match function.</li><li>Routes declared with <code class="inline">resources</code> expand to 8 clauses of the match function.</li><li>Resources may restrict the number of match function clauses by using the <code class="inline">only:</code> or <code class="inline">except:</code> options.</li><li>Any of these routes may be nested.</li><li>Any of these routes may be scoped to a given path.</li><li>Using verified routes with <code class="inline">~p</code> for compile-time route checks</li></ul>

  </body>
</html>
