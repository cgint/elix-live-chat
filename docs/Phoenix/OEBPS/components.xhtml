<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Components and HEEx - Phoenix v1.7.21</title>
    <meta name="generator" content="ExDoc v0.37.3" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Components and HEEx
    </h1>
<blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="installation.html">introductory guides</a> and got a Phoenix application <a href="up_and_running.html">up and running</a>.</p></blockquote><blockquote><p><strong>Requirement</strong>: This guide expects that you have gone through the <a href="request_lifecycle.html">request life-cycle guide</a>.</p></blockquote><p>The Phoenix endpoint pipeline takes a request, routes it to a controller, and calls a view module to render a template. The view interface from the controller is simple â€“ the controller calls a view function with the connections assigns, and the function's job is to return a HEEx template. We call any function that accepts an <code class="inline">assigns</code> parameter and returns a HEEx template a <em>function component</em>. Function components are defined with the help of the <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html"><code class="inline">Phoenix.Component</code></a> module.</p><p>Function components are the essential building block for any kind of markup-based template rendering you'll perform in Phoenix. They serve as a shared abstraction for the standard MVC controller-based applications, LiveView applications, layouts, and smaller UI definitions you'll use throughout other templates.</p><p>In this chapter, we will recap how components were used in previous chapters and find new use cases for them.</p><h2 id="function-components" class="section-heading">
  <a href="#function-components" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Function components</span>
</h2>
<p>At the end of the Request life-cycle chapter, we created a template at <code class="inline">lib/hello_web/controllers/hello_html/show.html.heex</code>, let's open it up:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">section</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span><span class="n">Hello World, from </span><span class="p" data-group-id="4114945253-1">{</span><span class="na">@messenger</span><span class="p" data-group-id="4114945253-1">}</span><span class="n">!</span><span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span></code></pre><p>This template, is embedded as part of <code class="inline">HelloHTML</code>, at <code class="inline">lib/hello_web/controllers/hello_html.ex</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.HelloHTML</span><span class="w"> </span><span class="k" data-group-id="6593435130-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:html</span><span class="w">

  </span><span class="n">embed_templates</span><span class="w"> </span><span class="s">&quot;hello_html/*&quot;</span><span class="w">
</span><span class="k" data-group-id="6593435130-1">end</span></code></pre><p>That's simple enough. There's only two lines, <code class="inline">use HelloWeb, :html</code>. This line calls the <code class="inline">html/0</code> function defined in <code class="inline">HelloWeb</code> which sets up the basic imports and configuration for our function components and templates.</p><p>All of the imports and aliases we make in our module will also be available in our templates. That's because templates are effectively compiled into functions inside their respective module. For example, if you define a function in your module, you will be able to invoke it directly from the template. Let's see this in practice.</p><p>Imagine we want to refactor our <code class="inline">show.html.heex</code> to move the rendering of <code class="inline">&lt;h2&gt;Hello World, from {@messenger}!&lt;/h2&gt;</code> to its own function. We can move it to a function component inside <code class="inline">HelloHTML</code>, let's do so:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HelloWeb.HelloHTML</span><span class="w"> </span><span class="k" data-group-id="3452350189-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">HelloWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:html</span><span class="w">

  </span><span class="n">embed_templates</span><span class="w"> </span><span class="s">&quot;hello_html/*&quot;</span><span class="w">

  </span><span class="n">attr</span><span class="w"> </span><span class="ss">:messenger</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="ss">required</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">greet</span><span class="p" data-group-id="3452350189-2">(</span><span class="n">assigns</span><span class="p" data-group-id="3452350189-2">)</span><span class="w"> </span><span class="k" data-group-id="3452350189-3">do</span><span class="w">
    </span><span class="sx">~H&quot;&quot;&quot;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nt">h2</span><span class="p">&gt;</span><span class="n">Hello World, from </span><span class="p" data-group-id="9517177799-1">{</span><span class="na">@messenger</span><span class="p" data-group-id="9517177799-1">}</span><span class="n">!</span><span class="p">&lt;/</span><span class="nt">h2</span><span class="p">&gt;</span><span class="w">
</span><span class="w">    </span><span class="sx">&quot;&quot;&quot;</span><span class="w">
  </span><span class="k" data-group-id="3452350189-3">end</span><span class="w">
</span><span class="k" data-group-id="3452350189-1">end</span></code></pre><p>We declared the attributes we accept via the <code class="inline">attr/3</code> macro provided by <code class="inline">Phoenix.Component</code>, then we defined our <code class="inline">greet/1</code> function which returns the HEEx template.</p><p>Next we need to update <code class="inline">show.html.heex</code>:</p><pre><code class="makeup elixir" translate="no"><span class="o">&lt;</span><span class="n">section</span><span class="o">&gt;</span><span class="w">
  </span><span class="o">&lt;</span><span class="o">.</span><span class="n">greet</span><span class="w"> </span><span class="n">messenger</span><span class="o">=</span><span class="p" data-group-id="4095698936-1">{</span><span class="na">@messenger</span><span class="p" data-group-id="4095698936-1">}</span><span class="w"> </span><span class="o">/</span><span class="o">&gt;</span><span class="w">
</span><span class="o">&lt;</span><span class="o">/</span><span class="n">section</span><span class="o">&gt;</span></code></pre><p>When we reload <code class="inline">http://localhost:4000/hello/Frank</code>, we should see the same content as before.</p><p>Since templates are embedded inside the <code class="inline">HelloHTML</code> module, we were able to invoke the view function simply as <code class="inline">&lt;.greet messenger=&quot;...&quot; /&gt;</code>.</p><p>If the component was defined elsewhere, we can also type <code class="inline">&lt;HelloWeb.HelloHTML.greet messenger=&quot;...&quot; /&gt;</code>.</p><p>By declaring attributes as required, Phoenix will warn at compile time if we call the <code class="inline">&lt;.greet /&gt;</code> component without passing attributes. If an attribute is optional, you can specify the <code class="inline">:default</code> option with a value:</p><pre><code class="makeup elixir" translate="no"><span class="n">attr</span><span class="w"> </span><span class="ss">:messenger</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="ss">default</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span></code></pre><p>Although this is a quick example, it shows the different roles function components play in Phoenix:</p><ul><li><p>Function components can be defined as functions that receive <code class="inline">assigns</code> as argument and call the <code class="inline">~H</code> sigil, as we did in <code class="inline">greet/1</code></p></li><li><p>Function components can be embedded from template files, that's how we load <code class="inline">show.html.heex</code> into <code class="inline">HelloWeb.HelloHTML</code></p></li><li><p>Function components can declare which attributes are expected, which are validated at compilation time</p></li><li><p>Function components can be directly rendered from controllers</p></li><li><p>Function components can be directly rendered from other function components, as we called <code class="inline">&lt;.greet messenger={@messenger} /&gt;</code> from <code class="inline">show.html.heex</code></p></li></ul><p>And there's more. Before we go deeper, let's fully understand the expressive power behind the HEEx template language.</p><h2 id="heex" class="section-heading">
  <a href="#heex" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">HEEx</span>
</h2>
<p>Function components and templates files are powered by <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#sigil_H/2">the HEEx template language</a>, which stands for  &quot;HTML+EEx&quot;. EEx is an Elixir library that uses <code class="inline">&lt;%= expression %&gt;</code> to execute Elixir expressions and interpolate their results into arbitrary text templates. HEEx extends EEx for writing HTML templates mixed with Elixir interpolation. We can write Elixir code inside <code class="inline">{...}</code> for HTML-aware interpolation inside tag attributes and the body. We can also interpolate arbitrary HEEx blocks using EEx interpolation (<code class="inline">&lt;%= ... %&gt;</code>). We use <code class="inline">@name</code> to access the key <code class="inline">name</code> defined inside <code class="inline">assigns</code>.</p><p>This is frequently used to display assigns we have set by way of the <code class="inline">@</code> shortcut. In your controller, if you invoke:</p><pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="n">render</span><span class="p" data-group-id="9375803145-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="ss">:show</span><span class="p">,</span><span class="w"> </span><span class="ss">username</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;joe&quot;</span><span class="p" data-group-id="9375803145-1">)</span></code></pre><p>Then you can access said username in the templates as <code class="inline">{@username}</code>. In addition to displaying assigns and functions, we can use pretty much any Elixir expression. For example, in order to have conditionals:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="2128277269-1">&lt;%=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">some_condition?</span><span class="w"> </span><span class="k" data-group-id="2128277269-ex-1">do</span><span class="w"> </span><span class="p" data-group-id="2128277269-1">%&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="n">Some condition is true for user: </span><span class="p" data-group-id="2128277269-2">{</span><span class="na">@username</span><span class="p" data-group-id="2128277269-2">}</span><span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span><span class="w">
</span><span class="p" data-group-id="2128277269-3">&lt;%</span><span class="w"> </span><span class="k" data-group-id="2128277269-ex-1">else</span><span class="w"> </span><span class="p" data-group-id="2128277269-3">%&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="n">Some condition is false for user: </span><span class="p" data-group-id="2128277269-4">{</span><span class="na">@username</span><span class="p" data-group-id="2128277269-4">}</span><span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span><span class="w">
</span><span class="p" data-group-id="2128277269-5">&lt;%</span><span class="w"> </span><span class="k" data-group-id="2128277269-ex-1">end</span><span class="w"> </span><span class="p" data-group-id="2128277269-5">%&gt;</span></code></pre><p>or even loops:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">table</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">tr</span><span class="p">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nt">th</span><span class="p">&gt;</span><span class="n">Number</span><span class="p">&lt;/</span><span class="nt">th</span><span class="p">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nt">th</span><span class="p">&gt;</span><span class="n">Power</span><span class="p">&lt;/</span><span class="nt">th</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;/</span><span class="nt">tr</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p" data-group-id="1581628779-1">&lt;%=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="w"> </span><span class="k" data-group-id="1581628779-ex-1">do</span><span class="w"> </span><span class="p" data-group-id="1581628779-1">%&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nt">tr</span><span class="p">&gt;</span><span class="w">
</span><span class="w">      </span><span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span><span class="p" data-group-id="1581628779-2">{</span><span class="n">number</span><span class="p" data-group-id="1581628779-2">}</span><span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span><span class="w">
</span><span class="w">      </span><span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span><span class="p" data-group-id="1581628779-3">{</span><span class="n">number</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">number</span><span class="p" data-group-id="1581628779-3">}</span><span class="p">&lt;/</span><span class="nt">td</span><span class="p">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;/</span><span class="nt">tr</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p" data-group-id="1581628779-4">&lt;%</span><span class="w"> </span><span class="k" data-group-id="1581628779-ex-1">end</span><span class="w"> </span><span class="p" data-group-id="1581628779-4">%&gt;</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">table</span><span class="p">&gt;</span></code></pre><p>Did you notice the use of <code class="inline">&lt;%= %&gt;</code> versus <code class="inline">&lt;% %&gt;</code> above? All expressions that output something to the template <strong>must</strong> use the equals sign (<code class="inline">=</code>). If this is not included the code will still be executed but nothing will be inserted into the template.</p><p>HEEx also comes with handy HTML extensions we will learn next.</p><h3 id="html-extensions" class="section-heading">
  <a href="#html-extensions" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">HTML extensions</span>
</h3>
<p>Besides allowing interpolation of Elixir expressions via <code class="inline">&lt;%= %&gt;</code>, <code class="inline">.heex</code> templates come with HTML-aware extensions. For example, let's see what happens if you try to interpolate a value with &quot;&lt;&quot; or &quot;&gt;&quot; in it, which would lead to HTML injection:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="5181934187-1">{</span><span class="s">&quot;&lt;b&gt;Bold?&lt;/b&gt;&quot;</span><span class="p" data-group-id="5181934187-1">}</span></code></pre><p>Once you render the template, you will see the literal <code class="inline">&lt;b&gt;</code> on the page. This means users cannot inject HTML content on the page. If you want to allow them to do so, you can call <code class="inline">raw</code>, but do so with extreme care:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="6543519215-1">{</span><span class="n">raw</span><span class="w"> </span><span class="s">&quot;&lt;b&gt;Bold?&lt;/b&gt;&quot;</span><span class="p" data-group-id="6543519215-1">}</span></code></pre><p>Another super power of HEEx templates is validation of HTML and interpolation syntax of attributes. You can write:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="ni">title</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">My div</span><span class="p">&quot;</span><span class="w"> </span><span class="ni">class</span><span class="p">=</span><span class="p" data-group-id="3714500522-1">{</span><span class="na">@class</span><span class="p" data-group-id="3714500522-1">}</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="n">Hello </span><span class="p" data-group-id="3714500522-2">{</span><span class="na">@username</span><span class="p" data-group-id="3714500522-2">}</span><span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span></code></pre><p>Notice how you could simply use <code class="inline">key={value}</code>. HEEx will automatically handle special values such as <code class="inline">false</code> to remove the attribute or a list of classes.</p><p>To interpolate a dynamic number of attributes in a keyword list or map, do:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="ni">title</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">My div</span><span class="p">&quot;</span><span class="w"> </span><span class="p" data-group-id="5872188440-1">{</span><span class="na">@many_attributes</span><span class="p" data-group-id="5872188440-1">}</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="n">Hello </span><span class="p" data-group-id="5872188440-2">{</span><span class="na">@username</span><span class="p" data-group-id="5872188440-2">}</span><span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span></code></pre><p>Also, try removing the closing <code class="inline">&lt;/div&gt;</code> or renaming it to <code class="inline">&lt;/div-typo&gt;</code>. HEEx templates will let you know about your error.</p><p>HEEx also supports shorthand syntax for <code class="inline">if</code> and <code class="inline">for</code> expressions via the special <code class="inline">:if</code> and <code class="inline">:for</code> attributes. For example, rather than this:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="4735871190-1">&lt;%=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="na">@some_condition</span><span class="w"> </span><span class="k" data-group-id="4735871190-ex-1">do</span><span class="w"> </span><span class="p" data-group-id="4735871190-1">%&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="n">...</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span><span class="w">
</span><span class="p" data-group-id="4735871190-2">&lt;%</span><span class="w"> </span><span class="k" data-group-id="4735871190-ex-1">end</span><span class="w"> </span><span class="p" data-group-id="4735871190-2">%&gt;</span></code></pre><p>You can write:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="ni">:if</span><span class="p">=</span><span class="p" data-group-id="6170000299-1">{</span><span class="na">@some_condition</span><span class="p" data-group-id="6170000299-1">}</span><span class="p">&gt;</span><span class="n">...</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span></code></pre><p>Likewise, for comprehensions may be written as:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">li</span><span class="w"> </span><span class="ni">:for</span><span class="p">=</span><span class="p" data-group-id="1688999159-1">{</span><span class="n">item</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="na">@items</span><span class="p" data-group-id="1688999159-1">}</span><span class="p">&gt;</span><span class="p" data-group-id="1688999159-2">{</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="p" data-group-id="1688999159-2">}</span><span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span></code></pre><h2 id="layouts" class="section-heading">
  <a href="#layouts" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">Layouts</span>
</h2>
<p>Layouts are just function components. They are defined in a module, just like all other function component templates. In a newly generated app, this is <code class="inline">lib/hello_web/components/layouts.ex</code>. You will also find a <code class="inline">layouts</code> folder with two built-in layouts generated by Phoenix. The default <em>root layout</em> is called <code class="inline">root.html.heex</code>, and it is the layout into which all templates will be rendered by default. The second is the <em>app layout</em>, called <code class="inline">app.html.heex</code>, which is rendered within the root layout and includes our contents.</p><p>You may be wondering how the string resulting from a rendered view ends up inside a layout. That's a great question! If we look at <code class="inline">lib/hello_web/components/layouts/root.html.heex</code>, just about at the end of the <code class="inline">&lt;body&gt;</code>, we will see this.</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="7640836933-1">{</span><span class="na">@inner_content</span><span class="p" data-group-id="7640836933-1">}</span></code></pre><p>In other words, after rendering your page, the result is placed in the <code class="inline">@inner_content</code> assign.</p><p>Phoenix provides all kinds of conveniences to control which layout should be rendered. For example, the <a href="Phoenix.Controller.xhtml"><code class="inline">Phoenix.Controller</code></a> module provides the <code class="inline">put_root_layout/2</code> function for us to switch <em>root layouts</em>. This takes <code class="inline">conn</code> as its first argument and a keyword list of formats and their layouts. You can set it to <code class="inline">false</code> to disable the layout altogether.</p><p>You can edit the <code class="inline">index</code> action of <code class="inline">HelloController</code> in <code class="inline">lib/hello_web/controllers/hello_controller.ex</code> to look like this.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">index</span><span class="p" data-group-id="9815459170-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="9815459170-1">)</span><span class="w"> </span><span class="k" data-group-id="9815459170-2">do</span><span class="w">
  </span><span class="n">conn</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">put_root_layout</span><span class="p" data-group-id="9815459170-3">(</span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="9815459170-3">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">render</span><span class="p" data-group-id="9815459170-4">(</span><span class="ss">:index</span><span class="p" data-group-id="9815459170-4">)</span><span class="w">
</span><span class="k" data-group-id="9815459170-2">end</span></code></pre><p>After reloading <a href="http://localhost:4000/hello">http://localhost:4000/hello</a>, we should see a very different page, one with no title or CSS styling at all.</p><p>To customize the application layout, we invoke a similar function named <code class="inline">put_layout/2</code>. Let's actually create another layout and render the index template into it. As an example, let's say we had a different layout for the admin section of our application which didn't have the logo image. To do this, copy the existing <code class="inline">app.html.heex</code> to a new file <code class="inline">admin.html.heex</code> in the same directory <code class="inline">lib/hello_web/components/layouts</code>. Then remove everything inside the <code class="inline">&lt;header&gt;...&lt;/header&gt;</code> tags (or change it to whatever you desire) in the new file.</p><p>Now, in the <code class="inline">index</code> action of the controller of <code class="inline">lib/hello_web/controllers/hello_controller.ex</code>, add the following:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">index</span><span class="p" data-group-id="4611229914-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_params</span><span class="p" data-group-id="4611229914-1">)</span><span class="w"> </span><span class="k" data-group-id="4611229914-2">do</span><span class="w">
  </span><span class="n">conn</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">put_layout</span><span class="p" data-group-id="4611229914-3">(</span><span class="ss">html</span><span class="p">:</span><span class="w"> </span><span class="ss">:admin</span><span class="p" data-group-id="4611229914-3">)</span><span class="w">
  </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">render</span><span class="p" data-group-id="4611229914-4">(</span><span class="ss">:index</span><span class="p" data-group-id="4611229914-4">)</span><span class="w">
</span><span class="k" data-group-id="4611229914-2">end</span></code></pre><p>When we load the page, we should be rendering the admin layout without the header (or a custom one that you wrote).</p><p>At this point, you may be wondering, why does Phoenix have two layouts?</p><p>First of all, it gives us flexibility. In practice, we will hardly have multiple root layouts, as they often contain only HTML headers. This allows us to focus on different application layouts with only the parts that changes between them. Second of all, Phoenix ships with a feature called LiveView, which allows us to build rich and real-time user experiences with server-rendered HTML. LiveView is capable of dynamically changing the contents of the page, but it only ever changes the app layout, never the root layout. Check out <a href="https://hexdocs.pm/phoenix_live_view">the LiveView documentation</a> to learn more.</p><h2 id="corecomponents" class="section-heading">
  <a href="#corecomponents" class="hover-link">
    <i class="ri-link-m" aria-hidden="true"></i>
  </a>
  <span class="text">CoreComponents</span>
</h2>
<p>In a new Phoenix application, you will also find a <code class="inline">core_components.ex</code> module inside the <code class="inline">components</code> folder. This module is a great example of defining function components to be reused throughout our application. This guarantees that, as our application evolves, our components will look consistent.</p><p>If you look inside <code class="inline">def html</code> in <code class="inline">HelloWeb</code> placed at <code class="inline">lib/hello_web.ex</code>, you will see that <code class="inline">CoreComponents</code> are automatically imported into all HTML views via <code class="inline">use HelloWeb, :html</code>. This is also the reason why <code class="inline">CoreComponents</code> itself performs <code class="inline">use Phoenix.Component</code> instead <code class="inline">use HelloWeb, :html</code> at the top: doing the latter would cause a deadlock as we would try to import <code class="inline">CoreComponents</code> into itself.</p><p>CoreComponents also play an important role in Phoenix code generators, as the code generators assume those components are available in order to quickly scaffold your application. In case you want to learn more about all of these pieces, you may:</p><ul><li><p>Explore the generated <code class="inline">CoreComponents</code> module to learn more from practical examples</p></li><li><p>Read the official documentation for <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html"><code class="inline">Phoenix.Component</code></a></p></li><li><p>Read the official documentation for <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#sigil_H/2">HEEx and the ~H sigils</a></p></li></ul>

  </body>
</html>
