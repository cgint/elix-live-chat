# Directory Structure
_Includes files where the actual content might be omitted. This way the LLM can still use the file structure to understand the project._
```
.
└── lib
    ├── mix
    │   └── tasks
    │       ├── cancel_subscription.ex
    │       ├── clean_clickhouse.ex
    │       ├── create_free_subscription.ex
    │       ├── create_paddle_prod_plans.ex
    │       ├── create_paddle_sandbox_plans.ex
    │       ├── download_country_database.ex
    │       ├── generate_referrer_favicons.ex
    │       ├── pull_sandbox_subscription.ex
    │       └── send_pageview.ex
    ├── oban_error_reporter.ex
    ├── plausible
    │   ├── application.ex
    │   ├── async_insert_repo.ex
    │   ├── audit
    │   │   └── repo.ex
    │   ├── auth
    │   │   ├── api_key.ex
    │   │   ├── auth.ex
    │   │   ├── email_activation_code.ex
    │   │   ├── email_verification.ex
    │   │   ├── password.ex
    │   │   ├── token.ex
    │   │   ├── totp
    │   │   │   ├── encrypted_binary.ex
    │   │   │   ├── recovery_code.ex
    │   │   │   └── vault.ex
    │   │   ├── totp.ex
    │   │   ├── user.ex
    │   │   ├── user_session.ex
    │   │   └── user_sessions.ex
    │   ├── billing
    │   │   ├── billing.ex
    │   │   ├── ecto
    │   │   │   ├── feature.ex
    │   │   │   └── limit.ex
    │   │   ├── enterprise_plan.ex
    │   │   ├── feature.ex
    │   │   ├── paddle_api.ex
    │   │   ├── plan.ex
    │   │   ├── plan_benefits.ex
    │   │   ├── plans.ex
    │   │   ├── qouta
    │   │   │   ├── limits.ex
    │   │   │   └── quota.ex
    │   │   ├── site_locker.ex
    │   │   ├── subscription
    │   │   │   └── status.ex
    │   │   ├── subscription.ex
    │   │   └── subscriptions.ex
    │   ├── cache
    │   │   ├── adapter.ex
    │   │   └── warmer.ex
    │   ├── cache.ex
    │   ├── cldr.ex
    │   ├── clickhouse_event_v2.ex
    │   ├── clickhouse_location_data.ex
    │   ├── clickhouse_repo.ex
    │   ├── clickhouse_session_v2.ex
    │   ├── data_migration
    │   │   ├── acquisition_channel.ex
    │   │   ├── backfill_teams.ex
    │   │   ├── backfill_teams_hourly_api_request_limit.ex
    │   │   ├── backfill_tracker_script_configuration.ex
    │   │   ├── clean_up_demo_site_referrer_source.ex
    │   │   ├── clickhouse_repo.ex
    │   │   ├── locations_sync.ex
    │   │   ├── numeric_ids.ex
    │   │   ├── populate_event_session_columns.ex
    │   │   ├── postgres_repo.ex
    │   │   ├── site_imports.ex
    │   │   └── versioned_sessions.ex
    │   ├── data_migration.ex
    │   ├── ecto
    │   │   └── types
    │   │       ├── compiled_regex.ex
    │   │       └── nanoid.ex
    │   ├── event
    │   │   └── write_buffer.ex
    │   ├── exports.ex
    │   ├── file.ex
    │   ├── funnel
    │   │   └── const.ex
    │   ├── geo.ex
    │   ├── goal
    │   │   └── schema.ex
    │   ├── goals
    │   │   ├── goals.ex
    │   │   └── system_goals.ex
    │   ├── google
    │   │   ├── api.ex
    │   │   ├── ga4
    │   │   │   ├── api.ex
    │   │   │   ├── http.ex
    │   │   │   └── report_request.ex
    │   │   ├── http.ex
    │   │   └── search_console
    │   │       └── filters.ex
    │   ├── helpers
    │   │   ├── changeset.ex
    │   │   ├── config.ex
    │   │   └── json.ex
    │   ├── http_client.ex
    │   ├── import_deletion_repo.ex
    │   ├── imported
    │   │   ├── browser.ex
    │   │   ├── buffer.ex
    │   │   ├── csv_importer.ex
    │   │   ├── custom_event.ex
    │   │   ├── device.ex
    │   │   ├── entry_page.ex
    │   │   ├── exit_page.ex
    │   │   ├── google_analytics4.ex
    │   │   ├── import_sources.ex
    │   │   ├── importer.ex
    │   │   ├── location.ex
    │   │   ├── noop_importer.ex
    │   │   ├── operating_system.ex
    │   │   ├── page.ex
    │   │   ├── site_import.ex
    │   │   ├── source.ex
    │   │   ├── universal_analytics.ex
    │   │   └── visitor.ex
    │   ├── imported.ex
    │   ├── ingest_repo.ex
    │   ├── ingestion
    │   │   ├── acquisition.ex
    │   │   ├── city_overrides.ex
    │   │   ├── counters
    │   │   │   ├── buffer.ex
    │   │   │   ├── record.ex
    │   │   │   └── telemetry_handler.ex
    │   │   ├── counters.ex
    │   │   ├── event.ex
    │   │   ├── geolocation.ex
    │   │   ├── request.ex
    │   │   ├── source.ex
    │   │   └── write_buffer.ex
    │   ├── installation_support
    │   │   ├── check.ex
    │   │   ├── check_runner.ex
    │   │   ├── checks
    │   │   │   ├── csp.ex
    │   │   │   ├── fetch_body.ex
    │   │   │   ├── installation.ex
    │   │   │   ├── installation_v2.ex
    │   │   │   ├── installation_v2_cache_bust.ex
    │   │   │   ├── scan_body.ex
    │   │   │   ├── snippet.ex
    │   │   │   └── snippet_cache_bust.ex
    │   │   ├── detection.ex
    │   │   ├── installation_support.ex
    │   │   ├── legacy_verification
    │   │   │   ├── checks.ex
    │   │   │   ├── diagnostics.ex
    │   │   │   └── errors.ex
    │   │   ├── result.ex
    │   │   ├── state.ex
    │   │   ├── url.ex
    │   │   └── verification
    │   │       ├── checks.ex
    │   │       └── diagnostics.ex
    │   ├── mailer.ex
    │   ├── migration_utils.ex
    │   ├── open_telemetry
    │   │   └── sampler.ex
    │   ├── open_telemetry.ex
    │   ├── pagination.ex
    │   ├── plugins
    │   │   └── api
    │   │       ├── capabilities.ex
    │   │       ├── custom_props.ex
    │   │       ├── goals.ex
    │   │       ├── shared_links.ex
    │   │       ├── token.ex
    │   │       └── tokens.ex
    │   ├── prom_ex
    │   │   ├── buckets.ex
    │   │   └── striped_peep.ex
    │   ├── prom_ex.ex
    │   ├── props.ex
    │   ├── purge.ex
    │   ├── rate_limit.ex
    │   ├── repo.ex
    │   ├── request_logger.ex
    │   ├── s3
    │   │   └── client.ex
    │   ├── s3.ex
    │   ├── segments
    │   │   ├── filters.ex
    │   │   ├── segment.ex
    │   │   └── segments.ex
    │   ├── sentry
    │   │   └── client.ex
    │   ├── session
    │   │   ├── balancer.ex
    │   │   ├── balancer_supervisor.ex
    │   │   ├── cache_store.ex
    │   │   ├── salts.ex
    │   │   ├── transfer
    │   │   │   ├── alive.ex
    │   │   │   └── tinysock.ex
    │   │   ├── transfer.ex
    │   │   └── write_buffer.ex
    │   ├── shield
    │   │   ├── country_rule.ex
    │   │   ├── country_rule_cache.ex
    │   │   ├── hostname_rule.ex
    │   │   ├── hostname_rule_cache.ex
    │   │   ├── ip_rule.ex
    │   │   ├── ip_rule_cache.ex
    │   │   ├── page_rule.ex
    │   │   └── page_rule_cache.ex
    │   ├── shields.ex
    │   ├── site
    │   │   ├── cache.ex
    │   │   ├── domain.ex
    │   │   ├── gate_keeper.ex
    │   │   ├── google_auth.ex
    │   │   ├── imported_data.ex
    │   │   ├── monthly_report.ex
    │   │   ├── removal.ex
    │   │   ├── shared_link.ex
    │   │   ├── tracker_script_configuration.ex
    │   │   ├── traffic_change_notification.ex
    │   │   ├── user_preference.ex
    │   │   └── weekly_report.ex
    │   ├── site.ex
    │   ├── sites.ex
    │   ├── stats
    │   │   ├── aggregate.ex
    │   │   ├── base.ex
    │   │   ├── breakdown.ex
    │   │   ├── clickhouse.ex
    │   │   ├── compare.ex
    │   │   ├── comparisons.ex
    │   │   ├── current_visitors.ex
    │   │   ├── custom_props.ex
    │   │   ├── datetime_range.ex
    │   │   ├── email_report.ex
    │   │   ├── filter_suggestions.ex
    │   │   ├── filters
    │   │   │   ├── filters.ex
    │   │   │   ├── query_parser.ex
    │   │   │   ├── stats_api_filter_parser.ex
    │   │   │   └── utils.ex
    │   │   ├── goal_suggestions.ex
    │   │   ├── goals.ex
    │   │   ├── imported
    │   │   │   ├── base.ex
    │   │   │   ├── imported.ex
    │   │   │   └── sql
    │   │   │       ├── expression.ex
    │   │   │       └── where_builder.ex
    │   │   ├── interval.ex
    │   │   ├── json-schema
    │   │   │   └── utils.ex
    │   │   ├── json_schema.ex
    │   │   ├── legacy
    │   │   │   ├── legacy_dimensions.ex
    │   │   │   ├── legacy_query_builder.ex
    │   │   │   └── time_on_page.ex
    │   │   ├── metrics.ex
    │   │   ├── query.ex
    │   │   ├── query_optimizer.ex
    │   │   ├── query_result.ex
    │   │   ├── query_runner.ex
    │   │   ├── sql
    │   │   │   ├── expression.ex
    │   │   │   ├── fragments.ex
    │   │   │   ├── query_builder.ex
    │   │   │   ├── special_metrics.ex
    │   │   │   └── where_builder.ex
    │   │   ├── table_decider.ex
    │   │   ├── time.ex
    │   │   ├── time_on_page.ex
    │   │   ├── timeseries.ex
    │   │   └── util.ex
    │   ├── stats.ex
    │   ├── teams
    │   │   ├── billing.ex
    │   │   ├── grace_period.ex
    │   │   ├── guest_invitation.ex
    │   │   ├── guest_membership.ex
    │   │   ├── invitation.ex
    │   │   ├── invitations
    │   │   │   ├── accept.ex
    │   │   │   ├── invite_to_site.ex
    │   │   │   ├── invite_to_team.ex
    │   │   │   ├── reject.ex
    │   │   │   ├── remove_from_site.ex
    │   │   │   └── remove_from_team.ex
    │   │   ├── invitations.ex
    │   │   ├── management
    │   │   │   ├── layout
    │   │   │   │   └── entry.ex
    │   │   │   └── layout.ex
    │   │   ├── membership.ex
    │   │   ├── memberships
    │   │   │   ├── leave.ex
    │   │   │   ├── remove.ex
    │   │   │   └── update_role.ex
    │   │   ├── memberships.ex
    │   │   ├── policy.ex
    │   │   ├── site_transfer.ex
    │   │   ├── sites
    │   │   │   └── transfer.ex
    │   │   ├── sites.ex
    │   │   ├── team.ex
    │   │   └── users.ex
    │   ├── teams.ex
    │   ├── telemetry
    │   │   └── plausible_metrics.ex
    │   ├── themes.ex
    │   ├── timezones.ex
    │   └── users.ex
    ├── plausible.ex
    ├── plausible_release.ex
    ├── plausible_web
    │   ├── captcha.ex
    │   ├── components
    │   │   ├── billing
    │   │   │   ├── billing.ex
    │   │   │   ├── legacy_plan_benefits.ex
    │   │   │   ├── legacy_plan_box.ex
    │   │   │   ├── notice.ex
    │   │   │   ├── pageview_slider.ex
    │   │   │   ├── plan_benefits.ex
    │   │   │   └── plan_box.ex
    │   │   ├── first_dashboard_launch_banner.ex
    │   │   ├── flow_progress.ex
    │   │   ├── generic.ex
    │   │   ├── google.ex
    │   │   ├── layout.ex
    │   │   ├── site
    │   │   │   └── feature.ex
    │   │   ├── team
    │   │   │   └── notice.ex
    │   │   └── two_factor.ex
    │   ├── controllers
    │   │   ├── api
    │   │   │   ├── external_controller.ex
    │   │   │   ├── external_query_api_controller.ex
    │   │   │   ├── external_stats_controller.ex
    │   │   │   ├── helpers.ex
    │   │   │   ├── internal
    │   │   │   │   └── segments_controller.ex
    │   │   │   ├── internal_controller.ex
    │   │   │   ├── paddle_controller.ex
    │   │   │   ├── stats_controller.ex
    │   │   │   └── system_controller.ex
    │   │   ├── auth_controller.ex
    │   │   ├── avatar_controller.ex
    │   │   ├── billing_controller.ex
    │   │   ├── debug_controller.ex
    │   │   ├── error_report_controller.ex
    │   │   ├── google_analytics_controller.ex
    │   │   ├── helpers.ex
    │   │   ├── invitation_controller.ex
    │   │   ├── page_controller.ex
    │   │   ├── settings_controller.ex
    │   │   ├── site
    │   │   │   └── membership_controller.ex
    │   │   ├── site_controller.ex
    │   │   ├── stats_controller.ex
    │   │   └── unsubscribe_controller.ex
    │   ├── email.ex
    │   ├── endpoint.ex
    │   ├── flows.ex
    │   ├── live
    │   │   ├── auth_context.ex
    │   │   ├── change_domain_v2.ex
    │   │   ├── choose_plan.ex
    │   │   ├── components
    │   │   │   ├── combo_box
    │   │   │   │   └── static_search.ex
    │   │   │   ├── combo_box.ex
    │   │   │   ├── form.ex
    │   │   │   ├── modal.ex
    │   │   │   ├── pagination.ex
    │   │   │   ├── team.ex
    │   │   │   ├── verification.ex
    │   │   │   └── visitors.ex
    │   │   ├── csv_export.ex
    │   │   ├── csv_import.ex
    │   │   ├── flash.ex
    │   │   ├── goal_settings
    │   │   │   ├── form.ex
    │   │   │   └── list.ex
    │   │   ├── goal_settings.ex
    │   │   ├── imports_exports_settings.ex
    │   │   ├── installation.ex
    │   │   ├── installationv2.ex
    │   │   ├── legacy_choose_plan.ex
    │   │   ├── plugins
    │   │   │   └── api
    │   │   │       ├── settings.ex
    │   │   │       └── token_form.ex
    │   │   ├── props_settings
    │   │   │   ├── form.ex
    │   │   │   └── list.ex
    │   │   ├── props_settings.ex
    │   │   ├── register_form.ex
    │   │   ├── reset_password_form.ex
    │   │   ├── sentry_context.ex
    │   │   ├── shields
    │   │   │   ├── countries.ex
    │   │   │   ├── country_rules.ex
    │   │   │   ├── hostname_rules.ex
    │   │   │   ├── hostnames.ex
    │   │   │   ├── ip_addresses.ex
    │   │   │   ├── ip_rules.ex
    │   │   │   ├── page_rules.ex
    │   │   │   └── pages.ex
    │   │   ├── sites.ex
    │   │   ├── team_management.ex
    │   │   ├── team_setup.ex
    │   │   └── verification.ex
    │   ├── login_preference.ex
    │   ├── mjml
    │   │   ├── stats_report.ex
    │   │   └── templates
    │   │       └── stats_report.mjml.eex
    │   ├── plugins
    │   │   └── api
    │   │       ├── controllers
    │   │       │   ├── capabilities.ex
    │   │       │   ├── custom_props.ex
    │   │       │   ├── goals.ex
    │   │       │   ├── shared_links.ex
    │   │       │   └── tracker_script_configuration.ex
    │   │       ├── errors.ex
    │   │       ├── schemas
    │   │       │   ├── capabilities.ex
    │   │       │   ├── custom_prop
    │   │       │   │   ├── disable_request.ex
    │   │       │   │   ├── enable_request.ex
    │   │       │   │   └── list_response.ex
    │   │       │   ├── custom_prop.ex
    │   │       │   ├── error.ex
    │   │       │   ├── goal
    │   │       │   │   ├── create_request
    │   │       │   │   │   ├── custom_event.ex
    │   │       │   │   │   ├── pageview.ex
    │   │       │   │   │   └── revenue.ex
    │   │       │   │   ├── create_request.ex
    │   │       │   │   ├── custom_event.ex
    │   │       │   │   ├── delete_bulk_request.ex
    │   │       │   │   ├── list_response.ex
    │   │       │   │   ├── pageview.ex
    │   │       │   │   ├── revenue.ex
    │   │       │   │   └── type.ex
    │   │       │   ├── goal.ex
    │   │       │   ├── link.ex
    │   │       │   ├── not_found.ex
    │   │       │   ├── pagination_metadata.ex
    │   │       │   ├── payment_required.ex
    │   │       │   ├── shared_link
    │   │       │   │   ├── create_request.ex
    │   │       │   │   └── list_response.ex
    │   │       │   ├── shared_link.ex
    │   │       │   ├── tracker_script_configuration
    │   │       │   │   └── update_request.ex
    │   │       │   ├── tracker_script_configuration.ex
    │   │       │   ├── unauthorized.ex
    │   │       │   └── unprocessable_entity.ex
    │   │       ├── spec.ex
    │   │       └── views
    │   │           ├── capabilities.ex
    │   │           ├── custom_props.ex
    │   │           ├── error.ex
    │   │           ├── goal.ex
    │   │           ├── pagination.ex
    │   │           ├── shared_link.ex
    │   │           └── tracker_script_configuration.ex
    │   ├── plugs
    │   │   ├── auth_plug.ex
    │   │   ├── authorize_plugins_api.ex
    │   │   ├── authorize_public_api.ex
    │   │   ├── authorize_site_access.ex
    │   │   ├── authorize_team_access.ex
    │   │   ├── error_handler.ex
    │   │   ├── favicon.ex
    │   │   ├── first_launch_plug.ex
    │   │   ├── maybe_disable_registration.ex
    │   │   ├── no_robots.ex
    │   │   ├── require_account.ex
    │   │   ├── require_logged_out.ex
    │   │   ├── restrict_user_type.ex
    │   │   ├── sso_team_access.ex
    │   │   ├── super_admin_only_plug.ex
    │   │   ├── tracker_plug.ex
    │   │   └── user_session_touch.ex
    │   ├── remote_ip.ex
    │   ├── router.ex
    │   ├── storybook.ex
    │   ├── templates
    │   │   ├── auth
    │   │   │   ├── activate.html.heex
    │   │   │   ├── generate_2fa_recovery_codes.html.heex
    │   │   │   ├── initiate_2fa_setup.html.heex
    │   │   │   ├── login_form.html.heex
    │   │   │   ├── password_reset_form.html.heex
    │   │   │   ├── password_reset_request_form.html.heex
    │   │   │   ├── password_reset_request_success.html.heex
    │   │   │   ├── select_team.html.heex
    │   │   │   ├── verify_2fa.html.heex
    │   │   │   ├── verify_2fa_recovery_code.html.heex
    │   │   │   └── verify_2fa_setup.html.heex
    │   │   ├── billing
    │   │   │   ├── change_enterprise_plan_contact_us.html.eex
    │   │   │   ├── change_plan_preview.html.heex
    │   │   │   ├── choose_plan.html.heex
    │   │   │   ├── upgrade_success.html.heex
    │   │   │   └── upgrade_to_enterprise_plan.html.heex
    │   │   ├── debug
    │   │   │   └── clickhouse.html.heex
    │   │   ├── email
    │   │   │   ├── activation_email.html.heex
    │   │   │   ├── approaching_accept_traffic_until.html.heex
    │   │   │   ├── cancellation_email.html.heex
    │   │   │   ├── check_stats_email.html.heex
    │   │   │   ├── create_site_email.html.heex
    │   │   │   ├── csv_import.html.heex
    │   │   │   ├── dashboard_locked.html.heex
    │   │   │   ├── drop_notification.html.heex
    │   │   │   ├── enterprise_over_limit_internal.html.heex
    │   │   │   ├── error_report_email.html.heex
    │   │   │   ├── existing_user_invitation.html.heex
    │   │   │   ├── existing_user_team_invitation.html.heex
    │   │   │   ├── export_failure.html.heex
    │   │   │   ├── export_success.html.heex
    │   │   │   ├── google_analytics_import.html.heex
    │   │   │   ├── guest_invitation_accepted.html.heex
    │   │   │   ├── guest_invitation_rejected.html.heex
    │   │   │   ├── guest_to_team_member_promotion.html.heex
    │   │   │   ├── new_user_invitation.html.heex
    │   │   │   ├── new_user_team_invitation.html.heex
    │   │   │   ├── over_limit.html.heex
    │   │   │   ├── ownership_transfer_accepted.html.heex
    │   │   │   ├── ownership_transfer_rejected.html.heex
    │   │   │   ├── ownership_transfer_request.html.heex
    │   │   │   ├── password_reset_email.html.heex
    │   │   │   ├── site_member_removed.html.heex
    │   │   │   ├── site_setup_help_email.html.heex
    │   │   │   ├── site_setup_success_email.html.heex
    │   │   │   ├── spike_notification.html.heex
    │   │   │   ├── sso_domain_verification_failure.html.heex
    │   │   │   ├── sso_domain_verification_success.html.heex
    │   │   │   ├── team_changed.html.heex
    │   │   │   ├── team_invitation_accepted.html.heex
    │   │   │   ├── team_invitation_rejected.html.heex
    │   │   │   ├── team_member_left.html.heex
    │   │   │   ├── team_member_removed.html.heex
    │   │   │   ├── trial_one_week_reminder.html.heex
    │   │   │   ├── trial_over_email.html.heex
    │   │   │   ├── trial_upgrade_email.html.heex
    │   │   │   ├── two_factor_disabled_email.html.heex
    │   │   │   ├── two_factor_enabled_email.html.heex
    │   │   │   ├── welcome_email.html.heex
    │   │   │   ├── yearly_expiration_notification.html.heex
    │   │   │   └── yearly_renewal_notification.html.heex
    │   │   ├── error
    │   │   │   ├── 404_error.html.heex
    │   │   │   ├── generic_error.html.heex
    │   │   │   ├── server_error.html.heex
    │   │   │   └── server_error_report_thanks.html.heex
    │   │   ├── google_analytics
    │   │   │   ├── confirm.html.heex
    │   │   │   └── property_form.html.heex
    │   │   ├── layout
    │   │   │   ├── _flash.html.heex
    │   │   │   ├── _footer.html.heex
    │   │   │   ├── _header.html.heex
    │   │   │   ├── _notice.html.heex
    │   │   │   ├── _tracking.html.heex
    │   │   │   ├── app.html.heex
    │   │   │   ├── base_email.html.heex
    │   │   │   ├── base_error.html.heex
    │   │   │   ├── embedded.html.heex
    │   │   │   ├── priority_email.html.heex
    │   │   │   ├── settings.html.heex
    │   │   │   └── site_settings.html.heex
    │   │   ├── page
    │   │   │   └── index.html.heex
    │   │   ├── settings
    │   │   │   ├── api_keys.html.heex
    │   │   │   ├── danger_zone.html.heex
    │   │   │   ├── invoices.html.heex
    │   │   │   ├── new_api_key.html.heex
    │   │   │   ├── preferences.html.heex
    │   │   │   ├── security.html.heex
    │   │   │   ├── subscription.html.heex
    │   │   │   ├── team_danger_zone.html.heex
    │   │   │   └── team_general.html.heex
    │   │   ├── site
    │   │   │   ├── change_domain.html.heex
    │   │   │   ├── csv_import.html.heex
    │   │   │   ├── edit_shared_link.html.heex
    │   │   │   ├── membership
    │   │   │   │   ├── change_team_form.html.heex
    │   │   │   │   ├── invite_member_form.html.heex
    │   │   │   │   └── transfer_ownership_form.html.heex
    │   │   │   ├── new.html.heex
    │   │   │   ├── new_shared_link.html.heex
    │   │   │   ├── settings_danger_zone.html.heex
    │   │   │   ├── settings_email_reports.html.heex
    │   │   │   ├── settings_funnels.html.heex
    │   │   │   ├── settings_general.html.heex
    │   │   │   ├── settings_goals.html.heex
    │   │   │   ├── settings_imports_exports.html.heex
    │   │   │   ├── settings_integrations.html.heex
    │   │   │   ├── settings_people.html.heex
    │   │   │   ├── settings_props.html.heex
    │   │   │   ├── settings_shields.html.heex
    │   │   │   └── settings_visibility.html.heex
    │   │   ├── stats
    │   │   │   ├── shared_link_password.html.heex
    │   │   │   ├── site_locked.html.heex
    │   │   │   └── stats.html.heex
    │   │   └── unsubscribe
    │   │       └── success.html.heex
    │   ├── tracker.ex
    │   ├── tracker_script_cache.ex
    │   ├── two_factor
    │   │   └── session.ex
    │   ├── user_auth.ex
    │   └── views
    │       ├── auth_view.ex
    │       ├── billing_view.ex
    │       ├── debug_view.ex
    │       ├── email_view.ex
    │       ├── error_view.ex
    │       ├── google_analytics_view.ex
    │       ├── layout_view.ex
    │       ├── page_view.ex
    │       ├── settings_view.ex
    │       ├── site
    │       │   └── membership_view.ex
    │       ├── site_view.ex
    │       ├── stats_view.ex
    │       ├── text_helpers.ex
    │       └── unsubscribe_view.ex
    ├── plausible_web.ex
    ├── sentry_filter.ex
    └── workers
        ├── accept_traffic_until_notification.ex
        ├── check_usage.ex
        ├── clean_invitations.ex
        ├── clean_user_sessions.ex
        ├── clickhouse_clean_sites.ex
        ├── expire_domain_change_transitions.ex
        ├── export_analytics.ex
        ├── import_analytics.ex
        ├── local_import_analytics_cleaner.ex
        ├── locations_sync.ex
        ├── lock_sites.ex
        ├── notify_annual_renewal.ex
        ├── notify_exported_analytics.ex
        ├── purge_cdn_cache.ex
        ├── rotate_salts.ex
        ├── schedule_email_reports.ex
        ├── send_check_stats_emails.ex
        ├── send_email_report.ex
        ├── send_site_setup_emails.ex
        ├── send_trial_notifications.ex
        ├── set_legacy_time_on_page_cutoff.ex
        └── traffic_change_notifier.ex
```

# File Contents

## File: `lib/mix/tasks/cancel_subscription.ex`
```
defmodule Mix.Tasks.CancelSubscription do
  @moduledoc """
  This task is meant to replicate the behavior of cancelling
  a subscription. On production, this action is initiated by
  a Paddle webhook. Currently, only the subscription status
  is changed with that action.
  """

  use Mix.Task
  use Plausible.Repo
  require Plausible.Billing.Subscription.Status
  require Logger
  alias Plausible.{Repo, Billing.Subscription}

  def run([paddle_subscription_id]) do
    Mix.Task.run("app.start")

    Repo.get_by!(Subscription, paddle_subscription_id: paddle_subscription_id)
    |> Subscription.changeset(%{status: Subscription.Status.deleted()})
    |> Repo.update!()

    Logger.notice("Successfully set the subscription status to #{Subscription.Status.deleted()}")
  end
end
```

## File: `lib/mix/tasks/clean_clickhouse.ex`
```
defmodule Mix.Tasks.CleanClickhouse do
  use Mix.Task

  alias Plausible.IngestRepo

  def run(_) do
    %{rows: rows} = IngestRepo.query!("show tables")
    tables = Enum.map(rows, fn [table] -> table end)

    to_truncate =
      tables --
        [
          "schema_migrations",
          "location_data",
          "location_data_dict",
          "acquisition_channel_source_category",
          "acquisition_channel_source_category_dict",
          "acquisition_channel_paid_sources",
          "acquisition_channel_paid_sources_dict"
        ]

    Enum.each(to_truncate, fn table ->
      IngestRepo.query!("truncate #{table}")
    end)
  end
end
```

## File: `lib/mix/tasks/create_free_subscription.ex`
```
defmodule Mix.Tasks.CreateFreeSubscription do
  use Mix.Task
  use Plausible.Repo
  require Logger
  alias Plausible.Billing.Subscription

  # coveralls-ignore-start

  def run([user_id]) do
    Application.ensure_all_started(:plausible)
    execute(user_id)
  end

  def run(_), do: IO.puts("Usage - mix create_free_subscription <user_id>")

  def execute(user_id) do
    user = Repo.get(Plausible.Auth.User, user_id)
    {:ok, team} = Plausible.Teams.get_or_create(user)

    team
    |> Subscription.free()
    |> Repo.insert!()

    IO.puts("Created a free subscription for user: #{user.name}")
  end
end
```

## File: `lib/mix/tasks/create_paddle_prod_plans.ex`
```
defmodule Mix.Tasks.CreatePaddleProdPlans do
  @moduledoc """
  ## Utility for creating Paddle plans for production use.

  Takes a single `filename` argument which should be of format
  `input_plans_v*.json`. That file should live in the `/priv` directory next
  to all other plans and it should contain the necessary information about
  the production plans to be created.

  In order to create the input file:

  * Copy an existing `plans_v*.json` (latest recommended) into the new
    `input_plans_v*.json` file.
  * For every plan object:
    * Adjust the generation, limits, features, etc as desired
    * Replace `monthly_product_id` with a `monthly_price` (integer)
    * Replace `yearly_product_id` with a `yearly_price` (integer)

  After this task is finished successfully, the plans will be created in Paddle
  with the prices given in the input file. With the creation, every plan gets an
  autoincremented ID in Paddle. We will then fetch those exact plans from Paddle
  in an API call and use their monthly and yearly product_id's to write
  `plans_v*.json`. It will be written taking the input file as the "template"
  and replacing the monthly/yearly prices with monthly/yearly product_id's.

  The prices will be written into `/priv/plan_prices.json` (instead of the
  prod plans output file). Note that this separation is intentional - we only
  store prices locally to not rely on Paddle in the dev environment. Otherwise,
  Paddle is considered the "source of truth" of plan prices.

  ## Usage example:

  ```
  mix create_paddle_prod_plans input_plans_v5.json
  ```

  ## Requirement 1: Replace the curl command

  Unfortunately, there's no API in Paddle that would allow "bulk creating"
  plans - it has to be done through the UI. As a hack though, we can automate
  the process by copying the curl request with the help of browser devtools.

  Therefore, this Mix.Task **does not work out of the box** and the actual curl
  command that it executes must be replaced by the developer. Here's how:

  0) Access required to the production Paddle account
  1) Navigate to https://vendors.paddle.com/subscriptions/plans. Chrome or
     Firefox recommended (need to copy a POST request as cURL in a later step)
  2) Click the "+ New Plan" button (top right of the screen) to open the form
  3) Open browser devtools, fill in the required fields and submit the form.
     No need to worry about the form fields since they're provided in this task
     (except `_token`) and they *should work* as long as nothing has changed.
  4) Find the POST request from the "Network" tab and copy it as cURL
  5) Come back here and paste it into the `create_paddle_plan` function
  6) Replace the params within the string with the real params (these should
     be available in the function already)

  ## Requirement 2: Paddle production credentials

  You also need to obtain the Paddle credentials from prod environment and
  replace them into the module attributes. See `@paddle_vendor_id` and
  `@paddle_vendor_auth_code`. Those are needed to fetch the plans via an
  actual API call after the plans have been created in Paddle.
  """

  use Mix.Task

  @requirements ["app.config"]

  @paddle_vendor_id "REPLACE ME"
  @paddle_vendor_auth_code "REPLACE ME"

  def run([filename]) do
    {:ok, _} = Application.ensure_all_started(:telemetry)
    Finch.start_link(name: MyFinch)

    if not Regex.match?(~r/^input_plans_v(\d+)\.json$/, filename) do
      raise ArgumentError,
            "Invalid filename argument. Note the strict format - e.g.: \"input_plans_v5.json\""
    end

    input_plans =
      Application.app_dir(:plausible, ["priv", filename])
      |> File.read!()
      |> JSON.decode!()

    to_be_created_in_paddle =
      input_plans
      |> Enum.flat_map(fn plan ->
        [
          create_paddle_plan_attrs(plan, "monthly"),
          create_paddle_plan_attrs(plan, "yearly")
        ]
      end)

    user_input =
      """
      \n
      ##########################################################################
      #                                                                        #
      #                              !WARNING!                                 #
      #                                                                        #
      #      You're about to create production plans in Paddle. Multiple       #
      #      consecutive executions will create the same plans again.          #
      #      Please make sure to not leave duplicates behind!                  #
      #                                                                        #
      ##########################################################################

      * 'y' - proceed and create all plans
      * 't' - test only with two plans
      * 'h' - halt

      What would you like to do?
      """
      |> IO.gets()
      |> String.trim()
      |> String.upcase()

    test_run? =
      case user_input do
        "Y" ->
          IO.puts("Creating all plans...")
          false

        "T" ->
          IO.puts("Creating 2 plans just for testing. Make sure to delete them manually!")
          true

        _ ->
          IO.puts("Halting execution per user request.")
          System.halt()
      end

    {paddle_create_count, create_count} =
      if test_run? do
        {2, 1}
      else
        {length(to_be_created_in_paddle), length(input_plans)}
      end

    to_be_created_in_paddle
    |> Enum.take(paddle_create_count)
    |> Enum.each(&create_paddle_plan/1)

    IO.puts("⏳ waiting 3s before fetching the newly created plans...")
    Process.sleep(3000)
    IO.puts("Fetching the #{create_count} plans created a moment ago...")

    created_paddle_plans =
      fetch_all_prod_plans()
      |> Enum.sort_by(& &1["id"])
      |> Enum.take(-paddle_create_count)

    file_path_to_write = Path.join("priv", String.replace(filename, "input_", ""))

    prod_plans_with_ids_and_prices =
      input_plans
      |> Enum.take(create_count)
      |> write_prod_plans_json_file(file_path_to_write, created_paddle_plans)

    IO.puts("✅ Wrote #{create_count} new plans into #{file_path_to_write}!")

    if not test_run? do
      write_prices(prod_plans_with_ids_and_prices)
      IO.puts("✅ Updated `plan_prices.json`.")
    end

    IO.puts("✅ All done!")
  end

  defp create_paddle_plan(%{name: name, price: price, type: type, interval_index: interval_index}) do
    your_unique_token = "abc"

    # Replace this curl command. You should be able to reuse
    # the request body after replacing your unique token.
    curl_command = """
    ... REPLACE ME
    --data-raw '_token=#{your_unique_token}&plan-id=&default-curr=USD&tmpicon=false&name=#{name}&checkout_custom_message=&taxable_type=standard&interval=#{interval_index}&period=1&type=#{type}&trial_length=&price_USD=#{price}&active_EUR=on&price_EUR=#{price}&active_GBP=on&price_GBP=#{price}'
    """

    case curl_quietly(curl_command) do
      :ok ->
        IO.puts("✅ Created #{name}")

      {:error, reason} ->
        IO.puts("❌ Halting. The plan #{name} could not be created. Error: #{reason}")
        System.halt(1)
    end
  end

  @paddle_interval_indexes %{"monthly" => 2, "yearly" => 5}

  defp create_paddle_plan_attrs(plan_with_price, type) do
    %{
      name: plan_name(plan_with_price, type),
      price: plan_with_price["#{type}_price"],
      type: type,
      interval_index: @paddle_interval_indexes[type]
    }
  end

  defp fetch_all_prod_plans() do
    "https://vendors.paddle.com/api/2.0/subscription/plans"
    |> fetch_all_paddle_plans(%{
      vendor_id: @paddle_vendor_id,
      vendor_auth_code: @paddle_vendor_auth_code
    })
  end

  @paddle_plans_api_pagination_limit 500
  def fetch_all_paddle_plans(url, paddle_credentials, page \\ 0, fetched \\ 0) do
    body =
      paddle_credentials
      |> Map.merge(%{
        limit: @paddle_plans_api_pagination_limit,
        offset: page * @paddle_plans_api_pagination_limit
      })
      |> JSON.encode!()

    headers = [
      {"Content-type", "application/json"},
      {"Accept", "application/json"}
    ]

    request = Finch.build(:post, url, headers, body)

    with {:ok, response} <- Finch.request(request, MyFinch),
         {:ok, %{"success" => true, "response" => plans} = body} <- JSON.decode(response.body) do
      fetched = body["count"] + fetched
      total = body["total"]

      IO.puts("✅ Successfully fetched #{fetched}/#{body["total"]} plans")

      if fetched == total do
        plans
      else
        plans ++ fetch_all_paddle_plans(url, paddle_credentials, page + 1, fetched)
      end
    else
      error ->
        IO.puts("❌ Failed to fetch plans from Paddle - #{inspect(error)}")
        System.halt(1)
    end
  end

  defp write_prod_plans_json_file(input_plans, filepath, paddle_plans) do
    prod_plans_with_prices =
      input_plans
      |> Enum.map(fn input_plan ->
        monthly_plan_name = plan_name(input_plan, "monthly")
        yearly_plan_name = plan_name(input_plan, "yearly")

        %{"id" => monthly_product_id} =
          Enum.find(paddle_plans, &(&1["name"] == monthly_plan_name))

        %{"id" => yearly_product_id} =
          Enum.find(paddle_plans, &(&1["name"] == yearly_plan_name))

        input_plan
        |> Map.merge(%{
          "monthly_product_id" => to_string(monthly_product_id),
          "yearly_product_id" => to_string(yearly_product_id)
        })
      end)

    content =
      prod_plans_with_prices
      |> Enum.map(fn plan ->
        plan
        |> Map.drop(["monthly_price", "yearly_price"])
        |> order_keys()
      end)
      |> Jason.encode!(pretty: true)

    File.write!(filepath, content)

    prod_plans_with_prices
  end

  @plan_prices_filepath Application.app_dir(:plausible, ["priv", "plan_prices.json"])
  defp write_prices(prod_plans_with_ids_and_prices) do
    current_prices = File.read!(@plan_prices_filepath) |> JSON.decode!()

    new_prices =
      prod_plans_with_ids_and_prices
      |> Enum.reduce(current_prices, fn plan, prices ->
        prices
        |> Map.put_new(plan["monthly_product_id"], plan["monthly_price"])
        |> Map.put_new(plan["yearly_product_id"], plan["yearly_price"])
      end)
      |> Enum.sort()
      |> Jason.OrderedObject.new()
      |> Jason.encode!(pretty: true)

    File.write(@plan_prices_filepath, new_prices)
  end

  @plan_key_order [
    "kind",
    "generation",
    "monthly_pageview_limit",
    "monthly_product_id",
    "yearly_product_id",
    "site_limit",
    "team_member_limit",
    "features"
  ]
  def order_keys(plan) do
    plan
    |> Map.to_list()
    |> Enum.sort_by(fn {key, _value} ->
      Enum.find_index(@plan_key_order, fn ordered_key -> ordered_key == key end) || 99
    end)
    |> Jason.OrderedObject.new()
  end

  defp plan_name(plan, type) do
    kind = plan["kind"] |> String.capitalize()
    type = type |> String.capitalize()

    volume =
      plan["monthly_pageview_limit"]
      |> PlausibleWeb.StatsView.large_number_format(capitalize_k?: true)

    "Plausible #{kind} #{type} Plan (#{volume})"
  end

  def curl_quietly(cmd) do
    cmd = String.replace(cmd, "curl", ~s|curl -s -o /dev/null -w "%{http_code}"|)

    case System.cmd("sh", ["-c", cmd], stderr_to_stdout: true) do
      {"302", 0} ->
        :ok

      {http_status, 0} ->
        {:error, "unexpected HTTP response status (#{http_status}). Expected 302."}

      {_, exit_code} ->
        {:error, "curl command exited with exit code #{exit_code}"}
    end
  end
end
```

## File: `lib/mix/tasks/create_paddle_sandbox_plans.ex`
```
defmodule Mix.Tasks.CreatePaddleSandboxPlans do
  @moduledoc """
  Utility for creating Sandbox plans that are used on staging. The product of
  this task is a `sandbox_plans_v*.json` file matching with the production
  plans, just with the monthly/yearly product_id's of the sandbox plans.

  In principle, this task works like `Mix.Tasks.CreatePaddleProdPlans`, with
  the following differences:

  * The `filename` argument should be the name of the JSON file containing the
    production plans (meaning that those should be created as the first step).
    No special "input file" required.

  * To copy the curl command from the browser, you need to add a plan from
    https://sandbox-vendors.paddle.com/subscriptions/plans. Everything else is
    the same - please see `create_paddle_prod_plans.ex` for instructions.

  * This task can be executed multiple times in a row - it will not create
    duplicates in Sandbox Paddle. On staging we can use a specific plan-naming
    structure to determine whether a plan has been created already. On prod we
    cannot do that since the plan names need to look nice.

  * No need to copy paddle API credentials.

  ## Usage example:

  ```
  mix create_paddle_sandbox_plans plans_v5.json
  ```
  """

  alias Mix.Tasks.CreatePaddleProdPlans
  use Mix.Task

  @requirements ["app.config"]

  def run([filename]) do
    {:ok, _} = Application.ensure_all_started(:telemetry)
    Finch.start_link(name: MyFinch)

    prod_plans =
      Application.app_dir(:plausible, ["priv", filename])
      |> File.read!()
      |> JSON.decode!()

    to_be_created =
      prod_plans
      |> put_prices()
      |> Enum.flat_map(fn priced_plan ->
        [
          create_paddle_plan_attrs(priced_plan, "monthly"),
          create_paddle_plan_attrs(priced_plan, "yearly")
        ]
      end)

    IO.puts("Fetching all sandbox plans before we get started...")
    paddle_plans_before = fetch_all_sandbox_plans()

    created =
      Enum.filter(to_be_created, fn attrs ->
        if Enum.any?(paddle_plans_before, &(&1["name"] == attrs.name)) do
          IO.puts("⚠️ The plan #{attrs.name} already exists in Sandbox Paddle")
          false
        else
          create_paddle_plan(attrs)
          true
        end
      end)

    paddle_plans_after =
      if created != [] do
        IO.puts("⏳ waiting 3s before fetching the newly created plans...")
        Process.sleep(3000)
        IO.puts("Fetching all sandbox plans after creation...")
        fetch_all_sandbox_plans()
      else
        IO.puts("All plans have been created already.")
        paddle_plans_before
      end

    file_path_to_write = Path.join("priv", "sandbox_" <> filename)

    write_sandbox_plans_json_file(prod_plans, file_path_to_write, paddle_plans_after)

    IO.puts("✅ All done! Wrote #{length(prod_plans)} new plans into #{file_path_to_write}!")
  end

  defp create_paddle_plan(%{name: name, price: price, type: type, interval_index: interval_index}) do
    your_unique_token = "abc"

    # Replace this curl command. You might be able to reuse
    # the request body after replacing your unique token.
    curl_command = """
    ... REPLACE ME
    --data-raw '_token=#{your_unique_token}&plan-id=&default-curr=USD&tmpicon=false&name=#{name}&checkout_custom_message=&taxable_type=standard&interval=#{interval_index}&period=1&type=#{type}&trial_length=&price_USD=#{price}&active_EUR=on&price_EUR=#{price}&active_GBP=on&price_GBP=#{price}'
    """

    case CreatePaddleProdPlans.curl_quietly(curl_command) do
      :ok ->
        IO.puts("✅ Created #{name}")

      {:error, reason} ->
        IO.puts("❌ Halting. The plan #{name} could not be created. Error: #{reason}")
        System.halt(1)
    end
  end

  defp fetch_all_sandbox_plans() do
    url = "https://sandbox-vendors.paddle.com/api/2.0/subscription/plans"

    paddle_config = Application.get_env(:plausible, :paddle)

    paddle_credentials = %{
      vendor_id: paddle_config[:vendor_id],
      vendor_auth_code: paddle_config[:vendor_auth_code]
    }

    CreatePaddleProdPlans.fetch_all_paddle_plans(url, paddle_credentials)
  end

  @paddle_interval_indexes %{"monthly" => 2, "yearly" => 5}

  defp create_paddle_plan_attrs(plan_with_price, type) do
    %{
      name: plan_name(plan_with_price, type),
      price: plan_with_price["#{type}_price"],
      type: type,
      interval_index: @paddle_interval_indexes[type]
    }
  end

  defp plan_name(plan, type) do
    generation = "v#{plan["generation"]}"
    kind = plan["kind"]
    volume = plan["monthly_pageview_limit"] |> PlausibleWeb.StatsView.large_number_format()

    [generation, type, kind, volume] |> Enum.join("_")
  end

  defp write_sandbox_plans_json_file(prod_plans, filepath, paddle_plans) do
    sandbox_plans =
      prod_plans
      |> Enum.map(fn prod_plan ->
        monthly_plan_name = plan_name(prod_plan, "monthly")
        yearly_plan_name = plan_name(prod_plan, "yearly")

        %{"id" => sandbox_monthly_product_id} =
          Enum.find(paddle_plans, &(&1["name"] == monthly_plan_name))

        %{"id" => sandbox_yearly_product_id} =
          Enum.find(paddle_plans, &(&1["name"] == yearly_plan_name))

        Map.merge(prod_plan, %{
          "monthly_product_id" => to_string(sandbox_monthly_product_id),
          "yearly_product_id" => to_string(sandbox_yearly_product_id)
        })
        |> CreatePaddleProdPlans.order_keys()
      end)

    content = Jason.encode!(sandbox_plans, pretty: true)
    File.write!(filepath, content)
  end

  defp put_prices(plans) do
    prices =
      Application.app_dir(:plausible, ["priv", "plan_prices.json"])
      |> File.read!()
      |> JSON.decode!()

    plans
    |> Enum.map(fn plan ->
      Map.merge(plan, %{
        "monthly_price" => prices[plan["monthly_product_id"]],
        "yearly_price" => prices[plan["yearly_product_id"]]
      })
    end)
  end
end
```

## File: `lib/mix/tasks/download_country_database.ex`
```
defmodule Mix.Tasks.DownloadCountryDatabase do
  @moduledoc """
  This task downloads the Country Lite database from DB-IP for self-hosted or development purposes.
  Plausible Cloud runs a paid version of DB-IP with more detailed geolocation data.
  """

  use Mix.Task
  use Plausible.Repo
  require Logger

  # coveralls-ignore-start

  def run(_) do
    Application.ensure_all_started(:httpoison)
    Application.ensure_all_started(:timex)
    this_month = Date.utc_today()
    last_month = Date.shift(this_month, month: -1)
    this_month = this_month |> Date.to_iso8601() |> binary_part(0, 7)
    last_month = last_month |> Date.to_iso8601() |> binary_part(0, 7)
    this_month_url = "https://download.db-ip.com/free/dbip-country-lite-#{this_month}.mmdb.gz"
    last_month_url = "https://download.db-ip.com/free/dbip-country-lite-#{last_month}.mmdb.gz"
    Logger.notice("Downloading #{this_month_url}")
    res = HTTPoison.get!(this_month_url)

    res =
      case res.status_code do
        404 ->
          Logger.warning("Got 404 for #{this_month_url}, trying #{last_month_url}")
          HTTPoison.get!(last_month_url)

        _ ->
          res
      end

    if res.status_code == 200 do
      File.mkdir("priv/geodb")
      File.write!("priv/geodb/dbip-country.mmdb.gz", res.body)
      Logger.notice("Downloaded and saved the database successfully")
    else
      Logger.error("Unable to download and save the database. Response: #{inspect(res)}")
    end
  end
end
```

## File: `lib/mix/tasks/generate_referrer_favicons.ex`
```
defmodule Mix.Tasks.GenerateReferrerFavicons do
  use Mix.Task
  use Plausible.Repo
  require Logger

  @dialyzer {:nowarn_function, run: 1}
  # coveralls-ignore-start

  def run(_) do
    entries =
      :yamerl_constr.file(Application.app_dir(:plausible, "priv/ref_inspector/referers.yml"))
      |> List.first()
      |> Enum.map(fn {_key, val} -> val end)
      |> Enum.concat()

    domains =
      Enum.reduce(entries, %{}, fn {key, val}, domains ->
        domain =
          Enum.into(val, %{})[~c"domains"]
          |> List.first()

        Map.put_new(domains, List.to_string(key), List.to_string(domain))
      end)

    File.write!(
      Application.app_dir(:plausible, "priv/referer_favicon_domains.json"),
      Jason.encode!(domains)
    )
  end
end
```

## File: `lib/mix/tasks/pull_sandbox_subscription.ex`
```
defmodule Mix.Tasks.PullSandboxSubscription do
  use Mix.Task
  use Plausible.Repo
  alias Plausible.{Repo, Auth.User, Billing.Subscription}
  require Logger

  # Steps to create a subscription in dev environment
  #
  # 1) Subscribe to a sandbox plan in the UI > User Settings. Instructions:
  #    https://developer.paddle.com/getting-started/ZG9jOjIxODY4NjYx-sandbox
  #
  # 2) find the created subscription_ID here:
  #    https://sandbox-vendors.paddle.com/subscriptions/customers
  #
  # 3) run from command line:
  #    mix pull_sandbox_subscription <subscription_ID>

  @headers [
    {"Content-type", "application/json"},
    {"Accept", "application/json"}
  ]

  def run([paddle_subscription_id]) do
    Mix.Task.run("app.start")

    config = Application.get_env(:plausible, :paddle)

    endpoint = Plausible.Billing.PaddleApi.vendors_domain() <> "/api/2.0/subscription/users"

    params = %{
      vendor_id: config[:vendor_id],
      vendor_auth_code: config[:vendor_auth_code],
      subscription_id: paddle_subscription_id
    }

    case HTTPoison.post(endpoint, Jason.encode!(params), @headers) do
      {:ok, response} ->
        body = Jason.decode!(response.body)

        if body["success"] do
          res = body["response"] |> List.first()
          user = Repo.get_by!(User, email: res["user_email"])
          {:ok, team} = Plausible.Teams.get_or_create(user)

          subscription = %{
            paddle_subscription_id: res["subscription_id"] |> to_string(),
            paddle_plan_id: res["plan_id"] |> to_string(),
            cancel_url: res["cancel_url"],
            update_url: res["update_url"],
            team_id: team.id,
            status: res["state"],
            last_bill_date: res["last_payment"]["date"],
            next_bill_date: res["next_payment"]["date"],
            next_bill_amount: res["next_payment"]["amount"] |> to_string(),
            currency_code: res["next_payment"]["currency"]
          }

          Subscription.changeset(%Subscription{}, subscription)
          |> Repo.insert!()

          Logger.notice("Subscription created for user #{user.id} (#{user.email})")
        else
          Logger.error(body["error"])
        end

      {:error, reason} ->
        Logger.error(reason)
    end
  end
end
```

## File: `lib/mix/tasks/send_pageview.ex`
```
defmodule Mix.Tasks.SendPageview do
  @moduledoc """
  It's often necessary to generate fake events for development and testing purposes. This Mix Task provides a quick and easy
  way to generate a pageview or custom event, either in your development environment or a remote Plausible instance.

  See Mix.Tasks.SendPageview.usage/1 for more detailed documentation.
  """

  use Mix.Task
  require Logger

  @default_host "http://localhost:8000"
  @default_ip_address "127.0.0.1"
  @default_user_agent "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36 OPR/71.0.3770.284"
  @default_domain "dummy.site"
  @default_page "/"
  @default_referrer "https://google.com"
  @default_event "pageview"
  @default_props "{}"
  @default_queryparams ""
  @options [
    ip: :string,
    user_agent: :string,
    domain: :string,
    page: :string,
    referrer: :string,
    host: :string,
    hostname: :string,
    event: :string,
    props: :string,
    revenue_currency: :string,
    revenue_amount: :string,
    queryparams: :string
  ]

  def run(opts) do
    Finch.start_link(name: Plausible.Finch)

    {parsed, _, invalid} = OptionParser.parse(opts, strict: @options)

    case invalid do
      [] ->
        do_send_pageview(parsed)

      [invalid_option | _] ->
        {key, _val} = invalid_option
        IO.puts("Invalid option #{key}. Aborting.")
        IO.puts(usage())
    end
  end

  defp do_send_pageview(parsed_opts) do
    ip = Keyword.get(parsed_opts, :ip, @default_ip_address)
    user_agent = Keyword.get(parsed_opts, :user_agent, @default_user_agent)
    host = Keyword.get(parsed_opts, :host, @default_host)

    url = get_url(host)
    headers = get_headers(ip, user_agent)
    body = get_body(parsed_opts)

    case Plausible.HTTPClient.post(url, headers, body) do
      {:ok, resp} ->
        IO.puts(
          "✅ Successfully sent #{body[:name]} event to #{url} ✅ \n\nip=#{ip}\nuser_agent=#{user_agent}\nbody= #{inspect(body, pretty: true)}"
        )

        IO.puts("Response headers: " <> inspect(resp.headers, pretty: true))

      {:error, e} ->
        IO.puts("❌ Could not send event to #{url}. Got the following error: \n\n #{inspect(e)}")
    end
  end

  defp get_url(host) do
    Path.join(host, "/api/event")
  end

  defp get_headers(ip, user_agent) do
    [
      {"x-forwarded-for", ip},
      {"user-agent", user_agent},
      {"content-type", "text/plain"}
    ]
  end

  defp get_body(opts) do
    domain = Keyword.get(opts, :domain, @default_domain)
    page = Keyword.get(opts, :page, @default_page)
    referrer = Keyword.get(opts, :referrer, @default_referrer)
    event = Keyword.get(opts, :event, @default_event)
    props = Keyword.get(opts, :props, @default_props)
    hostname = Keyword.get(opts, :hostname, domain)
    queryparams = Keyword.get(opts, :queryparams, @default_queryparams)

    revenue =
      if Keyword.get(opts, :revenue_currency) do
        %{
          currency: Keyword.get(opts, :revenue_currency),
          amount: Keyword.get(opts, :revenue_amount)
        }
      end

    %{
      name: event,
      url: "http://#{hostname}#{page}?#{queryparams}",
      domain: domain,
      referrer: referrer,
      props: props,
      revenue: revenue
    }
  end

  defp usage() do
    """
    usage: $ mix send_pageview [--domain domain] [--ip ip_address]"
    options: #{inspect(@options, pretty: true)}
    """
  end
end
```

## File: `lib/oban_error_reporter.ex`
```
defmodule ObanErrorReporter do
  use Plausible
  require Logger

  def handle_event(name, measurements, metadata, _) do
    # handling telemetry event in a try/catch block
    # to avoid handler detachment in the case of an error
    # see https://hexdocs.pm/telemetry/telemetry.html#attach/4
    try do
      handle_event(name, measurements, metadata)
    catch
      kind, reason ->
        message = Exception.format(kind, reason, __STACKTRACE__)
        Logger.error(message)
    end
  end

  defp handle_event([:oban, :job, :exception], measure, %{job: job} = meta) do
    extra =
      job
      |> Map.take([:id, :args, :meta, :queue, :worker])
      |> Map.merge(measure)

    on_job_exception(job)
    capture_error(meta, extra)
  end

  defp handle_event([:oban, :notifier, :exception], _timing, meta) do
    extra = Map.take(meta, ~w(channel payload)a)
    capture_error(meta, extra)
  end

  defp handle_event([:oban, :plugin, :exception], _timing, meta) do
    extra = Map.take(meta, ~w(plugin)a)
    capture_error(meta, extra)
  end

  defp on_job_exception(%Oban.Job{
         queue: "analytics_imports",
         args: %{"import_id" => import_id},
         state: "executing",
         attempt: attempt,
         max_attempts: max_attempts
       })
       when attempt >= max_attempts do
    site_import = Plausible.Repo.get(Plausible.Imported.SiteImport, import_id)

    if site_import do
      Plausible.Workers.ImportAnalytics.import_fail(site_import, [])
    end
  end

  defp on_job_exception(%Oban.Job{
         queue: "analytics_imports",
         args: %{"import_id" => import_id},
         state: "executing"
       }) do
    site_import = Plausible.Repo.get(Plausible.Imported.SiteImport, import_id)

    if site_import do
      Plausible.Workers.ImportAnalytics.import_fail_transient(site_import)
    end
  end

  defp on_job_exception(_job), do: :ignore

  # Logs the error and sends it to Sentry
  defp capture_error(meta, extra) do
    Logger.error(
      # this message is ignored by Sentry
      "Background job (#{inspect(extra)}) failed:\n\n  " <>
        Exception.format(:error, meta.reason, meta.stacktrace),
      # Sentry report is built entirely from crash_reason
      crash_reason: {meta.reason, meta.stacktrace},
      sentry: %{extra: extra}
    )
  end
end
```

## File: `lib/plausible.ex`
```
defmodule Plausible do
  @moduledoc """
  Build-related macros
  """

  @ce_builds [:ce, :ce_test, :ce_dev]

  defmacro __using__(_) do
    quote do
      require Plausible
      import Plausible
    end
  end

  @spec sso_enabled?() :: boolean()
  def sso_enabled?() do
    Application.fetch_env!(:plausible, :sso_enabled)
  end

  defmacro on_ee(clauses) do
    do_on_ee(clauses)
  end

  defmacro on_ce(clauses) do
    do_on_ce(clauses)
  end

  # :erlang.phash2(1, 1) == 0 tricks dialyzer as per:
  # https://github.com/elixir-lang/elixir/blob/v1.12.3/lib/elixir/lib/gen_server.ex#L771-L778
  # and also tricks elixir 1.18 type checker

  defmacro always(term) do
    quote do
      :erlang.phash2(1, 1) == 0 && unquote(term)
    end
  end

  defmacro ee? do
    quote do
      always(unquote(Mix.env() not in @ce_builds))
    end
  end

  defmacro ce? do
    quote do
      always(unquote(Mix.env() in @ce_builds))
    end
  end

  defp do_on_ce(do: block) do
    do_on_ee(do: nil, else: block)
  end

  defp do_on_ce(do: do_block, else: else_block) do
    do_on_ee(do: else_block, else: do_block)
  end

  defp do_on_ee(do: block) do
    do_on_ee(do: block, else: nil)
  end

  defp do_on_ee(do: do_block, else: else_block) do
    if ee?() do
      quote do
        unquote(do_block)
      end
    else
      quote do
        unquote(else_block)
      end
    end
  end

  def product_name do
    if ee?() do
      "Plausible Analytics"
    else
      "Plausible CE"
    end
  end
end
```

## File: `lib/plausible/application.ex`
```
defmodule Plausible.Application do
  @moduledoc false

  use Application
  use Plausible

  require Logger

  def start(_type, _args) do
    on_ee(do: Plausible.License.ensure_valid_license())
    on_ce(do: :inet_db.set_tcp_module(:happy_tcp))

    # in CE we start the endpoint under site_encrypt for automatic https
    endpoint = on_ee(do: PlausibleWeb.Endpoint, else: maybe_https_endpoint())

    children =
      [
        {PartitionSupervisor,
         child_spec: Task.Supervisor, name: Plausible.UserAgentParseTaskSupervisor},
        Plausible.Session.BalancerSupervisor,
        Plausible.PromEx,
        {Plausible.Auth.TOTP.Vault, key: totp_vault_key()},
        Plausible.Repo,
        Plausible.ClickhouseRepo,
        Plausible.IngestRepo,
        Plausible.AsyncInsertRepo,
        Plausible.ImportDeletionRepo,
        Plausible.Cache.Adapter.child_spec(:customer_currency, :cache_customer_currency,
          ttl_check_interval: :timer.minutes(5),
          n_lock_partitions: 1,
          global_ttl: :timer.minutes(60)
        ),
        Plausible.Cache.Adapter.child_spec(:user_agents, :cache_user_agents,
          ttl_check_interval: :timer.minutes(5),
          global_ttl: :timer.minutes(60),
          n_lock_partitions: 1,
          ets_options: [read_concurrency: true, write_concurrency: true]
        ),
        Plausible.Cache.Adapter.child_specs(:sessions, :cache_sessions,
          ttl_check_interval: :timer.seconds(10),
          global_ttl: :timer.minutes(30),
          n_lock_partitions: 1,
          ets_options: [read_concurrency: true, write_concurrency: true]
        ),
        {Plausible.Session.Transfer,
         base_path: Application.get_env(:plausible, :session_transfer_dir)},
        warmed_cache(Plausible.Site.Cache,
          adapter_opts: [
            n_lock_partitions: 1,
            ttl_check_interval: false,
            ets_options: [read_concurrency: true]
          ],
          warmers: [
            refresh_all:
              {Plausible.Site.Cache.All,
               interval: :timer.minutes(15) + Enum.random(1..:timer.seconds(10))},
            refresh_updated_recently:
              {Plausible.Site.Cache.RecentlyUpdated, interval: :timer.seconds(30)}
          ]
        ),
        warmed_cache(Plausible.Shield.IPRuleCache,
          adapter_opts: [
            n_lock_partitions: 1,
            ttl_check_interval: false,
            ets_options: [read_concurrency: true]
          ],
          warmers: [
            refresh_all:
              {Plausible.Shield.IPRuleCache.All,
               interval: :timer.minutes(3) + Enum.random(1..:timer.seconds(10))},
            refresh_updated_recently:
              {Plausible.Shield.IPRuleCache.RecentlyUpdated, interval: :timer.seconds(35)}
          ]
        ),
        warmed_cache(Plausible.Shield.CountryRuleCache,
          adapter_opts: [
            n_lock_partitions: 1,
            ttl_check_interval: false,
            ets_options: [read_concurrency: true]
          ],
          warmers: [
            refresh_all:
              {Plausible.Shield.CountryRuleCache.All,
               interval: :timer.minutes(3) + Enum.random(1..:timer.seconds(10))},
            refresh_updated_recently:
              {Plausible.Shield.CountryRuleCache.RecentlyUpdated, interval: :timer.seconds(35)}
          ]
        ),
        warmed_cache(Plausible.Shield.PageRuleCache,
          adapter_opts: [
            n_lock_partitions: 1,
            ttl_check_interval: false,
            ets_options: [:bag, read_concurrency: true]
          ],
          warmers: [
            refresh_all:
              {Plausible.Shield.PageRuleCache.All,
               interval: :timer.minutes(3) + Enum.random(1..:timer.seconds(10))},
            refresh_updated_recently:
              {Plausible.Shield.PageRuleCache.RecentlyUpdated, interval: :timer.seconds(35)}
          ]
        ),
        warmed_cache(Plausible.Shield.HostnameRuleCache,
          adapter_opts: [
            n_lock_partitions: 1,
            ttl_check_interval: false,
            ets_options: [:bag, read_concurrency: true]
          ],
          warmers: [
            refresh_all:
              {Plausible.Shield.HostnameRuleCache.All,
               interval: :timer.minutes(3) + Enum.random(1..:timer.seconds(10))},
            refresh_updated_recently:
              {Plausible.Shield.HostnameRuleCache.RecentlyUpdated, interval: :timer.seconds(25)}
          ]
        ),
        on_ee do
          warmed_cache(Plausible.Stats.SamplingCache,
            adapter_opts: [
              n_lock_partitions: 1,
              ttl_check_interval: false,
              read_concurrency: true
            ],
            warmers: [
              refresh_all:
                {Plausible.Stats.SamplingCache.All,
                 interval: :timer.hours(24) + Enum.random(1..:timer.minutes(60))}
            ]
          )
        end,
        on_ce do
          warmed_cache(PlausibleWeb.TrackerScriptCache,
            adapter_opts: [
              n_lock_partitions: 1,
              ttl_check_interval: false,
              ets_options: [:bag, read_concurrency: true]
            ],
            warmers: [
              refresh_all:
                {PlausibleWeb.TrackerScriptCache.All,
                 interval: :timer.minutes(180) + Enum.random(1..:timer.seconds(10))},
              refresh_updated_recently:
                {PlausibleWeb.TrackerScriptCache.RecentlyUpdated, interval: :timer.seconds(120)}
            ]
          )
        end,
        Plausible.Ingestion.Counters,
        Plausible.Session.Salts,
        Supervisor.child_spec(Plausible.Event.WriteBuffer, id: Plausible.Event.WriteBuffer),
        Supervisor.child_spec(Plausible.Session.WriteBuffer, id: Plausible.Session.WriteBuffer),
        ReferrerBlocklist,
        {Plausible.RateLimit, clean_period: :timer.minutes(10)},
        {Finch, name: Plausible.Finch, pools: finch_pool_config()},
        {Phoenix.PubSub, name: Plausible.PubSub},
        endpoint,
        {Oban, Application.get_env(:plausible, Oban)},
        on_ee do
          help_scout_vault()
        end
      ]
      |> List.flatten()
      |> Enum.reject(&is_nil/1)

    opts = [strategy: :one_for_one, name: Plausible.Supervisor]

    setup_request_logging()
    setup_sentry()
    setup_opentelemetry()

    setup_geolocation()
    Location.load_all()
    Plausible.Geo.await_loader()

    Supervisor.start_link(List.flatten(children), opts)
  end

  def config_change(changed, _new, removed) do
    PlausibleWeb.Endpoint.config_change(changed, removed)
    :ok
  end

  on_ee do
    defp help_scout_vault() do
      help_scout_vault_key =
        :plausible
        |> Application.fetch_env!(Plausible.HelpScout)
        |> Keyword.fetch!(:vault_key)
        |> Base.decode64!()

      [{Plausible.HelpScout.Vault, key: help_scout_vault_key}]
    end
  end

  defp totp_vault_key() do
    :plausible
    |> Application.fetch_env!(Plausible.Auth.TOTP)
    |> Keyword.fetch!(:vault_key)
  end

  defp finch_pool_config() do
    default = Application.get_env(:plausible, Plausible.Finch)

    base_config =
      if default do
        %{default: default}
      else
        %{}
      end

    default_opts = default || []

    base_config
    |> Map.put(
      "https://icons.duckduckgo.com",
      Config.Reader.merge(default_opts, conn_opts: [transport_opts: [timeout: 15_000]])
    )
    |> maybe_add_sentry_pool(default_opts)
    |> maybe_add_paddle_pool(default_opts)
    |> maybe_add_google_pools(default_opts)
  end

  defp maybe_add_sentry_pool(pool_config, default) do
    case Sentry.Config.dsn() do
      %{endpoint_uri: "http" <> _rest = url} ->
        Map.put(pool_config, url, Config.Reader.merge(default, size: 50))

      nil ->
        pool_config
    end
  end

  defp maybe_add_paddle_pool(pool_config, default) do
    paddle_conf = Application.get_env(:plausible, :paddle)

    cond do
      paddle_conf[:vendor_id] && paddle_conf[:vendor_auth_code] ->
        Map.put(
          pool_config,
          Plausible.Billing.PaddleApi.vendors_domain(),
          Config.Reader.merge(default, conn_opts: [transport_opts: [timeout: 15_000]])
        )

      true ->
        pool_config
    end
  end

  defp maybe_add_google_pools(pool_config, default) do
    google_conf = Application.get_env(:plausible, :google)

    cond do
      google_conf[:client_id] && google_conf[:client_secret] ->
        pool_config
        |> Map.put(
          google_conf[:api_url],
          Config.Reader.merge(default, conn_opts: [transport_opts: [timeout: 15_000]])
        )
        |> Map.put(
          google_conf[:reporting_api_url],
          Config.Reader.merge(default, conn_opts: [transport_opts: [timeout: 15_000]])
        )

      true ->
        pool_config
    end
  end

  def setup_request_logging() do
    :telemetry.attach(
      "plausible-request-logging",
      [:phoenix, :endpoint, :stop],
      &Plausible.RequestLogger.log_request/4,
      %{}
    )
  end

  def setup_sentry() do
    Logger.add_backend(Sentry.LoggerBackend)

    :telemetry.attach_many(
      "oban-errors",
      [[:oban, :job, :exception], [:oban, :notifier, :exception], [:oban, :plugin, :exception]],
      &ObanErrorReporter.handle_event/4,
      %{}
    )
  end

  defp setup_opentelemetry() do
    OpentelemetryPhoenix.setup()
    OpentelemetryEcto.setup([:plausible, :repo])
    OpentelemetryEcto.setup([:plausible, :clickhouse_repo])
    OpentelemetryOban.setup()
  end

  defp setup_geolocation do
    opts = Application.fetch_env!(:plausible, Plausible.Geo)
    :ok = Plausible.Geo.load_db(opts)
  end

  defp warmed_cache(impl_mod, opts) when is_atom(impl_mod) and is_list(opts) do
    warmers = Keyword.fetch!(opts, :warmers)

    warmer_specs =
      Enum.map(warmers, fn {warmer_fn, {warmer_id, warmer_opts}} ->
        {Plausible.Cache.Warmer,
         Keyword.merge(
           [
             child_name: warmer_id,
             cache_impl: impl_mod,
             warmer_fn: warmer_fn
           ],
           warmer_opts
         )}
      end)

    [{impl_mod, Keyword.fetch!(opts, :adapter_opts)} | warmer_specs]
  end

  on_ce do
    defp maybe_https_endpoint do
      endpoint_config = Application.fetch_env!(:plausible, PlausibleWeb.Endpoint)
      selfhost_config = Application.fetch_env!(:plausible, :selfhost)
      site_encrypt_config = Keyword.get(selfhost_config, :site_encrypt)

      if get_in(endpoint_config, [:https, :port]) do
        PlausibleWeb.Endpoint.force_https()
      end

      if site_encrypt_config do
        PlausibleWeb.Endpoint.allow_acme_challenges()
        {SiteEncrypt.Phoenix.Endpoint, endpoint: PlausibleWeb.Endpoint}
      else
        PlausibleWeb.Endpoint
      end
    end
  end
end
```

## File: `lib/plausible/async_insert_repo.ex`
```
defmodule Plausible.AsyncInsertRepo do
  @moduledoc """
  Clickhouse access with async inserts enabled
  """

  use Ecto.Repo,
    otp_app: :plausible,
    adapter: Ecto.Adapters.ClickHouse

  defmacro __using__(_) do
    quote do
      alias Plausible.AsyncInsertRepo
      import Ecto
      import Ecto.Query, only: [from: 1, from: 2]
    end
  end
end
```

## File: `lib/plausible/audit/repo.ex`
```
defmodule Plausible.Audit.Repo do
  @moduledoc """
  Equips Ecto.Repo with audited insert/update/delete variants.
  This module will potentially augment db operations with transaction wrappers.

  Audit is EE-specific, so CE gets only no-op adapter functions.
  """
  use Plausible

  @callback update_with_audit(
              changeset :: Ecto.Changeset.t(),
              entry_name :: any(),
              params :: map()
            ) :: {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}

  @callback update_with_audit!(
              changeset :: Ecto.Changeset.t(),
              entry_name :: any(),
              params :: map()
            ) :: Ecto.Schema.t()

  @callback insert_with_audit(
              changeset :: Ecto.Changeset.t(),
              entry_name :: any(),
              params :: map()
            ) :: {:ok, Ecto.Schema.t()} | {:error, Ecto.Changeset.t()}

  @callback insert_with_audit!(
              changeset :: Ecto.Changeset.t(),
              entry_name :: any(),
              params :: map(),
              insert_opts :: keyword()
            ) :: Ecto.Schema.t()

  @callback delete_with_audit!(
              resource :: Ecto.Schema.t() | Ecto.Changeset.t(),
              entry_name :: any(),
              params :: map()
            ) :: Ecto.Schema.t()

  defmacro __using__(_opts) do
    on_ee do
      quote do
        @behaviour Plausible.Audit.Repo

        def update_with_audit(%Ecto.Changeset{} = changeset, entry_name, params \\ %{}) do
          case update(changeset) do
            {:ok, result} ->
              store_audit(entry_name, result, changeset, params)

              {:ok, result}

            other ->
              other
          end
        end

        def update_with_audit!(%Ecto.Changeset{} = changeset, entry_name, params \\ %{}) do
          result = update!(changeset)
          store_audit(entry_name, result, changeset, params)
          result
        end

        def insert_with_audit(%Ecto.Changeset{} = changeset, entry_name, params \\ %{}) do
          case insert(changeset) do
            {:ok, result} ->
              store_audit(entry_name, result, params)

              {:ok, result}

            other ->
              other
          end
        end

        def insert_with_audit!(
              %Ecto.Changeset{} = changeset,
              entry_name,
              params \\ %{},
              insert_opts \\ []
            ) do
          result = insert!(changeset, insert_opts)
          store_audit(entry_name, result, params)
          result
        end

        def delete_with_audit!(resource, entry_name, params \\ %{}) do
          result = delete!(resource)
          store_audit(entry_name, resource, params)
          result
        end

        defp store_audit(entry_name, result, changeset, params) do
          entry_name
          |> Plausible.Audit.Entry.new(result, params)
          |> Plausible.Audit.Entry.include_change(changeset)
          |> Plausible.Audit.Entry.persist!()
        end

        defp store_audit(entry_name, result, params) do
          entry_name
          |> Plausible.Audit.Entry.new(result, params)
          |> Plausible.Audit.Entry.include_change(result)
          |> Plausible.Audit.Entry.persist!()
        end
      end
    else
      quote do
        @behaviour Plausible.Audit.Repo

        def update_with_audit(changeset, _, _) do
          update(changeset)
        end

        def update_with_audit!(changeset, _, _) do
          update!(changeset)
        end

        def insert_with_audit(changeset, _, _) do
          insert(changeset)
        end

        def insert_with_audit!(changeset, _, _, _) do
          insert!(changeset)
        end

        def delete_with_audit!(resource, _, _) do
          delete!(resource)
        end
      end
    end
  end
end
```

## File: `lib/plausible/auth/api_key.ex`
```
defmodule Plausible.Auth.ApiKey do
  use Plausible
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @required [:user_id, :name]
  @optional [:key, :scopes]

  @hourly_request_limit on_ee(do: 600, else: 1_000_000)

  schema "api_keys" do
    field :name, :string
    field :scopes, {:array, :string}, default: ["stats:read:*"]

    field :type, :string, virtual: true

    field :key, :string, virtual: true
    field :key_hash, :string
    field :key_prefix, :string

    belongs_to :team, Plausible.Teams.Team
    belongs_to :user, Plausible.Auth.User

    timestamps()
  end

  def hourly_request_limit(), do: @hourly_request_limit

  def changeset(struct, team, attrs) do
    struct
    |> cast(attrs, @required ++ @optional)
    |> validate_required(@required)
    |> maybe_put_key()
    |> process_key()
    |> maybe_put_team(team)
    |> unique_constraint(:key_hash, error_key: :key)
    |> unique_constraint([:team_id, :user_id], error_key: :team)
  end

  def update(struct, attrs \\ %{}) do
    struct
    |> cast(attrs, [:name, :user_id, :scopes])
    |> validate_required([:user_id, :name])
  end

  def do_hash(key) do
    :crypto.hash(:sha256, [secret_key_base(), key])
    |> Base.encode16()
    |> String.downcase()
  end

  def process_key(%{errors: [], changes: changes} = changeset) do
    prefix = binary_part(changes[:key], 0, 6)

    change(changeset,
      key_hash: do_hash(changes[:key]),
      key_prefix: prefix
    )
  end

  def process_key(changeset), do: changeset

  defp maybe_put_team(changeset, nil), do: changeset

  defp maybe_put_team(changeset, team) do
    put_assoc(changeset, :team, team)
  end

  defp maybe_put_key(changeset) do
    if get_change(changeset, :key) do
      changeset
    else
      key = :crypto.strong_rand_bytes(64) |> Base.url_encode64() |> binary_part(0, 64)
      put_change(changeset, :key, key)
    end
  end

  defp secret_key_base() do
    Application.get_env(:plausible, PlausibleWeb.Endpoint)
    |> Keyword.fetch!(:secret_key_base)
  end
end
```

## File: `lib/plausible/auth/auth.ex`
```
defmodule Plausible.Auth do
  @moduledoc """
  Functions for user authentication context.
  """

  use Plausible
  use Plausible.Repo

  import Ecto.Query

  alias Plausible.Auth
  alias Plausible.Billing
  alias Plausible.RateLimit
  alias Plausible.Teams

  require Logger

  @rate_limits %{
    login_ip: %{
      prefix: "login:ip",
      limit: 5,
      interval: :timer.seconds(60)
    },
    login_user: %{
      prefix: "login:user",
      limit: 5,
      interval: :timer.seconds(60)
    },
    email_change_user: %{
      prefix: "email-change:user",
      limit: 2,
      interval: :timer.hours(1)
    },
    password_change_user: %{
      prefix: "password-change:user",
      limit: 5,
      interval: :timer.minutes(20)
    }
  }

  @rate_limit_types Map.keys(@rate_limits)

  @type rate_limit_type() :: unquote(Enum.reduce(@rate_limit_types, &{:|, [], [&1, &2]}))

  @spec rate_limit(rate_limit_type(), Auth.User.t() | Plug.Conn.t()) ::
          :ok | {:error, {:rate_limit, rate_limit_type()}}
  def rate_limit(limit_type, key) when limit_type in @rate_limit_types do
    %{prefix: prefix, limit: limit, interval: interval} = @rate_limits[limit_type]
    full_key = "#{prefix}:#{rate_limit_key(key)}"

    case RateLimit.check_rate(full_key, interval, limit) do
      {:allow, _} -> :ok
      {:deny, _} -> {:error, {:rate_limit, limit_type}}
    end
  end

  @spec log_failed_login_attempt(String.t()) :: :ok
  def log_failed_login_attempt(message) do
    if Application.get_env(:plausible, :log_failed_login_attempts) do
      Logger.warning("[login] #{message}")
    end

    :ok
  end

  @spec find_user_by(Keyword.t()) :: Auth.User.t() | nil
  def find_user_by(opts) do
    Repo.get_by(Auth.User, opts)
  end

  @spec lookup(String.t()) :: {:ok, Auth.User.t()} | {:error, :user_not_found}
  def lookup(email) do
    query =
      on_ee do
        from(
          u in Auth.User,
          left_join: tm in assoc(u, :team_memberships),
          on: u.type == :sso and tm.role == :owner,
          left_join: t in assoc(tm, :team),
          where: u.email == ^email,
          where: u.type == :standard or (u.type == :sso and t.setup_complete == true)
        )
      else
        from(u in Auth.User, where: u.email == ^email)
      end

    case Repo.one(query) do
      %Auth.User{} = user -> {:ok, user}
      nil -> {:error, :user_not_found}
    end
  end

  @spec check_password(Auth.User.t(), String.t()) :: :ok | {:error, :wrong_password}
  def check_password(user, password) do
    if Plausible.Auth.Password.match?(password, user.password_hash || "") do
      :ok
    else
      {:error, :wrong_password}
    end
  end

  @spec delete_user(Auth.User.t()) ::
          {:ok, :deleted} | {:error, :is_only_team_owner | :active_subscription}
  def delete_user(user) do
    case Teams.get_by_owner(user) do
      {:ok, %{setup_complete: false} = team} ->
        delete_team_and_user(team, user)

      {:ok, team} ->
        with :ok <- check_can_leave_team(team) do
          delete_user!(user)
          {:ok, :deleted}
        end

      {:error, :multiple_teams} ->
        teams = Teams.Users.owned_teams(user)

        with :ok <- check_can_leave_teams(teams) do
          personal_team = Enum.find(teams, &(not Teams.setup?(&1)))
          delete_team_and_user(personal_team, user)
        end

      {:error, :no_team} ->
        delete_user!(user)
        {:ok, :deleted}
    end
  end

  defp delete_team_and_user(nil, user) do
    delete_user!(user)
    {:ok, :deleted}
  end

  defp delete_team_and_user(team, user) do
    Repo.transaction(fn ->
      case Teams.delete(team) do
        {:ok, :deleted} ->
          delete_user!(user)
          :deleted

        {:error, error} ->
          Repo.rollback(error)
      end
    end)
  end

  defp delete_user!(user) do
    Repo.transaction(fn ->
      Plausible.Segments.user_removed(user)
      Repo.delete!(user)
    end)

    :ok
  end

  defp check_can_leave_teams(teams) do
    teams
    |> Enum.filter(& &1.setup_complete)
    |> Enum.reduce_while(:ok, fn team, :ok ->
      case check_can_leave_team(team) do
        :ok -> {:cont, :ok}
        {:error, error} -> {:halt, {:error, error}}
      end
    end)
  end

  defp check_can_leave_team(team) do
    if Teams.Memberships.owners_count(team) > 1 do
      :ok
    else
      {:error, :is_only_team_owner}
    end
  end

  on_ee do
    def is_super_admin?(nil), do: false
    def is_super_admin?(%Plausible.Auth.User{id: id}), do: is_super_admin?(id)

    def is_super_admin?(user_id) when is_integer(user_id) do
      user_id in Application.get_env(:plausible, :super_admin_user_ids)
    end
  else
    def is_super_admin?(_), do: always(false)
  end

  @spec list_api_keys(Auth.User.t(), Teams.Team.t() | nil) :: [Auth.ApiKey.t()]
  def list_api_keys(user, team) do
    query =
      from(a in Auth.ApiKey,
        where: a.user_id == ^user.id,
        order_by: [desc: a.id],
        select: %{
          a
          | type:
              fragment(
                "CASE WHEN ? = ANY(?) THEN ? ELSE ? END",
                "sites:provision:*",
                a.scopes,
                "sites_api",
                "stats_api"
              )
        }
      )
      |> scope_api_keys_by_team(team)

    Repo.all(query)
  end

  @spec create_stats_api_key(Auth.User.t(), Teams.Team.t(), String.t(), String.t()) ::
          {:ok, Auth.ApiKey.t()} | {:error, Ecto.Changeset.t() | :upgrade_required}
  def create_stats_api_key(user, team, name, key) do
    params = %{name: name, user_id: user.id, key: key}
    changeset = Auth.ApiKey.changeset(%Auth.ApiKey{}, team, params)

    with :ok <- Billing.Feature.StatsAPI.check_availability(team) do
      Repo.insert(changeset)
    end
  end

  @spec create_sites_api_key(Auth.User.t(), Teams.Team.t(), String.t(), String.t()) ::
          {:ok, Auth.ApiKey.t()} | {:error, Ecto.Changeset.t() | :upgrade_required}
  def create_sites_api_key(user, team, name, key) do
    params = %{name: name, user_id: user.id, key: key, scopes: ["sites:provision:*"]}
    changeset = Auth.ApiKey.changeset(%Auth.ApiKey{}, team, params)

    with :ok <- Billing.Feature.StatsAPI.check_availability(team),
         :ok <- Billing.Feature.SitesAPI.check_availability(team) do
      Repo.insert(changeset)
    end
  end

  @spec delete_api_key(Auth.User.t(), integer()) :: :ok | {:error, :not_found}
  def delete_api_key(user, id) do
    query = from(api_key in Auth.ApiKey, where: api_key.id == ^id and api_key.user_id == ^user.id)

    case Repo.delete_all(query) do
      {1, _} -> :ok
      {0, _} -> {:error, :not_found}
    end
  end

  @spec find_api_key(String.t(), Keyword.t()) ::
          {:ok, %{api_key: Auth.ApiKey.t(), team: Teams.Team.t() | nil}}
          | {:error, :invalid_api_key | :missing_site_id}
  def find_api_key(raw_key, opts \\ []) do
    {team_scope, id} = Keyword.get(opts, :team_by, {nil, nil})

    find_api_key(raw_key, team_scope, id)
  end

  defp scope_api_keys_by_team(query, nil) do
    query
  end

  defp scope_api_keys_by_team(query, team) do
    where(query, [a], is_nil(a.team_id) or a.team_id == ^team.id)
  end

  defp find_api_key(raw_key, nil, _) do
    hashed_key = Auth.ApiKey.do_hash(raw_key)

    query =
      from(api_key in Auth.ApiKey,
        join: user in assoc(api_key, :user),
        left_join: team in assoc(api_key, :team),
        where: api_key.key_hash == ^hashed_key,
        preload: [user: user, team: team]
      )

    case Repo.one(query) do
      nil ->
        {:error, :invalid_api_key}

      %{team: %{} = team} = api_key ->
        {:ok, %{api_key: api_key, team: team}}

      api_key ->
        {:ok, %{api_key: api_key, team: nil}}
    end
  end

  defp find_api_key(raw_key, :site, nil) do
    find_api_key(raw_key, nil, nil)
  end

  defp find_api_key(raw_key, :site, domain) do
    case find_api_key(raw_key, nil, nil) do
      {:ok, %{api_key: api_key, team: nil}} ->
        team = find_team_by_site(domain)
        {:ok, %{api_key: api_key, team: team}}

      {:ok, %{api_key: api_key, team: team}} ->
        {:ok, %{api_key: api_key, team: team}}

      {:error, _} = error ->
        error
    end
  end

  defp find_team_by_site(domain) do
    Repo.one(
      from s in Plausible.Site,
        inner_join: t in assoc(s, :team),
        where: s.domain == ^domain or s.domain_changed_from == ^domain,
        select: t
    )
  end

  defp rate_limit_key(%Auth.User{id: id}), do: id
  defp rate_limit_key(%Plug.Conn{} = conn), do: PlausibleWeb.RemoteIP.get(conn)
end
```

## File: `lib/plausible/auth/email_activation_code.ex`
```
defmodule Plausible.Auth.EmailActivationCode do
  @moduledoc """
  Schema for email activation codes.
  """
  use Ecto.Schema

  import Ecto.Changeset

  alias Plausible.Auth.User

  @type t() :: %__MODULE__{}

  schema "email_activation_codes" do
    field :code, :string
    field :issued_at, :naive_datetime

    belongs_to :user, User
  end

  @spec new(User.t(), NaiveDateTime.t()) :: Ecto.Changeset.t()
  def new(user, now) do
    now = NaiveDateTime.truncate(now, :second)

    %__MODULE__{}
    |> change(code: generate_code(), issued_at: now)
    |> put_assoc(:user, user)
  end

  @spec generate_code() :: String.t()
  def generate_code do
    1000..9999
    |> Enum.random()
    |> Integer.to_string()
  end
end
```

## File: `lib/plausible/auth/email_verification.ex`
```
defmodule Plausible.Auth.EmailVerification do
  @moduledoc """
  API for verifying emails.
  """

  import Ecto.Query, only: [from: 2]

  alias Plausible.Auth
  alias Plausible.Auth.EmailActivationCode
  alias Plausible.Repo

  require Logger

  @expiration_hours 4

  @spec any?(Auth.User.t()) :: boolean()
  def any?(user) do
    Repo.exists?(from(v in EmailActivationCode, where: v.user_id == ^user.id))
  end

  @spec issue_code(Auth.User.t(), NaiveDateTime.t()) ::
          {:ok, EmailActivationCode.t()} | {:error, :hard_bounce | :unknown_error}
  def issue_code(user, now \\ NaiveDateTime.utc_now()) do
    now = NaiveDateTime.truncate(now, :second)

    verification =
      user
      |> EmailActivationCode.new(now)
      |> Repo.insert!(
        on_conflict: [
          set: [
            issued_at: now,
            code: EmailActivationCode.generate_code()
          ]
        ],
        conflict_target: :user_id,
        returning: true
      )

    email_template = PlausibleWeb.Email.activation_email(user, verification.code)

    case Plausible.Mailer.send(email_template) do
      :ok ->
        Logger.debug(
          "E-mail verification e-mail sent. In dev environment GET /sent-emails for details."
        )

        {:ok, verification}

      error ->
        error
    end
  end

  @spec verify_code(Auth.User.t(), String.t() | non_neg_integer()) ::
          :ok | {:error, :incorrect | :expired}
  def verify_code(user, code) do
    with {:ok, verification} <- get_verification(user, code) do
      Repo.transaction(fn ->
        user
        |> Ecto.Changeset.change(email_verified: true)
        |> Repo.update!()

        Repo.delete_all(from(c in EmailActivationCode, where: c.id == ^verification.id))
      end)

      :ok
    end
  end

  defp get_verification(user, code) do
    verification = Repo.get_by(EmailActivationCode, user_id: user.id, code: code)

    cond do
      is_nil(verification) ->
        {:error, :incorrect}

      expired?(verification) ->
        {:error, :expired}

      true ->
        {:ok, verification}
    end
  end

  @spec expired?(EmailActivationCode.t()) :: boolean()
  def expired?(verification) do
    expiration_time = NaiveDateTime.shift(NaiveDateTime.utc_now(), hour: -1 * @expiration_hours)
    NaiveDateTime.before?(verification.issued_at, expiration_time)
  end
end
```

## File: `lib/plausible/auth/password.ex`
```
defmodule Plausible.Auth.Password do
  def hash(password) do
    Bcrypt.hash_pwd_salt(password)
  end

  def match?(password, hash) do
    Bcrypt.verify_pass(password, hash)
  end

  def dummy_calculation do
    Bcrypt.no_user_verify()
  end
end
```

## File: `lib/plausible/auth/token.ex`
```
defmodule Plausible.Auth.Token do
  @one_hour_in_seconds 30 * 60

  def sign_shared_link(slug) do
    Phoenix.Token.sign(PlausibleWeb.Endpoint, "shared-link", %{slug: slug})
  end

  def verify_shared_link(token) do
    Phoenix.Token.verify(PlausibleWeb.Endpoint, "shared-link", token,
      max_age: @one_hour_in_seconds * 24
    )
  end

  def sign_password_reset(email) do
    Phoenix.Token.sign(PlausibleWeb.Endpoint, "password-reset", %{email: email})
  end

  def verify_password_reset(token) do
    Phoenix.Token.verify(PlausibleWeb.Endpoint, "password-reset", token,
      max_age: @one_hour_in_seconds
    )
  end
end
```

## File: `lib/plausible/auth/totp.ex`
```
defmodule Plausible.Auth.TOTP do
  @moduledoc """
  TOTP auth context

  Handles all the aspects of TOTP setup, management and validation for users.

  ## Setup

  TOTP setup is started with `initiate/1`. At this stage, a random secret
  binary is generated for user and stored under `User.totp_secret`. The secret
  is additionally encrypted while stored in the database using `Cloak`. The
  vault for safe storage is configured in `Plausible.Auth.TOTP.Vault` via
  a dedicated `Ecto` type defined in `Plausible.Auth.TOTP.EncryptedBinary`.
  The function returns updated user along with TOTP URI and a readable form
  of secret. Both - the URI and readable secret - are meant for exposure
  in the user's setup screen. The URI should be encoded as a QR code.

  After initiation, user is expected to confirm valid setup with `enable/2`,
  providing TOTP code from their authenticator app. After code validation
  passes successfully, the `User.totp_enabled` flag is set to `true`.
  Finally, the user must be immediately presented with a list of recovery codes
  returned by the same call of `enable/2`. The codes should be presented
  in copy/paste friendly form, ideally also with a print-friendly view option.

  The `initiate/1` and `enable/1` functions can be safely called multiple
  times, allowing user to abort and restart setup up to these stages.

  ## Management

  The state of TOTP for a particular user can be chcecked by calling
  `enabled?/1` or `initiated?/1`.

  TOTP can be disabled with `disable/2`. User is expected to provide their
  current password for safety. Once disabled, all TOTP user settings are
  cleared and any remaining generated recovery codes are removed. The function
  can be safely run more than once. There's also alternative call for forced
  disabling of TOTP for a given user without sending any notification,
  `force_disable/1`. It's meant for use in situation where user lost both,
  2FA device and recovery codes and their identity is verified independently.

  If the user needs to regenerate the recovery codes outside of setup procedure,
  they must do it via `generate_recovery_codes/2`, providing their current
  password for safety. They must be warned that any existing recovery codes
  will be invalidated.

  ## Validation

  After logging in, user's TOTP state must be checked with `enabled?/1`.

  If enabled, user must be presented with TOTP code input form accepting
  6 digit characters. The code must be checked using `validate_code/2`.

  User must have an option to alternatively input one of their recovery
  codes. Those codes must be checked with `use_recovery_code/2`.

  ## Code validity

  In case of TOTP codes, a grace period of 30 seconds is applied, which
  allows user to use their current and previous TOTP code, assuming 30
  second validity window of each. This allows user to use code that was
  about to expire before the submission. Regardless of that, each TOTP
  code can be used only once. Validation procedure rejects repeat use
  of the same code for safety. It's done by tracking last time a TOTP
  code was used successfully, stored under `User.totp_last_used_at`.

  In case of recovery codes, each code is deleted immediately after use.
  They are strictly one-time use only.

  ## TOTP Token

  TOTP token is an alternate method of authenticating  user session.
  It's main use case is "trust this device" functionality, where user
  can decide to skip 2FA verification for a particular browser session
  for next N days. The token should then be stored in an encrypted,
  signed cookie with a proper expiration timestamp.

  The token should be reset each time it either fails to match
  or when other credentials (like password) are reset. This should
  effectively invalidate all trusted devices for a given user.

  """

  import Ecto.Changeset, only: [change: 2]
  import Ecto.Query, only: [from: 2]

  alias Plausible.Auth
  alias Plausible.Auth.TOTP
  alias Plausible.Repo
  alias PlausibleWeb.Email

  @recovery_codes_count 10

  @spec enabled?(Auth.User.t()) :: boolean()
  def enabled?(user) do
    user.totp_enabled and not is_nil(user.totp_secret)
  end

  @spec initiated?(Auth.User.t()) :: boolean()
  def initiated?(user) do
    not user.totp_enabled and not is_nil(user.totp_secret)
  end

  @spec initiate(Auth.User.t()) ::
          {:ok, Auth.User.t(), %{totp_uri: String.t(), secret: String.t()}}
          | {:error, :not_verified | :already_setup}
  def initiate(%{email_verified: false}) do
    {:error, :not_verified}
  end

  def initiate(%{totp_enabled: true}) do
    {:error, :already_setup}
  end

  def initiate(user) do
    secret = NimbleTOTP.secret()

    user =
      user
      |> change(
        totp_enabled: false,
        totp_secret: secret,
        totp_token: nil
      )
      |> Repo.update!()

    {:ok, user, %{totp_uri: totp_uri(user), secret: readable_secret(user)}}
  end

  @spec enable(Auth.User.t(), String.t() | :skip_verify, Keyword.t()) ::
          {:ok, Auth.User.t(), %{recovery_codes: [String.t()]}}
          | {:error, :invalid_code | :not_initiated}
  def enable(user, code, opts \\ [])

  def enable(%{totp_secret: nil}, _, _) do
    {:error, :not_initiated}
  end

  def enable(user, :skip_verify, _opts) do
    do_enable(user)
  end

  def enable(user, code, opts) do
    with {:ok, user} <- do_validate_code(user, code, opts) do
      do_enable(user)
    end
  end

  defp do_enable(user) do
    {:ok, {user, recovery_codes}} =
      Repo.transaction(fn ->
        user =
          user
          |> change(
            totp_enabled: true,
            totp_token: generate_token()
          )
          |> Repo.update!()

        {:ok, recovery_codes} = do_generate_recovery_codes(user)

        {user, recovery_codes}
      end)

    user
    |> Email.two_factor_enabled_email()
    |> Plausible.Mailer.send()

    {:ok, user, %{recovery_codes: recovery_codes}}
  end

  @spec disable(Auth.User.t(), String.t()) :: {:ok, Auth.User.t()} | {:error, :invalid_password}
  def disable(user, password) do
    if Auth.Password.match?(password, user.password_hash) do
      {:ok, user} = disable_for(user)

      user
      |> Email.two_factor_disabled_email()
      |> Plausible.Mailer.send()

      {:ok, user}
    else
      {:error, :invalid_password}
    end
  end

  @spec force_disable(Auth.User.t()) :: {:ok, Auth.User.t()}
  def force_disable(user) do
    disable_for(user)
  end

  @spec reset_token(Auth.User.t()) :: Auth.User.t()
  def reset_token(user) do
    new_token =
      if user.totp_enabled do
        generate_token()
      end

    user
    |> change(totp_token: new_token)
    |> Repo.update!()
  end

  @spec generate_recovery_codes(Auth.User.t(), String.t()) ::
          {:ok, [String.t()]} | {:error, :invalid_password | :not_enabled}
  def generate_recovery_codes(%{totp_enabled: false}) do
    {:error, :not_enabled}
  end

  def generate_recovery_codes(user, password) do
    if Auth.Password.match?(password, user.password_hash) do
      do_generate_recovery_codes(user)
    else
      {:error, :invalid_password}
    end
  end

  defp do_generate_recovery_codes(%{totp_enabled: false}) do
    {:error, :not_enabled}
  end

  defp do_generate_recovery_codes(user) do
    Repo.transaction(fn ->
      {_, _} =
        user
        |> recovery_codes_query()
        |> Repo.delete_all()

      plain_codes = TOTP.RecoveryCode.generate_codes(@recovery_codes_count)

      now =
        NaiveDateTime.utc_now()
        |> NaiveDateTime.truncate(:second)

      codes =
        plain_codes
        |> Enum.map(fn plain_code ->
          user
          |> TOTP.RecoveryCode.changeset(plain_code)
          |> TOTP.RecoveryCode.changeset_to_map(now)
        end)

      {_, _} = Repo.insert_all(TOTP.RecoveryCode, codes)

      plain_codes
    end)
  end

  @spec validate_code(Auth.User.t(), String.t(), Keyword.t()) ::
          {:ok, Auth.User.t()} | {:error, :invalid_code | :not_enabled}
  def validate_code(user, code, opts \\ [])

  def validate_code(%{totp_enabled: false}, _, _) do
    {:error, :not_enabled}
  end

  def validate_code(user, code, opts) do
    do_validate_code(user, code, opts)
  end

  @spec use_recovery_code(Auth.User.t(), String.t()) ::
          :ok | {:error, :invalid_code | :not_enabled}
  def use_recovery_code(%{totp_enabled: false}, _) do
    {:error, :not_enabled}
  end

  def use_recovery_code(user, code) do
    matching_code =
      user
      |> recovery_codes_query()
      |> Repo.all()
      |> Enum.find(&TOTP.RecoveryCode.match?(&1, code))

    if matching_code do
      Repo.delete!(matching_code)
      :ok
    else
      {:error, :invalid_code}
    end
  end

  defp disable_for(user) do
    Repo.transaction(fn ->
      {_, _} =
        user
        |> recovery_codes_query()
        |> Repo.delete_all()

      user
      |> change(
        totp_enabled: false,
        totp_token: nil,
        totp_secret: nil,
        totp_last_used_at: nil
      )
      |> Repo.update!()
    end)
  end

  defp totp_uri(user) do
    issuer_name = Plausible.product_name()
    NimbleTOTP.otpauth_uri("#{issuer_name}:#{user.email}", user.totp_secret, issuer: issuer_name)
  end

  defp readable_secret(user) do
    Base.encode32(user.totp_secret, padding: false)
  end

  defp recovery_codes_query(user) do
    from(rc in TOTP.RecoveryCode, where: rc.user_id == ^user.id)
  end

  defp do_validate_code(user, code, opts) do
    # Necessary because we must be sure the timestamp is current.
    # User struct stored in liveview context on mount might be
    # pretty out of date, for instance.
    last_used =
      if Keyword.get(opts, :allow_reuse?) do
        nil
      else
        fetch_last_used(user)
      end

    time = System.os_time(:second)

    if NimbleTOTP.valid?(user.totp_secret, code, since: last_used, time: time) or
         NimbleTOTP.valid?(user.totp_secret, code, since: last_used, time: time - 30) do
      {:ok, bump_last_used!(user)}
    else
      {:error, :invalid_code}
    end
  end

  defp fetch_last_used(user) do
    datetime =
      from(u in Plausible.Auth.User, where: u.id == ^user.id, select: u.totp_last_used_at)
      |> Repo.one()

    if datetime do
      Timex.to_unix(datetime)
    end
  end

  defp bump_last_used!(user) do
    now = NaiveDateTime.utc_now() |> NaiveDateTime.truncate(:second)

    user
    |> change(totp_last_used_at: now)
    |> Repo.update!()
  end

  defp generate_token() do
    20
    |> :crypto.strong_rand_bytes()
    |> Base.encode64(padding: false)
  end
end
```

## File: `lib/plausible/auth/totp/encrypted_binary.ex`
```
defmodule Plausible.Auth.TOTP.EncryptedBinary do
  @moduledoc """
  Defines an Ecto type so Cloak.Ecto can encrypt/decrypt a binary field.
  """

  use Cloak.Ecto.Binary, vault: Plausible.Auth.TOTP.Vault
end
```

## File: `lib/plausible/auth/totp/recovery_code.ex`
```
defmodule Plausible.Auth.TOTP.RecoveryCode do
  @moduledoc """
  Schema for TOTP recovery codes.
  """

  use Ecto.Schema

  alias Plausible.Auth

  import Ecto.Changeset

  @type t :: %__MODULE__{}

  @code_length 10

  schema "totp_recovery_codes" do
    field :code_digest, :string

    belongs_to :user, Plausible.Auth.User

    timestamps(updated_at: false)
  end

  @doc """
  Generates `count` unique recovery codes, each alphanumeric
  and #{@code_length} characters long.
  """
  @spec generate_codes(non_neg_integer()) :: [String.t()]
  def generate_codes(count) do
    Stream.repeatedly(&generate_code/0)
    |> Stream.map(&disambiguate/1)
    |> Stream.uniq()
    |> Enum.take(count)
  end

  @spec match?(t(), String.t()) :: boolean()
  def match?(recovery_code, input_code) do
    Bcrypt.verify_pass(input_code, recovery_code.code_digest)
  end

  @spec changeset(Auth.User.t(), String.t()) :: Ecto.Changeset.t()
  def changeset(user, code) do
    %__MODULE__{}
    |> change()
    |> put_assoc(:user, user)
    |> put_change(:code_digest, hash(code))
  end

  @spec changeset_to_map(Ecto.Changeset.t(), NaiveDateTime.t()) :: map()
  def changeset_to_map(changeset, now) do
    changeset
    |> apply_changes()
    |> Map.take([:user_id, :code_digest])
    |> Map.put(:inserted_at, now)
  end

  @safe_disambiguations %{
    "O" => "8",
    "I" => "7"
  }

  @doc false
  # Exposed for testing only
  def disambiguate(code) do
    String.replace(
      code,
      Map.keys(@safe_disambiguations),
      &Map.fetch!(@safe_disambiguations, &1)
    )
  end

  defp generate_code() do
    Base.encode32(:crypto.strong_rand_bytes(6), padding: false)
  end

  defp hash(code) when byte_size(code) == @code_length do
    Bcrypt.hash_pwd_salt(code)
  end
end
```

## File: `lib/plausible/auth/totp/vault.ex`
```
defmodule Plausible.Auth.TOTP.Vault do
  @moduledoc """
  Provides a vault that will be used to encrypt/decrypt the TOTP secrets of users who enable it.
  """

  use Cloak.Vault, otp_app: :plausible

  @impl GenServer
  def init(config) do
    {key, config} = Keyword.pop!(config, :key)

    config =
      Keyword.put(config, :ciphers,
        default: {Cloak.Ciphers.AES.GCM, tag: "AES.GCM.V1", iv_length: 12, key: key}
      )

    {:ok, config}
  end
end
```

## File: `lib/plausible/auth/user.ex`
```
defimpl Bamboo.Formatter, for: Plausible.Auth.User do
  def format_email_address(user, _opts) do
    {user.name, user.email}
  end
end

defimpl FunWithFlags.Actor, for: Plausible.Auth.User do
  def id(%{id: id}) do
    "user:#{id}"
  end
end

defmodule Plausible.Auth.User do
  use Plausible
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @required [:email, :name, :password]

  on_ee do
    @derive {Plausible.Audit.Encoder,
             only: [
               :id,
               :email,
               :name,
               :email_verified,
               :previous_email,
               :totp_enabled,
               :last_team_identifier,
               :sso_integration,
               :sso_domain
             ]}
  end

  schema "users" do
    field :email, :string
    field :password_hash
    field :old_password, :string, virtual: true
    field :password, :string, virtual: true
    field :password_confirmation, :string, virtual: true
    field :name, :string
    field :last_seen, :naive_datetime
    field :theme, Ecto.Enum, values: [:system, :light, :dark]
    field :email_verified, :boolean
    field :previous_email, :string

    # Field for purely informational purposes in CRM context
    field :notes, :string

    # Fields for TOTP authentication. See `Plausible.Auth.TOTP`.
    field :totp_enabled, :boolean, default: false
    field :totp_secret, Plausible.Auth.TOTP.EncryptedBinary
    field :totp_token, :string
    field :totp_last_used_at, :naive_datetime

    # for context perseverance across sessions
    field :last_team_identifier, Ecto.UUID

    on_ee do
      # Fields for SSO
      field :type, Ecto.Enum, values: [:standard, :sso]
      field :sso_identity_id, :string
      field :last_sso_login, :naive_datetime

      belongs_to :sso_integration, Plausible.Auth.SSO.Integration, on_replace: :nilify
      belongs_to :sso_domain, Plausible.Auth.SSO.Domain, on_replace: :nilify
    end

    has_many :sessions, Plausible.Auth.UserSession
    has_many :team_memberships, Plausible.Teams.Membership
    has_many :api_keys, Plausible.Auth.ApiKey
    has_one :google_auth, Plausible.Site.GoogleAuth
    has_many :owner_memberships, Plausible.Teams.Membership, where: [role: :owner]
    has_many :owned_teams, through: [:owner_memberships, :team]

    on_ce do
      # we only need this for backfill teams migration to work; let's figure out how to safely remove later on
      field :trial_expiry_date, :date
    end

    timestamps()
  end

  def new(attrs \\ %{}) do
    %Plausible.Auth.User{}
    |> cast(attrs, @required)
    |> validate_required(@required)
    |> validate_password_length()
    |> validate_confirmation(:password, required: true)
    |> validate_password_strength()
    |> hash_password()
    |> set_email_verification_status()
    |> unique_constraint(:email)
  end

  def name_changeset(user, attrs \\ %{}) do
    user
    |> cast(attrs, [:name])
    |> validate_required([:name])
  end

  def theme_changeset(user, attrs \\ %{}) do
    user
    |> cast(attrs, [:theme])
    |> validate_required([:theme])
  end

  def settings_changeset(user, attrs \\ %{}) do
    user
    |> cast(attrs, [:email, :name, :theme])
    |> validate_required([:email, :name, :theme])
    |> unique_constraint(:email)
  end

  def email_changeset(user, attrs \\ %{}) do
    user
    |> cast(attrs, [:email, :password])
    |> validate_required([:email, :password])
    |> validate_email_changed()
    |> check_password()
    |> unique_constraint(:email)
    |> set_email_verification_status()
    |> put_change(:previous_email, user.email)
  end

  def cancel_email_changeset(user) do
    if user.previous_email do
      user
      |> change()
      |> unique_constraint(:email)
      |> put_change(:email_verified, true)
      |> put_change(:email, user.previous_email)
      |> put_change(:previous_email, nil)
    else
      # It shouldn't happen under normal circumstances
      raise "Previous email is empty for user #{user.id} (#{user.email}) when it shouldn't."
    end
  end

  def changeset(user, attrs \\ %{}) do
    user
    |> cast(attrs, [:email, :name, :email_verified, :theme, :notes])
    |> validate_required([:email, :name, :email_verified])
    |> unique_constraint(:email)
  end

  def set_password(user, password) do
    user
    |> cast(%{password: password}, [:password])
    |> validate_required([:password])
    |> validate_password_length()
    |> validate_password_strength()
    |> hash_password()
  end

  def password_changeset(user, params \\ %{}) do
    user
    |> cast(params, [:old_password, :password])
    |> check_password(:old_password)
    |> validate_required([:old_password, :password])
    |> validate_password_length()
    |> validate_confirmation(:password, required: true)
    |> validate_password_strength()
    |> validate_password_changed()
    |> hash_password()
  end

  def hash_password(%{errors: [], changes: changes} = changeset) do
    hash = Plausible.Auth.Password.hash(changes[:password])
    change(changeset, password_hash: hash)
  end

  def hash_password(changeset), do: changeset

  def password_strength(changeset) do
    case get_field(changeset, :password) do
      nil ->
        %{suggestions: [], warning: "", score: 0}

      # Passwords past (approximately) 32 characters are treated
      # as strong, despite what they contain, to avoid unnecessarily
      # expensive computation.
      password when byte_size(password) > 32 ->
        %{suggestions: [], warning: "", score: 4}

      password ->
        existing_phrases =
          []
          |> maybe_add_phrase(get_field(changeset, :name))
          |> maybe_add_phrase(get_field(changeset, :email))

        case ZXCVBN.zxcvbn(password, existing_phrases) do
          %{score: score, feedback: feedback} ->
            %{suggestions: feedback.suggestions, warning: feedback.warning, score: score}

          :error ->
            %{suggestions: [], warning: "", score: 3}
        end
    end
  catch
    _kind, _value ->
      %{suggestions: [], warning: "", score: 3}
  end

  def profile_img_url(%__MODULE__{email: email}) do
    hash =
      email
      |> String.trim()
      |> String.downcase()
      |> :erlang.md5()
      |> Base.encode16(case: :lower)

    Path.join(PlausibleWeb.Endpoint.url(), ["avatar/", hash])
  end

  def profile_img_url(email) when is_binary(email) do
    profile_img_url(%__MODULE__{email: email})
  end

  defp validate_email_changed(changeset) do
    if !get_change(changeset, :email) && !changeset.errors[:email] do
      add_error(changeset, :email, "can't be the same", validation: :different_email)
    else
      changeset
    end
  end

  defp validate_password_changed(changeset) do
    old_password = get_change(changeset, :old_password)
    new_password = get_change(changeset, :password)

    if old_password == new_password do
      add_error(changeset, :password, "is too weak", validation: :different_password)
    else
      changeset
    end
  end

  defp check_password(changeset, field \\ :password) do
    if password = get_change(changeset, field) do
      if Plausible.Auth.Password.match?(password, changeset.data.password_hash) do
        changeset
      else
        add_error(changeset, field, "is invalid", validation: :check_password)
      end
    else
      changeset
    end
  end

  defp validate_password_length(changeset) do
    changeset
    |> validate_length(:password, min: 12, message: "has to be at least 12 characters")
    |> validate_length(:password, max: 128, message: "cannot be longer than 128 characters")
  end

  defp validate_password_strength(changeset) do
    if get_change(changeset, :password) != nil and password_strength(changeset).score <= 2 do
      add_error(changeset, :password, "is too weak", validation: :strength)
    else
      changeset
    end
  end

  defp maybe_add_phrase(phrases, nil), do: phrases

  defp maybe_add_phrase(phrases, phrase) do
    parts = String.split(phrase)

    [phrase, parts]
    |> List.flatten(phrases)
    |> Enum.uniq()
  end

  defp set_email_verification_status(user) do
    on_ee do
      change(user, email_verified: false)
    else
      selfhosted_config = Application.get_env(:plausible, :selfhost)
      must_verify? = Keyword.fetch!(selfhosted_config, :enable_email_verification)
      change(user, email_verified: not must_verify?)
    end
  end
end
```

## File: `lib/plausible/auth/user_session.ex`
```
defmodule Plausible.Auth.UserSession do
  @moduledoc """
  Schema for storing user session data.
  """

  use Ecto.Schema
  use Plausible

  import Ecto.Changeset

  alias Plausible.Auth

  @type t() :: %__MODULE__{}

  @rand_size 32
  @timeout Duration.new!(day: 14)

  schema "user_sessions" do
    field :token, :binary
    field :device, :string
    field :last_used_at, :naive_datetime
    field :timeout_at, :naive_datetime

    belongs_to :user, Plausible.Auth.User

    timestamps(updated_at: false)
  end

  @spec timeout_duration() :: Duration.t()
  def timeout_duration(), do: @timeout

  @spec new_session(Auth.User.t(), String.t(), Keyword.t()) :: Ecto.Changeset.t()
  def new_session(user, device, opts \\ []) do
    now = Keyword.get(opts, :now, NaiveDateTime.utc_now(:second))
    timeout_at = Keyword.get(opts, :timeout_at, NaiveDateTime.shift(now, @timeout))

    %__MODULE__{}
    |> cast(%{device: device}, [:device])
    |> generate_token()
    |> put_assoc(:user, user)
    |> put_change(:timeout_at, timeout_at)
    |> touch_session(now)
  end

  @spec touch_session(t() | Ecto.Changeset.t(), NaiveDateTime.t()) :: Ecto.Changeset.t()
  def touch_session(session, now \\ NaiveDateTime.utc_now(:second)) do
    changeset = change(session)

    on_ee do
      case get_field(changeset, :user) do
        %{type: :sso} ->
          put_change(changeset, :last_used_at, now)

        _ ->
          changeset
          |> put_change(:last_used_at, now)
          |> put_change(:timeout_at, NaiveDateTime.shift(now, @timeout))
      end
    else
      changeset
      |> put_change(:last_used_at, now)
      |> put_change(:timeout_at, NaiveDateTime.shift(now, @timeout))
    end
  end

  defp generate_token(changeset) do
    token = :crypto.strong_rand_bytes(@rand_size)
    put_change(changeset, :token, token)
  end
end
```

## File: `lib/plausible/auth/user_sessions.ex`
```
defmodule Plausible.Auth.UserSessions do
  @moduledoc """
  Functions for interacting with user sessions.
  """

  use Plausible

  import Ecto.Query
  alias Plausible.Auth
  alias Plausible.Repo

  @socket_id_prefix "user_sessions:"

  @spec list_for_user(Auth.User.t(), NaiveDateTime.t()) :: [Auth.UserSession.t()]
  def list_for_user(user, now \\ NaiveDateTime.utc_now(:second)) do
    Repo.all(
      from us in Auth.UserSession,
        where: us.user_id == ^user.id,
        where: us.timeout_at >= ^now,
        order_by: [desc: us.last_used_at, desc: us.id]
    )
  end

  @spec count_for_users([Auth.User.t()], NaiveDateTime.t()) :: list()
  def count_for_users(users, now \\ NaiveDateTime.utc_now(:second)) when is_list(users) do
    Repo.all(
      from(us in Auth.UserSession,
        where: us.user_id in ^Enum.map(users, & &1.id),
        where: us.timeout_at >= ^now,
        group_by: us.user_id,
        select: {us.user_id, count(us.id)},
        order_by: [asc: us.user_id]
      )
    )
  end

  on_ee do
    alias Plausible.Teams

    @spec list_sso_for_team(Teams.Team.t(), NaiveDateTime.t()) :: [Auth.UserSession.t()]
    def list_sso_for_team(team, now \\ NaiveDateTime.utc_now(:second)) do
      user_ids =
        Repo.all(
          from t in Teams.Team,
            inner_join: tm in assoc(t, :team_memberships),
            inner_join: u in assoc(tm, :user),
            where: t.id == ^team.id,
            where: tm.role != :guest,
            where: u.type == :sso,
            select: u.id
        )

      Repo.all(
        from us in Auth.UserSession,
          inner_join: u in assoc(us, :user),
          where: us.user_id in ^user_ids,
          where: us.timeout_at >= ^now,
          order_by: [desc: us.last_used_at, desc: us.id],
          preload: [user: u]
      )
    end

    @spec revoke_sso_by_id(Teams.Team.t(), pos_integer()) :: :ok
    def revoke_sso_by_id(team, session_id) do
      {_, tokens} =
        Repo.delete_all(
          from us in Auth.UserSession,
            inner_join: u in assoc(us, :user),
            inner_join: tm in assoc(u, :team_memberships),
            where: u.type == :sso,
            where: us.id == ^session_id,
            where: tm.role != :guest,
            where: tm.team_id == ^team.id,
            select: us.token
        )

      case tokens do
        [token] ->
          disconnect_by_token(token)

        _ ->
          :pass
      end

      :ok
    end
  end

  @spec last_used_humanize(Auth.UserSession.t(), NaiveDateTime.t()) :: String.t()
  def last_used_humanize(user_session, now \\ NaiveDateTime.utc_now(:second)) do
    diff = NaiveDateTime.diff(now, user_session.last_used_at, :hour)
    diff_days = NaiveDateTime.diff(now, user_session.last_used_at, :day)

    cond do
      diff < 1 -> "Just recently"
      diff == 1 -> "1 hour ago"
      diff < 24 -> "#{diff} hours ago"
      diff < 2 * 24 -> "Yesterday"
      true -> "#{diff_days} days ago"
    end
  end

  @spec get_by_token(String.t()) ::
          {:ok, Auth.UserSession.t()}
          | {:error, :not_found}
          | {:error, :expired, Auth.UserSession.t()}
  def get_by_token(token) do
    now = NaiveDateTime.utc_now(:second)

    last_team_subscription_query = Plausible.Teams.last_subscription_join_query()

    token_query =
      from(us in Auth.UserSession,
        inner_join: u in assoc(us, :user),
        as: :user,
        left_join: tm in assoc(u, :team_memberships),
        on: tm.role != :guest,
        left_join: t in assoc(tm, :team),
        as: :team,
        left_join: o in assoc(t, :owners),
        left_lateral_join: ts in subquery(last_team_subscription_query),
        on: true,
        where: us.token == ^token,
        order_by: t.id,
        preload: [user: {u, team_memberships: {tm, team: {t, subscription: ts, owners: o}}}]
      )

    case Repo.one(token_query) do
      %Auth.UserSession{} = user_session ->
        if NaiveDateTime.compare(user_session.timeout_at, now) == :gt do
          {:ok, user_session}
        else
          {:error, :expired, user_session}
        end

      nil ->
        {:error, :not_found}
    end
  end

  @spec create!(Auth.User.t(), String.t(), Keyword.t()) :: Auth.UserSession.t()
  def create!(user, device_name, opts \\ []) do
    user
    |> Auth.UserSession.new_session(device_name, opts)
    |> Repo.insert!()
  end

  @spec remove_by_token(String.t()) :: :ok
  def remove_by_token(token) do
    Repo.delete_all(from us in Auth.UserSession, where: us.token == ^token)
    :ok
  end

  @spec touch(Auth.UserSession.t(), NaiveDateTime.t()) :: Auth.UserSession.t()
  def touch(user_session, now \\ NaiveDateTime.utc_now(:second)) do
    if NaiveDateTime.diff(now, user_session.last_used_at, :hour) >= 1 do
      Plausible.Users.bump_last_seen(user_session.user_id, now)

      user_session
      |> Repo.preload(:user)
      |> Auth.UserSession.touch_session(now)
      |> Repo.update!(allow_stale: true)
    else
      user_session
    end
  end

  @spec revoke_by_id(Auth.User.t(), pos_integer()) :: :ok
  def revoke_by_id(user, session_id) do
    {_, tokens} =
      Repo.delete_all(
        from us in Auth.UserSession,
          where: us.user_id == ^user.id and us.id == ^session_id,
          select: us.token
      )

    case tokens do
      [token] ->
        disconnect_by_token(token)

      _ ->
        :pass
    end

    :ok
  end

  @spec revoke_all(Auth.User.t(), Keyword.t()) :: :ok
  def revoke_all(user, opts \\ []) do
    except = Keyword.get(opts, :except)

    delete_query = from us in Auth.UserSession, where: us.user_id == ^user.id, select: us.token

    delete_query =
      if except do
        where(delete_query, [us], us.id != ^except.id)
      else
        delete_query
      end

    {_count, tokens} = Repo.delete_all(delete_query)

    Enum.each(tokens, &disconnect_by_token/1)
  end

  @spec disconnect_by_token(String.t()) :: :ok
  def disconnect_by_token(token_or_socket_id) do
    socket_id =
      if String.starts_with?(token_or_socket_id, @socket_id_prefix) do
        token_or_socket_id
      else
        socket_id(token_or_socket_id)
      end

    PlausibleWeb.Endpoint.broadcast(socket_id, "disconnect", %{})
    :ok
  end

  @spec socket_id(String.t()) :: String.t()
  def socket_id(token) do
    @socket_id_prefix <> Base.url_encode64(token)
  end
end
```

## File: `lib/plausible/billing/billing.ex`
```
defmodule Plausible.Billing do
  use Plausible
  use Plausible.Repo
  require Plausible.Billing.Subscription.Status
  alias Plausible.Auth
  alias Plausible.Billing.Subscription
  alias Plausible.Teams

  def subscription_created(params) do
    Repo.transaction(fn ->
      handle_subscription_created(params)
    end)
  end

  def subscription_updated(params) do
    Repo.transaction(fn ->
      handle_subscription_updated(params)
    end)
  end

  def subscription_cancelled(params) do
    Repo.transaction(fn ->
      handle_subscription_cancelled(params)
    end)
  end

  def subscription_payment_succeeded(params) do
    Repo.transaction(fn ->
      handle_subscription_payment_succeeded(params)
    end)
  end

  def change_plan_preview(subscription, new_plan_id) do
    case paddle_api().update_subscription_preview(
           subscription.paddle_subscription_id,
           new_plan_id
         ) do
      {:ok, response} ->
        {:ok, response}

      {:error, reason} ->
        {:error, reason}
    end
  end

  defp handle_subscription_created(params) do
    team = get_team!(params)

    subscription_params =
      params
      |> format_subscription()
      |> add_last_bill_date(params)

    team
    |> Subscription.create_changeset(subscription_params)
    |> Repo.insert!()
    |> after_subscription_update()
  end

  defp handle_subscription_updated(params) do
    subscription = Repo.get_by(Subscription, paddle_subscription_id: params["subscription_id"])

    # In a situation where the subscription is paused and a payment succeeds, we
    # get notified of two "subscription_updated" webhook alerts from Paddle at the
    # same time.
    #
    #   * one with an `old_status` of "paused", and a `status` of "past_due"
    #   * the other with an `old_status` of "past_due", and a `status` of "active"
    #
    # https://developer.paddle.com/classic/guides/zg9joji1mzu0mduy-payment-failures
    #
    # Relying on the time when the webhooks are sent has caused issues where
    # subscriptions have ended up `past_due` after a successful payment. Therefore,
    # we're now explicitly ignoring the first webhook (with the update that's not
    # relevant to us).
    irrelevant? = params["old_status"] == "paused" && params["status"] == "past_due"

    if subscription && not irrelevant? do
      params = format_subscription(params)

      subscription
      |> Subscription.changeset(params)
      |> Repo.update!()
      |> after_subscription_update()
    end
  end

  defp handle_subscription_cancelled(params) do
    subscription =
      Subscription
      |> Repo.get_by(paddle_subscription_id: params["subscription_id"])
      |> Repo.preload(team: [:owners, :billing_members])

    if subscription do
      changeset =
        Subscription.changeset(subscription, %{
          status: params["status"]
        })

      updated = Repo.update!(changeset)

      for recipient <- subscription.team.owners ++ subscription.team.billing_members do
        recipient
        |> PlausibleWeb.Email.cancellation_email()
        |> Plausible.Mailer.send()
      end

      updated
    end
  end

  defp handle_subscription_payment_succeeded(params) do
    subscription = Repo.get_by(Subscription, paddle_subscription_id: params["subscription_id"])

    if subscription do
      {:ok, api_subscription} = paddle_api().get_subscription(subscription.paddle_subscription_id)

      amount =
        :erlang.float_to_binary(api_subscription["next_payment"]["amount"] / 1, decimals: 2)

      subscription =
        subscription
        |> Subscription.changeset(%{
          next_bill_amount: amount,
          next_bill_date: api_subscription["next_payment"]["date"],
          last_bill_date: api_subscription["last_payment"]["date"]
        })
        |> Repo.update!()
        |> Repo.preload(:team)

      Plausible.Teams.update_accept_traffic_until(subscription.team)

      subscription
    end
  end

  defp get_team!(%{"passthrough" => passthrough}) do
    case parse_passthrough!(passthrough) do
      {:team_id, team_id} ->
        Teams.get!(team_id)

      {:user_id, user_id} ->
        # Given a guest or non-owner member user initiates the new subscription payment
        # and becomes an owner of an existing team already with a subscription in between,
        # this could result in assigning this new subscription to the newly owned team,
        # effectively "shadowing" any old one.
        #
        # That's why we are always defaulting to creating a new "My Personal Sites" team regardless
        # if they were owner of one before or not.
        Auth.User
        |> Repo.get!(user_id)
        |> Teams.force_create_my_team()
    end
  end

  defp get_team!(_params) do
    raise "Missing passthrough"
  end

  defp parse_passthrough!(passthrough) do
    {user_id, team_id} =
      case String.split(to_string(passthrough), ";") do
        ["ee:true", "user:" <> user_id, "team:" <> team_id] ->
          {user_id, team_id}

        ["ee:true", "user:" <> user_id] ->
          {user_id, "0"}

        _ ->
          raise "Invalid passthrough sent via Paddle: #{inspect(passthrough)}"
      end

    case {Integer.parse(user_id), Integer.parse(team_id)} do
      {{user_id, ""}, {0, ""}} when user_id > 0 ->
        {:user_id, user_id}

      {{_user_id, ""}, {team_id, ""}} when team_id > 0 ->
        {:team_id, team_id}

      _ ->
        raise "Invalid passthrough sent via Paddle: #{inspect(passthrough)}"
    end
  end

  defp format_subscription(params) do
    %{
      paddle_subscription_id: params["subscription_id"],
      paddle_plan_id: params["subscription_plan_id"],
      cancel_url: params["cancel_url"],
      update_url: params["update_url"],
      status: params["status"],
      next_bill_date: params["next_bill_date"],
      next_bill_amount: params["unit_price"] || params["new_unit_price"],
      currency_code: params["currency"]
    }
  end

  defp add_last_bill_date(subscription_params, paddle_params) do
    with datetime_str when is_binary(datetime_str) <- paddle_params["event_time"],
         {:ok, datetime} <- NaiveDateTime.from_iso8601(datetime_str),
         date <- NaiveDateTime.to_date(datetime) do
      Map.put(subscription_params, :last_bill_date, date)
    else
      _ -> subscription_params
    end
  end

  @spec format_price(Money.t()) :: String.t()
  def format_price(money) do
    Money.to_string!(money, fractional_digits: 2, no_fraction_if_integer: true)
  end

  def paddle_api(), do: Application.fetch_env!(:plausible, :paddle_api)

  def cancelled_subscription_notice_dismiss_id(id) do
    "subscription_cancelled__#{id}"
  end

  defp after_subscription_update(subscription) do
    team =
      Teams.Team
      |> Repo.get!(subscription.team_id)
      |> Teams.with_subscription()
      |> Repo.preload(:owners)

    if subscription.id != team.subscription.id do
      Sentry.capture_message("Susbscription ID mismatch",
        extra: %{subscription: inspect(subscription), team_id: team.id}
      )
    end

    team
    |> Plausible.Teams.update_accept_traffic_until()
    |> Plausible.Teams.remove_grace_period()
    |> Plausible.Teams.maybe_reset_next_upgrade_override()
    |> tap(&Plausible.Billing.SiteLocker.update_for/1)
    |> maybe_adjust_api_key_limits()
  end

  defp maybe_adjust_api_key_limits(team) do
    plan =
      Repo.get_by(Plausible.Billing.EnterprisePlan,
        team_id: team.id,
        paddle_plan_id: team.subscription.paddle_plan_id
      )

    if plan do
      Repo.update_all(
        from(t in Teams.Team, where: t.id == ^team.id),
        set: [hourly_api_request_limit: plan.hourly_api_request_limit]
      )
    end

    team
  end

  def dashboard_locked_notice_title(), do: "Dashboard locked"
  def active_grace_period_notice_title(), do: "You have outgrown your Plausible subscription tier"
  def subscription_cancelled_notice_title(), do: "Subscription cancelled"
  def subscription_past_due_notice_title(), do: "Payment failed"
  def subscription_paused_notice_title(), do: "Subscription paused"
  def upgrade_ineligible_notice_title(), do: "No sites owned"
  def pending_site_ownerships_notice_title(), do: "Pending ownership transfers"
end
```

## File: `lib/plausible/billing/ecto/feature.ex`
```
defmodule Plausible.Billing.Ecto.Feature do
  @moduledoc """
  Ecto type representing a feature. Features are cast and stored in the
  database as strings and loaded as modules, for example: `"props"` is loaded
  as `Plausible.Billing.Feature.Props`.
  """

  use Ecto.Type

  def type, do: :string

  def cast(feature) when is_binary(feature) do
    found =
      Enum.find(Plausible.Billing.Feature.list(), fn mod ->
        Atom.to_string(mod.name()) == feature
      end)

    if found, do: {:ok, found}, else: :error
  end

  def cast(mod) when is_atom(mod) do
    {:ok, mod}
  end

  def load(feature) when is_binary(feature) do
    cast(feature)
  end

  def dump(mod) when is_atom(mod) do
    {:ok, Atom.to_string(mod.name())}
  end
end
```

## File: `lib/plausible/billing/ecto/limit.ex`
```
defmodule Plausible.Billing.Ecto.Limit do
  @moduledoc """
  Ecto type representing a limit, that can be either a number or unlimited.
  Unlimited is dumped to the database as `-1` and loaded as `:unlimited` to
  keep compatibility with the rest of the codebase.
  """

  use Ecto.Type

  def type, do: :integer

  def cast(-1), do: {:ok, :unlimited}
  def cast(:unlimited), do: {:ok, :unlimited}
  def cast("unlimited"), do: {:ok, :unlimited}
  def cast(other), do: Ecto.Type.cast(:integer, other)

  def load(-1), do: {:ok, :unlimited}
  def load(other), do: Ecto.Type.load(:integer, other)

  def dump(:unlimited), do: {:ok, -1}
  def dump(other), do: Ecto.Type.dump(:integer, other)
end
```

## File: `lib/plausible/billing/enterprise_plan.ex`
```
defmodule Plausible.Billing.EnterprisePlan do
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @required_fields [
    :team_id,
    :paddle_plan_id,
    :billing_interval,
    :monthly_pageview_limit,
    :hourly_api_request_limit,
    :site_limit,
    :features,
    :team_member_limit
  ]

  schema "enterprise_plans" do
    field :paddle_plan_id, :string
    field :billing_interval, Ecto.Enum, values: [:monthly, :yearly]
    field :monthly_pageview_limit, :integer
    field :site_limit, :integer
    field :team_member_limit, Plausible.Billing.Ecto.Limit
    field :features, {:array, Plausible.Billing.Ecto.Feature}, default: []
    field :hourly_api_request_limit, :integer

    belongs_to :team, Plausible.Teams.Team

    timestamps()
  end

  @max round(:math.pow(2, 31))

  def changeset(model, attrs \\ %{}) do
    model
    |> cast(attrs, @required_fields)
    |> validate_number(:monthly_pageview_limit, less_than: @max)
    |> validate_number(:site_limit, less_than: @max)
    |> validate_number(:hourly_api_request_limit, less_than: @max)
    |> validate_required(@required_fields)
  end
end
```

## File: `lib/plausible/billing/feature.ex`
```
defmodule Plausible.Billing.Feature do
  @moduledoc """
  This module provides an interface for managing features, e.g. Revenue Goals,
  Funnels and Custom Properties.

  Feature modules have functions for toggling the feature on/off and checking
  whether the feature is available for a site/user.

  When defining new features, the following options are expected by the
  `__using__` macro:

    * `:name` - an atom representing the feature name in the plan JSON
    file (see also Plausible.Billing.Plan).

    * `:display_name` - human-readable display name of the feature

    * `:toggle_field` - the field in the %Plausible.Site{} schema that toggles
    the feature. If `nil` or not set, toggle/2 silently returns `:ok`

    * `:free` - if set to `true`, makes the `check_availability/1` function
    always return `:ok` (no matter the user's subscription status)

  Functions defined by `__using__` can be overridden if needed.
  """

  @doc """
  Returns the atom representing the feature name in the plan JSON file.
  """
  @callback name() :: atom()

  @doc """
  Returns the human-readable display name of the feature.
  """
  @callback display_name() :: String.t()

  @doc """
  Returns the %Plausible.Site{} field that toggles the feature on and off.
  """
  @callback toggle_field() :: atom()

  @doc """
  Returns whether the feature is free to use or not.
  """
  @callback free?() :: boolean()

  @doc """
  Toggles the feature on and off for a site. Returns
  `{:error, :upgrade_required}` when toggling a feature the site owner does not
  have access to.
  """
  @callback toggle(Plausible.Site.t(), Plausible.Auth.User.t(), Keyword.t()) ::
              :ok | {:error, :upgrade_required}

  @doc """
  Checks whether a feature is enabled or not. Returns false when the feature is
  disabled or the user does not have access to it.
  """
  @callback enabled?(Plausible.Site.t()) :: boolean()

  @doc """
  Returns whether the site explicitly opted out of the feature. This function
  is different from enabled/1, because enabled/1 returns false when the site
  owner does not have access to the feature.
  """
  @callback opted_out?(Plausible.Site.t()) :: boolean()

  @doc """
  Checks whether the team or the team plan includes the given feature.
  """
  @callback check_availability(Plausible.Teams.Team.t() | nil) ::
              :ok | {:error, :upgrade_required} | {:error, :not_implemented}

  @features [
    Plausible.Billing.Feature.Props,
    Plausible.Billing.Feature.SharedLinks,
    Plausible.Billing.Feature.Funnels,
    Plausible.Billing.Feature.Goals,
    Plausible.Billing.Feature.RevenueGoals,
    Plausible.Billing.Feature.SiteSegments,
    Plausible.Billing.Feature.SitesAPI,
    Plausible.Billing.Feature.StatsAPI,
    Plausible.Billing.Feature.SSO
  ]

  # Generate a union type for features
  @type t() :: unquote(Enum.reduce(@features, &{:|, [], [&1, &2]}))

  @doc """
  Lists all available feature modules.
  """
  def list() do
    @features
  end

  @doc """
  Lists all the feature short names, e.g. RevenueGoals
  """
  defmacro list_short_names() do
    @features
    |> Enum.map(fn mod ->
      Module.split(mod)
      |> List.last()
      |> String.to_atom()
    end)
  end

  @doc false
  defmacro __using__(opts \\ []) do
    quote location: :keep do
      @behaviour Plausible.Billing.Feature
      alias Plausible.Billing.Quota

      @impl true
      def name, do: Keyword.get(unquote(opts), :name)

      @impl true
      def display_name, do: Keyword.get(unquote(opts), :display_name)

      @impl true
      def toggle_field, do: Keyword.get(unquote(opts), :toggle_field)

      @impl true
      def free?, do: Keyword.get(unquote(opts), :free, false)

      @impl true
      def enabled?(%Plausible.Site{} = site) do
        site = Plausible.Repo.preload(site, :team)
        check_availability(site.team) == :ok && !opted_out?(site)
      end

      @impl true
      def opted_out?(%Plausible.Site{} = site) do
        if is_nil(toggle_field()), do: false, else: !Map.fetch!(site, toggle_field())
      end

      @impl true
      def check_availability(team_or_nil) do
        cond do
          free?() -> :ok
          __MODULE__ in Plausible.Teams.Billing.allowed_features_for(team_or_nil) -> :ok
          true -> {:error, :upgrade_required}
        end
      end

      @impl true
      def toggle(%Plausible.Site{} = site, %Plausible.Auth.User{} = user, opts \\ []) do
        if toggle_field(), do: do_toggle(site, user, opts), else: :ok
      end

      defp do_toggle(%Plausible.Site{} = site, user, opts) do
        override = Keyword.get(opts, :override)
        toggle = if is_boolean(override), do: override, else: !Map.fetch!(site, toggle_field())
        availability = if toggle, do: check_availability(site.team), else: :ok

        case availability do
          :ok ->
            site
            |> Ecto.Changeset.change(%{toggle_field() => toggle})
            |> Plausible.Repo.update()

          error ->
            error
        end
      end

      defoverridable check_availability: 1
    end
  end
end

defmodule Plausible.Billing.Feature.Funnels do
  @moduledoc false
  use Plausible.Billing.Feature,
    name: :funnels,
    display_name: "Funnels",
    toggle_field: :funnels_enabled
end

defmodule Plausible.Billing.Feature.RevenueGoals do
  @moduledoc false
  use Plausible.Billing.Feature,
    name: :revenue_goals,
    display_name: "Revenue Goals"
end

defmodule Plausible.Billing.Feature.Goals do
  @moduledoc false
  use Plausible.Billing.Feature,
    name: :goals,
    display_name: "Goals",
    toggle_field: :conversions_enabled,
    free: true
end

defmodule Plausible.Billing.Feature.Props do
  @moduledoc false
  use Plausible.Billing.Feature,
    name: :props,
    display_name: "Custom Properties",
    toggle_field: :props_enabled
end

defmodule Plausible.Billing.Feature.SharedLinks do
  @moduledoc false
  use Plausible.Billing.Feature,
    name: :shared_links,
    display_name: "Shared Links"
end

defmodule Plausible.Billing.Feature.SiteSegments do
  @moduledoc false
  use Plausible.Billing.Feature,
    name: :site_segments,
    display_name: "Shared Segments"
end

defmodule Plausible.Billing.Feature.StatsAPI do
  use Plausible

  @moduledoc false
  use Plausible.Billing.Feature,
    name: :stats_api,
    display_name: "Stats API"
end

defmodule Plausible.Billing.Feature.SitesAPI do
  use Plausible

  @moduledoc false
  use Plausible.Billing.Feature,
    name: :sites_api,
    display_name: "Sites API"
end

defmodule Plausible.Billing.Feature.SSO do
  use Plausible

  @moduledoc false
  use Plausible.Billing.Feature,
    name: :sso,
    display_name: "Single Sign-On"
end

defmodule Plausible.Billing.Feature.Teams do
  @moduledoc """
  Unlike other feature modules, this one only exists to make feature gating
  settings views more convenient. Other than that, it's not even considered
  a feature on its own. The real access to "Teams" is controlled by the
  team member limit.
  """
  def check_availability(team) do
    if Plausible.Teams.Billing.solo?(team) do
      {:error, :upgrade_required}
    else
      :ok
    end
  end
end
```

## File: `lib/plausible/billing/paddle_api.ex`
```
defmodule Plausible.Billing.PaddleApi do
  alias Plausible.HTTPClient

  @headers [
    {"content-type", "application/json"},
    {"accept", "application/json"}
  ]

  def update_subscription_preview(paddle_subscription_id, new_plan_id) do
    config = get_config()

    params = %{
      vendor_id: config[:vendor_id],
      vendor_auth_code: config[:vendor_auth_code],
      subscription_id: paddle_subscription_id,
      plan_id: new_plan_id,
      prorate: true,
      keep_modifiers: true,
      bill_immediately: true,
      quantity: 1
    }

    case HTTPClient.post(preview_update_url(), @headers, params) do
      {:ok, response} ->
        if response.body["success"] do
          {:ok, response.body["response"]}
        else
          {:error, response.body["error"]}
        end

      {:error, error} ->
        {:error, error}
    end
  end

  def update_subscription(paddle_subscription_id, params) do
    config = get_config()

    params =
      Map.merge(params, %{
        vendor_id: config[:vendor_id],
        vendor_auth_code: config[:vendor_auth_code],
        subscription_id: paddle_subscription_id,
        prorate: true,
        keep_modifiers: true,
        bill_immediately: true,
        quantity: 1
      })

    case HTTPClient.post(update_subscription_url(), @headers, params) do
      {:ok, response} ->
        if response.body["success"] do
          {:ok, response.body["response"]}
        else
          {:error, response.body["error"]}
        end

      {:error, %{reason: reason}} ->
        {:error, reason}
    end
  end

  def get_subscription(paddle_subscription_id) do
    config = get_config()

    params = %{
      vendor_id: config[:vendor_id],
      vendor_auth_code: config[:vendor_auth_code],
      subscription_id: paddle_subscription_id
    }

    case HTTPClient.post(get_subscription_url(), @headers, params) do
      {:ok, response} ->
        if response.body["success"] do
          [subscription] = response.body["response"]
          {:ok, subscription}
        else
          {:error, response.body["error"]}
        end

      {:error, %{reason: reason}} ->
        {:error, reason}
    end
  end

  @spec get_invoices(Plausible.Billing.Subscription.t() | nil) ::
          {:ok, list()}
          | {:error, :request_failed}
          | {:error, :no_invoices}
  def get_invoices(nil), do: {:error, :no_invoices}
  def get_invoices(%{paddle_subscription_id: nil}), do: {:error, :no_invoices}

  def get_invoices(subscription) do
    config = get_config()

    params = %{
      vendor_id: config[:vendor_id],
      vendor_auth_code: config[:vendor_auth_code],
      subscription_id: subscription.paddle_subscription_id,
      is_paid: 1,
      from: Date.shift(Date.utc_today(), year: -5) |> Calendar.strftime("%Y-%m-%d"),
      to: Date.shift(Date.utc_today(), day: 1) |> Calendar.strftime("%Y-%m-%d")
    }

    with {:ok, %{body: body}} <- HTTPClient.post(invoices_url(), @headers, params),
         true <- Map.get(body, "success"),
         [_ | _] = response <- Map.get(body, "response") do
      Enum.sort(response, fn %{"payout_date" => d1}, %{"payout_date" => d2} ->
        Date.compare(Date.from_iso8601!(d1), Date.from_iso8601!(d2)) == :gt
      end)
      |> then(&{:ok, &1})
    else
      error ->
        Sentry.capture_message("Failed to retrieve invoices from Paddle",
          extra: %{extra: inspect(error), params: params, invoices_url: invoices_url()}
        )

        {:error, :request_failed}
    end
  end

  def fetch_prices([_ | _] = product_ids, customer_ip) do
    params = %{product_ids: Enum.join(product_ids, ","), customer_ip: customer_ip}

    case HTTPClient.impl().get(prices_url(), @headers, params) do
      {:ok, %{body: %{"success" => true, "response" => %{"products" => products}}}} ->
        products =
          Enum.into(products, %{}, fn %{
                                        "currency" => currency,
                                        "price" => %{"net" => net_price},
                                        "product_id" => product_id
                                      } ->
            {Integer.to_string(product_id), Money.from_float!(currency, net_price)}
          end)

        {:ok, products}

      {:ok, %{body: body}} ->
        Sentry.capture_message("Paddle API: Unexpected response when fetching prices",
          extra: %{api_response: body, product_ids: product_ids}
        )

        {:error, :api_error}

      {:error, %{reason: reason}} ->
        Sentry.capture_message("Paddle API: Error when fetching prices", extra: %{reason: reason})
        {:error, :api_error}
    end
  end

  def checkout_domain() do
    if Application.get_env(:plausible, :environment) == "staging" do
      "https://sandbox-checkout.paddle.com"
    else
      "https://checkout.paddle.com"
    end
  end

  def vendors_domain() do
    if Application.get_env(:plausible, :environment) == "staging" do
      "https://sandbox-vendors.paddle.com"
    else
      "https://vendors.paddle.com"
    end
  end

  defp get_config() do
    Application.get_env(:plausible, :paddle)
  end

  defp invoices_url() do
    Path.join(vendors_domain(), "/api/2.0/subscription/payments")
  end

  defp preview_update_url() do
    Path.join(vendors_domain(), "/api/2.0/subscription/preview_update")
  end

  defp update_subscription_url() do
    Path.join(vendors_domain(), "/api/2.0/subscription/users/update")
  end

  defp get_subscription_url() do
    Path.join(vendors_domain(), "/api/2.0/subscription/users")
  end

  defp prices_url() do
    Path.join(checkout_domain(), "/api/2.0/prices")
  end
end
```

## File: `lib/plausible/billing/plan.ex`
```
defmodule Plausible.Billing.Plan do
  @moduledoc false

  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  embedded_schema do
    # Due to grandfathering, we sometimes need to check the "generation" (e.g.
    # v1, v2, etc...) of a user's subscription plan. For instance, on prod, the
    # users subscribed to a v2 plan are only supposed to see v2 plans when they
    # go to the upgrade page.
    #
    # In the `dev` environment though, "sandbox" plans are used, which unlike
    # production plans, contain multiple generations of plans in the same file
    # for testing purposes.
    field :generation, :integer
    field :kind, Ecto.Enum, values: [:starter, :growth, :business]

    field :features, {:array, Plausible.Billing.Ecto.Feature}
    field :monthly_pageview_limit, :integer
    field :site_limit, :integer
    field :team_member_limit, Plausible.Billing.Ecto.Limit
    field :volume, :string
    field :data_retention_in_years, :integer

    field :monthly_cost
    field :monthly_product_id, :string
    field :yearly_cost
    field :yearly_product_id, :string
  end

  @required_fields ~w(generation kind features monthly_pageview_limit site_limit team_member_limit volume)a
  @optional_fields ~w(monthly_cost yearly_cost monthly_product_id yearly_product_id data_retention_in_years)a
  @fields @required_fields ++ @optional_fields

  def changeset(plan, attrs) do
    plan
    |> cast(attrs, @fields)
    |> put_volume()
    |> validate_required_either([:monthly_product_id, :yearly_product_id])
    |> validate_required(@required_fields)
  end

  defp put_volume(changeset) do
    if volume = get_field(changeset, :monthly_pageview_limit) do
      put_change(changeset, :volume, PlausibleWeb.StatsView.large_number_format(volume))
    else
      changeset
    end
  end

  def validate_required_either(changeset, fields) do
    if Enum.any?(fields, &get_field(changeset, &1)) do
      changeset
    else
      add_error(changeset, hd(fields), "one of these fields must be present #{inspect(fields)}")
    end
  end
end
```

## File: `lib/plausible/billing/plan_benefits.ex`
```
defmodule Plausible.Billing.PlanBenefits do
  @moduledoc false

  alias Plausible.Billing.Plan

  @doc """
  This function takes a starter plan and returns a list representing
  the different benefits a user gets when subscribing to this plan.
  """
  def for_starter(starter_plan) do
    [
      site_limit_benefit(starter_plan),
      data_retention_benefit(starter_plan),
      "Intuitive, fast and privacy-friendly dashboard",
      "Email/Slack reports",
      "Google Analytics import"
    ]
    |> Kernel.++(feature_benefits(starter_plan))
    |> Kernel.++(["Saved Segments"])
  end

  @doc """
  Returns Growth benefits for the given Growth plan.

  A second argument is also required - list of Starter benefits. This
  is because we don't want to list the same benefits in both Starter
  and Growth. Everything in Starter is also included in Growth.
  """
  def for_growth(growth_plan, starter_benefits) do
    [
      if(Enum.empty?(starter_benefits), do: nil, else: "Everything in Starter"),
      site_limit_benefit(growth_plan),
      team_member_limit_benefit(growth_plan),
      "Team Management",
      if(Enum.empty?(starter_benefits), do: "Saved Segments", else: nil)
    ]
    |> Kernel.++(feature_benefits(growth_plan))
    |> Kernel.--(starter_benefits)
    |> Enum.filter(& &1)
  end

  @doc """
  Returns Business benefits for the given Business plan.

  A second argument is also required - list of Growth benefits. This
  is because we don't want to list the same benefits in both Growth
  and Business. Everything in Growth is also included in Business.
  """
  def for_business(plan, growth_benefits, starter_benefits) do
    [
      "Everything in Growth",
      site_limit_benefit(plan),
      team_member_limit_benefit(plan),
      data_retention_benefit(plan)
    ]
    |> Kernel.++(feature_benefits(plan))
    |> Kernel.--(growth_benefits)
    |> Kernel.--(starter_benefits)
    |> Enum.filter(& &1)
  end

  @doc """
  This function only takes a list of business benefits. Since all
  limits and features of enterprise plans are configurable, we can
  say on the upgrade page that enterprise plans include everything
  in Business.
  """
  def for_enterprise(business_benefits) do
    team_members =
      cond do
        "Unlimited team members" in business_benefits -> nil
        "Up to 10 team members" in business_benefits -> "10+ team members"
        "Up to 50 team members" in business_benefits -> "50+ team members"
        # if there's nothing about team members in Business benefits, then
        # Growth has unlimited team members already. In that case, we don't
        # mention team members at all.
        true -> nil
      end

    sites =
      cond do
        "Up to 10 sites" in business_benefits -> "10+ sites"
        "Up to 50 sites" in business_benefits -> "50+ sites"
        # Before v4, every plan (both Growth and Business) had 50 sites.
        # Therefore, if Business benefits do not mention site limit, then
        # it's 50. Newer Business plans always define a higher site limit.
        true -> "50+ sites"
      end

    data_retention =
      if "5 years of data retention" in business_benefits, do: "5+ years of data retention"

    [
      "Everything in Business",
      sites,
      team_members,
      "600+ Stats API requests per hour",
      "Sites API",
      "Single Sign-On (SSO)",
      "Managed Proxy",
      data_retention,
      "Priority support"
    ]
    |> Enum.filter(& &1)
  end

  defp data_retention_benefit(%Plan{} = plan) do
    if plan.data_retention_in_years, do: "#{plan.data_retention_in_years} years of data retention"
  end

  defp team_member_limit_benefit(%Plan{} = plan) do
    case plan.team_member_limit do
      :unlimited -> "Unlimited team members"
      number -> "Up to #{number} team members"
    end
  end

  defp site_limit_benefit(%Plan{} = plan) do
    case plan.site_limit do
      1 -> "One site"
      site_limit -> "Up to #{site_limit} sites"
    end
  end

  defp feature_benefits(%Plan{} = plan) do
    Enum.flat_map(plan.features, fn feature_mod ->
      case feature_mod.name() do
        :goals -> ["Goals and custom events"]
        :stats_api -> ["Stats API (600 requests per hour)", "Looker Studio Connector"]
        :shared_links -> ["Shared Links", "Embedded Dashboards"]
        :revenue_goals -> ["Ecommerce revenue attribution"]
        _ -> [feature_mod.display_name()]
      end
    end)
  end
end
```

## File: `lib/plausible/billing/plans.ex`
```
defmodule Plausible.Billing.Plans do
  alias Plausible.Billing.Subscriptions
  use Plausible.Repo
  alias Plausible.Billing.{Subscription, Plan, EnterprisePlan}
  alias Plausible.Teams

  @generations [:legacy_plans, :plans_v1, :plans_v2, :plans_v3, :plans_v4, :plans_v5]

  for group <- Enum.flat_map(@generations, &[&1, :"sandbox_#{&1}"]) do
    path = Application.app_dir(:plausible, ["priv", "#{group}.json"])

    plans_list =
      for attrs <- path |> File.read!() |> Jason.decode!() do
        %Plan{} |> Plan.changeset(attrs) |> Ecto.Changeset.apply_action!(nil)
      end

    Module.put_attribute(__MODULE__, group, plans_list)

    # https://hexdocs.pm/elixir/1.15/Module.html#module-external_resource
    Module.put_attribute(__MODULE__, :external_resource, path)
  end

  # Generate functions returning a specific generation of plans depending on
  # the app environment
  for fn_name <- @generations do
    defp unquote(fn_name)() do
      if Application.get_env(:plausible, :environment) == "staging" do
        unquote(Macro.escape(Module.get_attribute(__MODULE__, :"sandbox_#{fn_name}")))
      else
        unquote(Macro.escape(Module.get_attribute(__MODULE__, fn_name)))
      end
    end
  end

  defp starter_plans_for(subscription, legacy?) do
    active_plan = get_regular_plan(subscription, only_non_expired: true)

    case {legacy?, active_plan} do
      {true, _} -> []
      {_, %Plan{kind: :growth, generation: g}} when g <= 4 -> []
      {_, _} -> Enum.filter(plans_v5(), &(&1.kind == :starter))
    end
  end

  @spec growth_plans_for(Subscription.t(), boolean()) :: [Plan.t()]
  @doc """
  Returns a list of growth plans available for the subscription to choose.

  As new versions of plans are introduced, subscriptions which were on old plans can
  still choose from old plans.
  """
  def growth_plans_for(subscription, legacy? \\ false) do
    owned_plan = get_regular_plan(subscription)

    default_plans = if legacy?, do: plans_v4(), else: plans_v5()

    cond do
      is_nil(owned_plan) -> default_plans
      subscription && Subscriptions.expired?(subscription) -> default_plans
      owned_plan.kind == :business -> default_plans
      owned_plan.generation == 1 -> plans_v1() |> drop_high_plans(owned_plan)
      owned_plan.generation == 2 -> plans_v2() |> drop_high_plans(owned_plan)
      owned_plan.generation == 3 -> plans_v3()
      owned_plan.generation == 4 -> plans_v4()
      owned_plan.generation == 5 -> plans_v5()
    end
    |> Enum.filter(&(&1.kind == :growth))
  end

  def business_plans_for(subscription, legacy? \\ false) do
    owned_plan = get_regular_plan(subscription)

    default_plans = if legacy?, do: plans_v4(), else: plans_v5()

    cond do
      subscription && Subscriptions.expired?(subscription) -> default_plans
      owned_plan && owned_plan.generation <= 3 -> plans_v3()
      owned_plan && owned_plan.generation <= 4 -> plans_v4()
      true -> default_plans
    end
    |> Enum.filter(&(&1.kind == :business))
  end

  def available_plans_for(subscription, opts \\ []) do
    legacy? = Keyword.get(opts, :legacy?, false)

    %{
      starter: starter_plans_for(subscription, legacy?) |> maybe_add_prices(opts),
      growth: growth_plans_for(subscription, legacy?) |> maybe_add_prices(opts),
      business: business_plans_for(subscription, legacy?) |> maybe_add_prices(opts)
    }
  end

  defp maybe_add_prices([] = _plans, _opts), do: []

  defp maybe_add_prices(plans, opts) do
    if Keyword.get(opts, :with_prices) do
      customer_ip = Keyword.fetch!(opts, :customer_ip)
      with_prices(plans, customer_ip)
    else
      plans
    end
  end

  @high_legacy_volumes [20_000_000, 50_000_000]
  defp drop_high_plans(plans, %Plan{monthly_pageview_limit: current_volume} = _owned) do
    plans
    |> Enum.reject(fn %Plan{monthly_pageview_limit: plan_volume} ->
      plan_volume in @high_legacy_volumes and current_volume < plan_volume
    end)
  end

  @spec yearly_product_ids() :: [String.t()]
  @doc """
  List yearly plans product IDs.
  """
  def yearly_product_ids do
    for %{yearly_product_id: yearly_product_id} <- all(),
        is_binary(yearly_product_id),
        do: yearly_product_id
  end

  def find(nil), do: nil

  def find(product_id) do
    Enum.find(all(), fn plan ->
      product_id in [plan.monthly_product_id, plan.yearly_product_id]
    end)
  end

  @spec get_subscription_plan(nil | Subscription.t()) ::
          nil | :free_10k | Plan.t() | EnterprisePlan.t()
  def get_subscription_plan(nil), do: nil

  def get_subscription_plan(subscription) do
    if subscription.paddle_plan_id == "free_10k" do
      :free_10k
    else
      get_regular_plan(subscription) || get_enterprise_plan(subscription)
    end
  end

  def subscription_interval(subscription) do
    case get_subscription_plan(subscription) do
      %EnterprisePlan{billing_interval: interval} ->
        interval

      %Plan{} = plan ->
        if plan.monthly_product_id == subscription.paddle_plan_id do
          "monthly"
        else
          "yearly"
        end

      _any ->
        "N/A"
    end
  end

  @doc """
  This function takes a list of plans as an argument, gathers all product
  IDs in a single list, and makes an API call to Paddle. After a successful
  response, fills in the `monthly_cost` and `yearly_cost` fields for each
  given plan and returns the new list of plans with completed information.
  """
  def with_prices([_ | _] = plans, customer_ip \\ "127.0.0.1") do
    product_ids = Enum.flat_map(plans, &[&1.monthly_product_id, &1.yearly_product_id])

    case Plausible.Billing.paddle_api().fetch_prices(product_ids, customer_ip) do
      {:ok, prices} ->
        Enum.map(plans, fn plan ->
          plan
          |> Map.put(:monthly_cost, prices[plan.monthly_product_id])
          |> Map.put(:yearly_cost, prices[plan.yearly_product_id])
        end)

      {:error, :api_error} ->
        plans
    end
  end

  def get_regular_plan(subscription, opts \\ [])

  def get_regular_plan(nil, _opts), do: nil

  def get_regular_plan(%Subscription{} = subscription, opts) do
    if Keyword.get(opts, :only_non_expired) && Subscriptions.expired?(subscription) do
      nil
    else
      find(subscription.paddle_plan_id)
    end
  end

  def get_price_for(%EnterprisePlan{paddle_plan_id: product_id}, customer_ip) do
    case Plausible.Billing.paddle_api().fetch_prices([product_id], customer_ip) do
      {:ok, prices} -> Map.fetch!(prices, product_id)
      {:error, :api_error} -> nil
    end
  end

  defp get_enterprise_plan(%Subscription{} = subscription) do
    Repo.get_by(EnterprisePlan,
      team_id: subscription.team_id,
      paddle_plan_id: subscription.paddle_plan_id
    )
  end

  def business_tier?(nil), do: false

  def business_tier?(%Subscription{} = subscription) do
    case get_subscription_plan(subscription) do
      %Plan{kind: :business} -> true
      _ -> false
    end
  end

  @doc """
  Returns the most appropriate monthly pageview volume for a given usage cycle.
  The cycle is either last 30 days (for trials) or last billing cycle for teams
  with an existing subscription.

  The generation and tier from which we're searching for a suitable volume doesn't
  matter - the monthly pageview volumes for all plans starting from v3 are going from
  10k to 10M. This function uses v4 Growth but it might as well be e.g. v5 Business.

  If the usage during the cycle exceeds the enterprise-level threshold, or if
  the team already has an enterprise plan, it returns `:enterprise`. Otherwise,
  a string representing the volume, e.g. "100k" or "5M".
  """
  @spec suggest_volume(Teams.Team.t(), non_neg_integer()) :: String.t() | :enterprise
  def suggest_volume(team, usage_during_cycle) do
    if Teams.Billing.enterprise_configured?(team) do
      :enterprise
    else
      plans_v4()
      |> Enum.filter(&(&1.kind == :growth))
      |> Enum.find(%{volume: :enterprise}, &(usage_during_cycle < &1.monthly_pageview_limit))
      |> Map.get(:volume)
    end
  end

  def all() do
    legacy_plans() ++ plans_v1() ++ plans_v2() ++ plans_v3() ++ plans_v4() ++ plans_v5()
  end
end
```

## File: `lib/plausible/billing/qouta/limits.ex`
```
defmodule Plausible.Billing.Quota.Limits do
  @moduledoc false

  @type over_limits_error() :: {:over_plan_limits, [limit()]}
  @typep limit() :: :site_limit | :pageview_limit | :team_member_limit

  @pageview_allowance_margin 0.1

  def pageview_limit_with_margin(limit, margin \\ nil) do
    margin = if margin, do: margin, else: @pageview_allowance_margin
    ceil(limit * (1 + margin))
  end
end
```

## File: `lib/plausible/billing/qouta/quota.ex`
```
defmodule Plausible.Billing.Quota do
  @moduledoc """
  This module provides functions to work with plans usage and limits.
  """

  use Plausible
  alias Plausible.Billing.{EnterprisePlan, Plan}
  alias Plausible.Billing.Quota.Limits

  @type cycle() :: :current_cycle | :last_cycle | :penultimate_cycle

  @type cycles_usage() :: %{cycle() => usage_cycle()}

  @type usage_cycle() :: %{
          date_range: Date.Range.t(),
          pageviews: non_neg_integer(),
          custom_events: non_neg_integer(),
          total: non_neg_integer()
        }

  @doc """
  Ensures that the given usage map is within the limits
  of the given plan.

  An `opts` argument can be passed with `ignore_pageview_limit: true`
  which bypasses the pageview limit check and returns `:ok` as long as
  the other limits are not exceeded.
  """
  @spec ensure_within_plan_limits(map(), struct() | atom() | nil, Keyword.t()) ::
          :ok | {:error, Limits.over_limits_error()}

  def ensure_within_plan_limits(usage, plan_mod, opts \\ [])

  def ensure_within_plan_limits(usage, %plan_mod{} = plan, opts)
      when plan_mod in [Plan, EnterprisePlan] do
    case exceeded_limits(usage, plan, opts) do
      [] -> :ok
      exceeded_limits -> {:error, {:over_plan_limits, exceeded_limits}}
    end
  end

  def ensure_within_plan_limits(_, _, _), do: :ok

  def eligible_for_upgrade?(usage), do: usage.sites > 0

  def ensure_feature_access(usage, plan) do
    case usage.features -- plan.features do
      [] -> :ok
      features -> {:error, {:unavailable_features, features}}
    end
  end

  @doc """
  Suggests a suitable tier (Starter, Growth or Business) for the given usage map.

  If even the highest Business plan does not accommodate the usage, then
  `:custom` is returned. This means that this kind of usage should get on
  a custom plan.

  To avoid confusion, we do not recommend a lower tier for customers that
  are already on a higher tier (even if their usage is low enough).

  `nil` is returned if the usage is not eligible for upgrade.
  """
  def suggest_tier(usage, highest_starter, highest_growth, highest_business, owned_tier) do
    cond do
      not eligible_for_upgrade?(usage) ->
        nil

      not is_nil(highest_starter) and usage_fits_plan?(usage, highest_starter) and
          owned_tier not in [:business, :growth] ->
        :starter

      usage_fits_plan?(usage, highest_growth) and owned_tier != :business ->
        :growth

      usage_fits_plan?(usage, highest_business) ->
        :business

      true ->
        :custom
    end
  end

  @doc """
  [DEPRECATED] Used in LegacyChoosePlan in order to suggest a tier
  when `starter_tier` flag is not enabled.
  """
  def legacy_suggest_tier(usage, highest_growth, highest_business, owned_tier) do
    cond do
      not eligible_for_upgrade?(usage) -> nil
      usage_fits_plan?(usage, highest_growth) and owned_tier != :business -> :growth
      usage_fits_plan?(usage, highest_business) -> :business
      true -> :custom
    end
  end

  defp usage_fits_plan?(usage, plan) do
    with :ok <- ensure_within_plan_limits(usage, plan),
         :ok <- ensure_feature_access(usage, plan) do
      true
    else
      _ -> false
    end
  end

  defp exceeded_limits(usage, plan, opts) do
    site_limit_exceeded? =
      if opts[:skip_site_limit_check?] do
        false
      else
        not within_limit?(usage.sites, plan.site_limit)
      end

    for {limit, exceeded?} <- [
          {:team_member_limit, not within_limit?(usage.team_members, plan.team_member_limit)},
          {:site_limit, site_limit_exceeded?},
          {:monthly_pageview_limit,
           exceeds_monthly_pageview_limit?(usage.monthly_pageviews, plan, opts)}
        ],
        exceeded? do
      limit
    end
  end

  defp exceeds_monthly_pageview_limit?(usage, plan, opts) do
    if Keyword.get(opts, :ignore_pageview_limit) do
      false
    else
      case usage do
        %{last_30_days: %{total: total}} ->
          margin = Keyword.get(opts, :pageview_allowance_margin)
          limit = Limits.pageview_limit_with_margin(plan.monthly_pageview_limit, margin)
          !within_limit?(total, limit)

        cycles_usage ->
          exceeds_last_two_usage_cycles?(cycles_usage, plan.monthly_pageview_limit)
      end
    end
  end

  @spec exceeds_last_two_usage_cycles?(cycles_usage(), non_neg_integer()) ::
          boolean()
  def exceeds_last_two_usage_cycles?(cycles_usage, allowed_volume) do
    exceeded = exceeded_cycles(cycles_usage, allowed_volume)
    :penultimate_cycle in exceeded && :last_cycle in exceeded
  end

  @spec exceeded_cycles(cycles_usage(), non_neg_integer()) :: list()
  def exceeded_cycles(cycles_usage, allowed_volume) do
    limit = Limits.pageview_limit_with_margin(allowed_volume)

    Enum.reduce(cycles_usage, [], fn {cycle, %{total: total}}, exceeded_cycles ->
      if below_limit?(total, limit) do
        exceeded_cycles
      else
        exceeded_cycles ++ [cycle]
      end
    end)
  end

  @spec below_limit?(non_neg_integer(), non_neg_integer() | :unlimited) :: boolean()
  @doc """
  Returns whether the usage is below the limit or not.
  Returns false if usage is equal to the limit.
  """
  def below_limit?(usage, limit) do
    if limit == :unlimited, do: true, else: usage < limit
  end

  @spec within_limit?(non_neg_integer(), non_neg_integer() | :unlimited) :: boolean()
  @doc """
  Returns whether the usage is within the limit or not.
  Returns true if usage is equal to the limit.
  """
  def within_limit?(usage, limit) do
    if limit == :unlimited, do: true, else: usage <= limit
  end
end
```

## File: `lib/plausible/billing/site_locker.ex`
```
defmodule Plausible.Billing.SiteLocker do
  use Plausible.Repo

  alias Plausible.Teams

  @type update_opt() :: {:send_email?, boolean()}

  @type lock_reason() ::
          :grace_period_ended_now
          | :grace_period_ended_already
          | :no_trial
          | :no_active_subscription

  @spec update_for(Teams.Team.t(), [update_opt()]) ::
          {:locked, lock_reason()} | :unlocked
  def update_for(team, opts \\ []) do
    send_email? = Keyword.get(opts, :send_email?, true)
    usage_mod = Keyword.get(opts, :usage_mod, Teams.Billing)

    team = Teams.with_subscription(team)

    case Teams.Billing.check_needs_to_upgrade(team, usage_mod) do
      {:needs_to_upgrade, :grace_period_ended} ->
        set_lock_status_for(team, true)

        if team.grace_period.is_over != true do
          Teams.end_grace_period(team)

          send_grace_period_end_email(team, send_email?)

          {:locked, :grace_period_ended_now}
        else
          {:locked, :grace_period_ended_already}
        end

      {:needs_to_upgrade, reason} ->
        if Teams.owned_sites_count(team) > 0 do
          set_lock_status_for(team, true)
          {:locked, reason}
        else
          set_lock_status_for(team, false)
          :unlocked
        end

      :no_upgrade_needed ->
        set_lock_status_for(team, false)
        :unlocked
    end
  end

  @spec set_lock_status_for(Teams.Team.t(), boolean()) :: :ok
  def set_lock_status_for(team, status) do
    query = from(t in Teams.Team, where: t.id == ^team.id)

    {_, _} = Repo.update_all(query, set: [locked: status])

    :ok
  end

  defp send_grace_period_end_email(team, true) do
    team = Repo.preload(team, [:owners, :billing_members])
    usage = Teams.Billing.monthly_pageview_usage(team)
    suggested_volume = Plausible.Billing.Plans.suggest_volume(team, usage.last_cycle.total)

    for recipient <- team.owners ++ team.billing_members do
      recipient
      |> PlausibleWeb.Email.dashboard_locked(team, usage, suggested_volume)
      |> Plausible.Mailer.send()
    end
  end

  defp send_grace_period_end_email(_team, false), do: :ok
end
```

## File: `lib/plausible/billing/subscription.ex`
```
defmodule Plausible.Billing.Subscription do
  @moduledoc false

  use Ecto.Schema
  import Ecto.Changeset
  require Plausible.Billing.Subscription.Status
  alias Plausible.Billing.Subscription

  @type t() :: %__MODULE__{}

  @required_fields [
    :paddle_subscription_id,
    :paddle_plan_id,
    :update_url,
    :cancel_url,
    :status,
    :next_bill_amount,
    :next_bill_date,
    :currency_code
  ]

  @optional_fields [:last_bill_date]

  schema "subscriptions" do
    field :paddle_subscription_id, :string
    field :paddle_plan_id, :string
    field :update_url, :string
    field :cancel_url, :string
    field :status, Ecto.Enum, values: Subscription.Status.valid_statuses()
    field :next_bill_amount, :string
    field :next_bill_date, :date
    field :last_bill_date, :date
    field :currency_code, :string

    belongs_to :team, Plausible.Teams.Team

    timestamps()
  end

  def create_changeset(team, attrs \\ %{}) do
    %__MODULE__{}
    |> changeset(attrs)
    |> put_assoc(:team, team)
  end

  def changeset(subscription, attrs \\ %{}) do
    subscription
    |> cast(attrs, @required_fields ++ @optional_fields)
    |> validate_required(@required_fields)
    |> unique_constraint(:paddle_subscription_id)
  end

  def free(team, attrs \\ %{}) do
    %__MODULE__{
      paddle_plan_id: "free_10k",
      status: Subscription.Status.active(),
      next_bill_amount: "0",
      currency_code: "EUR"
    }
    |> cast(attrs, @required_fields ++ @optional_fields)
    |> put_assoc(:team, team)
    |> unique_constraint(:paddle_subscription_id)
  end
end
```

## File: `lib/plausible/billing/subscription/status.ex`
```
defmodule Plausible.Billing.Subscription.Status do
  @moduledoc """
  The subscription statuses are stored in Paddle. They can only be changed
  through Paddle webhooks, which always send the current subscription status
  via the payload.

  * `active` - All good with the payments. Can access stats.

  * `past_due` - The payment has failed, but we're trying to charge the customer
    again. Access to stats is still granted. There will be three retries - after
    3, 5, and 7 days have passed from the first failure. After a failure on the
    final retry, the subscription status will change to `paused`. As soon as the
    customer updates their billing details, Paddle will charge them again, and
    after a successful payment, the subscription will become `active` again.

  * `paused` - we've tried to charge the customer but all the retries have failed.
    Stats access restricted. As soon as the customer updates their billing details,
    Paddle will charge them again, and after a successful payment, the subscription
    will become `active` again.

  * `deleted` - The customer has triggered the cancel subscription action. Access
    to stats should be granted for the time the customer has already paid for. If
    they want to upgrade again, new billing details have to be provided.

  Paddle documentation links for reference:

  * Subscription statuses -
    https://developer.paddle.com/classic/reference/zg9joji1mzu0mdi2-subscription-status-reference

  * Payment failures -
    https://developer.paddle.com/classic/guides/zg9joji1mzu0mduy-payment-failures
  """

  @statuses [:active, :past_due, :paused, :deleted]

  @type status() :: unquote(Enum.reduce(@statuses, &{:|, [], [&1, &2]}))

  for status <- @statuses do
    defmacro unquote(status)(), do: unquote(status)

    def unquote(:"#{status}?")(nil), do: false
    def unquote(:"#{status}?")(subscription), do: subscription.status == unquote(status)
  end

  defmacro in?(subscription, expected) do
    expected_expanded = Enum.map(expected, &Macro.expand(&1, __CALLER__))

    if expected_expanded -- Plausible.Billing.Subscription.Status.valid_statuses() != [] do
      raise ArgumentError, "Invalid subscription statuses provided: #{inspect(expected_expanded)}"
    end

    quote bind_quoted: [subscription: subscription, expected: expected] do
      if is_nil(subscription), do: false, else: Map.get(subscription, :status) in expected
    end
  end

  def valid_statuses() do
    @statuses
  end
end
```

## File: `lib/plausible/billing/subscriptions.ex`
```
defmodule Plausible.Billing.Subscriptions do
  @moduledoc false

  require Plausible.Billing.Subscription.Status
  alias Plausible.Billing.Subscription

  def active?(%Subscription{status: Subscription.Status.active()}), do: true
  def active?(%Subscription{status: Subscription.Status.past_due()}), do: true

  def active?(%Subscription{status: Subscription.Status.deleted()} = subscription) do
    not is_nil(subscription.next_bill_date) and
      not Date.before?(subscription.next_bill_date, Date.utc_today())
  end

  def active?(%Subscription{}), do: false
  def active?(nil), do: false

  @spec expired?(Subscription.t()) :: boolean()
  @doc """
  Returns whether the given subscription is expired. That means that the
  subscription status is `deleted` and the date until which the customer
  has paid for (i.e. `next_bill_date`) has passed.
  """
  def expired?(subscription)

  def expired?(%Subscription{paddle_plan_id: "free_10k"}), do: false

  def expired?(%Subscription{next_bill_date: next_bill_date} = subscription) do
    deleted? = Subscription.Status.deleted?(subscription)
    expired? = Timex.compare(next_bill_date, Date.utc_today()) < 0

    deleted? && expired?
  end

  def resumable?(subscription) do
    Subscription.Status.in?(subscription, [
      Subscription.Status.active(),
      Subscription.Status.past_due(),
      Subscription.Status.paused()
    ])
  end

  def halted?(subscription) do
    Subscription.Status.in?(subscription, [
      Subscription.Status.past_due(),
      Subscription.Status.paused()
    ])
  end
end
```

## File: `lib/plausible/cache.ex`
```
defmodule Plausible.Cache do
  @moduledoc """
  Caching interface specific for Plausible. Usage:

      use Plausible.Cache

      # - Implement the callbacks required
      # - Optionally override `unwrap_cache_keys/1`
      # - Populate the cache with `Plausible.Cache.Warmer`

  Serves as a wrapper around `Plausible.Cache.Adapter`, where the underlying
  implementation can be transparently swapped.

  Even though normally the relevant Adapter processes are started, cache access is disabled
  during tests via the `:plausible, #{__MODULE__}, enabled: bool()` application env key.
  This can be overridden on case by case basis, using the child specs options.

  The `base_db_query/0` callback is used to generate the base query that is
  executed on every cache refresh.

  There are two modes of refresh operation: `:all` and `:updated_recently`;
  the former will invoke the query as is and clear all the existing entries,
  while the latter will attempt to limit the query to only the records that
  have been updated in the last 15 minutes and try to merge the new results with
  existing cache entries.

  Both refresh modes are normally executed periodically from within a warmer process;
  see: `Plausible.Cache.Warmer`. The reason for two modes is that the latter is lighter
  on the database and can be executed more frequently.

  When Cache is disabled via application env, the `get/1` function
  falls back to pure database lookups (implemented via `get_from_source/1` callback.
  This should help with introducing cached lookups in existing code,
  so that no existing tests should break.

  Refreshing the cache emits telemetry event defined as per `telemetry_event_refresh/2`.
  """
  @doc "Unique cache name, used by underlying implementation"
  @callback name() :: atom()
  @doc "Supervisor child id, must be unique within the supervision tree"
  @callback child_id() :: atom()
  @doc "Optional repo to use. Defaults to Plausible.Repo"
  @callback repo() :: Ecto.Repo.t()
  @doc "Counts all items at the source, an aggregate query most likely"
  @callback count_all() :: integer()
  @doc "Optionally unwraps the keys of the cache items, in case one item is stored under multiple keys"
  @callback unwrap_cache_keys([any()]) :: [{any(), any()}]
  @doc "Returns the base Ecto query used to refresh the cache"
  @callback base_db_query() :: Ecto.Query.t()
  @doc "Retrieves the item from the source, in case the cache is disabled"
  @callback get_from_source(any()) :: any()

  @doc "Looks for application env value at `:plausible, #{__MODULE__}, enabled: bool()`"
  def enabled?() do
    Application.fetch_env!(:plausible, __MODULE__)[:enabled] == true
  end

  # credo:disable-for-this-file Credo.Check.Refactor.LongQuoteBlocks
  defmacro __using__(_opts) do
    quote do
      @behaviour Plausible.Cache
      @modes [:all, :updated_recently]

      alias Plausible.Cache.Adapter
      require Logger

      @spec get(any(), Keyword.t()) :: any() | nil
      def get(key, opts \\ []) when is_list(opts) do
        cache_name = Keyword.get(opts, :cache_name, name())
        force? = Keyword.get(opts, :force?, false)

        if Plausible.Cache.enabled?() or force? do
          Adapter.get(cache_name, key)
        else
          get_from_source(key)
        end
      end

      @spec get_or_store(any(), (-> any()), Keyword.t()) :: any() | nil
      def get_or_store(key, fallback_fn, opts \\ [])
          when is_function(fallback_fn, 0) and is_list(opts) do
        cache_name = Keyword.get(opts, :cache_name, name())
        force? = Keyword.get(opts, :force?, false)

        if Plausible.Cache.enabled?() or force? do
          Adapter.get(cache_name, key, fallback_fn)
        else
          get_from_source(key) || fallback_fn.()
        end
      end

      def unwrap_cache_keys(items), do: items
      defoverridable unwrap_cache_keys: 1

      def repo(), do: Plausible.Repo
      defoverridable repo: 0

      @spec refresh_all(Keyword.t()) :: :ok
      def refresh_all(opts \\ []) do
        refresh(
          :all,
          base_db_query(),
          Keyword.put(opts, :delete_stale_items?, true)
        )
      end

      @spec refresh_updated_recently(Keyword.t()) :: :ok
      def refresh_updated_recently(opts \\ []) do
        recently_updated_query =
          from [s, ...] in base_db_query(),
            order_by: [asc: s.updated_at],
            where: s.updated_at > ago(^15, "minute")

        refresh(
          :updated_recently,
          recently_updated_query,
          Keyword.put(opts, :delete_stale_items?, false)
        )
      end

      @spec merge_items(new_items :: [any()], opts :: Keyword.t()) :: :ok
      def merge_items(new_items, opts \\ [])
      def merge_items([], _), do: :ok

      def merge_items(new_items, opts) do
        new_items = unwrap_cache_keys(new_items)
        cache_name = Keyword.get(opts, :cache_name, name())
        :ok = Adapter.put_many(cache_name, new_items)

        if Keyword.get(opts, :delete_stale_items?, true) do
          old_keys = Adapter.keys(cache_name)

          new = MapSet.new(Enum.into(new_items, [], fn {k, _} -> k end))
          old = MapSet.new(old_keys)

          old
          |> MapSet.difference(new)
          |> Enum.each(fn k ->
            Adapter.delete(cache_name, k)
          end)
        end

        :ok
      end

      @spec child_spec(Keyword.t()) :: Supervisor.child_spec()
      def child_spec(opts) do
        cache_name = Keyword.get(opts, :cache_name, name())
        child_id = Keyword.get(opts, :child_id, child_id())
        Adapter.child_spec(cache_name, child_id, opts)
      end

      @doc """
      Ensures the cache has non-zero size unless no items exist.
      Useful for orchestrating app startup to prevent the service
      going up asynchronously with an empty cache.
      """
      @spec ready?(atom()) :: boolean
      def ready?(cache_name \\ name()) do
        case size(cache_name) do
          n when is_integer(n) and n > 0 ->
            true

          0 ->
            count_all() == 0

          _ ->
            false
        end
      end

      defdelegate size(cache_name \\ name()), to: Plausible.Cache.Adapter

      @spec telemetry_event_refresh(atom(), atom()) :: list(atom())
      def telemetry_event_refresh(cache_name \\ name(), mode) when mode in @modes do
        [:plausible, :cache, cache_name, :refresh, mode]
      end

      defp refresh(mode, query, opts) when mode in @modes do
        cache_name = Keyword.get(opts, :cache_name, name())

        Plausible.PromEx.Plugins.PlausibleMetrics.measure_duration(
          telemetry_event_refresh(cache_name, mode),
          fn ->
            try do
              items = repo().all(query)
              :ok = merge_items(items, opts)
            catch
              _, e ->
                Logger.error("Error refreshing '#{cache_name}' - #{inspect(e)}")
            end
          end
        )

        :ok
      end
    end
  end
end
```

## File: `lib/plausible/cache/adapter.ex`
```
defmodule Plausible.Cache.Adapter do
  @moduledoc """
  Interface for the underlying cache implementation.
  Currently: ConCache

  Using the Adapter module directly, the user must ensure that the relevant
  processes are available to use, which is normally done via the child specification.
  """

  require Logger

  @spec child_specs(atom(), atom(), Keyword.t()) :: [Supervisor.child_spec()]
  def child_specs(name, child_id, opts \\ [])
      when is_atom(name) and is_atom(child_id) and is_list(opts) do
    partitions = partitions(name)

    if partitions == 1 do
      [child_spec(name, child_id, opts)]
    else
      Enum.map(1..partitions, fn partition ->
        partition_name = String.to_atom("#{name}_#{partition}")
        partition_child_id = String.to_atom("#{child_id}_#{partition}")

        child_spec(partition_name, partition_child_id, opts)
      end)
    end
  end

  @spec child_spec(atom(), atom(), Keyword.t()) :: Supervisor.child_spec()
  def child_spec(name, child_id, opts \\ [])
      when is_atom(name) and is_atom(child_id) and is_list(opts) do
    cache_name = Keyword.get(opts, :cache_name, name)
    child_id = Keyword.get(opts, :child_id, child_id)
    ttl_check_interval = Keyword.get(opts, :ttl_check_interval, false)

    opts =
      opts
      |> Keyword.put(:name, cache_name)
      |> Keyword.put(:ttl_check_interval, ttl_check_interval)

    Supervisor.child_spec(
      {ConCache, opts},
      id: child_id
    )
  end

  @spec size(atom()) :: non_neg_integer() | nil
  def size(cache_name) do
    cache_name
    |> get_names()
    |> Enum.map(&ConCache.size/1)
    |> Enum.sum()
  catch
    :exit, _ -> nil
  end

  @spec get(atom(), any()) :: any()
  def get(cache_name, key) do
    full_cache_name = get_name(cache_name, key)
    ConCache.get(full_cache_name, key)
  catch
    :exit, _ ->
      Logger.error("Error retrieving key from '#{inspect(cache_name)}'")
      nil
  end

  @spec get(atom(), any(), (-> any())) :: any()
  def get(cache_name, key, fallback_fn) do
    full_cache_name = get_name(cache_name, key)
    ConCache.dirty_get_or_store(full_cache_name, key, fallback_fn)
  catch
    :exit, _ ->
      Logger.error("Error retrieving key from '#{inspect(cache_name)}'")
      nil
  end

  @spec fetch(atom(), any(), (-> any())) :: any()
  def fetch(cache_name, key, fallback_fn) do
    full_cache_name = get_name(cache_name, key)
    ConCache.dirty_fetch_or_store(full_cache_name, key, fallback_fn)
  catch
    :exit, _ ->
      Logger.error("Error fetching key from '#{inspect(cache_name)}'")
      nil
  end

  @spec put(atom(), any(), any()) :: any()
  def put(cache_name, key, value, _opts \\ []) do
    full_cache_name = get_name(cache_name, key)
    :ok = ConCache.dirty_put(full_cache_name, key, value)

    value
  catch
    :exit, _ ->
      Logger.error("Error putting a key to '#{cache_name}'")
      nil
  end

  @spec put_many(atom(), [any()]) :: :ok
  def put_many(cache_name, items) when is_list(items) do
    items
    |> Enum.group_by(fn {key, _} -> get_name(cache_name, key) end)
    |> Enum.each(fn {full_cache_name, items} ->
      true = :ets.insert(ConCache.ets(full_cache_name), items)
    end)

    :ok
  catch
    :exit, _ ->
      Logger.error("Error putting keys to '#{cache_name}'")
      :ok
  end

  @spec delete(atom(), any()) :: :ok
  def delete(cache_name, key) do
    full_cache_name = get_name(cache_name, key)
    ConCache.dirty_delete(full_cache_name, key)
  catch
    :exit, _ ->
      Logger.error("Error deleting a key in '#{cache_name}'")
      :ok
  end

  @spec keys(atom()) :: Enumerable.t()
  def keys(cache_name) do
    cache_name
    |> get_names()
    |> Enum.reduce([], fn full_cache_name, stream ->
      Stream.concat(stream, get_keys(full_cache_name))
    end)
  catch
    :exit, _ ->
      Logger.error("Error retrieving key from '#{inspect(cache_name)}'")
      []
  end

  @spec get_names(atom()) :: [atom()]
  def get_names(cache_name) do
    partitions = partitions(cache_name)

    if partitions == 1 do
      [cache_name]
    else
      Enum.map(1..partitions, &String.to_existing_atom("#{cache_name}_#{&1}"))
    end
  end

  defp get_keys(full_cache_name) do
    ets = ConCache.ets(full_cache_name)

    Stream.resource(
      fn -> :ets.first(ets) end,
      fn
        :"$end_of_table" -> {:halt, nil}
        prev_key -> {[prev_key], :ets.next(ets, prev_key)}
      end,
      fn _ -> :ok end
    )
  end

  defp get_name(cache_name, key) do
    partitions = partitions(cache_name)

    if partitions == 1 do
      cache_name
    else
      chosen_partition = :erlang.phash2(key, partitions) + 1
      String.to_existing_atom("#{cache_name}_#{chosen_partition}")
    end
  end

  defp partitions(cache_name) do
    Application.get_env(:plausible, __MODULE__)[cache_name][:partitions] || 1
  end

  def cache2list(full_cache_name) do
    :ets.tab2list(ConCache.ets(full_cache_name))
  end
end
```

## File: `lib/plausible/cache/warmer.ex`
```
defmodule Plausible.Cache.Warmer do
  @moduledoc """
  A periodic cache warmer.

  Child specification options available:

    * `cache_impl` - module expected to implement `Plausible.Cache` behaviour
    * `interval` - the number of milliseconds for each warm-up cycle
    * `cache_name` - defaults to cache_impl.name() but can be overridden for testing
    * `force_start?` - enforcess process startup for testing, even if it's barred
      by `Plausible.Cache.enabled?`. This is useful for avoiding issues with DB ownership
      and async tests.
    * `warmer_fn` - by convention, either `:refresh_all` or `:refresh_updated_recently`,
      both are automatically provided by `cache_impl` module. Technically any exported
      or captured function will work, if need be.

  See tests for more comprehensive examples.
  """

  @behaviour :gen_cycle

  require Logger

  @spec child_spec(Keyword.t()) :: Supervisor.child_spec() | :ignore
  def child_spec(opts) do
    child_name = Keyword.get(opts, :child_name, __MODULE__)

    %{
      id: child_name,
      start: {:gen_cycle, :start_link, [{:local, child_name}, __MODULE__, opts]}
    }
  end

  @impl true
  def init_cycle(opts) do
    cache_impl = Keyword.fetch!(opts, :cache_impl)
    cache_name = Keyword.get(opts, :cache_name, cache_impl.name())
    interval = Keyword.fetch!(opts, :interval)

    warmer_fn =
      case Keyword.fetch!(opts, :warmer_fn) do
        f when is_function(f, 1) ->
          f

        f when is_atom(f) ->
          true = function_exported?(cache_impl, f, 1)
          Function.capture(cache_impl, f, 1)
      end

    force_start? = Keyword.get(opts, :force_start?, false)

    if Plausible.Cache.enabled?() or force_start? do
      Logger.notice(
        "#{__MODULE__} initializing #{inspect(warmer_fn)} #{cache_name} with interval #{interval}..."
      )

      {:ok,
       {interval,
        opts
        |> Keyword.put(:cache_name, cache_name)
        |> Keyword.put(:warmer_fn, warmer_fn)}}
    else
      :ignore
    end
  end

  @impl true
  def handle_cycle(opts) do
    cache_name = Keyword.fetch!(opts, :cache_name)
    warmer_fn = Keyword.fetch!(opts, :warmer_fn)

    Logger.notice("#{__MODULE__} running #{inspect(warmer_fn)} on #{cache_name}...")

    warmer_fn.(opts)

    {:continue_hibernated, opts}
  end

  @impl true
  def handle_info(_msg, state) do
    {:continue, state}
  end
end
```

## File: `lib/plausible/cldr.ex`
```
defmodule Plausible.Cldr do
  @moduledoc false

  use Cldr, locales: ["en"], providers: [Cldr.Number, Money]
end
```

## File: `lib/plausible/clickhouse_event_v2.ex`
```
defmodule Plausible.ClickhouseEventV2 do
  @moduledoc """
  Event schema for when NumericIDs migration is complete
  """
  use Ecto.Schema
  import Ecto.Changeset

  @primary_key false
  schema "events_v2" do
    field :name, Ch, type: "LowCardinality(String)"
    field :site_id, Ch, type: "UInt64"
    field :hostname, :string
    field :pathname, :string
    field :user_id, Ch, type: "UInt64"
    field :session_id, Ch, type: "UInt64"
    field :timestamp, :naive_datetime

    field :"meta.key", {:array, :string}
    field :"meta.value", {:array, :string}
    field :scroll_depth, Ch, type: "UInt8"
    field :engagement_time, Ch, type: "UInt32"

    field :revenue_source_amount, Ch, type: "Nullable(Decimal64(3))"
    field :revenue_source_currency, Ch, type: "FixedString(3)"
    field :revenue_reporting_amount, Ch, type: "Nullable(Decimal64(3))"
    field :revenue_reporting_currency, Ch, type: "FixedString(3)"

    # Session attributes
    field :referrer, :string
    field :referrer_source, :string
    field :click_id_param, Ch, type: "LowCardinality(String)"
    field :utm_medium, :string
    field :utm_source, :string
    field :utm_campaign, :string
    field :utm_content, :string
    field :utm_term, :string

    field :country_code, Ch, type: "FixedString(2)"
    field :subdivision1_code, Ch, type: "LowCardinality(String)"
    field :subdivision2_code, Ch, type: "LowCardinality(String)"
    field :city_geoname_id, Ch, type: "UInt32"

    field :screen_size, Ch, type: "LowCardinality(String)"
    field :operating_system, Ch, type: "LowCardinality(String)"
    field :operating_system_version, Ch, type: "LowCardinality(String)"
    field :browser, Ch, type: "LowCardinality(String)"
    field :browser_version, Ch, type: "LowCardinality(String)"

    field :acquisition_channel, Ch, type: "LowCardinality(String)", writable: :never

    # Virtual field used during event processing
    field :interactive?, :boolean, default: true, virtual: true, writable: :never
  end

  def new(attrs) do
    %__MODULE__{}
    |> cast(
      attrs,
      [
        :name,
        :site_id,
        :hostname,
        :pathname,
        :user_id,
        :timestamp,
        :"meta.key",
        :"meta.value",
        :scroll_depth,
        :engagement_time,
        :revenue_source_amount,
        :revenue_source_currency,
        :revenue_reporting_amount,
        :revenue_reporting_currency
      ]
    )
    |> validate_required([:name, :site_id, :hostname, :pathname, :user_id, :timestamp])
  end

  @session_properties [
    :session_id,
    :user_id,
    :referrer,
    :referrer_source,
    :click_id_param,
    :utm_medium,
    :utm_source,
    :utm_campaign,
    :utm_content,
    :utm_term,
    :country_code,
    :subdivision1_code,
    :subdivision2_code,
    :city_geoname_id,
    :screen_size,
    :operating_system,
    :operating_system_version,
    :browser,
    :browser_version
  ]

  def merge_session(%__MODULE__{} = event, session) do
    Map.merge(event, Map.take(session, @session_properties))
  end
end
```

## File: `lib/plausible/clickhouse_location_data.ex`
```
defmodule Plausible.ClickhouseLocationData do
  @moduledoc """
  Schema for storing location id <-> translation mappings in ClickHouse

  Indirectly read via dictionary `location_data_dictionary` in ALIAS columns in
  `events_v2`, `sessions_v2` and `imported_locations` table.
  """
  use Ecto.Schema

  @primary_key false
  schema "location_data" do
    field :type, Ch, type: "LowCardinality(String)"
    field :id, :string
    field :name, :string
  end
end
```

## File: `lib/plausible/clickhouse_repo.ex`
```
defmodule Plausible.ClickhouseRepo do
  use Plausible

  use Ecto.Repo,
    otp_app: :plausible,
    adapter: Ecto.Adapters.ClickHouse,
    read_only: true

  defmacro __using__(_) do
    quote do
      alias Plausible.ClickhouseRepo
      import Ecto
      import Ecto.Query, only: [from: 1, from: 2]
    end
  end

  @task_timeout 60_000
  def parallel_tasks(queries, opts \\ []) do
    ctx = OpenTelemetry.Ctx.get_current()

    execute_with_tracing = fn fun ->
      OpenTelemetry.Ctx.attach(ctx)
      fun.()
    end

    max_concurrency = Keyword.get(opts, :max_concurrency, 3)

    task_timeout =
      on_ee do
        @task_timeout
      else
        # Quadruple the repo timeout to ensure the task doesn't timeout before db_connection does.
        # This maintains the default ratio (@task_timeout / default_timeout = 60_000 / 15_000 = 4).
        ch_timeout = Keyword.fetch!(config(), :timeout)
        max(ch_timeout * 4, @task_timeout)
      end

    Task.async_stream(queries, execute_with_tracing,
      max_concurrency: max_concurrency,
      timeout: task_timeout
    )
    |> Enum.to_list()
    |> Keyword.values()
  end

  @impl true
  def prepare_query(_operation, query, opts) do
    {plausible_query, opts} = Keyword.pop(opts, :query)
    log_comment = if(plausible_query, do: Jason.encode!(plausible_query.debug_metadata), else: "")

    opts =
      Keyword.update(opts, :settings, [log_comment: log_comment], fn settings ->
        [{:log_comment, log_comment} | settings]
      end)

    {query, opts}
  end
end
```

## File: `lib/plausible/clickhouse_session_v2.ex`
```
defmodule Plausible.ClickhouseSessionV2 do
  @moduledoc """
  Session schema for when NumericIDs migration is complete
  """
  use Ecto.Schema

  defmodule BoolUInt8 do
    @moduledoc """
    Custom type to cast Bool as UInt8
    """

    use Ecto.Type

    u8 = Ecto.ParameterizedType.init(Ch, type: "UInt8")

    @impl true
    def type, do: unquote(Macro.escape(u8))

    @impl true
    def cast(true), do: {:ok, 1}
    def cast(false), do: {:ok, 0}
    def cast(nil), do: {:ok, 0}

    @impl true
    def load(1), do: {:ok, true}
    def load(0), do: {:ok, false}

    @impl true
    def dump(true), do: {:ok, 1}
    def dump(false), do: {:ok, 0}
    def dump(nil), do: {:ok, 0}
  end

  @primary_key false
  schema "sessions_v2" do
    field :hostname, :string
    field :site_id, Ch, type: "UInt64"
    field :user_id, Ch, type: "UInt64"
    field :session_id, Ch, type: "UInt64"

    field :start, :naive_datetime
    field :duration, Ch, type: "UInt32"
    field :is_bounce, BoolUInt8
    field :entry_page, :string
    field :exit_page, :string
    field :exit_page_hostname, :string
    field :pageviews, Ch, type: "Int32"
    field :events, Ch, type: "Int32"
    field :sign, Ch, type: "Int8"

    field :"entry_meta.key", {:array, :string}
    field :"entry_meta.value", {:array, :string}

    field :utm_medium, :string
    field :utm_source, :string
    field :utm_campaign, :string
    field :utm_content, :string
    field :utm_term, :string
    field :referrer, :string
    field :referrer_source, :string
    field :click_id_param, Ch, type: "LowCardinality(String)"

    field :country_code, Ch, type: "LowCardinality(FixedString(2))"
    field :subdivision1_code, Ch, type: "LowCardinality(String)"
    field :subdivision2_code, Ch, type: "LowCardinality(String)"
    field :city_geoname_id, Ch, type: "UInt32"

    field :screen_size, Ch, type: "LowCardinality(String)"
    field :operating_system, Ch, type: "LowCardinality(String)"
    field :operating_system_version, Ch, type: "LowCardinality(String)"
    field :browser, Ch, type: "LowCardinality(String)"
    field :browser_version, Ch, type: "LowCardinality(String)"
    field :timestamp, :naive_datetime

    field :transferred_from, :string

    field :acquisition_channel, Ch, type: "LowCardinality(String)", writable: :never
  end

  def random_uint64() do
    :crypto.strong_rand_bytes(8) |> :binary.decode_unsigned()
  end
end
```

## File: `lib/plausible/data_migration.ex`
```
defmodule Plausible.DataMigration do
  @moduledoc """
  Base module for coordinated Clickhouse data migrations
  run via remote shell or otherwise (TBD).
  """

  defmacro __using__(opts) do
    dir = Keyword.fetch!(opts, :dir)
    repo = Keyword.get(opts, :repo, Plausible.DataMigration.ClickhouseRepo)

    quote bind_quoted: [dir: dir, repo: repo] do
      @dir dir
      @repo repo

      def run_sql_confirm(name, assigns \\ [], options \\ []) do
        query = unwrap_with_io(name, assigns)
        message = Keyword.get(options, :prompt_message, "Execute?")
        default_choice = Keyword.get(options, :prompt_default_choice, :yes)
        confirm(message, fn -> do_run(name, query) end, default_choice)
      end

      def confirm(message, func, default_choice \\ :yes) do
        choices =
          case default_choice do
            :yes -> " [Y/n]: "
            :no -> " [y/N]: "
          end

        prompt = IO.ANSI.white() <> message <> choices <> IO.ANSI.reset()
        answer = String.downcase(String.trim(IO.gets(prompt)))

        skip = fn ->
          IO.puts("    #{IO.ANSI.cyan()}Skipped.#{IO.ANSI.reset()}")
          {:ok, :skip}
        end

        case answer do
          "y" ->
            func.()

          "n" ->
            skip.()

          _ ->
            case default_choice do
              :yes -> func.()
              :no -> skip.()
            end
        end
      end

      def unwrap(name, assigns \\ []) do
        :plausible
        |> :code.priv_dir()
        |> Path.join("data_migrations")
        |> Path.join(@dir)
        |> Path.join("sql")
        |> Path.join(name <> ".sql.eex")
        |> EEx.eval_file(assigns: assigns)
      end

      @doc """
      Runs a single SQL query in a file.

      Valid options:
      - `quiet` - reduces output from running the SQL
      - `params` - List of query parameters.
      - `query_options` - passed to Repo.query
      """
      def run_sql(name, assigns \\ [], options \\ []) do
        query = unwrap(name, assigns)

        do_run(name, query, options)
      end

      @doc """
      Runs multiple SQL queries from a single file.

      Note that each query must be separated by semicolons.
      """
      def run_sql_multi(name, assigns \\ [], options \\ []) do
        unwrap(name, assigns)
        |> String.trim()
        |> String.split(";", trim: true)
        |> Enum.with_index(1)
        |> Enum.reduce_while(:ok, fn {query, index}, _ ->
          case do_run("#{name}-#{index}", query, options) do
            {:ok, _} -> {:cont, :ok}
            error -> {:halt, error}
          end
        end)
      end

      def do_run(name, query, options \\ []) do
        params = Keyword.get(options, :params, [])
        query_options = Keyword.get(options, :query_options, [])

        case @repo.query(query, params, [timeout: :infinity] ++ query_options) do
          {:ok, res} ->
            if not Keyword.get(options, :quiet, false) do
              IO.puts(
                "    #{IO.ANSI.yellow()}#{name} #{IO.ANSI.green()}Done!#{IO.ANSI.reset()}\n"
              )

              IO.puts(String.duplicate("-", 78))
            end

            {:ok, res}

          result ->
            result
        end
      end

      defp unwrap_with_io(name, assigns) do
        IO.puts("#{IO.ANSI.yellow()}Running #{name}#{IO.ANSI.reset()}")
        query = unwrap(name, assigns)

        IO.puts("""
          -> Query: #{IO.ANSI.blue()}#{String.trim(query)}#{IO.ANSI.reset()}
        """)

        query
      end
    end
  end
end
```

## File: `lib/plausible/data_migration/acquisition_channel.ex`
```
defmodule Plausible.DataMigration.AcquisitionChannel do
  @moduledoc """
  Creates dictionaries and functions to calculate acquisition channel in ClickHouse

  Creates `acquisition_channel` columns in `events_v2` and `sessions_v2` tables.
  Run via `Plausible.DataMigration.AcquisitionChannel.run(options)`

  Options:
  - `add_column` - creates the materialized column. Already done in a migration
  - `update_column` - Updates the column definition to use new function definitions. Defaults to true.
      Note that historical data is only updated if `backfill` is set to true or if it was never materialized.
  - `backfill` - backfills the data for the column. Speeds up calculations on historical data.

  SQL files available at: priv/data_migrations/AcquisitionChannel/sql
  """
  use Plausible.DataMigration, dir: "AcquisitionChannel", repo: Plausible.IngestRepo

  def run(opts \\ []) do
    on_cluster_statement = Plausible.MigrationUtils.on_cluster_statement("sessions_v2")
    # In distributed environments, wait for insert to all temporary tables.
    insert_quorum = Plausible.IngestRepo.replica_count("sessions_v2")

    :ok =
      run_sql_multi(
        "acquisition_channel_functions",
        [
          on_cluster_statement: on_cluster_statement,
          table_settings: Plausible.MigrationUtils.table_settings_expr(),
          dictionary_connection_params: Plausible.MigrationUtils.dictionary_connection_params(),
          insert_quorum: insert_quorum
        ],
        params: %{
          "source_categories" =>
            Plausible.Ingestion.Acquisition.source_categories() |> Map.to_list(),
          "paid_sources" => Plausible.Ingestion.Source.paid_sources()
        },
        quiet: Keyword.get(opts, :quiet, false)
      )

    cond do
      Keyword.get(opts, :add_column) ->
        alter_data_tables(
          "acquisition_channel_add_materialized_column",
          on_cluster_statement,
          opts
        )

      Keyword.get(opts, :update_column, true) ->
        alter_data_tables(
          "acquisition_channel_update_materialized_column",
          on_cluster_statement,
          opts
        )

      true ->
        nil
    end

    if Keyword.get(opts, :backfill) do
      alter_data_tables(
        "acquisition_channel_backfill_materialized_column",
        on_cluster_statement,
        opts
      )
    end

    :ok
  end

  defp alter_data_tables(sql_name, on_cluster_statement, opts) do
    {:ok, _} =
      run_sql(
        sql_name,
        [
          table: "events_v2",
          on_cluster_statement: on_cluster_statement
        ],
        quiet: Keyword.get(opts, :quiet, false)
      )

    {:ok, _} =
      run_sql(
        sql_name,
        [
          table: "sessions_v2",
          on_cluster_statement: on_cluster_statement
        ],
        quiet: Keyword.get(opts, :quiet, false)
      )
  end
end
```

## File: `lib/plausible/data_migration/backfill_teams.ex`
```
defmodule Plausible.DataMigration.BackfillTeams do
  @moduledoc """
  Backfill and sync all teams related entities.
  """

  import Ecto.Query

  alias Plausible.Repo

  defmacrop is_distinct(f1, f2) do
    quote do
      fragment("? IS DISTINCT FROM ?", unquote(f1), unquote(f2))
    end
  end

  def run(opts \\ []) do
    dry_run? = Keyword.get(opts, :dry_run?, true)
    Repo.transaction(fn -> backfill(dry_run?) end, timeout: :infinity)
  end

  defp backfill(dry_run?) do
    # Orphaned teams

    orphaned_teams =
      from(
        t in "teams",
        left_join: tm in "team_memberships",
        on: tm.team_id == t.id,
        left_join: s in "sites",
        on: s.team_id == t.id,
        where: is_nil(tm.id),
        where: is_nil(s.id),
        select: %{id: t.id}
      )
      |> Repo.all(timeout: :infinity)

    log("Found #{length(orphaned_teams)} orphaned teams...")

    if not dry_run? do
      delete_orphaned_teams(orphaned_teams)

      log("Deleted orphaned teams")
    end

    # Sites without teams

    sites_without_teams =
      from(
        s in "sites",
        inner_join: m in "site_memberships",
        on: m.site_id == s.id,
        inner_join: o in "users",
        on: o.id == m.user_id,
        where: m.role == "owner",
        where: is_nil(s.team_id),
        select: %{
          id: s.id,
          owner_id: o.id
        }
      )
      |> Repo.all(timeout: :infinity)

    log("Found #{length(sites_without_teams)} sites without teams...")

    if not dry_run? do
      teams_count = backfill_teams(sites_without_teams)

      log("Backfilled #{teams_count} teams.")
    end

    # Users on trial without team

    users_on_trial_without_team =
      from(
        u in "users",
        as: :user,
        where: not is_nil(u.trial_expiry_date),
        where:
          not exists(
            from tm in "team_memberships",
              where: tm.role == "owner",
              where: tm.user_id == parent_as(:user).id,
              select: 1
          ),
        select: u.id
      )
      |> Repo.all(timeout: :infinity)

    log("Found #{length(users_on_trial_without_team)} users on trial without team...")

    if not dry_run? do
      Enum.each(users_on_trial_without_team, fn user_id ->
        create_personal_team(user_id)
      end)

      log("Created teams for all users on trial without a team.")
    end

    # Guest memberships with mismatched team site

    mismatched_guest_memberships_to_remove =
      from(
        gm in "guest_memberships",
        inner_join: tm in "team_memberships",
        on: tm.id == gm.team_membership_id,
        inner_join: s in "sites",
        on: s.id == gm.site_id,
        where: tm.team_id != s.team_id,
        select: gm.id
      )
      |> Repo.all()

    log(
      "Found #{length(mismatched_guest_memberships_to_remove)} guest memberships with mismatched team to remove..."
    )

    if not dry_run? do
      team_ids_to_prune = remove_guest_memberships(mismatched_guest_memberships_to_remove)

      log("Pruning guest team memberships for #{length(team_ids_to_prune)} teams...")

      Enum.each(team_ids_to_prune, fn team_id ->
        prune_guests(team_id)
      end)

      log("Guest memberships with mismatched team cleared.")
    end

    # Guest Memberships cleanup

    site_memberships_query =
      from(
        sm in "site_memberships",
        where: sm.site_id == parent_as(:guest_membership).site_id,
        where: sm.user_id == parent_as(:team_membership).user_id,
        where: sm.role != "owner",
        select: 1
      )

    guest_memberships_to_remove =
      from(
        gm in "guest_memberships",
        as: :guest_membership,
        inner_join: tm in "team_memberships",
        on: tm.id == gm.team_membership_id,
        as: :team_membership,
        where: not exists(site_memberships_query),
        select: gm.id
      )
      |> Repo.all(timeout: :infinity)

    log("Found #{length(guest_memberships_to_remove)} guest memberships to remove...")

    if not dry_run? do
      team_ids_to_prune = remove_guest_memberships(guest_memberships_to_remove)

      log("Pruning guest team memberships for #{length(team_ids_to_prune)} teams...")

      Enum.each(team_ids_to_prune, fn team ->
        prune_guests(team.id)
      end)

      log("Guest memberships cleared.")
    end

    # Guest Memberships backfill

    guest_memberships_query =
      from(
        gm in "guest_memberships",
        inner_join: tm in "team_memberships",
        on: tm.id == gm.team_membership_id,
        where: gm.site_id == parent_as(:site_membership).site_id,
        where: tm.user_id == parent_as(:site_membership).user_id,
        select: 1
      )

    site_memberships_to_backfill =
      from(
        sm in "site_memberships",
        as: :site_membership,
        inner_join: s in "sites",
        on: s.id == sm.site_id,
        inner_join: t in "teams",
        on: t.id == s.team_id,
        inner_join: u in "users",
        on: u.id == sm.user_id,
        where: sm.role != "owner",
        where: not exists(guest_memberships_query),
        select: %{
          user_id: u.id,
          site_id: s.id,
          team_id: t.id,
          inserted_at: sm.inserted_at,
          updated_at: sm.updated_at,
          role: sm.role
        }
      )
      |> Repo.all(timeout: :infinity)

    log(
      "Found #{length(site_memberships_to_backfill)} site memberships without guest membership..."
    )

    if not dry_run? do
      backfill_guest_memberships(site_memberships_to_backfill)

      log("Backfilled missing guest memberships.")
    end

    # Stale guest memberships sync

    stale_guest_memberships =
      from(
        sm in "site_memberships",
        inner_join: tm in "team_memberships",
        on: tm.user_id == sm.user_id,
        inner_join: gm in "guest_memberships",
        on: gm.site_id == sm.site_id,
        where: tm.role == "guest",
        where:
          (gm.role == "viewer" and sm.role == "admin") or
            (gm.role == "editor" and sm.role == "viewer"),
        select: {gm.id, sm.role}
      )
      |> Repo.all(timeout: :infinity)

    log("Found #{length(stale_guest_memberships)} guest memberships with role out of sync...")

    if not dry_run? do
      sync_guest_memberships(stale_guest_memberships)

      log("All guest memberships are up to date now.")
    end

    # Guest invitations cleanup

    site_invitations_query =
      from(
        i in "invitations",
        where: i.site_id == parent_as(:guest_invitation).site_id,
        where: i.email == parent_as(:team_invitation).email,
        where:
          (i.role == "viewer" and parent_as(:guest_invitation).role == "viewer") or
            (i.role == "admin" and parent_as(:guest_invitation).role == "editor"),
        select: true
      )

    guest_invitations_to_remove =
      from(
        gi in "guest_invitations",
        as: :guest_invitation,
        inner_join: ti in "team_invitations",
        on: ti.id == gi.team_invitation_id,
        as: :team_invitation,
        where: not exists(site_invitations_query),
        select: gi.id
      )
      |> Repo.all(timeout: :infinity)

    log("Found #{length(guest_invitations_to_remove)} guest invitations to remove...")

    if not dry_run? do
      team_ids_to_prune = remove_guest_invitations(guest_invitations_to_remove)

      log("Pruning guest team invitations for #{length(team_ids_to_prune)} teams...")

      Enum.each(team_ids_to_prune, fn team_id ->
        prune_guest_invitations(team_id)
      end)

      log("Guest invitations cleared.")
    end

    # Guest invitations backfill

    guest_invitations_query =
      from(
        gi in "guest_invitations",
        inner_join: ti in "team_invitations",
        on: ti.id == gi.team_invitation_id,
        where: gi.site_id == parent_as(:site_invitation).site_id,
        where: ti.email == parent_as(:site_invitation).email,
        select: 1
      )

    site_invitations_to_backfill =
      from(
        si in "invitations",
        as: :site_invitation,
        inner_join: s in "sites",
        on: si.site_id == s.id,
        inner_join: t in "teams",
        on: t.id == s.team_id,
        inner_join: inv in "users",
        on: inv.id == si.inviter_id,
        where: si.role != "owner",
        where: not exists(guest_invitations_query),
        select: %{
          inserted_at: si.inserted_at,
          updated_at: si.updated_at,
          role: si.role,
          invitation_id: si.invitation_id,
          email: si.email,
          site_id: s.id,
          team_id: t.id,
          inviter_id: inv.id
        }
      )
      |> Repo.all(timeout: :infinity)

    log(
      "Found #{length(site_invitations_to_backfill)} site invitations without guest invitation..."
    )

    if not dry_run? do
      backfill_guest_invitations(site_invitations_to_backfill)

      log("Backfilled missing guest invitations.")
    end

    # Stale guest invitations sync

    stale_guest_invitations =
      from(
        si in "invitations",
        inner_join: ti in "team_invitations",
        on: ti.email == si.email,
        inner_join: gi in "guest_invitations",
        on: gi.team_invitation_id == ti.id,
        on: gi.site_id == si.site_id,
        where: ti.role == "guest",
        where:
          (gi.role == "viewer" and si.role == "admin") or
            (gi.role == "editor" and si.role == "viewer") or
            is_distinct(gi.invitation_id, si.invitation_id),
        select: {gi.id, %{role: si.role, invitation_id: si.invitation_id}}
      )
      |> Repo.all(timeout: :infinity)

    log("Found #{length(stale_guest_invitations)} guest invitations with role out of sync...")

    if not dry_run? do
      sync_guest_invitations(stale_guest_invitations)

      log("All guest invitations are up to date now.")
    end

    # Site transfers cleanup

    site_invitations_query =
      from(
        i in "invitations",
        where: i.site_id == parent_as(:site_transfer).site_id,
        where: i.email == parent_as(:site_transfer).email,
        where: i.role == "owner",
        select: true
      )

    site_transfers_to_remove =
      from(
        st in "team_site_transfers",
        as: :site_transfer,
        where: not exists(site_invitations_query),
        select: st.id
      )
      |> Repo.all(timeout: :infinity)

    log("Found #{length(site_transfers_to_remove)} site transfers to remove...")

    if not dry_run? do
      remove_site_transfers(site_transfers_to_remove)

      log("Site transfers cleared.")
    end

    # Site transfers backfill

    site_transfers_query =
      from(
        st in "team_site_transfers",
        where: st.site_id == parent_as(:site_invitation).site_id,
        where: st.email == parent_as(:site_invitation).email,
        select: 1
      )

    site_invitations_to_backfill =
      from(
        si in "invitations",
        as: :site_invitation,
        inner_join: s in "sites",
        on: s.id == si.site_id,
        inner_join: inv in "users",
        on: inv.id == si.inviter_id,
        where: si.role == "owner",
        where: not exists(site_transfers_query),
        select: %{
          email: si.email,
          invitation_id: si.invitation_id,
          inserted_at: si.inserted_at,
          updated_at: si.updated_at,
          site_id: s.id,
          inviter_id: inv.id
        }
      )
      |> Repo.all(timeout: :infinity)

    log(
      "Found #{length(site_invitations_to_backfill)} ownership transfers without site transfer..."
    )

    if not dry_run? do
      backfill_site_transfers(site_invitations_to_backfill)

      log("Backfilled missing site transfers.")

      log("All data are up to date now!")
    end
  end

  def delete_orphaned_teams(teams) do
    ids = Enum.map(teams, & &1.id)
    Repo.delete_all(from(t in "teams", where: t.id in ^ids))
  end

  defp backfill_teams(sites) do
    sites
    |> Enum.map(fn %{id: site_id, owner_id: owner_id} ->
      {owner_id, site_id}
    end)
    |> Enum.group_by(&elem(&1, 0), &elem(&1, 1))
    |> tap(fn
      grouped when grouped != %{} ->
        log("Teams about to be created: #{map_size(grouped)}")

        log(
          "Max sites: #{Enum.max_by(grouped, fn {_, sites} -> length(sites) end) |> elem(1) |> length()}"
        )

      _ ->
        :pass
    end)
    |> Enum.map(fn {owner_id, site_ids} ->
      Repo.transaction(
        fn ->
          {user_id, trial_expiry_date, updated_at} =
            from(
              u in "users",
              where: u.id == ^owner_id,
              select: {u.id, u.trial_expiry_date, u.updated_at}
            )
            |> Repo.one!()

          team = create_personal_team(user_id)

          Repo.update_all(
            from(t in "teams", where: t.id == ^team.id),
            set: [
              trial_expiry_date: trial_expiry_date,
              updated_at: updated_at
            ]
          )

          Repo.update_all(from(s in "sites", where: s.id in ^site_ids),
            set: [team_id: team.id]
          )
        end,
        timeout: :infinity
      )

      IO.write(".")
    end)
    |> length()
  end

  defp remove_guest_memberships(guest_membership_ids) do
    {_, team_ids} =
      Repo.delete_all(
        from(
          gm in "guest_memberships",
          inner_join: tm in "team_memberships",
          on: tm.id == gm.team_membership_id,
          where: gm.id in ^guest_membership_ids,
          select: tm.team_id
        )
      )

    Enum.uniq(team_ids)
  end

  defp backfill_guest_memberships(site_memberships) do
    site_memberships
    |> Enum.group_by(&{&1.team_id, &1.user_id}, & &1)
    |> tap(fn
      grouped when grouped != %{} ->
        log("Team memberships to be created: #{map_size(grouped)}")

        log(
          "Max guest memberships: #{Enum.max_by(grouped, fn {_, gms} -> length(gms) end) |> elem(1) |> length()}"
        )

      _ ->
        :pass
    end)
    |> Enum.each(fn {{team_id, user_id}, site_memberships} ->
      first_site_membership =
        Enum.min_by(site_memberships, & &1.inserted_at)

      team_membership_data = %{
        team_id: team_id,
        user_id: user_id,
        role: "guest",
        is_autocreated: false,
        inserted_at: first_site_membership.inserted_at,
        updated_at: first_site_membership.updated_at
      }

      {_, [team_membership]} =
        Repo.insert_all(
          "team_memberships",
          [team_membership_data],
          returning: [:id],
          on_conflict: [set: [updated_at: first_site_membership.updated_at]],
          conflict_target: [:team_id, :user_id]
        )

      Enum.each(site_memberships, fn site_membership ->
        guest_membership_data = %{
          team_membership_id: team_membership.id,
          site_id: site_membership.site_id,
          role: translate_role(site_membership.role),
          inserted_at: site_membership.inserted_at,
          updated_at: site_membership.updated_at
        }

        Repo.insert_all("guest_memberships", [guest_membership_data])
      end)

      IO.write(".")
    end)
  end

  defp sync_guest_memberships(guest_memberships_and_roles) do
    Enum.each(guest_memberships_and_roles, fn {guest_membership_id, role} ->
      Repo.update_all(
        from(gm in "guest_memberships", where: gm.id == ^guest_membership_id),
        set: [role: translate_role(role)]
      )

      IO.write(".")
    end)
  end

  defp remove_guest_invitations(guest_invitation_ids) do
    {_, team_ids} =
      Repo.delete_all(
        from(
          gi in "guest_invitations",
          inner_join: ti in "team_invitations",
          on: ti.id == gi.team_invitation_id,
          where: gi.id in ^guest_invitation_ids,
          select: ti.team_id
        )
      )

    Enum.uniq(team_ids)
  end

  defp backfill_guest_invitations(site_invitations) do
    site_invitations
    |> Enum.group_by(&{&1.team_id, &1.email}, & &1)
    |> Enum.each(fn {{team_id, email}, site_invitations} ->
      first_site_invitation = List.first(site_invitations)

      team_invitation_data = %{
        invitation_id: Nanoid.generate(),
        email: email,
        role: "guest",
        inviter_id: first_site_invitation.inviter_id,
        team_id: team_id,
        inserted_at: first_site_invitation.inserted_at,
        updated_at: first_site_invitation.updated_at
      }

      {_, [team_invitation]} =
        Repo.insert_all(
          "team_invitations",
          [team_invitation_data],
          on_conflict: [set: [updated_at: first_site_invitation.updated_at]],
          conflict_target: [:team_id, :email],
          returning: [:id]
        )

      Enum.each(site_invitations, fn site_invitation ->
        guest_invitation_data = %{
          invitation_id: site_invitation.invitation_id,
          role: translate_role(site_invitation.role),
          site_id: site_invitation.site_id,
          team_invitation_id: team_invitation.id,
          inserted_at: site_invitation.inserted_at,
          updated_at: site_invitation.updated_at
        }

        Repo.insert_all("guest_invitations", [guest_invitation_data])
      end)

      IO.write(".")
    end)
  end

  defp sync_guest_invitations(guest_and_site_invitations) do
    Enum.each(guest_and_site_invitations, fn {guest_invitation_id, site_invitation} ->
      Repo.update_all(
        from(gi in "guest_invitations", where: gi.id == ^guest_invitation_id),
        set: [
          role: translate_role(site_invitation.role),
          invitation_id: site_invitation.invitation_id
        ]
      )

      IO.write(".")
    end)
  end

  defp remove_site_transfers(site_transfer_ids) do
    Repo.delete_all(from(st in "team_site_transfers", where: st.id in ^site_transfer_ids))
  end

  defp backfill_site_transfers(site_invitations) do
    Enum.each(site_invitations, fn site_invitation ->
      site_transfer_data = %{
        initiator: site_invitation.inviter_id,
        email: site_invitation.email,
        site_id: site_invitation.site_id,
        transfer_id: site_invitation.invitation_id,
        inserted_at: site_invitation.inserted_at,
        updated_at: site_invitation.updated_at
      }

      Repo.insert_all("team_site_transfers", [site_transfer_data])

      IO.write(".")
    end)
  end

  defp translate_role("admin"), do: "editor"
  defp translate_role("viewer"), do: "viewer"

  defp log(msg) do
    IO.puts("[#{DateTime.utc_now(:second)}] #{msg}")
  end

  defp create_personal_team(user_id) do
    trial_expiry_date = Date.shift(Date.utc_today(), year: 100)

    team_data =
      %{
        identifier: Ecto.UUID.generate() |> Ecto.UUID.dump!(),
        name: "My Personal Sites",
        trial_expiry_date: trial_expiry_date,
        accept_traffic_until: Date.add(trial_expiry_date, 14),
        hourly_api_request_limit: 1_000_000,
        allow_next_upgrade_override: false,
        locked: false,
        setup_complete: false,
        inserted_at: NaiveDateTime.utc_now(),
        updated_at: NaiveDateTime.utc_now()
      }

    {1, [team]} = Repo.insert_all("teams", [team_data], returning: [:id])

    team_membership_data = %{
      team_id: team.id,
      user_id: user_id,
      role: "owner",
      is_autocreated: true,
      inserted_at: NaiveDateTime.utc_now(),
      updated_at: NaiveDateTime.utc_now()
    }

    {1, _} = Repo.insert_all("team_memberships", [team_membership_data])

    team
  end

  defp prune_guests(team_id) do
    guest_query =
      from(
        gm in "guest_memberships",
        where: gm.team_membership_id == parent_as(:team_membership).id,
        select: true
      )

    Repo.delete_all(
      from(
        tm in "team_memberships",
        as: :team_membership,
        where: tm.team_id == ^team_id and tm.role == "guest",
        where: not exists(guest_query)
      )
    )
  end

  defp prune_guest_invitations(team_id) do
    guest_query =
      from(
        gi in "guest_invitations",
        where: gi.team_invitation_id == parent_as(:team_invitation).id,
        select: true
      )

    Repo.delete_all(
      from(
        ti in "team_invitations",
        as: :team_invitation,
        where: ti.team_id == ^team_id and ti.role == "guest",
        where: not exists(guest_query)
      )
    )
  end
end
```

## File: `lib/plausible/data_migration/backfill_teams_hourly_api_request_limit.ex`
```
defmodule Plausible.DataMigration.BackfillTeamsHourlyRequestLimit do
  @moduledoc """
  !!!WARNING!!!: This script is used in migrations. Please take special care
  when altering it.

  Backfill `Team.hourly_api_request_limit`.
  """

  import Ecto.Query

  alias Plausible.Billing
  alias Plausible.Repo
  alias Plausible.Teams

  def run(opts \\ []) do
    dry_run? = Keyword.get(opts, :dry_run?, true)

    log("DRY RUN: #{dry_run?}")

    active_enterprise_plans_query =
      from t in Teams.Team,
        as: :team,
        inner_lateral_join: s in subquery(Teams.last_subscription_join_query()),
        on: true,
        inner_join: ep in Billing.EnterprisePlan,
        on: ep.team_id == t.id and ep.paddle_plan_id == s.paddle_plan_id,
        select: ep

    active_enterprise_plans_query
    |> Repo.all()
    |> tap(fn enterprise_plans ->
      log("About to update #{length(enterprise_plans)} teams with active enterprise plans...")
    end)
    |> Enum.each(fn enterprise_plan ->
      log(
        "Updating team ##{enterprise_plan.team_id} to hourly API request limit " <>
          "of #{enterprise_plan.hourly_api_request_limit} rps"
      )

      if not dry_run? do
        Repo.update_all(
          from(t in Teams.Team, where: t.id == ^enterprise_plan.team_id),
          set: [hourly_api_request_limit: enterprise_plan.hourly_api_request_limit]
        )
      end
    end)

    log("Done!")
  end

  def log(msg) do
    IO.puts("[#{inspect(__MODULE__)}] #{msg}")
  end
end
```

## File: `lib/plausible/data_migration/backfill_tracker_script_configuration.ex`
```
defmodule Plausible.DataMigration.BackfillTrackerScriptConfiguration do
  @moduledoc """
  Backfill Plausible.Site.TrackerScriptConfiguration for all sites.
  """

  import Ecto.Query

  alias Plausible.Repo

  defmodule TrackerScriptConfigurationSnapshot do
    @moduledoc """
    A snapshot of the Plausible.Site.TrackerScriptConfiguration schema from May 2025.
    """

    use Ecto.Schema

    @primary_key false
    schema "tracker_script_configuration" do
      field :id, :string
      field :installation_type, Ecto.Enum, values: [:manual, :wordpress, :gtm, nil]

      field :track_404_pages, :boolean, default: false
      field :hash_based_routing, :boolean, default: false
      field :outbound_links, :boolean, default: false
      field :file_downloads, :boolean, default: false
      field :revenue_tracking, :boolean, default: false
      field :tagged_events, :boolean, default: false
      field :form_submissions, :boolean, default: false
      field :pageview_props, :boolean, default: false

      field :site_id, :integer

      timestamps()
    end
  end

  def run() do
    now = NaiveDateTime.utc_now(:second)
    process_batch(0, now)
  end

  @batch_size 1000

  def process_batch(offset, now) do
    sites =
      Repo.all(
        from(s in Plausible.Site, order_by: [asc: :id], limit: @batch_size, offset: ^offset)
      )

    if length(sites) > 0 do
      create_tracker_script_configurations(sites, now)
      process_batch(offset + @batch_size, now)
    end
  end

  defp create_tracker_script_configurations(sites, now) do
    configurations = Enum.map(sites, &tracker_script_configuration(&1, now))

    Repo.insert_all(
      TrackerScriptConfigurationSnapshot,
      configurations,
      # Conflicts mean that the site has already been updated and is in sync
      on_conflict: :nothing,
      conflict_target: [:site_id]
    )
  end

  defp tracker_script_configuration(site, now) do
    installation_meta = site.installation_meta
    installation_type = if(installation_meta, do: installation_meta.installation_type, else: nil)
    script_config = if(installation_meta, do: installation_meta.script_config, else: %{})

    %{
      id: Nanoid.generate(),
      site_id: site.id,
      installation_type: installation_type |> remap_installation_type(),
      track_404_pages: Map.get(script_config, "404", false),
      hash_based_routing: Map.get(script_config, "hash", false),
      outbound_links: Map.get(script_config, "outbound-links", false),
      file_downloads: Map.get(script_config, "file-downloads", false),
      revenue_tracking: Map.get(script_config, "revenue", false),
      tagged_events: Map.get(script_config, "tagged-events", false),
      form_submissions: Map.get(script_config, "form-submissions", false),
      pageview_props: Map.get(script_config, "pageview-props", false),
      inserted_at: now,
      updated_at: now
    }
  end

  defp remap_installation_type("WordPress"), do: :wordpress
  defp remap_installation_type("GTM"), do: :gtm
  defp remap_installation_type("manual"), do: :manual
  defp remap_installation_type(nil), do: nil
end
```

## File: `lib/plausible/data_migration/clean_up_demo_site_referrer_source.ex`
```
defmodule Plausible.DataMigration.CleanUpDemoSiteReferrerSource do
  @moduledoc """
  Clean up referrer_source entries for demo site with
  `Direct / None` for value populated by dogfooding
  Plausible stats.
  """

  alias Plausible.IngestRepo
  alias Plausible.Repo

  def run(timeout \\ 60_000) do
    demo_domain = PlausibleWeb.Endpoint.host()
    %{id: demo_site_id} = Repo.get_by(Plausible.Site, domain: demo_domain)

    for table <- ["sessions_v2", "events_v2"] do
      IngestRepo.query!(
        "ALTER TABLE {$0:Identifier} UPDATE referrer_source = '' WHERE " <>
          "site_id = {$1:UInt64} AND referrer_source = 'Direct / None'",
        [table, demo_site_id],
        settings: [mutations_sync: 1],
        timeout: timeout
      )
    end
  end
end
```

## File: `lib/plausible/data_migration/clickhouse_repo.ex`
```
defmodule Plausible.DataMigration.ClickhouseRepo do
  @moduledoc """
  Ecto.Repo for Clickhouse data migrations, to be started manually,
  outside of the main application supervision tree.
  """
  use Ecto.Repo,
    otp_app: :plausible,
    adapter: Ecto.Adapters.ClickHouse

  def start(url, max_threads) when is_binary(url) and is_integer(max_threads) do
    default_config = Plausible.IngestRepo.config()

    start_link(
      url: url,
      queue_target: 500,
      queue_interval: 2000,
      pool_size: 1,
      settings: [
        max_insert_threads: max_threads,
        send_progress_in_http_headers: 1
      ],
      transport_opts: Keyword.fetch!(default_config, :transport_opts)
    )
  end
end
```

## File: `lib/plausible/data_migration/locations_sync.ex`
```
defmodule Plausible.DataMigration.LocationsSync do
  @moduledoc """
  ClickHouse locations data migration for storing location names in ClickHouse.

  Only run when `Location.version()` changes: either as a migration or in cron.

  The migration:
  1. Truncates existing `location_data` table (if exists)
  2. Creates new table (if needed)
  3. Inserts new data from Location module
  4. (Re-)Creates dictionary to read location data from table
  5. Creates ALIAS columns in `events_v2`, `sessions_v2` and `imported_locations` table to make reading location names easy
  6. Updates table comment for `location_data` to indicate last version synced.

  Note that the dictionary is large enough to cache the whole dataset in memory, making lookups fast.

  This migration is intended to be idempotent and rerunnable - if run multiple times, it should always set things to the same
  result as if run once.

  SQL files available at: priv/data_migrations/LocationsSync/sql
  """
  alias Plausible.ClickhouseLocationData

  use Plausible.DataMigration, dir: "LocationsSync", repo: Plausible.IngestRepo

  @columns [
    %{
      table: "events_v2",
      column_name: "country_name",
      type: "country",
      input_column: "country_code"
    },
    %{
      table: "events_v2",
      column_name: "region_name",
      type: "subdivision",
      input_column: "subdivision1_code"
    },
    %{
      table: "events_v2",
      column_name: "city_name",
      type: "city",
      input_column: "city_geoname_id"
    },
    %{
      table: "sessions_v2",
      column_name: "country_name",
      type: "country",
      input_column: "country_code"
    },
    %{
      table: "sessions_v2",
      column_name: "region_name",
      type: "subdivision",
      input_column: "subdivision1_code"
    },
    %{
      table: "sessions_v2",
      column_name: "city_name",
      type: "city",
      input_column: "city_geoname_id"
    },
    %{
      table: "imported_locations",
      column_name: "country_name",
      type: "country",
      input_column: "country"
    },
    %{
      table: "imported_locations",
      column_name: "region_name",
      type: "subdivision",
      input_column: "region"
    },
    %{
      table: "imported_locations",
      column_name: "city_name",
      type: "city",
      input_column: "city"
    }
  ]

  def out_of_date?() do
    case run_sql("get-location-data-table-comment") do
      {:ok, %{rows: [[stored_version]]}} -> stored_version != Location.version()
      _ -> true
    end
  end

  def run() do
    cluster? = Plausible.IngestRepo.clustered_table?("sessions_v2")

    {:ok, _} = run_sql("truncate-location-data-table", cluster?: cluster?)

    {:ok, _} =
      run_sql("create-location-data-table",
        cluster?: cluster?,
        table_settings: Plausible.MigrationUtils.table_settings_expr(:suffix)
      )

    countries =
      Location.Country.all()
      |> Enum.map(fn %Location.Country{alpha_2: alpha_2, name: name} ->
        %{type: "country", id: alpha_2, name: name}
      end)

    subdivisions =
      Location.Subdivision.all()
      |> Enum.map(fn %Location.Subdivision{code: code, name: name} ->
        %{type: "subdivision", id: code, name: name}
      end)

    cities =
      Location.City.all()
      |> Enum.map(fn %Location.City{id: id, name: name} ->
        %{type: "city", id: Integer.to_string(id), name: name}
      end)

    insert_data = Enum.concat([countries, subdivisions, cities])
    @repo.insert_all(ClickhouseLocationData, insert_data)

    {:ok, _} =
      run_sql("update-location-data-dictionary",
        cluster?: cluster?,
        dictionary_connection_params: Plausible.MigrationUtils.dictionary_connection_params()
      )

    for column <- @columns do
      {:ok, _} =
        run_sql("add-alias-column",
          cluster?: cluster?,
          table: column.table,
          column_name: column.column_name,
          type: column.type,
          input_column: column.input_column
        )
    end

    {:ok, _} =
      run_sql("update-location-data-table-comment",
        cluster?: cluster?,
        version: Location.version()
      )
  end
end
```

## File: `lib/plausible/data_migration/numeric_ids.ex`
```
defmodule Plausible.DataMigration.NumericIDs do
  @moduledoc """
  Numeric IDs migration, SQL files available at:
  priv/data_migrations/NumericIDs/sql
  """
  use Plausible.DataMigration, dir: "NumericIDs"

  import Ecto.Query

  defmodule DomainsLookup do
    @moduledoc false
    use Ecto.Schema

    @primary_key false
    schema "domains_lookup" do
      field :site_id, Ch, type: "UInt64"
      field :domain, :string
    end
  end

  def run(opts \\ []) do
    interactive? = Keyword.get(opts, :interactive?, true)

    db_url =
      System.get_env(
        "NUMERIC_IDS_MIGRATION_DB_URL",
        Application.get_env(:plausible, Plausible.IngestRepo)[:url]
      )

    max_threads =
      "NUMERIC_IDS_MIGRATION_MAX_THREADS" |> System.get_env("16") |> String.to_integer()

    table_settings =
      Keyword.get(opts, :table_settings) || System.get_env("NUMERIC_IDS_TABLE_SETTINGS") ||
        Plausible.MigrationUtils.table_settings_expr()

    start_from =
      Keyword.get(opts, :start_from) || System.get_env("NUMERIC_IDS_PARTITION_START_FROM")

    stop_at = Keyword.get(opts, :stop_at) || System.get_env("NUMERIC_IDS_PARTITION_STOP_AT")

    @repo.start(db_url, max_threads)

    cluster? =
      case run_sql("check-replicas") do
        {:ok, %{num_rows: 0}} -> false
        {:ok, %{num_rows: 1}} -> true
      end

    {:ok, %{rows: partitions}} =
      run_sql("list-partitions", start_from: start_from, stop_at: stop_at)

    partitions = Enum.map(partitions, fn [part] -> part end)

    start_from = start_from || List.first(partitions)

    IO.puts("""
    Got the following migration settings:

      - max_threads: #{max_threads}
      - table_settings: #{table_settings}
      - db url: #{db_url}
      - cluster?: #{cluster?}
      - partitions to do: #{inspect(partitions, pretty: true, limit: :infinity, width: 80)}
      - start from: #{start_from}
      - stop at: #{stop_at}
    """)

    run_sql_fn =
      if interactive? do
        &run_sql_confirm/3
      else
        &run_sql/3
      end

    confirm_fn =
      if interactive? do
        &confirm/2
      else
        fn _, run_fn ->
          run_fn.()
        end
      end

    drop_v2_extra_opts = fn table ->
      case @repo.query("select count(*) from {$0:Identifier}", [table]) do
        {:ok, %{rows: [[count]]}} when count > 0 ->
          [
            prompt_message: "The table contains #{count} rows. Execute?",
            prompt_default_choice: :no
          ]

        {:ok, _} ->
          [prompt_default_choice: :no]

        {:error, _} ->
          []
      end
    end

    {:ok, _} =
      run_sql_fn.("drop-events-v2", [cluster?: cluster?], drop_v2_extra_opts.("events_v2"))

    {:ok, _} =
      run_sql_fn.("drop-sessions-v2", [cluster?: cluster?], drop_v2_extra_opts.("sessions_v2"))

    {:ok, _} = run_sql_fn.("drop-tmp-events-v2", [], [])
    {:ok, _} = run_sql_fn.("drop-tmp-sessions-v2", [], [])
    {:ok, _} = run_sql_fn.("drop-domains-lookup", [], [])

    {:ok, _} =
      run_sql_fn.("create-events-v2", [table_settings: table_settings, cluster?: cluster?], [])

    {:ok, _} =
      run_sql_fn.("create-sessions-v2", [table_settings: table_settings, cluster?: cluster?], [])

    {:ok, _} = run_sql_fn.("create-tmp-events-v2", [table_settings: table_settings], [])
    {:ok, _} = run_sql_fn.("create-tmp-sessions-v2", [table_settings: table_settings], [])

    case run_sql_fn.("create-domains-lookup", [table_settings: table_settings], []) do
      {:ok, _} ->
        confirm_fn.("Populate domains-lookup with postgres sites", fn ->
          mappings =
            Plausible.Site
            |> select([s], %{site_id: s.id, domain: s.domain})
            |> Plausible.Repo.all()

          @repo.insert_all(DomainsLookup, mappings)
        end)

      _ ->
        :ignore
    end

    confirm_fn.("Start migration? (starting from partition: #{start_from})", fn ->
      IO.puts("start.. #{DateTime.utc_now()}")

      for part <- partitions do
        part_start = System.monotonic_time()

        confirm_fn.("Run partition: #{part}?", fn ->
          {:ok, _} = run_sql("insert-into-tmp-events-v2", partition: part)
          {:ok, _} = run_sql("attach-tmp-events-v2", partition: part)
          {:ok, _} = run_sql("truncate-tmp-events-v2", [])
          {:ok, _} = run_sql("insert-into-tmp-sessions-v2", partition: part)
          {:ok, _} = run_sql("attach-tmp-sessions-v2", partition: part)
          {:ok, _} = run_sql("truncate-tmp-sessions-v2", [])
        end)

        part_end = System.monotonic_time()

        IO.puts(
          "#{part} took #{System.convert_time_unit(part_end - part_start, :native, :second)} seconds"
        )
      end

      IO.puts("end.. #{DateTime.utc_now()}")
    end)
  end
end
```

## File: `lib/plausible/data_migration/populate_event_session_columns.ex`
```
defmodule Plausible.DataMigration.PopulateEventSessionColumns do
  @moduledoc """
  Populates event session columns with data from sessions table.

  Run via: ./bin/plausible rpc "Plausible.DataMigration.PopulateEventSessionColumns.run"
  Kill via: ./bin/plausible rpc "Plausible.DataMigration.PopulateEventSessionColumns.kill"
  Monitor via ./bin/plausible rpc "Plausible.DataMigration.PopulateEventSessionColumns.report_progress"

  Suggested to run in a screen/tmux session to be able to easily monitor

  SQL files available at: priv/data_migrations/PopulateEventSessionColumns/sql
  """
  use Plausible.DataMigration, dir: "PopulateEventSessionColumns", repo: Plausible.IngestRepo

  require Logger

  # See https://clickhouse.com/docs/en/sql-reference/dictionaries#cache for meaning of these defaults
  @default_dictionary_config %{
    lifetime: 600_000,
    size_in_cells: 1_000_000,
    max_threads_for_updates: 6
  }

  def run(opts \\ []) do
    cluster? = Plausible.IngestRepo.clustered_table?("sessions_v2")

    {:ok, _} =
      run_sql("create-sessions-dictionary",
        cluster?: cluster?,
        dictionary_connection_params:
          Keyword.get(
            opts,
            :dictionary_connection_string,
            Plausible.MigrationUtils.dictionary_connection_params()
          ),
        dictionary_config: dictionary_config(opts)
      )

    {partitions, _, _, _} = get_partitions(opts)

    IO.puts("Starting mutation on #{length(partitions)} partition(s)")

    for partition <- partitions do
      {:ok, _} =
        run_sql("update-table", [cluster?: cluster?, partition: partition],
          query_options: [settings: [allow_nondeterministic_mutations: 1]]
        )
    end

    wait_until_mutations_complete(opts)

    IO.puts("Mutations seem done, cleaning up!")
    {:ok, _} = run_sql("drop-sessions-dictionary", cluster?: cluster?)
  end

  def kill(opts \\ []) do
    cluster? = Plausible.IngestRepo.clustered_table?("events_v2")

    report_progress(opts)

    IO.puts("Killing running mutations")
    {:ok, _} = run_sql("kill-running-mutations", cluster?: cluster?)
  end

  def wait_until_mutations_complete(opts \\ []) do
    Process.sleep(5_000)
    in_progress? = report_progress(opts)

    if in_progress? do
      wait_until_mutations_complete(opts)
    end
  end

  def report_progress(opts \\ []) do
    {partitions, parts, min_partition, max_partition} = get_partitions(opts)

    {:ok, %{rows: mutation_results}} =
      run_sql("get-mutations-progress",
        min_partition: min_partition,
        max_partition: max_partition
      )

    [
      [
        mutations,
        parts_to_do,
        running_for,
        total_size,
        todo_size,
        progress,
        latest_fail_reason,
        _,
        _
      ]
    ] =
      mutation_results

    {:ok, %{rows: [[merges]]}} = run_sql("get-merges-progress")
    {:ok, %{rows: disks}} = run_sql("get-disks")

    IO.puts("\n\n#{DateTime.utc_now() |> DateTime.to_iso8601()}")

    # List partitions that need to run
    IO.puts(
      "Progress report for partitions #{Enum.min(partitions)}-#{Enum.max(partitions)} (parts: #{length(parts)})"
    )

    IO.puts("Disks overview:")

    for [name, path, full_space, total_space, full_percentage] <- disks do
      IO.puts(
        "  #{name} at #{path} is at #{full_space}/#{total_space} (#{full_percentage}% full)"
      )
    end

    IO.puts("Currently #{mutations} mutation(s) are running.")

    if mutations > 0 do
      IO.puts("  To do #{parts_to_do} parts, #{todo_size}")
      IO.puts("  Out of #{length(parts)} parts, #{total_size}")
      IO.puts("  Running for #{format_duration(running_for)}")

      if progress > 0 do
        estimated_time_left = round(running_for / progress / 100 - running_for)
        IO.puts("  Estimated #{progress}% done, #{format_duration(estimated_time_left)} left")
      end

      if latest_fail_reason do
        IO.puts("  Some mutations might be failing. ClickHouse report: #{latest_fail_reason}")
      end
    end

    IO.puts("Currently #{merges} merge(s) are running relating to mutations.")

    mutations > 0
  end

  defp dictionary_config(opts) do
    @default_dictionary_config
    |> Map.merge(Keyword.get(opts, :dictionary_config, %{}))
  end

  defp get_partitions(opts) do
    [min_partition, max_partition] = Keyword.get(opts, :partition_range, ["0", "999999"])

    {:ok, %{rows: [[partitions, parts]]}} =
      run_sql("list-partitions", min_partition: min_partition, max_partition: max_partition)

    {partitions, parts, min_partition, max_partition}
  end

  defp format_duration(seconds) do
    seconds
    |> Timex.Duration.from_seconds()
    |> Timex.format_duration(Timex.Format.Duration.Formatters.Humanized)
  end
end
```

## File: `lib/plausible/data_migration/postgres_repo.ex`
```
defmodule Plausible.DataMigration.PostgresRepo do
  @moduledoc """
  Ecto.Repo for Posrtgres data migrations, to be started manually,
  outside of the main application supervision tree.
  """
  use Ecto.Repo,
    otp_app: :plausible,
    adapter: Ecto.Adapters.Postgres

  def start(url, opts \\ []) when is_binary(url) do
    default_config = Plausible.Repo.config()

    start_link(
      url: url,
      queue_target: 500,
      queue_interval: 2000,
      pool_size: opts[:pool_size] || 1,
      ssl: opts[:ssl] || default_config[:ssl],
      ssl_opts: opts[:ssl_opts] || default_config[:ssl_opts]
    )
  end
end
```

## File: `lib/plausible/data_migration/site_imports.ex`
```
defmodule Plausible.DataMigration.SiteImports do
  @moduledoc """
  !!!WARNING!!!: This script is used in migrations. Please take special care
  when altering it.

  Site imports migration backfilling SiteImport entries for old imports
  and alters import end dates to match actual end date of respective import stats.
  """

  import Ecto.Query

  alias Plausible.{Repo, ClickhouseRepo, Site}

  defmodule SiteImportSnapshot do
    @moduledoc """
    A snapshot of the Plausible.Imported.SiteImport schema from April 2024.
    """

    use Ecto.Schema

    schema "site_imports" do
      field :start_date, :date
      field :end_date, :date
      field :label, :string
      field :source, Ecto.Enum, values: [:universal_analytics, :google_analytics_4, :csv, :noop]
      field :status, Ecto.Enum, values: [:pending, :importing, :completed, :failed]
      field :legacy, :boolean, default: false

      belongs_to :site, Plausible.Site
      belongs_to :imported_by, Plausible.Auth.User

      timestamps()
    end
  end

  @imported_tables_april_2024 [
    "imported_visitors",
    "imported_sources",
    "imported_pages",
    "imported_entry_pages",
    "imported_exit_pages",
    "imported_custom_events",
    "imported_locations",
    "imported_devices",
    "imported_browsers",
    "imported_operating_systems"
  ]

  def imported_tables_april_2024(), do: @imported_tables_april_2024

  def run(opts \\ []) do
    dry_run? = Keyword.get(opts, :dry_run?, true)

    site_import_query =
      from(i in SiteImportSnapshot,
        where: i.site_id == parent_as(:site).id and i.status == ^:completed,
        select: 1
      )

    sites_with_only_legacy_import =
      from(s in Site,
        as: :site,
        select: %{id: s.id, imported_data: s.imported_data},
        where:
          not is_nil(s.imported_data) and fragment("?->>'status'", s.imported_data) == "ok" and
            not exists(site_import_query)
      )
      |> Repo.all(log: false)

    site_imports =
      from(i in SiteImportSnapshot, where: i.status == ^:completed)
      |> Repo.all(log: false)

    legacy_site_imports = backfill_legacy_site_imports(sites_with_only_legacy_import, dry_run?)

    all_site_imports = Repo.preload(site_imports ++ legacy_site_imports, :site)

    adjust_site_import_end_dates(all_site_imports, dry_run?)

    IO.puts("Finished")
  end

  defp backfill_legacy_site_imports(sites, dry_run?) do
    total = length(sites)

    IO.puts("Backfilling legacy site import across #{total} sites (DRY RUN: #{dry_run?})...")

    legacy_site_imports =
      for {site, idx} <- Enum.with_index(sites) do
        IO.puts("Creating legacy site import entry for site ID #{site.id} (#{idx + 1}/#{total})")

        params =
          site.imported_data
          |> from_legacy()
          |> Map.put(:site_id, site.id)
          |> Map.take([:legacy, :start_date, :end_date, :source, :status, :site_id])

        %SiteImportSnapshot{}
        |> Ecto.Changeset.change(params)
        |> insert!(dry_run?)
      end

    IO.puts("Finished backfilling sites.")

    legacy_site_imports
  end

  defp adjust_site_import_end_dates(site_imports, dry_run?) do
    total = length(site_imports)

    IO.puts("Adjusting end dates of #{total} site imports (DRY RUN: #{dry_run?})...")

    for {site_import, idx} <- Enum.with_index(site_imports) do
      IO.puts(
        "Adjusting end date for site import #{site_import.id} (#{idx + 1}/#{total}) (site ID #{site_import.site_id}, start date: #{site_import.start_date}, end date: #{site_import.end_date})"
      )

      import_ids =
        if site_import.legacy do
          [0, site_import.id]
        else
          [site_import.id]
        end

      end_date = imported_stats_end_date(site_import.site_id, import_ids)

      if !end_date do
        IO.puts(
          "Site import #{site_import.id} (site ID #{site_import.site_id}) does not have any recorded stats. Removing it."
        )

        if site_import.legacy do
          # sanity check that data is correct
          "ok" = site_import.site.imported_data.status

          clear_imported_data(site_import.site, dry_run?)
        end

        delete!(site_import, dry_run?)
      else
        case Date.compare(end_date, site_import.end_date) do
          :lt ->
            IO.puts(
              "End date of site import #{site_import.id} (site ID #{site_import.site_id}) is adjusted from #{site_import.end_date} to #{end_date}."
            )

            site_import
            |> Ecto.Changeset.change(end_date: end_date)
            |> update!(dry_run?)

            # credo:disable-for-next-line Credo.Check.Refactor.Nesting
            if site_import.legacy do
              # sanity check that data is correct
              "ok" = site_import.site.imported_data.status

              site_import.site
              |> Ecto.Changeset.change(imported_data: %{end_date: end_date})
              |> update!(dry_run?)
            end

          :eq ->
            IO.puts(
              "End date of site import #{site_import.id} (site ID #{site_import.site_id}) is left unadjusted."
            )

          :gt ->
            IO.puts(
              "Site import #{site_import.id} (site ID #{site_import.site_id}) computed end date is later than the current one. Skipping."
            )
        end
      end
    end

    IO.puts("Finished adjusting end dates of site imports.")
  end

  # Exposed for testing purposes
  @doc false
  def imported_stats_end_date(site_id, import_ids) do
    [first_table | tables] = @imported_tables_april_2024

    query =
      Enum.reduce(tables, max_date_query(first_table, site_id, import_ids), fn table, query ->
        from(s in subquery(union_all(query, ^max_date_query(table, site_id, import_ids))))
      end)

    dates = ClickhouseRepo.all(from(q in query, select: q.max_date), log: false)

    if dates != [] do
      case Enum.max(dates, Date) do
        # no stats for this domain yet
        ~D[1970-01-01] ->
          nil

        date ->
          date
      end
    else
      nil
    end
  end

  defp insert!(changeset, false = _dry_run?) do
    Repo.insert!(changeset)
  end

  defp insert!(changeset, true = _dry_run?) do
    if changeset.valid? do
      changeset
      |> Ecto.Changeset.change(id: 0)
      |> Ecto.Changeset.apply_changes()
    else
      raise "Invalid insert: #{inspect(changeset)}"
    end
  end

  defp clear_imported_data(site, false = _dry_run?) do
    Repo.update_all(from(s in Site, where: s.id == ^site.id), set: [imported_data: nil])
  end

  defp clear_imported_data(site, true = _dry_run?) do
    %{site | imported_data: nil}
  end

  defp update!(changeset, false = _dry_run?) do
    Repo.update!(changeset)
  end

  defp update!(changeset, true = _dry_run?) do
    if changeset.valid? do
      Ecto.Changeset.apply_changes(changeset)
    else
      raise "Invalid update: #{inspect(changeset)}"
    end
  end

  defp delete!(entity, false = _dry_run?) do
    Repo.delete!(entity)
  end

  defp delete!(entity, true = _dry_run?) do
    entity
  end

  defp max_date_query(table, site_id, import_ids) do
    from(q in table,
      where: q.site_id == ^site_id,
      where: q.import_id in ^import_ids,
      select: %{max_date: fragment("max(?)", q.date)}
    )
  end

  defp from_legacy(%Site.ImportedData{} = data) do
    status =
      case data.status do
        "ok" -> :completed
        "error" -> :failed
        _ -> :importing
      end

    %SiteImportSnapshot{
      id: 0,
      legacy: true,
      start_date: data.start_date,
      end_date: data.end_date,
      source: :universal_analytics,
      status: status
    }
  end
end
```

## File: `lib/plausible/data_migration/versioned_sessions.ex`
```
defmodule Plausible.DataMigration.VersionedSessions do
  @moduledoc """
  !!!WARNING!!!: This script is used in migrations. Please take special care
  when altering it.

  Sessions CollapsingMergeTree -> VersionedCollapsingMergeTree migration,
  SQL files available at:

  priv/data_migrations/VersionedSessions/sql
  """
  use Plausible.DataMigration, dir: "VersionedSessions", repo: Plausible.IngestRepo

  @suffix_format "%Y%m%d%H%M%S"
  @versioned_table_engines [
    "ReplicatedVersionedCollapsingMergeTree",
    "VersionedCollapsingMergeTree"
  ]

  def run(opts \\ []) do
    run_exchange? = Keyword.get(opts, :run_exchange?, true)

    unique_suffix = DateTime.utc_now() |> Calendar.strftime(@suffix_format)

    cluster? = Plausible.IngestRepo.clustered_table?("sessions_v2")

    {:ok, %{rows: partitions}} = run_sql("list-partitions")
    partitions = Enum.map(partitions, fn [part] -> part end)

    {:ok, %{rows: [[current_table_engine, table_settings]]}} =
      run_sql("get-sessions-table-settings")

    if Enum.member?(@versioned_table_engines, current_table_engine) do
      IO.puts("sessions_v2 table is already versioned, no migration needed")
    else
      {:ok, _} = run_sql("drop-sessions-tmp-table", cluster?: cluster?)

      {:ok, _} =
        run_sql("create-sessions-tmp-table",
          cluster?: cluster?,
          table_settings: table_settings,
          unique_suffix: unique_suffix
        )

      for partition <- partitions do
        {:ok, _} = run_sql("attach-partition", partition: partition)
      end

      if run_exchange? do
        run_exchange(cluster?)
      end

      IO.puts("Migration done!")
    end
  end

  defp run_exchange(cluster?) do
    case run_sql("exchange-sessions-tables", cluster?: cluster?) do
      {:ok, _} ->
        nil

      # Docker containers don't seem to support EXCHANGE TABLE, hack around this with a non-atomic swap
      {:error, %Ch.Error{code: code}} when code in [1, 48] ->
        IO.puts("Exchanging sessions_v2 and sessions_v2_tmp_versioned non-atomically")

        {:ok, _} =
          run_sql("rename-table",
            from: "sessions_v2",
            to: "sessions_v2_backup",
            cluster?: cluster?
          )

        {:ok, _} =
          run_sql("rename-table",
            from: "sessions_v2_tmp_versioned",
            to: "sessions_v2",
            cluster?: cluster?
          )
    end
  end
end
```

## File: `lib/plausible/ecto/types/compiled_regex.ex`
```
defmodule Plausible.Ecto.Types.CompiledRegex do
  @moduledoc """
  Ensures that the regex is compiled on load
  """
  use Ecto.Type

  def type, do: :string

  def cast(val) when is_binary(val), do: {:ok, val}
  def cast(_), do: :error

  def load(val), do: {:ok, Regex.compile!(val)}
  def dump(val), do: {:ok, val}
end
```

## File: `lib/plausible/ecto/types/nanoid.ex`
```
defmodule Plausible.Ecto.Types.Nanoid do
  @moduledoc """
  Custom column type for nanoid strings
  """

  use Ecto.Type

  def type(), do: :string

  def cast(value) when is_binary(value), do: {:ok, value}
  def cast(_), do: :error

  def load(value), do: {:ok, value}

  def dump(value) when is_binary(value), do: {:ok, value}
  def dump(_), do: :error

  @spec autogenerate() :: String.t()
  def autogenerate(), do: Nanoid.generate()
end
```

## File: `lib/plausible/event/write_buffer.ex`
```
defmodule Plausible.Event.WriteBuffer do
  @moduledoc false

  %{
    header: header,
    insert_sql: insert_sql,
    insert_opts: insert_opts,
    fields: fields,
    encoding_types: encoding_types
  } =
    Plausible.Ingestion.WriteBuffer.compile_time_prepare(Plausible.ClickhouseEventV2)

  def child_spec(opts) do
    opts =
      Keyword.merge(opts,
        name: __MODULE__,
        header: unquote(header),
        insert_sql: unquote(insert_sql),
        insert_opts: unquote(insert_opts)
      )

    Plausible.Ingestion.WriteBuffer.child_spec(opts)
  end

  def insert(event) do
    row_binary =
      [Enum.map(unquote(fields), fn field -> Map.fetch!(event, field) end)]
      |> Ch.RowBinary._encode_rows(unquote(encoding_types))
      |> IO.iodata_to_binary()

    :ok = Plausible.Ingestion.WriteBuffer.insert(__MODULE__, row_binary)
    {:ok, event}
  end

  def flush do
    Plausible.Ingestion.WriteBuffer.flush(__MODULE__)
  end
end
```

## File: `lib/plausible/exports.ex`
```
defmodule Plausible.Exports do
  @moduledoc """
  Contains functions to export data for events and sessions as Zip archives.
  """

  use Plausible
  use Plausible.Stats.SQL.Fragments
  import Ecto.Query

  @doc "Schedules CSV export job to S3 storage"
  @spec schedule_s3_export(pos_integer, String.t()) ::
          {:ok, Oban.Job.t()} | {:error, :no_data}
  def schedule_s3_export(site_id, email_to) do
    with :ok <- ensure_has_data(site_id) do
      args = %{
        "storage" => "s3",
        "site_id" => site_id,
        "email_to" => email_to,
        "s3_bucket" => Plausible.S3.exports_bucket(),
        "s3_path" => s3_export_key(site_id)
      }

      {:ok, Oban.insert!(Plausible.Workers.ExportAnalytics.new(args))}
    end
  end

  @doc "Schedules CSV export job to local storage"
  @spec schedule_local_export(pos_integer, String.t()) :: {:ok, Oban.Job.t()} | {:error, :no_data}
  def schedule_local_export(site_id, email_to) do
    with :ok <- ensure_has_data(site_id) do
      args = %{
        "storage" => "local",
        "site_id" => site_id,
        "email_to" => email_to,
        "local_path" => local_export_file(site_id)
      }

      {:ok, Oban.insert!(Plausible.Workers.ExportAnalytics.new(args))}
    end
  end

  @spec ensure_has_data(pos_integer) :: :ok | {:error, :no_data}
  defp ensure_has_data(site_id) do
    # SELECT true FROM "events_v2" AS e0 WHERE (e0."site_id" = ^site_id) LIMIT 1
    has_data? = Plausible.ClickhouseRepo.exists?(from "events_v2", where: [site_id: ^site_id])
    if has_data?, do: :ok, else: {:error, :no_data}
  end

  @doc "Gets last CSV export job for a site"
  @spec get_last_export_job(pos_integer) :: Oban.Job.t() | nil
  def get_last_export_job(site_id) do
    Plausible.Repo.one(
      from e in Plausible.Workers.ExportAnalytics.base_query(site_id),
        order_by: [desc: :id],
        limit: 1
    )
  end

  @doc "Subscribes to CSV export job notifications"
  def oban_listen, do: Oban.Notifier.listen(__MODULE__)
  @doc false
  def oban_notify(site_id), do: Oban.Notifier.notify(__MODULE__, %{"site_id" => site_id})

  @doc """
  Renders export archive filename.

  Examples:

      iex> archive_filename("plausible.io", _created_on = ~D[2024-12-31])
      "plausible_io_20241231.zip"

  """
  def archive_filename(domain, %Date{} = created_on) do
    String.replace(domain, ".", "_") <> "_" <> Calendar.strftime(created_on, "%Y%m%d") <> ".zip"
  end

  @doc ~S"""
  Safely renders content disposition for an arbitrary export filename.

  Examples:

      iex> content_disposition("plausible_io_20241231.zip")
      "attachment; filename=\"plausible_io_20241231.zip\""

      iex> content_disposition("📊.zip")
      "attachment; filename=\"plausible-export.zip\"; filename*=utf-8''%F0%9F%93%8A.zip"

  """
  def content_disposition(filename) do
    encoded_filename = URI.encode(filename)

    if encoded_filename == filename do
      ~s[attachment; filename="#{filename}"]
    else
      ~s[attachment; filename="plausible-export.zip"; filename*=utf-8''#{encoded_filename}]
    end
  end

  @type export :: %{
          path: Path.t(),
          name: String.t(),
          expires_at: DateTime.t() | nil,
          size: pos_integer
        }

  @doc "Gets local export for a site"
  @spec get_local_export(pos_integer, String.t(), String.t()) :: export | nil
  def get_local_export(site_id, domain, timezone) do
    path = local_export_file(site_id)

    if File.exists?(path) do
      %File.Stat{size: size, mtime: mtime} = File.stat!(path, time: :posix)
      created_at = DateTime.from_unix!(mtime)
      created_on_in_site_tz = Plausible.Timezones.to_date_in_timezone(created_at, timezone)
      name = archive_filename(domain, created_on_in_site_tz)

      %{path: path, name: name, expires_at: nil, size: size}
    end
  end

  @doc "Deletes local export for a site"
  @spec delete_local_export(pos_integer) :: :ok
  def delete_local_export(site_id) do
    file = local_export_file(site_id)

    if File.exists?(file) do
      File.rm!(file)
    end

    :ok
  end

  @spec local_export_file(pos_integer) :: Path.t()
  defp local_export_file(site_id) do
    data_dir = Application.get_env(:plausible, :data_dir)
    Path.join([data_dir || System.tmp_dir!(), "plausible-exports", Integer.to_string(site_id)])
  end

  @doc "Gets S3 export for a site. Raises if object storage is unavailable."
  @spec get_s3_export!(pos_integer, non_neg_integer) :: export | nil
  def get_s3_export!(site_id, retries \\ 0) do
    path = s3_export_key(site_id)
    bucket = Plausible.S3.exports_bucket()
    head_object_op = ExAws.S3.head_object(bucket, path)

    case ExAws.request(head_object_op, retries: retries) do
      {:ok, %{status_code: 200, headers: headers}} ->
        "attachment; filename=" <> filename = :proplists.get_value("content-disposition", headers)
        name = String.trim(filename, "\"")
        size = :proplists.get_value("content-length", headers, nil)

        expires_at =
          if x_amz_expiration = :proplists.get_value("x-amz-expiration", headers, nil) do
            ["expiry-date=", expiry_date, ", rule-id=", _rule_id] =
              String.split(x_amz_expiration, "\"", trim: true)

            Timex.parse!(expiry_date, "{RFC1123}")
          end

        %{
          path: path,
          name: name,
          expires_at: expires_at,
          size: String.to_integer(size)
        }

      {:error, {:http_error, 404, _response}} ->
        nil

      {:error, %Mint.TransportError{} = e} ->
        raise e
    end
  end

  @doc "Deletes S3 export for a site. Raises if object storage is unavailable."
  @spec delete_s3_export!(pos_integer) :: :ok
  def delete_s3_export!(site_id) do
    if export = get_s3_export!(site_id) do
      exports_bucket = Plausible.S3.exports_bucket()
      delete_op = ExAws.S3.delete_object(exports_bucket, export.path)
      ExAws.request!(delete_op)
    end

    :ok
  end

  defp s3_export_key(site_id), do: Integer.to_string(site_id)

  @doc "Returns the date range for the site's events data in site's timezone or `nil` if there is no data"
  @spec date_range(pos_integer, String.t()) :: Date.Range.t() | nil
  def date_range(site_id, timezone) do
    [%Date{} = start_date, %Date{} = end_date] =
      Plausible.ClickhouseRepo.one(
        from e in "events_v2",
          where: [site_id: ^site_id],
          select: [
            fragment("toDate(min(?),?)", e.timestamp, ^timezone),
            fragment("toDate(max(?),?)", e.timestamp, ^timezone)
          ]
      )

    unless end_date == ~D[1970-01-01] do
      Date.range(start_date, end_date)
    end
  end

  @doc """
  Builds Ecto queries to export data from `events_v2` and `sessions_v2`
  tables into the format of `imported_*` tables for a website.
  """
  @spec export_queries(pos_integer,
          extname: String.t(),
          date_range: Date.Range.t(),
          timezone: String.t()
        ) ::
          %{String.t() => Ecto.Query.t()}
  def export_queries(site_id, opts \\ []) do
    extname = opts[:extname] || ".csv"
    date_range = opts[:date_range]
    timezone = opts[:timezone] || "UTC"

    suffix =
      if date_range do
        first_date = Calendar.strftime(date_range.first, "%Y%m%d")
        last_date = Calendar.strftime(date_range.last, "%Y%m%d")
        "_#{first_date}_#{last_date}" <> extname
      else
        extname
      end

    filename = fn name -> name <> suffix end

    %{
      filename.("imported_visitors") => export_visitors_q(site_id, timezone, date_range),
      filename.("imported_sources") => export_sources_q(site_id, timezone, date_range),
      filename.("imported_pages") => export_pages_q(site_id, timezone, date_range),
      filename.("imported_entry_pages") => export_entry_pages_q(site_id, timezone, date_range),
      filename.("imported_exit_pages") => export_exit_pages_q(site_id, timezone, date_range),
      filename.("imported_custom_events") =>
        export_custom_events_q(site_id, timezone, date_range),
      filename.("imported_locations") => export_locations_q(site_id, timezone, date_range),
      filename.("imported_devices") => export_devices_q(site_id, timezone, date_range),
      filename.("imported_browsers") => export_browsers_q(site_id, timezone, date_range),
      filename.("imported_operating_systems") =>
        export_operating_systems_q(site_id, timezone, date_range)
    }
  end

  on_ee do
    defp sampled(table) do
      Plausible.Stats.Sampling.add_query_hint(from(table))
    end
  else
    defp sampled(table) do
      table
    end
  end

  defp export_filter(site_id, date_range) do
    filter = dynamic([t], t.site_id == ^site_id)

    if date_range do
      dynamic(
        ^filter and
          selected_as(:date) >= ^date_range.first and
          selected_as(:date) <= ^date_range.last
      )
    else
      filter
    end
  end

  defmacrop date(timestamp, timezone) do
    quote do
      selected_as(
        fragment("toDate(?,?)", unquote(timestamp), unquote(timezone)),
        :date
      )
    end
  end

  defmacrop visit_duration(t) do
    quote do
      selected_as(
        scale_sample(fragment("greatest(sum(?*?),0)", unquote(t).sign, unquote(t).duration)),
        :visit_duration
      )
    end
  end

  defmacrop visitors(t) do
    quote do
      selected_as(
        scale_sample(fragment("uniq(?)", unquote(t).user_id)),
        :visitors
      )
    end
  end

  defmacrop visits(t) do
    quote do
      selected_as(
        scale_sample(fragment("greatest(sum(?),0)", unquote(t).sign)),
        :visits
      )
    end
  end

  defmacrop bounces(t) do
    quote do
      selected_as(
        scale_sample(
          fragment(
            "greatest(sum(?*?),0)",
            unquote(t).sign,
            unquote(t).is_bounce
          )
        ),
        :bounces
      )
    end
  end

  defmacrop pageviews(t) do
    quote do
      selected_as(
        scale_sample(
          fragment(
            "greatest(sum(?*?),0)",
            unquote(t).sign,
            unquote(t).pageviews
          )
        ),
        :pageviews
      )
    end
  end

  defp export_visitors_q(site_id, timezone, date_range) do
    visitors_sessions_q =
      from s in sampled("sessions_v2"),
        where: ^export_filter(site_id, date_range),
        group_by: selected_as(:date),
        select: %{
          date: date(s.timestamp, ^timezone),
          bounces: bounces(s),
          visits: visits(s),
          visit_duration: visit_duration(s),
          visitors: visitors(s)
        }

    visitors_events_q =
      from e in sampled("events_v2"),
        where: ^export_filter(site_id, date_range),
        group_by: selected_as(:date),
        select: %{
          date: date(e.timestamp, ^timezone),
          pageviews:
            selected_as(
              scale_sample(fragment("countIf(?='pageview')", e.name)),
              :pageviews
            )
        }

    visitors_q =
      "e"
      |> with_cte("e", as: ^visitors_events_q)
      |> with_cte("s", as: ^visitors_sessions_q)

    from e in visitors_q,
      full_join: s in "s",
      on: e.date == s.date,
      order_by: selected_as(:date),
      select: [
        selected_as(fragment("greatest(?,?)", s.date, e.date), :date),
        s.visitors,
        e.pageviews,
        s.bounces,
        s.visits,
        s.visit_duration
      ]
  end

  defp export_sources_q(site_id, timezone, date_range) do
    from s in sampled("sessions_v2"),
      where: ^export_filter(site_id, date_range),
      group_by: [
        selected_as(:date),
        selected_as(:source),
        s.referrer,
        s.utm_source,
        s.utm_medium,
        s.utm_campaign,
        s.utm_content,
        s.utm_term
      ],
      order_by: selected_as(:date),
      select: [
        date(s.timestamp, ^timezone),
        selected_as(s.referrer_source, :source),
        s.referrer,
        s.utm_source,
        s.utm_medium,
        s.utm_campaign,
        s.utm_content,
        s.utm_term,
        pageviews(s),
        visitors(s),
        visits(s),
        visit_duration(s),
        bounces(s)
      ]
  end

  defp export_pages_q(site_id, timezone, date_range) do
    base_q =
      from(e in sampled("events_v2"),
        where: ^export_filter(site_id, date_range),
        where: [name: "pageview"],
        group_by: [selected_as(:date), selected_as(:page)],
        order_by: selected_as(:date)
      )

    max_scroll_depth_per_session_q =
      from(e in "events_v2",
        where: ^export_filter(site_id, date_range),
        where: e.name == "engagement" and e.scroll_depth <= 100,
        select: %{
          date: date(e.timestamp, ^timezone),
          page: selected_as(e.pathname, :page),
          session_id: e.session_id,
          max_scroll_depth: max(e.scroll_depth)
        },
        group_by: [e.session_id, selected_as(:date), selected_as(:page)]
      )

    scroll_depth_q =
      from(p in subquery(max_scroll_depth_per_session_q),
        select: %{
          date: p.date,
          page: p.page,
          total_scroll_depth: fragment("sum(?)", p.max_scroll_depth),
          total_scroll_depth_visits: fragment("uniq(?)", p.session_id)
        },
        group_by: [:date, :page]
      )

    from(e in base_q,
      left_join: s in subquery(scroll_depth_q),
      on: s.date == selected_as(:date) and s.page == selected_as(:page),
      select: %{
        date: date(e.timestamp, ^timezone),
        hostname: selected_as(fragment("any(?)", e.hostname), :hostname),
        page: selected_as(e.pathname, :page),
        visits:
          selected_as(
            scale_sample(fragment("uniq(?)", e.session_id)),
            :visits
          ),
        visitors: visitors(e),
        pageviews: selected_as(scale_sample(fragment("count()")), :pageviews),
        total_scroll_depth:
          selected_as(fragment("any(?)", s.total_scroll_depth), :total_scroll_depth),
        total_scroll_depth_visits:
          selected_as(fragment("any(?)", s.total_scroll_depth_visits), :total_scroll_depth_visits)
      }
    )
    |> add_time_on_page_columns(site_id, timezone, date_range)
  end

  defp add_time_on_page_columns(q, site_id, timezone, date_range) do
    site = Plausible.Repo.get(Plausible.Site, site_id)

    if Plausible.Stats.TimeOnPage.new_time_on_page_visible?(site) do
      cutoff = Plausible.Stats.TimeOnPage.legacy_time_on_page_cutoff(site)

      engagements_q =
        from(e in sampled("events_v2"),
          where: ^export_filter(site_id, date_range),
          where: e.name == "engagement",
          group_by: [selected_as(:date), selected_as(:page)],
          order_by: selected_as(:date),
          select: %{
            date: date(e.timestamp, ^timezone),
            page: selected_as(e.pathname, :page),
            total_time_on_page:
              fragment(
                "toUInt64(round(sumIf(?, ? >= ?) / 1000))",
                e.engagement_time,
                e.timestamp,
                ^cutoff
              ),
            total_time_on_page_visits:
              fragment("uniqIf(?, ? >= ?)", e.session_id, e.timestamp, ^cutoff)
          }
        )

      q
      |> join(:left, [], s in subquery(engagements_q),
        on: s.date == selected_as(:date) and s.page == selected_as(:page)
      )
      |> select_merge_as([..., s], %{
        total_time_on_page: fragment("any(?)", s.total_time_on_page),
        total_time_on_page_visits: fragment("any(?)", s.total_time_on_page_visits)
      })
    else
      q
    end
  end

  defp export_entry_pages_q(site_id, timezone, date_range) do
    from s in sampled("sessions_v2"),
      where: ^export_filter(site_id, date_range),
      group_by: [selected_as(:date), s.entry_page],
      order_by: selected_as(:date),
      select: [
        date(s.timestamp, ^timezone),
        s.entry_page,
        visitors(s),
        selected_as(
          scale_sample(fragment("greatest(sum(?),0)", s.sign)),
          :entrances
        ),
        visit_duration(s),
        bounces(s),
        pageviews(s)
      ]
  end

  defp export_exit_pages_q(site_id, timezone, date_range) do
    from s in sampled("sessions_v2"),
      where: ^export_filter(site_id, date_range),
      group_by: [selected_as(:date), s.exit_page],
      order_by: selected_as(:date),
      select: [
        date(s.timestamp, ^timezone),
        s.exit_page,
        visitors(s),
        visit_duration(s),
        selected_as(
          scale_sample(fragment("greatest(sum(?),0)", s.sign)),
          :exits
        ),
        bounces(s),
        pageviews(s)
      ]
  end

  defp export_custom_events_q(site_id, timezone, date_range) do
    from e in sampled("events_v2"),
      where: ^export_filter(site_id, date_range),
      where: e.name != "pageview",
      group_by: [
        selected_as(:date),
        e.name,
        selected_as(:link_url),
        selected_as(:path)
      ],
      order_by: selected_as(:date),
      select: [
        date(e.timestamp, ^timezone),
        e.name,
        selected_as(
          fragment(
            "if(? in ?, ?, '')",
            e.name,
            ^Plausible.Goals.SystemGoals.goals_with_url(),
            get_by_key(e, :meta, "url")
          ),
          :link_url
        ),
        selected_as(
          fragment(
            "if(? in ?, ?, '')",
            e.name,
            ^Plausible.Goals.SystemGoals.goals_with_path(),
            get_by_key(e, :meta, "path")
          ),
          :path
        ),
        visitors(e),
        selected_as(scale_sample(fragment("count()")), :events)
      ]
  end

  defp export_locations_q(site_id, timezone, date_range) do
    from s in sampled("sessions_v2"),
      where: ^export_filter(site_id, date_range),
      where: s.country_code != "\0\0" and s.country_code != "ZZ",
      group_by: [selected_as(:date), s.country_code, s.subdivision1_code, s.city_geoname_id],
      order_by: selected_as(:date),
      select: [
        date(s.timestamp, ^timezone),
        selected_as(s.country_code, :country),
        selected_as(s.subdivision1_code, :region),
        selected_as(s.city_geoname_id, :city),
        visitors(s),
        visits(s),
        visit_duration(s),
        bounces(s),
        pageviews(s)
      ]
  end

  defp export_devices_q(site_id, timezone, date_range) do
    from s in sampled("sessions_v2"),
      where: ^export_filter(site_id, date_range),
      group_by: [selected_as(:date), s.screen_size],
      order_by: selected_as(:date),
      select: [
        date(s.timestamp, ^timezone),
        selected_as(s.screen_size, :device),
        visitors(s),
        visits(s),
        visit_duration(s),
        bounces(s),
        pageviews(s)
      ]
  end

  defp export_browsers_q(site_id, timezone, date_range) do
    from s in sampled("sessions_v2"),
      where: ^export_filter(site_id, date_range),
      group_by: [selected_as(:date), s.browser, s.browser_version],
      order_by: selected_as(:date),
      select: [
        date(s.timestamp, ^timezone),
        s.browser,
        s.browser_version,
        visitors(s),
        visits(s),
        visit_duration(s),
        bounces(s),
        pageviews(s)
      ]
  end

  defp export_operating_systems_q(site_id, timezone, date_range) do
    from s in sampled("sessions_v2"),
      where: ^export_filter(site_id, date_range),
      group_by: [selected_as(:date), s.operating_system, s.operating_system_version],
      order_by: selected_as(:date),
      select: [
        date(s.timestamp, ^timezone),
        s.operating_system,
        s.operating_system_version,
        visitors(s),
        visits(s),
        visit_duration(s),
        bounces(s),
        pageviews(s)
      ]
  end

  @doc """
  Creates a streamable Zip archive from the provided (named) Ecto queries.

  Example usage:

      {:ok, pool} = Ch.start_link(pool_size: 1)

      DBConnection.run(pool, fn conn ->
        conn
        |> stream_archive(export_queries(_site_id = 1), format: "CSVWithNames")
        |> Stream.into(File.stream!("export.zip"))
        |> Stream.run()
      end)

  """
  @spec stream_archive(DBConnection.t(), %{String.t() => Ecto.Query.t()}, [Ch.query_option()]) ::
          Enumerable.t()
  def stream_archive(conn, named_queries, opts \\ []) do
    entries =
      Enum.map(named_queries, fn {name, query} ->
        {sql, params} = Plausible.ClickhouseRepo.to_sql(:all, query)

        datastream =
          conn
          |> Ch.stream(sql, params, opts)
          |> Stream.map(fn %Ch.Result{data: data} -> data end)

        Zstream.entry(name, datastream, coder: Zstream.Coder.Stored)
      end)

    Zstream.zip(entries)
  end
end
```

## File: `lib/plausible/file.ex`
```
defmodule Plausible.File do
  @moduledoc """
  File helpers for Plausible.
  """

  @doc """
  Moves a file from one location to another.

  Tries renaming first, and falls back to copying and deleting the original.
  """
  @spec mv!(Path.t(), Path.t()) :: :ok
  def mv!(source, destination) do
    File.rename!(source, destination)
  rescue
    e in File.RenameError ->
      try do
        case e.reason do
          # fallback to cp/rm for cross-device moves
          # https://github.com/plausible/analytics/issues/4638
          :exdev -> File.cp!(source, destination)
          _ -> reraise(e, __STACKTRACE__)
        end
      after
        File.rm(source)
      end
  end
end
```

## File: `lib/plausible/funnel/const.ex`
```
defmodule Plausible.Funnel.Const do
  @moduledoc """
  Compile-time convenience constants for funnel characteristics.
  """
  @min_steps 2
  @max_steps 8

  defmacro min_steps() do
    quote do
      unquote(@min_steps)
    end
  end

  defmacro max_steps() do
    quote do
      unquote(@max_steps)
    end
  end

  defmacro __using__(_opts \\ []) do
    quote do
      require Plausible.Funnel.Const
      alias Plausible.Funnel
    end
  end
end
```

## File: `lib/plausible/geo.ex`
```
defmodule Plausible.Geo do
  @moduledoc """
  This module provides an API for fetching IP geolocation.
  """

  require Logger

  @db :geolocation

  @doc """
  Starts the geodatabase loading process. Two modes are supported: local file
  and MaxMind license key.

  ## Options

    * `:path` - the path to the .mmdb database local file. When present,
      `:license_key` and `:edition` are not required.

    * `:license_key` - the [license key](https://support.maxmind.com/hc/en-us/articles/4407111582235-Generate-a-License-Key)
      from MaxMind to authenticate requests to MaxMind.

    * `:edition` - the name of the MaxMind database to be downloaded from MaxMind
      servers. Defaults to `GeoLite2-City`.

    * `:cache_dir` - if set, the downloaded .mmdb files are cached there across
      restarts.

    * `:async` - when used, configures the database loading to run
      asynchronously.

  ## Examples

    Loading from a local file:

      iex> load_db(path: "/etc/plausible/dbip-city.mmdb")
      :ok

    Downloading a MaxMind DB (this license key is no longer active):

      iex> load_db(license_key: "LNpsJCCKPis6XvBP", edition: "GeoLite2-City", async: true)
      :ok

  """
  def load_db(opts) do
    cond do
      license_key = opts[:license_key] ->
        edition = opts[:edition] || "GeoLite2-City"
        maxmind_opts = [license_key: license_key]

        loader_opts =
          if is_binary(opts[:cache_dir]) do
            [
              database_cache_file:
                String.to_charlist(Path.join(opts[:cache_dir], edition <> ".mmdb.gz"))
            ]
          else
            [:no_cache]
          end

        :ok = :locus.start_loader(@db, {:maxmind, edition}, maxmind_opts ++ loader_opts)

      path = opts[:path] ->
        :ok = :locus.start_loader(@db, path)

      true ->
        raise "failed to load geolocation db: need :path or :license_key to be provided"
    end

    unless opts[:async] do
      {:ok, _version} = :locus.await_loader(@db)
    end

    :ok
  end

  @doc """
  Waits for the database to start after calling `load_db/1` with the async option.
  """
  def await_loader, do: :locus.await_loader(@db)

  @doc """
  Returns geodatabase type.

  Used for deciding whether to show the DB-IP disclaimer or not.

  ## Examples

    In the case of a DB-IP database:

      iex> database_type()
      "DBIP-City-Lite"

    In the case of a MaxMind database:

      iex> database_type()
      "GeoLite2-City"

  """
  def database_type do
    case :locus.get_info(@db, :metadata) do
      {:ok, %{database_type: type}} -> type
      _other -> nil
    end
  end

  @doc """
  Looks up geo info about an IP address.

  ## Examples

      iex> lookup("8.7.6.5")
      %{
        "city" => %{
          "geoname_id" => 5349755,
          "names" => %{
            "de" => "Fontana",
            "en" => "Fontana",
            "ja" => "フォンタナ",
            "ru" => "Фонтана"
          }
        },
        "continent" => %{
          "code" => "NA",
          "geoname_id" => 6255149,
          "names" => %{
            "de" => "Nordamerika",
            "en" => "North America",
            "es" => "Norteamérica",
            "fr" => "Amérique du Nord",
            "ja" => "北アメリカ",
            "pt-BR" => "América do Norte",
            "ru" => "Северная Америка",
            "zh-CN" => "北美洲"
          }
        },
        "country" => %{
          "geoname_id" => 6252001,
          "iso_code" => "US",
          "names" => %{
            "de" => "Vereinigte Staaten",
            "en" => "United States",
            "es" => "Estados Unidos",
            "fr" => "États Unis",
            "ja" => "アメリカ",
            "pt-BR" => "EUA",
            "ru" => "США",
            "zh-CN" => "美国"
          }
        },
        "location" => %{
          "accuracy_radius" => 50,
          "latitude" => 34.1211,
          "longitude" => -117.4362,
          "metro_code" => 803,
          "time_zone" => "America/Los_Angeles"
        },
        "postal" => %{"code" => "92336"},
        "registered_country" => %{
          "geoname_id" => 6252001,
          "iso_code" => "US",
          "names" => %{
            "de" => "Vereinigte Staaten",
            "en" => "United States",
            "es" => "Estados Unidos",
            "fr" => "États Unis",
            "ja" => "アメリカ",
            "pt-BR" => "EUA",
            "ru" => "США",
            "zh-CN" => "美国"
          }
        },
        "subdivisions" => [
          %{
            "geoname_id" => 5332921,
            "iso_code" => "CA",
            "names" => %{
              "de" => "Kalifornien",
              "en" => "California",
              "es" => "California",
              "fr" => "Californie",
              "ja" => "カリフォルニア州",
              "pt-BR" => "Califórnia",
              "ru" => "Калифорния",
              "zh-CN" => "加州"
            }
          }
        ]
      }

  """
  def lookup(ip_address) do
    case :locus.lookup(@db, ip_address) do
      {:ok, entry} ->
        entry

      :not_found ->
        nil

      {:error, {:invalid_address, _address}} ->
        nil

      {:error, reason} ->
        Logger.error("Failed to lookup IP address. Reason: " <> inspect(reason))
        nil
    end
  end
end
```

## File: `lib/plausible/goal/schema.ex`
```
defmodule Plausible.Goal do
  use Plausible
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  schema "goals" do
    field :event_name, :string
    field :page_path, :string
    field :scroll_threshold, :integer, default: -1
    field :display_name, :string

    on_ee do
      field :currency, Ecto.Enum, values: Money.Currency.known_current_currencies()
      many_to_many :funnels, Plausible.Funnel, join_through: Plausible.Funnel.Step
    else
      field :currency, :string, virtual: true, default: nil
      field :funnels, {:array, :map}, virtual: true, default: []
    end

    belongs_to :site, Plausible.Site

    timestamps()
  end

  @fields [:id, :site_id, :event_name, :page_path, :scroll_threshold, :display_name] ++
            on_ee(do: [:currency], else: [])

  @max_event_name_length 120

  def max_event_name_length(), do: @max_event_name_length

  def changeset(goal, attrs \\ %{}) do
    goal
    |> cast(attrs, @fields)
    |> validate_required([:site_id])
    |> cast_assoc(:site)
    |> update_leading_slash()
    |> validate_event_name_and_page_path()
    |> validate_page_path_for_scroll_goal()
    |> maybe_put_display_name()
    |> unique_constraint(:event_name, name: :goals_event_name_unique)
    |> unique_constraint([:page_path, :scroll_threshold],
      name: :goals_page_path_and_scroll_threshold_unique
    )
    |> unique_constraint(:display_name, name: :goals_site_id_display_name_index)
    |> validate_length(:event_name, max: @max_event_name_length)
    |> validate_number(:scroll_threshold,
      greater_than_or_equal_to: -1,
      less_than_or_equal_to: 100,
      message: "Should be -1 (missing) or in range [0, 100]"
    )
    |> check_constraint(:event_name,
      name: :check_event_name_or_page_path,
      message: "cannot co-exist with page_path"
    )
    |> maybe_drop_currency()
  end

  @spec display_name(t()) :: String.t()
  def display_name(goal) do
    goal.display_name
  end

  @spec type(t()) :: :event | :scroll | :page
  def type(goal) do
    cond do
      is_binary(goal.event_name) -> :event
      is_binary(goal.page_path) && goal.scroll_threshold > -1 -> :scroll
      is_binary(goal.page_path) -> :page
    end
  end

  defp update_leading_slash(changeset) do
    case get_field(changeset, :page_path) do
      "/" <> _ ->
        changeset

      page_path when is_binary(page_path) ->
        put_change(changeset, :page_path, "/" <> page_path)

      _ ->
        changeset
    end
  end

  defp validate_event_name_and_page_path(changeset) do
    case {validate_page_path(changeset), validate_event_name(changeset)} do
      {:ok, _} ->
        update_change(changeset, :page_path, &String.trim/1)

      {_, :ok} ->
        update_change(changeset, :event_name, &String.trim/1)

      {{:error, page_path_error}, {:error, event_name_error}} ->
        changeset
        |> add_error(:event_name, event_name_error)
        |> add_error(:page_path, page_path_error)
    end
  end

  defp validate_page_path_for_scroll_goal(changeset) do
    scroll_threshold = get_field(changeset, :scroll_threshold)
    page_path = get_field(changeset, :page_path)

    if scroll_threshold > -1 and is_nil(page_path) do
      changeset
      |> add_error(:scroll_threshold, "page_path field missing for page scroll goal")
    else
      changeset
    end
  end

  defp validate_page_path(changeset) do
    value = get_field(changeset, :page_path)

    if value && String.match?(value, ~r/^\/.*/) do
      :ok
    else
      {:error, "this field is required and must start with a /"}
    end
  end

  defp validate_event_name(changeset) do
    value = get_field(changeset, :event_name)

    cond do
      value == "engagement" ->
        {:error, "The event name 'engagement' is reserved and cannot be used as a goal"}

      value && String.match?(value, ~r/^.+/) ->
        :ok

      true ->
        {:error, "this field is required and cannot be blank"}
    end
  end

  defp maybe_drop_currency(changeset) do
    if ee?() and get_field(changeset, :page_path) do
      delete_change(changeset, :currency)
    else
      changeset
    end
  end

  defp maybe_put_display_name(changeset) do
    clause =
      Enum.map([:display_name, :page_path, :event_name], &get_field(changeset, &1))

    case clause do
      [nil, path, _] when is_binary(path) ->
        put_change(changeset, :display_name, "Visit " <> path)

      [nil, _, event_name] when is_binary(event_name) ->
        put_change(changeset, :display_name, event_name)

      _ ->
        changeset
    end
    |> update_change(:display_name, &String.trim/1)
    |> validate_required(:display_name)
  end
end

defimpl Jason.Encoder, for: Plausible.Goal do
  def encode(value, opts) do
    domain = value.site.domain

    value
    |> Map.put(:goal_type, Plausible.Goal.type(value))
    |> Map.take([:id, :goal_type, :event_name, :page_path])
    |> Map.put(:domain, domain)
    |> Map.put(:display_name, value.display_name)
    |> Jason.Encode.map(opts)
  end
end

defimpl String.Chars, for: Plausible.Goal do
  def to_string(goal) do
    goal.display_name
  end
end

defimpl Phoenix.HTML.Safe, for: Plausible.Goal do
  def to_iodata(data) do
    data |> to_string() |> Phoenix.HTML.Engine.html_escape()
  end
end
```

## File: `lib/plausible/goals/goals.ex`
```
defmodule Plausible.Goals do
  use Plausible
  use Plausible.Repo
  use Plausible.Funnel.Const

  import Ecto.Query

  alias Plausible.Goal
  alias Ecto.Multi

  @spec get(Plausible.Site.t(), pos_integer()) :: nil | Plausible.Goal.t()
  def get(site, id) when is_integer(id) do
    q =
      from g in Plausible.Goal,
        where: g.site_id == ^site.id,
        order_by: [desc: g.id],
        where: g.id == ^id

    Repo.one(q)
  end

  @spec create(Plausible.Site.t(), map(), Keyword.t()) ::
          {:ok, Goal.t()} | {:error, Ecto.Changeset.t()} | {:error, :upgrade_required}
  @doc """
  Creates a Goal for a site.

  If the created goal is a revenue goal, it sets site.updated_at to be
  refreshed by the sites cache, as revenue goals are used during ingestion.
  """
  def create(site, params, opts \\ []) do
    upsert? = Keyword.get(opts, :upsert?, false)

    Repo.transaction(fn ->
      case insert_goal(site, params, upsert?) do
        {:ok, :insert, goal} ->
          on_ee do
            now = Keyword.get(opts, :now, DateTime.utc_now())
            # credo:disable-for-next-line Credo.Check.Refactor.Nesting
            if Plausible.Goal.Revenue.revenue?(goal) do
              Plausible.Site.Cache.touch_site!(site, now)
            end
          end

          Repo.preload(goal, :site)

        {:ok, :upsert, goal} ->
          Repo.preload(goal, :site)

        {:error, cause} ->
          Repo.rollback(cause)
      end
    end)
  end

  @spec update(Plausible.Goal.t(), map()) ::
          {:ok, Goal.t()} | {:error, Ecto.Changeset.t()} | {:error, :upgrade_required}
  def update(goal, params) do
    changeset = Goal.changeset(goal, params)

    Repo.transaction(fn ->
      site = Repo.preload(goal, :site).site

      with :ok <- maybe_check_feature_access(site, changeset),
           {:ok, updated_goal} <- Repo.update(changeset),
           :ok <- Plausible.Segments.update_goal_in_segments(site, goal, updated_goal) do
        on_ee do
          Repo.preload(updated_goal, :funnels)
        else
          updated_goal
        end
      else
        {:error, %Ecto.Changeset{} = changeset} ->
          Repo.rollback(changeset)

        {:error, :upgrade_required} ->
          Repo.rollback(:upgrade_required)
      end
    end)
  end

  def find_or_create(
        site,
        %{
          "goal_type" => "event",
          "event_name" => event_name,
          "currency" => currency
        } = params
      )
      when is_binary(event_name) and is_binary(currency) do
    with {:ok, goal} <- create(site, params, upsert?: true) do
      if to_string(goal.currency) == currency do
        {:ok, goal}
      else
        # we must disallow creation of the same goal name with different currency
        changeset =
          goal
          |> Goal.changeset()
          |> Ecto.Changeset.add_error(
            :event_name,
            "'#{goal.event_name}' (with currency: #{goal.currency}) has already been taken"
          )

        {:error, changeset}
      end
    end
  end

  def find_or_create(site, %{"goal_type" => "event", "event_name" => event_name} = params)
      when is_binary(event_name) do
    create(site, params, upsert?: true)
  end

  def find_or_create(_, %{"goal_type" => "event"}), do: {:missing, "event_name"}

  def find_or_create(site, %{"goal_type" => "page", "page_path" => _} = params) do
    create(site, params, upsert?: true)
  end

  def find_or_create(_, %{"goal_type" => "page"}), do: {:missing, "page_path"}

  def list_revenue_goals(site) do
    from(g in Plausible.Goal,
      where: g.site_id == ^site.id and not is_nil(g.currency),
      select: %{display_name: g.display_name, currency: g.currency}
    )
    |> Plausible.Repo.all()
  end

  def for_site(site, opts \\ []) do
    site
    |> for_site_query(opts)
    |> Repo.all()
    |> Enum.map(&maybe_trim/1)
  end

  def for_site_query(site, opts \\ []) do
    query =
      from g in Goal,
        inner_join: assoc(g, :site),
        where: g.site_id == ^site.id,
        order_by: [desc: g.id],
        preload: [:site]

    if ee?() and opts[:preload_funnels?] == true do
      from(g in query,
        left_join: assoc(g, :funnels),
        group_by: g.id,
        preload: [:funnels]
      )
    else
      query
    end
  end

  def batch_create_event_goals(names, site) do
    Enum.reduce(names, [], fn name, acc ->
      case insert_goal(site, %{event_name: name}, true) do
        {:ok, _, goal} -> acc ++ [goal]
        _ -> acc
      end
    end)
  end

  @doc """
  If a goal belongs to funnel(s), we need to inspect their number of steps.

  If it exceeds the minimum allowed (defined via `Plausible.Funnel.min_steps/0`),
  the funnel will be reduced (i.e. a step associated with the goal to be deleted
  is removed), so that the minimum number of steps is preserved. This is done
  implicitly, by postgres, as per on_delete: :delete_all.

  Otherwise, for associated funnel(s) consisting of minimum number steps only,
  funnel record(s) are removed completely along with the targeted goal.
  """
  def delete(id, %Plausible.Site{id: site_id}) do
    delete(id, site_id)
  end

  def delete(id, site_id) do
    goal_query =
      from(g in Goal,
        where: g.id == ^id,
        where: g.site_id == ^site_id
      )

    goal_query = on_ee(do: preload(goal_query, funnels: :steps), else: goal_query)

    result =
      Multi.new()
      |> Multi.one(
        :goal,
        goal_query
      )
      |> Multi.run(:funnel_ids_to_wipe, fn
        _, %{goal: nil} ->
          {:error, :not_found}

        _, %{goal: %{funnels: []}} ->
          {:ok, []}

        _, %{goal: %{funnels: funnels}} ->
          funnels_to_wipe =
            funnels
            |> Enum.filter(&(Enum.count(&1.steps) == Funnel.Const.min_steps()))
            |> Enum.map(& &1.id)

          {:ok, funnels_to_wipe}
      end)
      |> Multi.merge(fn
        %{funnel_ids_to_wipe: []} ->
          Ecto.Multi.new()

        %{funnel_ids_to_wipe: [_ | _] = funnel_ids} ->
          Ecto.Multi.new()
          |> Multi.delete_all(
            :delete_funnels,
            from(f in "funnels",
              where: f.id in ^funnel_ids
            )
          )
      end)
      |> Multi.delete_all(
        :delete_goals,
        fn _ ->
          from g in Goal,
            where: g.id == ^id,
            where: g.site_id == ^site_id
        end
      )
      |> Repo.transaction()

    case result do
      {:ok, _} -> :ok
      {:error, _step, reason, _context} -> {:error, reason}
    end
  end

  @spec count(Plausible.Site.t()) :: non_neg_integer()
  def count(site) do
    Repo.aggregate(
      from(
        g in Goal,
        where: g.site_id == ^site.id
      ),
      :count
    )
  end

  @spec create_outbound_links(Plausible.Site.t()) :: :ok
  def create_outbound_links(%Plausible.Site{} = site) do
    create(site, %{"event_name" => "Outbound Link: Click"}, upsert?: true)
    :ok
  end

  @spec create_file_downloads(Plausible.Site.t()) :: :ok
  def create_file_downloads(%Plausible.Site{} = site) do
    create(site, %{"event_name" => "File Download"}, upsert?: true)
    :ok
  end

  @spec create_form_submissions(Plausible.Site.t()) :: :ok
  def create_form_submissions(%Plausible.Site{} = site) do
    create(site, %{"event_name" => "Form: Submission"}, upsert?: true)
    :ok
  end

  @spec create_404(Plausible.Site.t()) :: :ok
  def create_404(%Plausible.Site{} = site) do
    create(site, %{"event_name" => "404"}, upsert?: true)
    :ok
  end

  @spec delete_outbound_links(Plausible.Site.t()) :: :ok
  def delete_outbound_links(%Plausible.Site{} = site) do
    q =
      from g in Goal,
        where: g.site_id == ^site.id,
        where: g.event_name == "Outbound Link: Click"

    Repo.delete_all(q)
    :ok
  end

  @spec delete_file_downloads(Plausible.Site.t()) :: :ok
  def delete_file_downloads(%Plausible.Site{} = site) do
    q =
      from g in Goal,
        where: g.site_id == ^site.id,
        where: g.event_name == "File Download"

    Repo.delete_all(q)
    :ok
  end

  @spec delete_404(Plausible.Site.t()) :: :ok
  def delete_404(%Plausible.Site{} = site) do
    q =
      from g in Goal,
        where: g.site_id == ^site.id,
        where: g.event_name == "404"

    Repo.delete_all(q)
    :ok
  end

  @spec delete_form_submissions(Plausible.Site.t()) :: :ok
  def delete_form_submissions(%Plausible.Site{} = site) do
    q =
      from g in Goal,
        where: g.site_id == ^site.id,
        where: g.event_name == "Form: Submission"

    Repo.delete_all(q)
    :ok
  end

  defp insert_goal(site, params, upsert?) do
    params = Map.delete(params, "site_id")

    insert_opts =
      if upsert? do
        [on_conflict: :nothing]
      else
        []
      end

    changeset = Goal.changeset(%Goal{site_id: site.id}, params)

    with :ok <- maybe_check_feature_access(site, changeset),
         {:ok, goal} <- Repo.insert(changeset, insert_opts) do
      # Upsert with `on_conflict: :nothing` strategy
      # will result in goal struct missing primary key field
      # which is generated by the database.
      if goal.id do
        {:ok, :insert, goal}
      else
        get_params =
          goal
          |> Map.take([:site_id, :event_name, :page_path])
          |> Enum.reject(fn {_, value} -> is_nil(value) end)

        {:ok, :upsert, Repo.get_by!(Goal, get_params)}
      end
    end
  end

  defp maybe_check_feature_access(site, changeset) do
    if Ecto.Changeset.get_field(changeset, :currency) do
      site = Plausible.Repo.preload(site, :team)
      Plausible.Billing.Feature.RevenueGoals.check_availability(site.team)
    else
      :ok
    end
  end

  defp maybe_trim(%Goal{} = goal) do
    # we make sure that even if we saved goals erroneously with trailing
    # space, it's removed during fetch
    goal
    |> Map.update!(:event_name, &maybe_trim/1)
    |> Map.update!(:page_path, &maybe_trim/1)
  end

  defp maybe_trim(s) when is_binary(s) do
    String.trim(s)
  end

  defp maybe_trim(other) do
    other
  end
end
```

## File: `lib/plausible/goals/system_goals.ex`
```
defmodule Plausible.Goals.SystemGoals do
  @moduledoc """
  This module contains logic for special goals
  """

  # Special system goals which can be filtered by 'url' custom property
  @goals_with_url ["Outbound Link: Click", "Cloaked Link: Click", "File Download"]

  # Special system goals which can be filtered by 'path' custom property
  @goals_with_path ["404", "WP Form Completions", "Form: Submission"]

  @spec goals_with_url() :: [String.t()]
  def goals_with_url() do
    @goals_with_url
  end

  @spec goals_with_path() :: [String.t()]
  def goals_with_path() do
    @goals_with_path
  end

  @spec special_goals_for(String.t()) :: [String.t()]
  def special_goals_for("event:props:url"), do: goals_with_url()
  def special_goals_for("event:props:path"), do: goals_with_path()

  @doc """
  Checks if the event name is for a special goal that should have the event.props.path synced with the event.pathname property.

  ### Examples
  iex> sync_props_path_with_pathname?("404", [{"path", "/foo"}])
  false

  Note: Should not override event.props.path if it is set deliberately to nil
  iex> sync_props_path_with_pathname?("404", [{"path", nil}])
  false

  iex> sync_props_path_with_pathname?("404", [{"other", "value"}])
  true

  iex> sync_props_path_with_pathname?("404", [])
  true
  """
  @spec sync_props_path_with_pathname?(String.t(), [{String.t(), String.t()}]) :: boolean()
  def sync_props_path_with_pathname?(event_name, props_in_request) do
    event_name in goals_with_path() and
      not Enum.any?(props_in_request, fn {k, _} -> k == "path" end)
  end
end
```

## File: `lib/plausible/google/api.ex`
```
defmodule Plausible.Google.API do
  @moduledoc """
  API to Google services.
  """

  use Timex

  alias Plausible.Google.HTTP
  alias Plausible.Google.SearchConsole
  alias Plausible.Stats.Query

  require Logger

  @search_console_scope URI.encode_www_form(
                          "email https://www.googleapis.com/auth/webmasters.readonly"
                        )
  @import_scope URI.encode_www_form("email https://www.googleapis.com/auth/analytics.readonly")

  @verified_permission_levels ["siteOwner", "siteFullUser", "siteRestrictedUser"]

  def search_console_authorize_url(site_id) do
    "https://accounts.google.com/o/oauth2/v2/auth?client_id=#{client_id()}&redirect_uri=#{redirect_uri()}&prompt=consent&response_type=code&access_type=offline&scope=#{@search_console_scope}&state=" <>
      Jason.encode!([site_id, "search-console"])
  end

  def import_authorize_url(site_id) do
    "https://accounts.google.com/o/oauth2/v2/auth?client_id=#{client_id()}&redirect_uri=#{redirect_uri()}&prompt=consent&response_type=code&access_type=offline&scope=#{@import_scope}&state=" <>
      Jason.encode!([site_id, "import"])
  end

  def fetch_access_token!(code) do
    HTTP.fetch_access_token!(code)
  end

  def list_properties(access_token) do
    Plausible.Google.GA4.API.list_properties(access_token)
  end

  def get_property(access_token, property) do
    Plausible.Google.GA4.API.get_property(access_token, property)
  end

  def get_analytics_start_date(access_token, property) do
    Plausible.Google.GA4.API.get_analytics_start_date(access_token, property)
  end

  def get_analytics_end_date(access_token, property) do
    Plausible.Google.GA4.API.get_analytics_end_date(access_token, property)
  end

  def fetch_verified_properties(auth) do
    with {:ok, access_token} <- maybe_refresh_token(auth),
         {:ok, sites} <- Plausible.Google.HTTP.list_sites(access_token) do
      sites
      |> Map.get("siteEntry", [])
      |> Enum.filter(fn site -> site["permissionLevel"] in @verified_permission_levels end)
      |> Enum.map(fn site -> site["siteUrl"] end)
      |> Enum.map(fn url -> String.trim_trailing(url, "/") end)
      |> then(&{:ok, &1})
    end
  end

  def fetch_stats(site, query, pagination, search) do
    with {:ok, site} <- ensure_search_console_property(site),
         {:ok, access_token} <- maybe_refresh_token(site.google_auth),
         {:ok, gsc_filters} <-
           SearchConsole.Filters.transform(site.google_auth.property, query.filters, search),
         {:ok, stats} <-
           HTTP.list_stats(
             access_token,
             site.google_auth.property,
             Query.date_range(query),
             pagination,
             gsc_filters
           ) do
      stats
      |> Map.get("rows", [])
      |> Enum.map(&search_console_row/1)
      |> then(&{:ok, &1})
    else
      :google_property_not_configured -> {:error, :google_property_not_configured}
      :unsupported_filters -> {:error, :unsupported_filters}
      {:error, error} -> {:error, error}
    end
  end

  def maybe_refresh_token(%Plausible.Site.GoogleAuth{} = auth) do
    with true <- needs_to_refresh_token?(auth.expires),
         {:ok, {new_access_token, expires_at}} <- do_refresh_token(auth.refresh_token),
         changeset <-
           Plausible.Site.GoogleAuth.changeset(auth, %{
             access_token: new_access_token,
             expires: expires_at
           }),
         {:ok, _google_auth} <- Plausible.Repo.update(changeset) do
      {:ok, new_access_token}
    else
      false -> {:ok, auth.access_token}
      {:error, cause} -> {:error, cause}
    end
  end

  def maybe_refresh_token({access_token, refresh_token, expires_at}) do
    with true <- needs_to_refresh_token?(expires_at),
         {:ok, {new_access_token, _expires_at}} <- do_refresh_token(refresh_token) do
      {:ok, new_access_token}
    else
      false -> {:ok, access_token}
      {:error, cause} -> {:error, cause}
    end
  end

  def property?(value), do: String.starts_with?(value, "properties/")

  defp do_refresh_token(refresh_token) do
    case HTTP.refresh_auth_token(refresh_token) do
      {:ok, %{"access_token" => new_access_token, "expires_in" => expires_in}} ->
        expires_at = NaiveDateTime.add(NaiveDateTime.utc_now(), expires_in)
        {:ok, {new_access_token, expires_at}}

      {:error, cause} ->
        {:error, cause}
    end
  end

  defp needs_to_refresh_token?(expires_at) when is_binary(expires_at) do
    expires_at
    |> NaiveDateTime.from_iso8601!()
    |> needs_to_refresh_token?()
  end

  defp needs_to_refresh_token?(%NaiveDateTime{} = expires_at) do
    thirty_seconds_ago = DateTime.shift(DateTime.utc_now(), second: 30)
    NaiveDateTime.before?(expires_at, thirty_seconds_ago)
  end

  defp ensure_search_console_property(site) do
    site = Plausible.Repo.preload(site, :google_auth)

    if site.google_auth && site.google_auth.property do
      {:ok, site}
    else
      :google_property_not_configured
    end
  end

  defp search_console_row(row) do
    %{
      # We always request just one dimension at a time (`query`)
      name: row["keys"] |> List.first(),
      visitors: row["clicks"],
      impressions: row["impressions"],
      ctr: rounded_ctr(row["ctr"]),
      position: rounded_position(row["position"])
    }
  end

  defp rounded_ctr(ctr) do
    {:ok, decimal} = Decimal.cast(ctr)

    decimal
    |> Decimal.mult(100)
    |> Decimal.round(1)
    |> Decimal.to_float()
  end

  defp rounded_position(position) do
    {:ok, decimal} = Decimal.cast(position)

    decimal
    |> Decimal.round(1)
    |> Decimal.to_float()
  end

  defp client_id() do
    Keyword.fetch!(Application.get_env(:plausible, :google), :client_id)
  end

  defp redirect_uri() do
    PlausibleWeb.Endpoint.url() <> "/auth/google/callback"
  end
end
```

## File: `lib/plausible/google/ga4/api.ex`
```
defmodule Plausible.Google.GA4.API do
  @moduledoc """
  API for Google Analytics 4.
  """

  alias Plausible.Google
  alias Plausible.Google.GA4

  require Logger

  @type import_auth :: {
          access_token :: String.t(),
          refresh_token :: String.t(),
          expires_at :: String.t()
        }

  @per_page 200_000
  @backoff_factor :timer.seconds(10)
  @max_attempts 5

  def list_properties(access_token) do
    case GA4.HTTP.list_accounts_for_user(access_token) do
      {:ok, %{"accountSummaries" => accounts}} ->
        accounts =
          accounts
          |> Enum.filter(& &1["propertySummaries"])
          |> Enum.map(fn account ->
            %{"account" => account_id, "displayName" => account_name} = account

            {"#{account_name} (#{account_id})",
             Enum.map(account["propertySummaries"], fn property ->
               %{"displayName" => property_name, "property" => property_id} = property

               {"#{property_name} (#{property_id})", property_id}
             end)}
          end)

        {:ok, accounts}

      {:ok, _} ->
        {:ok, []}

      {:error, cause} ->
        {:error, cause}
    end
  end

  def get_property(access_token, lookup_property) do
    case GA4.HTTP.get_property(access_token, lookup_property) do
      {:ok, property} ->
        %{"displayName" => property_name, "name" => property_id, "account" => account_id} =
          property

        {:ok,
         %{
           id: property_id,
           name: "#{property_name} (#{property_id})",
           account_id: account_id
         }}

      {:error, cause} ->
        {:error, cause}
    end
  end

  def get_analytics_start_date(access_token, property) do
    GA4.HTTP.get_analytics_start_date(access_token, property)
  end

  def get_analytics_end_date(access_token, property) do
    GA4.HTTP.get_analytics_end_date(access_token, property)
  end

  def import_analytics(date_range, property, auth, opts) do
    persist_fn = Keyword.fetch!(opts, :persist_fn)
    fetch_opts = Keyword.get(opts, :fetch_opts, [])
    resume_opts = Keyword.get(opts, :resume_opts, [])

    Logger.debug(
      "[#{inspect(__MODULE__)}:#{property}] Starting import from #{date_range.first} to #{date_range.last}"
    )

    with {:ok, access_token} <- Google.API.maybe_refresh_token(auth) do
      do_import_analytics(date_range, property, access_token, persist_fn, fetch_opts, resume_opts)
    end
  end

  defp do_import_analytics(
         date_range,
         property,
         access_token,
         persist_fn,
         fetch_opts,
         [] = _resume_opts
       ) do
    Enum.reduce_while(GA4.ReportRequest.full_report(), :ok, fn report_request, :ok ->
      Logger.debug(
        "[#{inspect(__MODULE__)}:#{property}] Starting to import #{report_request.dataset}"
      )

      report_request = prepare_request(report_request, date_range, property, access_token)

      case fetch_and_persist(report_request, persist_fn: persist_fn, fetch_opts: fetch_opts) do
        :ok -> {:cont, :ok}
        {:error, _} = error -> {:halt, error}
      end
    end)
  end

  defp do_import_analytics(
         date_range,
         property,
         access_token,
         persist_fn,
         fetch_opts,
         resume_opts
       ) do
    dataset = Keyword.fetch!(resume_opts, :dataset)
    offset = Keyword.fetch!(resume_opts, :offset)

    GA4.ReportRequest.full_report()
    |> Enum.drop_while(&(&1.dataset != dataset))
    |> Enum.reduce_while(:ok, fn report_request, :ok ->
      Logger.debug(
        "[#{inspect(__MODULE__)}:#{property}] Starting to import #{report_request.dataset}"
      )

      request_offset =
        if report_request.dataset == dataset do
          offset
        else
          0
        end

      report_request =
        report_request
        |> prepare_request(date_range, property, access_token)
        |> Map.put(:offset, request_offset)

      case fetch_and_persist(report_request, persist_fn: persist_fn, fetch_opts: fetch_opts) do
        :ok -> {:cont, :ok}
        {:error, _} = error -> {:halt, error}
      end
    end)
  end

  @spec fetch_and_persist(GA4.ReportRequest.t(), Keyword.t()) ::
          :ok | {:error, term()}
  def fetch_and_persist(%GA4.ReportRequest{} = report_request, opts \\ []) do
    persist_fn = Keyword.fetch!(opts, :persist_fn)
    attempt = Keyword.get(opts, :attempt, 1)
    fetch_opts = Keyword.get(opts, :fetch_opts, [])
    max_attempts = Keyword.get(fetch_opts, :max_attempts, @max_attempts)
    sleep_time = Keyword.get(fetch_opts, :sleep_time, @backoff_factor)

    case GA4.HTTP.get_report(report_request) do
      {:ok, {_, 0}} ->
        Logger.debug(
          "[#{inspect(__MODULE__)}:#{report_request.property}] Fetched empty response for #{report_request.dataset}"
        )

        :ok

      {:ok, {rows, row_count}} ->
        Logger.debug(
          "[#{inspect(__MODULE__)}:#{report_request.property}] Fetched #{length(rows)} rows of total #{row_count} with offset #{report_request.offset} for #{report_request.dataset}"
        )

        :ok = persist_fn.(report_request.dataset, rows)

        Logger.debug(
          "[#{inspect(__MODULE__)}:#{report_request.property}] Persisted #{length(rows)} for #{report_request.dataset}"
        )

        if report_request.offset + @per_page < row_count do
          fetch_and_persist(
            %GA4.ReportRequest{report_request | offset: report_request.offset + @per_page},
            opts
          )
        else
          :ok
        end

      {:error, {:rate_limit_exceeded, details}} ->
        {:error, {:rate_limit_exceeded, details}}

      {:error, cause} ->
        if attempt >= max_attempts do
          Logger.debug(
            "[#{inspect(__MODULE__)}:#{report_request.property}] Request failed for #{report_request.dataset}. Terminating."
          )

          {:error, cause}
        else
          Logger.debug(
            "[#{inspect(__MODULE__)}:#{report_request.property}] Request failed for #{report_request.dataset}. Will retry."
          )

          Process.sleep(attempt * sleep_time)
          fetch_and_persist(report_request, Keyword.merge(opts, attempt: attempt + 1))
        end
    end
  end

  defp prepare_request(report_request, date_range, property, access_token) do
    %GA4.ReportRequest{
      report_request
      | date_range: date_range,
        property: property,
        access_token: access_token,
        offset: 0,
        limit: @per_page
    }
  end
end
```

## File: `lib/plausible/google/ga4/http.ex`
```
defmodule Plausible.Google.GA4.HTTP do
  @moduledoc """
  HTTP client implementation for Google Analytics 4 API.
  """

  use Plausible

  alias Plausible.HTTPClient

  require Logger

  @spec get_report(Plausible.Google.GA4.ReportRequest.t()) ::
          {:ok, {[map()], non_neg_integer()}} | {:error, any()}
  def get_report(%Plausible.Google.GA4.ReportRequest{} = report_request) do
    params = %{
      requests: [
        %{
          property: report_request.property,
          dateRanges: [
            %{
              startDate: report_request.date_range.first,
              endDate: report_request.date_range.last
            }
          ],
          dimensions: Enum.map(report_request.dimensions, &%{name: &1}),
          metrics: Enum.map(report_request.metrics, &build_metric/1),
          orderBys: [
            %{
              dimension: %{
                dimensionName: "date",
                orderType: "ALPHANUMERIC"
              },
              desc: true
            }
          ],
          dimensionFilter: report_request.dimension_filter,
          limit: report_request.limit,
          offset: report_request.offset
        }
      ]
    }

    url =
      "#{reporting_api_url()}/v1beta/#{report_request.property}:batchRunReports"

    response =
      HTTPClient.impl().post(
        url,
        [{"Authorization", "Bearer #{report_request.access_token}"}],
        params,
        receive_timeout: 80_000
      )

    with {:ok, %{body: body}} <- response,
         {:ok, report} <- parse_report_from_response(body),
         row_count <- Map.get(report, "rowCount", 0),
         {:ok, report} <- convert_to_maps(report) do
      {:ok, {report, row_count}}
    else
      {:error, %{reason: %{status: 429, body: body}} = error} ->
        log_ce_error("retrieving report for #{report_request.dataset}", error)

        Logger.debug(
          "[#{inspect(__MODULE__)}:#{report_request.property}] Request failed for #{report_request.dataset} due to exceeding rate limit."
        )

        Sentry.Context.set_extra_context(%{ga_response: %{body: body, status: 429}})

        {:error,
         {:rate_limit_exceeded, dataset: report_request.dataset, offset: report_request.offset}}

      {:error, %{reason: %{status: status, body: body}} = error} when status >= 500 ->
        log_ce_error("retrieving report for #{report_request.dataset}", error)

        Logger.warning(
          "[#{inspect(__MODULE__)}:#{report_request.property}] Request failed for #{report_request.dataset} with code #{status}: #{inspect(body)}"
        )

        Sentry.Context.set_extra_context(%{ga_response: %{body: body, status: status}})

        {:error, {:server_failed, dataset: report_request.dataset, offset: report_request.offset}}

      {:error, %{reason: %{status: status, body: body}} = error} ->
        log_ce_error("retrieving report for #{report_request.dataset}", error)

        Logger.warning(
          "[#{inspect(__MODULE__)}:#{report_request.property}] Request failed for #{report_request.dataset} with code #{status}: #{inspect(body)}"
        )

        Sentry.Context.set_extra_context(%{ga_response: %{body: body, status: status}})

        {:error, :request_failed}

      {:error, reason} ->
        log_ce_error("retrieving report for #{report_request.dataset}", reason)

        Logger.warning(
          "[#{inspect(__MODULE__)}:#{report_request.property}] Request failed for #{report_request.dataset}: #{inspect(reason)}"
        )

        Sentry.Context.set_extra_context(%{ga_response: %{body: inspect(reason), status: 0}})

        {:error, {:socket_failed, dataset: report_request.dataset, offset: report_request.offset}}
    end
  end

  defp build_metric(expression) do
    case String.split(expression, " = ") do
      [name, expression] ->
        %{
          name: name,
          expression: expression
        }

      [name] ->
        %{name: name}
    end
  end

  defp parse_report_from_response(%{"reports" => [report | _]}) do
    {:ok, report}
  end

  defp parse_report_from_response(body) do
    Sentry.Context.set_extra_context(%{google_analytics4_response: body})

    Logger.error(
      "Google Analytics 4: Failed to find report in response. Reason: #{inspect(body)}"
    )

    {:error, {:invalid_response, body}}
  end

  defp convert_to_maps(%{
         "rows" => rows,
         "dimensionHeaders" => dimension_headers,
         "metricHeaders" => metric_headers
       })
       when is_list(rows) do
    dimension_headers = Enum.map(dimension_headers, & &1["name"])
    metric_headers = Enum.map(metric_headers, & &1["name"])

    report =
      Enum.map(rows, fn %{"dimensionValues" => dimensions, "metricValues" => metrics} ->
        dimension_values = Enum.map(dimensions, & &1["value"])
        metric_values = Enum.map(metrics, & &1["value"])
        metrics = Enum.zip(metric_headers, metric_values)
        dimensions = Enum.zip(dimension_headers, dimension_values)
        %{metrics: Map.new(metrics), dimensions: Map.new(dimensions)}
      end)

    {:ok, report}
  end

  defp convert_to_maps(%{"dimensionHeaders" => _, "metricHeaders" => _}) do
    {:ok, []}
  end

  defp convert_to_maps(response) do
    Logger.error(
      "Google Analytics 4: Failed to read report in response. Reason: #{inspect(response)}"
    )

    Sentry.Context.set_extra_context(%{google_analytics4_response: response})
    {:error, {:invalid_response, response}}
  end

  def list_accounts_for_user(access_token) do
    url = "#{admin_api_url()}/v1beta/accountSummaries?pageSize=200"

    headers = [{"Authorization", "Bearer #{access_token}"}]

    case HTTPClient.impl().get(url, headers) do
      {:ok, %Finch.Response{body: body, status: 200}} ->
        {:ok, body}

      {:error, %HTTPClient.Non200Error{reason: %{status: 429}} = error} ->
        log_ce_error("listing accounts for user", error)
        {:error, :rate_limit_exceeded}

      {:error, %HTTPClient.Non200Error{} = error} when error.reason.status in [401, 403] ->
        log_ce_error("listing accounts for user", error)
        {:error, authentication_failed(error)}

      {:error, %{reason: :timeout} = error} ->
        log_ce_error("listing accounts for user", error)
        {:error, :timeout}

      {:error, error} ->
        log_ce_error("listing accounts for user", error)
        Sentry.capture_message("Error listing GA4 accounts for user", extra: %{error: error})
        {:error, :unknown}
    end
  end

  def get_property(access_token, property) do
    url = "#{admin_api_url()}/v1beta/#{property}"

    headers = [{"Authorization", "Bearer #{access_token}"}]

    case HTTPClient.impl().get(url, headers) do
      {:ok, %Finch.Response{body: body, status: 200}} ->
        {:ok, body}

      {:error, %HTTPClient.Non200Error{reason: %{status: 429}} = error} ->
        log_ce_error("retrieving property #{property}", error)
        {:error, :rate_limit_exceeded}

      {:error, %HTTPClient.Non200Error{} = error} when error.reason.status in [401, 403] ->
        log_ce_error("retrieving property #{property}", error)
        {:error, authentication_failed(error)}

      {:error, %HTTPClient.Non200Error{} = error} when error.reason.status in [404] ->
        log_ce_error("retrieving property #{property}", error)
        {:error, :not_found}

      {:error, %{reason: :timeout} = error} ->
        log_ce_error("retrieving property #{property}", error)
        {:error, :timeout}

      {:error, error} ->
        log_ce_error("retrieving property #{property}", error)

        Sentry.capture_message("Error retrieving GA4 property #{property}",
          extra: %{error: error}
        )

        {:error, :unknown}
    end
  end

  @earliest_valid_date "2015-08-14"

  def get_analytics_start_date(access_token, property) do
    get_analytics_boundary_date(access_token, property, :start)
  end

  def get_analytics_end_date(access_token, property) do
    get_analytics_boundary_date(access_token, property, :end)
  end

  defp get_analytics_boundary_date(access_token, property, edge) do
    descending? = edge == :end

    params = %{
      requests: [
        %{
          property: "#{property}",
          dateRanges: [
            %{startDate: @earliest_valid_date, endDate: Date.to_iso8601(Date.utc_today())}
          ],
          dimensions: [%{name: "date"}],
          metrics: [%{name: "screenPageViews"}],
          orderBys: [
            %{dimension: %{dimensionName: "date", orderType: "ALPHANUMERIC"}, desc: descending?}
          ],
          limit: 1
        }
      ]
    }

    url = "#{reporting_api_url()}/v1beta/#{property}:batchRunReports"
    headers = [{"Authorization", "Bearer #{access_token}"}]

    case HTTPClient.impl().post(url, headers, params) do
      {:ok, %Finch.Response{body: body, status: 200}} ->
        report = List.first(body["reports"])

        date =
          case report["rows"] do
            [%{"dimensionValues" => [%{"value" => date_str}]}] ->
              Timex.parse!(date_str, "%Y%m%d", :strftime) |> NaiveDateTime.to_date()

            _ ->
              nil
          end

        {:ok, date}

      {:error, %HTTPClient.Non200Error{reason: %{status: 429}} = error} ->
        log_ce_error("retrieving #{edge} date", error)
        {:error, :rate_limit_exceeded}

      {:error, %HTTPClient.Non200Error{} = error} when error.reason.status in [401, 403] ->
        log_ce_error("retrieving #{edge} date", error)
        {:error, authentication_failed(error)}

      {:error, %{reason: :timeout} = error} ->
        log_ce_error("retrieving #{edge} date", error)
        {:error, :timeout}

      {:error, error} ->
        log_ce_error("retrieving #{edge} date", error)

        Sentry.capture_message("Error retrieving GA4 #{edge} date",
          extra: %{error: error}
        )

        {:error, :unknown}
    end
  end

  defp reporting_api_url, do: "https://analyticsdata.googleapis.com"
  defp admin_api_url, do: "https://analyticsadmin.googleapis.com"

  @spec authentication_failed(HTTPClient.Non200Error.t()) ::
          {:authentication_failed, String.t() | nil}
  defp authentication_failed(error) do
    message =
      case error.reason.body do
        %{"error" => %{"message" => message}} when is_binary(message) -> message
        _ -> nil
      end

    {:authentication_failed, message}
  end

  @spec log_ce_error(String.t(), any) :: :ok
  defp log_ce_error(action, error)

  on_ce do
    defp log_ce_error(action, error) do
      Logger.error("Google Analytics 4: Failed when #{action}. Reason: #{inspect(error)}")
    end
  end

  on_ee do
    defp log_ce_error(_action, _error), do: :ok
  end
end
```

## File: `lib/plausible/google/ga4/report_request.ex`
```
defmodule Plausible.Google.GA4.ReportRequest do
  @moduledoc """
  Report request struct for Google Analytics 4 API
  """

  @excluded_event_names [
    "page_view",
    "session_start",
    "first_visit",
    "user_engagement"
  ]

  defstruct [
    :dataset,
    :dimensions,
    :metrics,
    :date_range,
    :property,
    :access_token,
    :offset,
    :dimension_filter,
    :limit
  ]

  @type t() :: %__MODULE__{
          dataset: String.t(),
          dimensions: [String.t()],
          metrics: [String.t()],
          date_range: Date.Range.t(),
          property: term(),
          access_token: String.t(),
          offset: non_neg_integer(),
          limit: non_neg_integer()
        }

  def full_report do
    [
      %__MODULE__{
        dataset: "imported_visitors",
        dimensions: ["date"],
        metrics: [
          "totalUsers",
          "screenPageViews",
          "bounces = sessions - engagedSessions",
          "sessions",
          "userEngagementDuration"
        ]
      },
      %__MODULE__{
        dataset: "imported_sources",
        dimensions: [
          "date",
          "sessionSource",
          "sessionDefaultChannelGroup",
          "sessionMedium",
          "sessionCampaignName",
          "sessionManualAdContent",
          "sessionGoogleAdsKeyword"
        ],
        metrics: [
          "screenPageViews",
          "totalUsers",
          "sessions",
          "bounces = sessions - engagedSessions",
          "userEngagementDuration"
        ]
      },
      %__MODULE__{
        dataset: "imported_pages",
        dimensions: ["date", "hostName", "pagePath"],
        # NOTE: no exits as GA4 DATA API does not provide that metric
        metrics: [
          "totalUsers",
          "activeUsers",
          "screenPageViews",
          "sessions",
          "userEngagementDuration"
        ]
      },
      %__MODULE__{
        dataset: "imported_entry_pages",
        dimensions: ["date", "landingPage"],
        metrics: [
          "screenPageViews",
          "totalUsers",
          "sessions",
          "userEngagementDuration",
          "bounces = sessions - engagedSessions"
        ]
      },
      # NOTE: Skipping for now as there's no dimension directly mapping to exit page path
      # %__MODULE__{
      #   dataset: "imported_exit_pages",
      #   dimensions: ["date", "ga:exitPagePath"],
      #   metrics: [
      #     "totalUsers",
      #     "sessions",
      #     "screenPageViews",
      #     "userEngagementDuration",
      #     "bounces = sessions - engagedSessions"
      #   ]
      # },
      %__MODULE__{
        dataset: "imported_custom_events",
        dimensions: ["date", "eventName", "linkUrl"],
        metrics: [
          "totalUsers",
          "eventCount"
        ],
        dimension_filter: %{
          "notExpression" => %{
            "filter" => %{
              "fieldName" => "eventName",
              "inListFilter" => %{
                "values" => @excluded_event_names,
                "caseSensitive" => true
              }
            }
          }
        }
      },
      %__MODULE__{
        dataset: "imported_locations",
        dimensions: ["date", "countryId", "region", "city"],
        metrics: [
          "screenPageViews",
          "totalUsers",
          "sessions",
          "bounces = sessions - engagedSessions",
          "userEngagementDuration"
        ]
      },
      %__MODULE__{
        dataset: "imported_devices",
        dimensions: ["date", "deviceCategory"],
        metrics: [
          "screenPageViews",
          "totalUsers",
          "sessions",
          "bounces = sessions - engagedSessions",
          "userEngagementDuration"
        ]
      },
      %__MODULE__{
        dataset: "imported_browsers",
        dimensions: ["date", "browser"],
        metrics: [
          "screenPageViews",
          "totalUsers",
          "sessions",
          "bounces = sessions - engagedSessions",
          "userEngagementDuration"
        ]
      },
      %__MODULE__{
        dataset: "imported_operating_systems",
        dimensions: ["date", "operatingSystem", "operatingSystemVersion"],
        metrics: [
          "screenPageViews",
          "totalUsers",
          "sessions",
          "bounces = sessions - engagedSessions",
          "userEngagementDuration"
        ]
      }
    ]
  end
end
```

## File: `lib/plausible/google/http.ex`
```
defmodule Plausible.Google.HTTP do
  require Logger
  alias Plausible.HTTPClient

  def list_sites(access_token) do
    url = "#{api_url()}/webmasters/v3/sites"
    headers = [{"Content-Type", "application/json"}, {"Authorization", "Bearer #{access_token}"}]

    case HTTPClient.impl().get(url, headers) do
      {:ok, %{body: body}} ->
        {:ok, body}

      {:error, %{reason: %{status: s}}} when s in [401, 403] ->
        {:error, "google_auth_error"}

      {:error, %{reason: %{body: %{"error" => error}}}} ->
        {:error, error}

      {:error, reason} ->
        Logger.error("Google Analytics: failed to list sites: #{inspect(reason)}")
        {:error, "failed_to_list_sites"}
    end
  end

  def fetch_access_token!(code) do
    url = "#{api_url()}/oauth2/v4/token"
    headers = [{"Content-Type", "application/x-www-form-urlencoded"}]

    params = %{
      client_id: client_id(),
      client_secret: client_secret(),
      code: code,
      grant_type: :authorization_code,
      redirect_uri: redirect_uri()
    }

    {:ok, response} = HTTPClient.post(url, headers, params)

    response.body
  end

  def list_stats(access_token, property, date_range, pagination, search_console_filters) do
    {limit, page} = pagination

    params = %{
      startDate: Date.to_iso8601(date_range.first),
      endDate: Date.to_iso8601(date_range.last),
      dimensions: ["query"],
      rowLimit: limit,
      startRow: page * limit,
      dimensionFilterGroups: search_console_filters
    }

    url =
      "#{api_url()}/webmasters/v3/sites/#{URI.encode_www_form(property)}/searchAnalytics/query"

    headers = [{"Authorization", "Bearer #{access_token}"}]

    case HTTPClient.impl().post(url, headers, params) do
      {:ok, %Finch.Response{body: body, status: 200}} ->
        {:ok, body}

      {:error, %{reason: %Finch.Response{body: _body, status: status}}}
      when status in [401, 403] ->
        {:error, "google_auth_error"}

      {:error, %{reason: %{body: %{"error" => error}}}} ->
        {:error, error}

      {:error, reason} ->
        Logger.error("Google Search Console: failed to list stats: #{inspect(reason)}")
        {:error, "failed_to_list_stats"}
    end
  end

  def refresh_auth_token(refresh_token) do
    url = "#{api_url()}/oauth2/v4/token"
    headers = [{"content-type", "application/x-www-form-urlencoded"}]

    params = %{
      client_id: client_id(),
      client_secret: client_secret(),
      refresh_token: refresh_token,
      grant_type: :refresh_token,
      redirect_uri: redirect_uri()
    }

    case HTTPClient.impl().post(url, headers, params) do
      {:ok, %Finch.Response{body: body, status: 200}} ->
        {:ok, body}

      {:error, %{reason: %Finch.Response{body: %{"error" => error}, status: _non_http_200}}} ->
        {:error, error}

      {:error, %{reason: _} = e} ->
        Sentry.capture_message("Error fetching Google queries", extra: %{error: inspect(e)})
        {:error, :unknown_error}
    end
  end

  defp config, do: Application.get_env(:plausible, :google)
  defp client_id, do: Keyword.fetch!(config(), :client_id)
  defp client_secret, do: Keyword.fetch!(config(), :client_secret)
  defp api_url, do: Keyword.fetch!(config(), :api_url)
  defp redirect_uri, do: PlausibleWeb.Endpoint.url() <> "/auth/google/callback"
end
```

## File: `lib/plausible/google/search_console/filters.ex`
```
defmodule Plausible.Google.SearchConsole.Filters do
  @moduledoc false
  import Plausible.Stats.Filters.Utils, only: [page_regex: 1]

  def transform(property, plausible_filters, search) do
    gsc_filters =
      Enum.reduce_while(plausible_filters, [], fn plausible_filter, gsc_filters ->
        case transform_filter(property, plausible_filter) do
          :unsupported -> {:halt, :unsupported_filters}
          :ignore -> {:cont, gsc_filters}
          gsc_filter -> {:cont, [gsc_filter | gsc_filters]}
        end
      end)
      |> maybe_add_search_filter(search)

    case gsc_filters do
      :unsupported_filters -> :unsupported_filters
      [] -> {:ok, []}
      filters when is_list(filters) -> {:ok, [%{filters: filters}]}
    end
  end

  defp transform_filter(property, [op, "event:page" | rest]) do
    transform_filter(property, [op, "visit:entry_page" | rest])
  end

  # :TODO: Should also work case-insensitive, if not, blacklist.
  defp transform_filter(property, [:is, "visit:entry_page", pages | _]) when is_list(pages) do
    expression =
      Enum.map_join(pages, "|", fn page -> property_url(property, Regex.escape(page)) end)

    %{dimension: "page", operator: "includingRegex", expression: expression}
  end

  defp transform_filter(property, [:matches_wildcard, "visit:entry_page", pages | _])
       when is_list(pages) do
    expression =
      Enum.map_join(pages, "|", fn page -> page_regex(property_url(property, page)) end)

    %{dimension: "page", operator: "includingRegex", expression: expression}
  end

  defp transform_filter(_property, [:is, "visit:screen", devices | _]) when is_list(devices) do
    expression = Enum.map_join(devices, "|", &search_console_device/1)
    %{dimension: "device", operator: "includingRegex", expression: expression}
  end

  defp transform_filter(_property, [:is, "visit:country", countries | _])
       when is_list(countries) do
    expression = Enum.map_join(countries, "|", &search_console_country/1)
    %{dimension: "country", operator: "includingRegex", expression: expression}
  end

  defp transform_filter(_, [_, "visit:source" | _rest]), do: :ignore

  defp transform_filter(_, _filter), do: :unsupported

  defp property_url("sc-domain:" <> domain, page), do: "https://" <> domain <> page
  defp property_url(url, page), do: url <> page

  defp search_console_device("Desktop"), do: "DESKTOP"
  defp search_console_device("Mobile"), do: "MOBILE"
  defp search_console_device("Tablet"), do: "TABLET"

  defp search_console_country(alpha_2) do
    country = Location.Country.get_country(alpha_2)
    country.alpha_3
  end

  defp maybe_add_search_filter(gsc_filters, search) when byte_size(search) > 0 do
    [%{operator: "includingRegex", expression: search, dimension: "query"} | gsc_filters]
  end

  defp maybe_add_search_filter(gsc_filters, _search), do: gsc_filters
end
```

## File: `lib/plausible/helpers/changeset.ex`
```
defmodule Plausible.ChangesetHelpers do
  @moduledoc "Helper function for working with Ecto changesets"

  def traverse_errors(changeset) do
    Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
      Regex.replace(~r"%{(\w+)}", msg, fn _, key ->
        opts
        |> Keyword.get(String.to_existing_atom(key), key)
        |> to_string()
      end)
    end)
  end
end
```

## File: `lib/plausible/helpers/config.ex`
```
defmodule Plausible.ConfigHelpers do
  def get_var_from_path_or_env(config_dir, var_name, default \\ nil) do
    var_path = Path.join(config_dir, var_name)

    if File.exists?(var_path) do
      File.read!(var_path) |> String.trim()
    else
      System.get_env(var_name, default)
    end
  end

  def get_int_from_path_or_env(config_dir, var_name, default \\ nil) do
    var = get_var_from_path_or_env(config_dir, var_name)

    case var do
      nil ->
        default

      var ->
        case Integer.parse(var) do
          {int, ""} -> int
          _ -> raise "Config variable #{var_name} must be an integer. Got #{var}"
        end
    end
  end

  def get_bool_from_path_or_env(config_dir, var_name, default \\ nil) do
    case get_var_from_path_or_env(config_dir, var_name) do
      nil -> default
      var -> parse_bool(var)
    end
  end

  @var_true ["1", "t", "true", "y", "yes", "on"]
  @var_false ["0", "f", "false", "n", "no", "off"]
  @var_bool_message Enum.zip_with(@var_true, @var_false, fn t, f -> [t, f] end)
                    |> List.flatten()
                    |> Enum.join(", ")

  defp parse_bool(var) do
    case String.downcase(var) do
      t when t in @var_true ->
        true

      f when f in @var_false ->
        false

      _ ->
        raise ArgumentError,
              "Invalid boolean value: #{inspect(var)}. Expected one of: " <> @var_bool_message
    end
  end
end
```

## File: `lib/plausible/helpers/json.ex`
```
defmodule Plausible.Helpers.JSON do
  @moduledoc """
  Common helpers for JSON handling
  """

  def decode_or_fallback(raw) do
    with raw when is_binary(raw) <- raw,
         {:ok, %{} = decoded} <- Jason.decode(raw) do
      decoded
    else
      already_a_map when is_map(already_a_map) -> already_a_map
      _any -> %{}
    end
  end
end
```

## File: `lib/plausible/http_client.ex`
```
defmodule Plausible.HTTPClient.Non200Error do
  defstruct reason: nil

  @type t :: %__MODULE__{reason: Finch.Response.t()}

  @spec new(Finch.Response.t()) :: t()
  def new(%Finch.Response{status: status} = response)
      when is_integer(status) and (status < 200 or status >= 300) do
    %__MODULE__{reason: response}
  end
end

defmodule Plausible.HTTPClient.Interface do
  @type finch_request_opts() :: Keyword.t()
  @type url() :: Finch.Request.url()
  @type headers() :: Finch.Request.headers()
  @type params() :: Finch.Request.body() | map()
  @type response() ::
          {:ok, Finch.Response.t()}
          | {:error, Mint.Types.error() | Finch.Error.t() | Plausible.HTTPClient.Non200Error.t()}

  @callback get(url(), headers(), params()) :: response()
  @callback get(url(), headers()) :: response()
  @callback get(url()) :: response()
  @callback post(url(), headers(), params()) :: response()
  @callback post(url(), headers(), params(), finch_request_opts()) :: response()
end

defmodule Plausible.HTTPClient do
  @moduledoc """
  HTTP Client built on top of Finch.

  By default, request parameters are json-encoded.

  If a raw binary value is supplied, no encoding is performed.
  If x-www-form-urlencoded content-type is set in headers,
  URL encoding is invoked.
  """

  require OpenTelemetry.Tracer
  alias Plausible.HTTPClient.Non200Error

  @doc """
  Make a POST request
  """
  @behaviour Plausible.HTTPClient.Interface

  @impl Plausible.HTTPClient.Interface
  def post(url, headers \\ [], params \\ nil, finch_req_opts \\ []) do
    call(:post, url, headers, params, finch_req_opts)
  end

  @doc """
  Make a GET request
  """
  @impl Plausible.HTTPClient.Interface
  def get(url, headers \\ [], params \\ nil) do
    call(:get, url, headers, params)
  end

  # TODO: Is it possible to tell the type checker that we're returning a module that conforms to the
  # Plausible.HTTPClient.Interface behaviour?
  @spec impl() :: Plausible.HTTPClient
  def impl() do
    Application.get_env(:plausible, :http_impl, __MODULE__)
  end

  defp call(method, url, headers, params, finch_req_opts \\ []) do
    OpenTelemetry.Tracer.with_span "http_client.request" do
      {params, headers} = maybe_encode_params(params, headers)

      method
      |> build_request(url, headers, params)
      |> trace_request()
      |> do_request(finch_req_opts)
      |> maybe_decode_body()
      |> tag_error()
      |> trace_response()
    end
  end

  defp build_request(method, url, headers, params) do
    Finch.build(method, url, headers, params)
  end

  defp do_request(request, finch_req_opts) do
    Finch.request(request, Plausible.Finch, finch_req_opts)
  end

  defp maybe_encode_params(params, headers) when is_binary(params) or is_nil(params) do
    {params, headers}
  end

  defp maybe_encode_params(params, headers) when is_map(params) do
    content_type =
      Enum.find_value(headers, "", fn {k, v} ->
        if String.downcase(k) == "content-type" do
          v
        end
      end)

    case String.downcase(content_type) do
      "application/x-www-form-urlencoded" ->
        {URI.encode_query(params), headers}

      "application/json" ->
        {Jason.encode!(params), headers}

      _ ->
        {Jason.encode!(params), [{"content-type", "application/json"} | headers]}
    end
  end

  defp tag_error({:ok, %Finch.Response{status: status}} = ok)
       when is_integer(status) and status >= 200 and status < 300 do
    ok
  end

  defp tag_error({:ok, %Finch.Response{status: _} = response}) do
    {:error, Non200Error.new(response)}
  end

  defp tag_error({:error, _} = error) do
    error
  end

  defp maybe_decode_body({:ok, %{headers: headers, body: body} = resp})
       when is_binary(body) and body != "" do
    if json?(headers) do
      {:ok, update_in(resp.body, &Jason.decode!/1)}
    else
      {:ok, resp}
    end
  end

  defp maybe_decode_body(response), do: response

  defp json?(headers) do
    found =
      Enum.find(headers, fn
        {"content-type", "application/json" <> _} ->
          true

        _ ->
          false
      end)

    is_tuple(found)
  end

  defp trace_request(%Finch.Request{} = request) do
    OpenTelemetry.Tracer.set_attributes([
      {"http_client.request.host", request.host},
      {"http_client.request.method", request.method},
      {"http_client.request.path", request.path}
    ])

    request
  end

  defp trace_response(response) do
    case response do
      {:ok, %{status: status}} ->
        OpenTelemetry.Tracer.set_attributes([
          {"http_client.response.status", status}
        ])

      {:error, %Non200Error{reason: %{status: status}}} ->
        OpenTelemetry.Tracer.set_attributes([
          {"http_client.request.failure", "non_200"},
          {"http_client.response.status", status}
        ])

      {:error, exception} when is_exception(exception) ->
        OpenTelemetry.Tracer.set_attributes([
          {"http_client.request.failure", Exception.message(exception)}
        ])

      _any ->
        :skip
    end

    response
  end
end
```

## File: `lib/plausible/import_deletion_repo.ex`
```
defmodule Plausible.ImportDeletionRepo do
  @moduledoc """
  A dedicated repo for import related mutations
  """

  use Ecto.Repo,
    otp_app: :plausible,
    adapter: Ecto.Adapters.ClickHouse

  defmacro __using__(_) do
    quote do
      alias Plausible.ImportDeletionRepo
      import Ecto
      import Ecto.Query, only: [from: 1, from: 2]
    end
  end
end
```

## File: `lib/plausible/imported.ex`
```
defmodule Plausible.Imported do
  @moduledoc """
  Context for managing site statistics imports.

  For list of currently supported import sources see `Plausible.Imported.ImportSources`.

  For more information on implementing importers, see `Plausible.Imported.Importer`.
  """

  import Ecto.Query

  alias Plausible.{Site, Repo, Imported}
  alias Plausible.Imported.SiteImport
  alias Plausible.Stats.Query

  require Plausible.Imported.SiteImport

  @tables [
    Imported.Visitor,
    Imported.Source,
    Imported.Page,
    Imported.EntryPage,
    Imported.ExitPage,
    Imported.CustomEvent,
    Imported.Location,
    Imported.Device,
    Imported.Browser,
    Imported.OperatingSystem
  ]

  @table_names Enum.map(@tables, & &1.__schema__(:source))
  # Maximum number of complete imports to account for when querying stats
  @max_complete_imports 5

  @spec schemas() :: [module()]
  def schemas, do: @tables

  @spec tables() :: [String.t()]
  def tables, do: @table_names

  @spec max_complete_imports() :: non_neg_integer()
  def max_complete_imports() do
    @max_complete_imports
  end

  @spec imported_custom_props() :: [String.t()]
  def imported_custom_props do
    # NOTE: Keep up to date with `Plausible.Props.internal_keys/1`,
    # but _ignore_ unsupported keys. Currently, `search_query` is
    # not supported in imported queries.
    Enum.map(~w(url path), &("event:props:" <> &1))
  end

  @spec any_completed_imports?(Site.t()) :: boolean()
  def any_completed_imports?(site) do
    get_completed_imports(site) != []
  end

  @spec earliest_import_start_date(Site.t()) :: Date.t() | nil
  def earliest_import_start_date(site) do
    site
    |> get_completed_imports()
    |> Enum.map(& &1.start_date)
    |> Enum.min(Date, fn -> nil end)
  end

  @spec complete_import_ids(Site.t()) :: [non_neg_integer()]
  def complete_import_ids(site) do
    imports = get_completed_imports(site)
    has_legacy? = Enum.any?(imports, fn %{legacy: legacy?} -> legacy? end)
    ids = Enum.map(imports, fn %{id: id} -> id end)

    # account for legacy imports as well
    if has_legacy? do
      [0 | ids]
    else
      ids
    end
  end

  @spec completed_imports_in_query_range(Site.t(), Query.t()) :: [SiteImport.t()]
  def completed_imports_in_query_range(%Site{} = site, %Query{} = query) do
    date_range = Query.date_range(query)

    site
    |> get_completed_imports()
    |> Enum.reject(fn site_import ->
      Date.after?(site_import.start_date, date_range.last) or
        Date.before?(site_import.end_date, date_range.first)
    end)
  end

  @spec get_import(Site.t(), non_neg_integer()) :: SiteImport.t() | nil
  def get_import(site, import_id) do
    Repo.get_by(SiteImport, id: import_id, site_id: site.id)
  end

  defdelegate listen(), to: Imported.Importer

  @spec list_all_imports(Site.t(), atom()) :: [SiteImport.t()]
  def list_all_imports(site, status \\ nil) do
    from(i in SiteImport, where: i.site_id == ^site.id, order_by: [desc: i.inserted_at])
    |> maybe_filter_by_status(status)
    |> Repo.all()
  end

  @spec other_imports_in_progress?(SiteImport.t()) :: boolean()
  def other_imports_in_progress?(site_import) do
    Repo.exists?(
      from(i in SiteImport,
        where: i.site_id == ^site_import.site_id and i.id != ^site_import.id,
        where: i.status in ^[SiteImport.pending(), SiteImport.importing()]
      )
    )
  end

  defp maybe_filter_by_status(query, nil), do: query

  defp maybe_filter_by_status(query, status) do
    where(query, [i], i.status == ^status)
  end

  @spec delete_imports_for_site(Site.t()) :: :ok
  def delete_imports_for_site(site) do
    Repo.delete_all(from i in SiteImport, where: i.site_id == ^site.id)

    :ok
  end

  @spec clamp_dates(Site.t(), Date.t(), Date.t()) ::
          {:ok, Date.t(), Date.t()} | {:error, :no_time_window}
  def clamp_dates(site, start_date, end_date) do
    cutoff_date = get_cutoff_date(site)
    occupied_ranges = get_occupied_date_ranges(site)

    clamp_dates(occupied_ranges, cutoff_date, start_date, end_date)
  end

  @spec clamp_dates([Date.Range.t()], Date.t(), Date.t(), Date.t()) ::
          {:ok, Date.t(), Date.t()} | {:error, :no_time_window}
  def clamp_dates(occupied_ranges, cutoff_date, start_date, end_date) do
    end_date = Enum.min([end_date, cutoff_date], Date)

    with true <- Date.diff(end_date, start_date) >= 2,
         [_ | _] = free_ranges <- find_free_ranges(start_date, end_date, occupied_ranges) do
      longest = Enum.max_by(free_ranges, &Date.diff(&1.last, &1.first))
      {:ok, longest.first, longest.last}
    else
      _ -> {:error, :no_time_window}
    end
  end

  @spec get_occupied_date_ranges(Site.t()) :: [Date.Range.t()]
  def get_occupied_date_ranges(site) do
    site
    |> Imported.list_all_imports(Imported.SiteImport.completed())
    |> Enum.reject(&(Date.diff(&1.end_date, &1.start_date) < 2))
    |> Enum.map(&Date.range(&1.start_date, &1.end_date))
    |> Enum.sort_by(& &1.first, Date)
  end

  @spec get_cutoff_date(Site.t()) :: Date.t()
  def get_cutoff_date(site) do
    Plausible.Sites.native_stats_start_date(site) ||
      DateTime.to_date(DateTime.now!(site.timezone))
  end

  defp find_free_ranges(start_date, end_date, occupied_ranges) do
    Date.range(start_date, end_date)
    |> free_ranges(start_date, occupied_ranges, [])
  end

  # This function recursively finds open ranges that are not yet occupied
  # by existing imported data. The idea is that we keep moving a dynamic
  # date index `d` from start until the end of `imported_range`, hopping
  # over each occupied range, and capturing the open ranges step-by-step
  # in the `result` array.
  defp free_ranges(import_range, d, [occupied_range | rest_of_occupied_ranges], result) do
    cond do
      Date.diff(occupied_range.last, d) <= 0 ->
        free_ranges(import_range, d, rest_of_occupied_ranges, result)

      in_range?(d, occupied_range) || Date.diff(occupied_range.first, d) < 2 ->
        d = occupied_range.last
        free_ranges(import_range, d, rest_of_occupied_ranges, result)

      true ->
        free_range = Date.range(d, occupied_range.first)
        result = result ++ [free_range]
        d = occupied_range.last
        free_ranges(import_range, d, rest_of_occupied_ranges, result)
    end
  end

  defp free_ranges(import_range, d, [], result) do
    if Date.diff(import_range.last, d) < 2 do
      result
    else
      result ++ [Date.range(d, import_range.last)]
    end
  end

  defp in_range?(date, range) do
    Date.before?(range.first, date) && Date.after?(range.last, date)
  end

  defp get_completed_imports(site) do
    site
    |> Repo.preload(:completed_imports)
    |> Map.fetch!(:completed_imports)
  end
end
```

## File: `lib/plausible/imported/browser.ex`
```
defmodule Plausible.Imported.Browser do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_browsers" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :browser, :string
    field :browser_version, :string
    field :visitors, Ch, type: "UInt64"
    field :visits, Ch, type: "UInt64"
    field :visit_duration, Ch, type: "UInt64"
    field :pageviews, Ch, type: "UInt64"
    field :bounces, Ch, type: "UInt32"
  end
end
```

## File: `lib/plausible/imported/buffer.ex`
```
defmodule Plausible.Imported.Buffer do
  @moduledoc """
  This GenServer inserts records into Clickhouse `imported_*` tables. Multiple buffers are
  automatically created for each table. Records are flushed when the table buffer reaches the
  maximum size, defined by `max_buffer_size/0`.
  """

  use GenServer
  require Logger

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts)
  end

  def init(opts) do
    flush_interval = Keyword.get(opts, :flush_interval_ms, 1000)
    {:ok, %{flush_interval: flush_interval, buffers: %{}}}
  end

  @spec insert_many(pid(), term(), [map()]) :: :ok
  @doc """
  Puts the given records into the table buffer.
  """
  def insert_many(pid, table_name, records) do
    GenServer.call(pid, {:insert_many, table_name, records})
  end

  @spec size(pid(), term()) :: non_neg_integer()
  @doc """
  Returns the total count of items in the given table buffer.
  """
  def size(pid, table_name) do
    GenServer.call(pid, {:get_size, table_name})
  end

  @spec flush(pid()) :: :ok
  @doc """
  Flushes all table buffers to Clickhouse.
  """
  def flush(pid, timeout \\ :infinity) do
    GenServer.call(pid, :flush_all_buffers, timeout)
  end

  def stop(pid) do
    GenServer.stop(pid)
  end

  def handle_call({:get_size, table_name}, _from, %{buffers: buffers} = state) do
    size =
      buffers
      |> Map.get(table_name, [])
      |> length()

    {:reply, size, state}
  end

  def handle_call({:insert_many, table_name, records}, _from, %{buffers: buffers} = state) do
    Logger.notice("Import: Adding #{length(records)} to #{table_name} buffer")

    new_buffer = Map.get(buffers, table_name, []) ++ records
    new_state = put_in(state.buffers[table_name], new_buffer)

    if length(new_buffer) >= max_buffer_size() do
      {:reply, :ok, new_state, {:continue, {:flush, table_name}}}
    else
      {:reply, :ok, new_state}
    end
  end

  def handle_call(:flush_all_buffers, _from, state) do
    Enum.each(state.buffers, fn {table_name, records} ->
      flush_buffer(records, table_name, state.flush_interval)
    end)

    {:reply, :ok, put_in(state.buffers, %{})}
  end

  def handle_continue({:flush, table_name}, state) do
    flush_buffer(state.buffers[table_name], table_name, state.flush_interval)
    {:noreply, put_in(state.buffers[table_name], [])}
  end

  defp max_buffer_size do
    :plausible
    |> Application.fetch_env!(:imported)
    |> Keyword.fetch!(:max_buffer_size)
  end

  defp flush_buffer(records, table_name, flush_interval) do
    # Clickhouse does not recommend sending more than 1 INSERT operation per second, and this
    # sleep call slows down the flushing
    Process.sleep(flush_interval)

    Logger.notice("Import: Flushing #{length(records)} from #{table_name} buffer")
    insert_all(table_name, records)
  end

  # used in tests `setup`
  @doc false
  def insert_all(table_name, records) do
    schema = table_schema(table_name)
    Plausible.IngestRepo.insert_all(schema, records)
  end

  defp table_schema("imported_visitors"), do: Plausible.Imported.Visitor
  defp table_schema("imported_sources"), do: Plausible.Imported.Source
  defp table_schema("imported_pages"), do: Plausible.Imported.Page
  defp table_schema("imported_entry_pages"), do: Plausible.Imported.EntryPage
  defp table_schema("imported_exit_pages"), do: Plausible.Imported.ExitPage
  defp table_schema("imported_custom_events"), do: Plausible.Imported.CustomEvent
  defp table_schema("imported_locations"), do: Plausible.Imported.Location
  defp table_schema("imported_devices"), do: Plausible.Imported.Device
  defp table_schema("imported_browsers"), do: Plausible.Imported.Browser
  defp table_schema("imported_operating_systems"), do: Plausible.Imported.OperatingSystem
end
```

## File: `lib/plausible/imported/csv_importer.ex`
```
defmodule Plausible.Imported.CSVImporter do
  @moduledoc """
  CSV importer from either S3 for which it uses ClickHouse [s3 table function](https://clickhouse.com/docs/en/sql-reference/table-functions/s3)
  or from local storage for which it uses [input function.](https://clickhouse.com/docs/en/sql-reference/table-functions/input)
  """

  use Plausible.Imported.Importer
  import Ecto.Query, only: [from: 2]

  @impl true
  def name(), do: :csv

  @impl true
  def label(), do: "CSV"

  @impl true
  def email_template(), do: "csv_import.html"

  @impl true
  def parse_args(%{"uploads" => uploads, "storage" => storage}) do
    [uploads: uploads, storage: storage]
  end

  @impl true
  def import_data(site_import, opts) do
    storage = Keyword.fetch!(opts, :storage)
    uploads = Keyword.fetch!(opts, :uploads)

    if storage == "local" do
      # we need to remove the imported files from local storage
      # after the importer has completed or ran out of attempts
      paths = Enum.map(uploads, &Map.fetch!(&1, "local_path"))

      Oban.insert!(
        Plausible.Workers.LocalImportAnalyticsCleaner.new(
          %{"import_id" => site_import.id, "paths" => paths},
          schedule_in: _one_hour = 3600
        )
      )
    end

    {:ok, ch} =
      Plausible.IngestRepo.config()
      |> Keyword.replace!(:pool_size, 1)
      |> Ch.start_link()

    case storage do
      "s3" -> import_s3(ch, site_import, uploads)
      "local" -> import_local(ch, site_import, uploads)
    end
  rescue
    # we are cancelling on any argument or ClickHouse errors, assuming they are permanent
    e in [ArgumentError, Ch.Error] ->
      # see Plausible.Imported.Importer for more details on transient vs permanent errors
      {:error, Exception.message(e)}
  end

  def on_success(site_import, _extra_data) do
    has_scroll_depth? =
      Plausible.ClickhouseRepo.exists?(
        from(i in "imported_pages",
          where: i.site_id == ^site_import.site_id,
          where: i.import_id == ^site_import.id,
          where: i.total_scroll_depth_visits > 0,
          select: 1
        )
      )

    if has_scroll_depth? do
      site_import
      |> Ecto.Changeset.change(%{has_scroll_depth: true})
      |> Plausible.Repo.update!()
    end

    :ok
  end

  defp import_s3(ch, site_import, uploads) do
    %{
      id: import_id,
      site_id: site_id,
      start_date: start_date,
      end_date: end_date
    } = site_import

    %{access_key_id: s3_access_key_id, secret_access_key: s3_secret_access_key} =
      Plausible.S3.import_clickhouse_credentials()

    Enum.each(uploads, fn upload ->
      %{"filename" => filename, "s3_url" => s3_url} = upload

      {table, _, _} = parse_filename!(filename)
      s3_structure = input_structure!(table)
      s3_columns = input_columns!(table)

      statement =
        """
        INSERT INTO {table:Identifier}(site_id,import_id,#{s3_columns}) \
        SELECT {site_id:UInt64}, {import_id:UInt64}, #{s3_columns} \
        FROM s3({s3_url:String},{s3_access_key_id:String},{s3_secret_access_key:String},{s3_format:String},{s3_structure:String}) \
        WHERE date >= {start_date:Date} AND date <= {end_date:Date}\
        """

      params =
        %{
          "table" => table,
          "site_id" => site_id,
          "import_id" => import_id,
          "s3_url" => s3_url,
          "s3_access_key_id" => s3_access_key_id,
          "s3_secret_access_key" => s3_secret_access_key,
          "s3_format" => "CSVWithNames",
          "s3_structure" => s3_structure,
          "start_date" => start_date,
          "end_date" => end_date
        }

      Ch.query!(ch, statement, params, timeout: :infinity)
    end)
  end

  defp import_local(ch, site_import, uploads) do
    %{
      id: import_id,
      site_id: site_id,
      start_date: start_date,
      end_date: end_date
    } = site_import

    DBConnection.run(
      ch,
      fn conn ->
        Enum.each(uploads, fn upload ->
          %{"filename" => filename, "local_path" => local_path} = upload

          {table, _, _} = parse_filename!(filename)
          input_structure = input_structure!(table)
          input_columns = input_columns!(table)

          statement =
            """
            INSERT INTO {table:Identifier}(site_id,import_id,#{input_columns}) \
            SELECT {site_id:UInt64}, {import_id:UInt64}, #{input_columns} \
            FROM input({input_structure:String}) \
            WHERE date >= {start_date:Date} AND date <= {end_date:Date} \
            FORMAT CSVWithNames
            """

          params = %{
            "table" => table,
            "site_id" => site_id,
            "import_id" => import_id,
            "input_structure" => input_structure,
            "start_date" => start_date,
            "end_date" => end_date
          }

          # we are reading in 512KB chunks for better performance
          # the default would've been line by line (not great for a CSV)
          File.stream!(local_path, 512_000)
          |> Stream.into(Ch.stream(conn, statement, params))
          |> Stream.run()
        end)
      end,
      timeout: :infinity
    )
  end

  input_structures = %{
    "imported_browsers" =>
      "date Date, browser String, browser_version String, visitors UInt64, visits UInt64, visit_duration UInt64, bounces UInt32, pageviews UInt64",
    "imported_devices" =>
      "date Date, device String, visitors UInt64, visits UInt64, visit_duration UInt64, bounces UInt32, pageviews UInt64",
    "imported_entry_pages" =>
      "date Date, entry_page String, visitors UInt64, entrances UInt64, visit_duration UInt64, bounces UInt32, pageviews UInt64",
    "imported_exit_pages" =>
      "date Date, exit_page String, visitors UInt64, visit_duration UInt64, exits UInt64, bounces UInt32, pageviews UInt64",
    "imported_custom_events" =>
      "date Date, name String, link_url String, path String, visitors UInt64, events UInt64",
    "imported_locations" =>
      "date Date, country String, region String, city UInt64, visitors UInt64, visits UInt64, visit_duration UInt64, bounces UInt32, pageviews UInt64",
    "imported_operating_systems" =>
      "date Date, operating_system String, operating_system_version String, visitors UInt64, visits UInt64, visit_duration UInt64, bounces UInt32, pageviews UInt64",
    "imported_pages" =>
      "date Date, hostname String, page String, visits UInt64, visitors UInt64, pageviews UInt64, total_scroll_depth UInt64, total_scroll_depth_visits UInt64, total_time_on_page UInt64, total_time_on_page_visits UInt64",
    "imported_sources" =>
      "date Date, source String, referrer String, utm_source String, utm_medium String, utm_campaign String, utm_content String, utm_term String, pageviews UInt64, visitors UInt64, visits UInt64, visit_duration UInt64, bounces UInt32",
    "imported_visitors" =>
      "date Date, visitors UInt64, pageviews UInt64, bounces UInt64, visits UInt64, visit_duration UInt64"
  }

  @doc """
  Extracts min/max date range from a list of uploads.

  Examples:

      iex> date_range([
      ...>   %{"filename" => "imported_devices_20190101_20210101.csv"},
      ...>   "pages_20200101_20220101.csv"
      ...> ])
      Date.range(~D[2019-01-01], ~D[2022-01-01])

      iex> date_range([])
      nil

  """
  @spec date_range([String.t() | %{String.t() => String.t()}, ...]) :: Date.Range.t() | nil
  def date_range([_ | _] = uploads), do: date_range(uploads, _start_date = nil, _end_date = nil)
  def date_range([]), do: nil

  defp date_range([upload | uploads], prev_start_date, prev_end_date) do
    filename =
      case upload do
        %{"filename" => filename} -> filename
        filename when is_binary(filename) -> filename
      end

    {_table, start_date, end_date} = parse_filename!(filename)

    start_date =
      if prev_start_date do
        Enum.min([start_date, prev_start_date], Date)
      else
        start_date
      end

    end_date =
      if prev_end_date do
        Enum.max([end_date, prev_end_date], Date)
      else
        end_date
      end

    date_range(uploads, start_date, end_date)
  end

  defp date_range([], first, last), do: Date.range(first, last)

  @spec parse_date!(String.t()) :: Date.t()
  defp parse_date!(<<yyyy::bytes-4, mm::bytes-2, dd::bytes-2>>) do
    Date.from_iso8601!("#{yyyy}-#{mm}-#{dd}")
  end

  @doc """
  Extracts table name and min/max dates from the filename.

  Examples:

      iex> parse_filename!("my_data.csv")
      ** (ArgumentError) invalid filename

      iex> parse_filename!("imported_devices_00010101_20250101.csv")
      {"imported_devices", ~D[0001-01-01], ~D[2025-01-01]}

      iex> parse_filename!("devices_00010101_20250101.csv")
      {"imported_devices", ~D[0001-01-01], ~D[2025-01-01]}

  """
  @spec parse_filename!(String.t()) ::
          {table :: String.t(), start_date :: Date.t(), end_date :: Date.t()}
  def parse_filename!(filename)

  for {table, input_structure} <- input_structures do
    defp input_structure!(unquote(table)), do: unquote(input_structure)

    input_columns =
      input_structure
      |> String.split(",", trim: true)
      |> Enum.map_join(",", fn kv ->
        [col, _type] = String.split(kv)
        String.trim(col)
      end)

    defp input_columns!(unquote(table)), do: unquote(input_columns)

    def parse_filename!(
          <<unquote(table)::bytes, ?_, start_date::8-bytes, ?_, end_date::8-bytes, ".csv">>
        ) do
      {unquote(table), parse_date!(start_date), parse_date!(end_date)}
    end

    "imported_" <> name = table

    def parse_filename!(
          <<unquote(name)::bytes, ?_, start_date::8-bytes, ?_, end_date::8-bytes, ".csv">>
        ) do
      {unquote(table), parse_date!(start_date), parse_date!(end_date)}
    end
  end

  def parse_filename!(_filename) do
    raise ArgumentError, "invalid filename"
  end

  @doc """
  Checks if the provided filename conforms to the expected format.

  Examples:

      iex> valid_filename?("my_data.csv")
      false

      iex> valid_filename?("imported_devices_00010101_20250101.csv")
      true

      iex> valid_filename?("devices_00010101_20250101.csv")
      true

  """
  @spec valid_filename?(String.t()) :: boolean
  def valid_filename?(filename) do
    try do
      parse_filename!(filename)
    else
      _ -> true
    rescue
      _ -> false
    end
  end

  @doc """
  Extracts the table name from the provided filename.

  Raises if the filename doesn't conform to the expected format.

  Examples:

      iex> extract_table("my_data.csv")
      ** (ArgumentError) invalid filename

      iex> extract_table("imported_devices_00010101_20250101.csv")
      "imported_devices"

      iex> extract_table("devices_00010101_20250101.csv")
      "imported_devices"

  """
  @spec extract_table(String.t()) :: String.t()
  def extract_table(filename) do
    {table, _start_date, _end_date} = parse_filename!(filename)
    table
  end

  @doc """
  Returns local directory for CSV imports storage.

  Builds upon `$DATA_DIR`, `$PERSISTENT_CACHE_DIR` or `$DEFAULT_DATA_DIR` (if set) and falls back to /tmp.

  `$DEFAULT_DATA_DIR` is set to `/var/lib/plausible` in container images.

  Examples:

      iex> local_dir = local_dir(_site_id = 37)
      iex> String.ends_with?(local_dir, "/plausible-imports/37")
      true

  """
  def local_dir(site_id) do
    data_dir = Application.get_env(:plausible, :data_dir)
    Path.join([data_dir || System.tmp_dir!(), "plausible-imports", Integer.to_string(site_id)])
  end
end
```

## File: `lib/plausible/imported/custom_event.ex`
```
defmodule Plausible.Imported.CustomEvent do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_custom_events" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :name, :string
    field :link_url, :string
    field :path, :string
    field :visitors, Ch, type: "UInt64"
    field :events, Ch, type: "UInt64"
  end
end
```

## File: `lib/plausible/imported/device.ex`
```
defmodule Plausible.Imported.Device do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_devices" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :device, :string
    field :visitors, Ch, type: "UInt64"
    field :visits, Ch, type: "UInt64"
    field :visit_duration, Ch, type: "UInt64"
    field :pageviews, Ch, type: "UInt64"
    field :bounces, Ch, type: "UInt32"
  end
end
```

## File: `lib/plausible/imported/entry_page.ex`
```
defmodule Plausible.Imported.EntryPage do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_entry_pages" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :entry_page, :string
    field :visitors, Ch, type: "UInt64"
    field :entrances, Ch, type: "UInt64"
    field :visit_duration, Ch, type: "UInt64"
    field :pageviews, Ch, type: "UInt64"
    field :bounces, Ch, type: "UInt32"
  end
end
```

## File: `lib/plausible/imported/exit_page.ex`
```
defmodule Plausible.Imported.ExitPage do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_exit_pages" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :exit_page, :string
    field :exits, Ch, type: "UInt64"
    field :visitors, Ch, type: "UInt64"
    field :visit_duration, Ch, type: "UInt64"
    field :pageviews, Ch, type: "UInt64"
    field :bounces, Ch, type: "UInt32"
  end
end
```

## File: `lib/plausible/imported/google_analytics4.ex`
```
defmodule Plausible.Imported.GoogleAnalytics4 do
  @moduledoc """
  Import implementation for Google Analytics 4.
  """

  use Plausible.Imported.Importer

  alias Plausible.Imported
  alias Plausible.Repo

  @recoverable_errors [:rate_limit_exceeded, :socket_failed, :server_failed]
  @missing_values ["(none)", "(not set)", "(not provided)", "(other)"]

  @impl true
  def name(), do: :google_analytics_4

  @impl true
  def label(), do: "Google Analytics 4"

  @impl true
  def email_template(), do: "google_analytics_import.html"

  @impl true
  def before_start(site_import, opts) do
    site_import = Repo.preload(site_import, :site)

    if import_id = Keyword.get(opts, :resume_from_import_id) do
      if existing_site_import = Imported.get_import(site_import.site, import_id) do
        Repo.delete!(site_import)
        {:ok, existing_site_import}
      else
        # NOTE: shouldn't happen under normal circumsatnces
        {:error, {:no_import_to_resume, import_id}}
      end
    else
      {:ok, site_import}
    end
  end

  @impl true
  def parse_args(%{"resume_from_dataset" => dataset, "resume_from_offset" => offset} = args) do
    args
    |> Map.drop(["resume_from_dataset", "resume_from_offset"])
    |> parse_args()
    |> Keyword.put(:dataset, dataset)
    |> Keyword.put(:offset, offset)
  end

  def parse_args(
        %{"property" => property, "start_date" => start_date, "end_date" => end_date} = args
      ) do
    start_date = Date.from_iso8601!(start_date)
    end_date = Date.from_iso8601!(end_date)
    date_range = Date.range(start_date, end_date)

    auth = {
      Map.fetch!(args, "access_token"),
      Map.fetch!(args, "refresh_token"),
      Map.fetch!(args, "token_expires_at")
    }

    [
      property: property,
      date_range: date_range,
      auth: auth
    ]
  end

  @doc """
  Imports stats from a Google Analytics 4 property to a Plausible site.

  This function fetches Google Analytics 4 reports which are then passed in batches
  to Clickhouse by the `Plausible.Imported.Buffer` process.
  """
  @impl true
  def import_data(site_import, opts) do
    date_range = Keyword.fetch!(opts, :date_range)
    property = Keyword.fetch!(opts, :property)
    auth = Keyword.fetch!(opts, :auth)
    flush_interval_ms = Keyword.get(opts, :flush_interval_ms, 1000)

    {:ok, buffer} = Plausible.Imported.Buffer.start_link(flush_interval_ms: flush_interval_ms)

    persist_fn = fn table, rows ->
      records = from_report(rows, site_import.site_id, site_import.id, table)
      Plausible.Imported.Buffer.insert_many(buffer, table, records)
    end

    resume_opts = Keyword.take(opts, [:dataset, :offset])
    fetch_opts = Keyword.get(opts, :fetch_opts, [])

    try do
      result =
        Plausible.Google.GA4.API.import_analytics(date_range, property, auth,
          persist_fn: persist_fn,
          fetch_opts: fetch_opts,
          resume_opts: resume_opts
        )

      case result do
        {:error, {error, details}} when error in @recoverable_errors ->
          site_import = Repo.preload(site_import, [:site, :imported_by])
          dataset = Keyword.fetch!(details, :dataset)
          offset = Keyword.fetch!(details, :offset)
          {access_token, refresh_token, token_expires_at} = auth

          resume_import_opts = [
            property: property,
            label: property,
            start_date: date_range.first,
            end_date: date_range.last,
            access_token: access_token,
            refresh_token: refresh_token,
            token_expires_at: token_expires_at,
            resume_from_import_id: site_import.id,
            resume_from_dataset: dataset,
            resume_from_offset: offset,
            job_opts: [schedule_in: {65, :minutes}, unique: nil]
          ]

          new_import(
            site_import.site,
            site_import.imported_by,
            resume_import_opts
          )

          {:error, error, skip_purge?: true, skip_mark_failed?: true}

        other ->
          other
      end
    after
      Plausible.Imported.Buffer.flush(buffer)
      Plausible.Imported.Buffer.stop(buffer)
    end
  end

  def from_report(nil, _site_id, _import_id, _metric), do: nil

  def from_report(data, site_id, import_id, table) do
    Enum.reduce(data, [], fn row, acc ->
      if Map.get(row.dimensions, "date") in @missing_values do
        acc
      else
        [new_from_report(site_id, import_id, table, row) | acc]
      end
    end)
  end

  defp parse_number(nr) do
    {float, ""} = Float.parse(nr)
    round(float)
  end

  defp maybe_override_event_name("file_download"), do: "File Download"
  defp maybe_override_event_name("click"), do: "Outbound Link: Click"
  defp maybe_override_event_name(name), do: name

  defp new_from_report(site_id, import_id, "imported_visitors", row) do
    %{
      site_id: site_id,
      import_id: import_id,
      date: get_date(row),
      visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
      pageviews: row.metrics |> Map.fetch!("screenPageViews") |> parse_number(),
      bounces: row.metrics |> Map.fetch!("bounces") |> parse_number(),
      visits: row.metrics |> Map.fetch!("sessions") |> parse_number(),
      visit_duration: row.metrics |> Map.fetch!("userEngagementDuration") |> parse_number()
    }
  end

  defp new_from_report(site_id, import_id, "imported_sources", row) do
    %{
      site_id: site_id,
      import_id: import_id,
      date: get_date(row),
      source: row.dimensions |> Map.fetch!("sessionSource") |> parse_source(),
      # GA4 channels map 1-1 to Plausible channels
      channel: row.dimensions |> Map.fetch!("sessionDefaultChannelGroup"),
      referrer: nil,
      # Only `source` exists in GA4 API
      utm_source: nil,
      utm_medium: row.dimensions |> Map.fetch!("sessionMedium") |> default_if_missing(),
      utm_campaign: row.dimensions |> Map.fetch!("sessionCampaignName") |> default_if_missing(),
      utm_content: row.dimensions |> Map.fetch!("sessionManualAdContent") |> default_if_missing(),
      utm_term: row.dimensions |> Map.fetch!("sessionGoogleAdsKeyword") |> default_if_missing(),
      visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
      visits: row.metrics |> Map.fetch!("sessions") |> parse_number(),
      pageviews: row.metrics |> Map.fetch!("screenPageViews") |> parse_number(),
      bounces: row.metrics |> Map.fetch!("bounces") |> parse_number(),
      visit_duration: row.metrics |> Map.fetch!("userEngagementDuration") |> parse_number()
    }
  end

  defp new_from_report(site_id, import_id, "imported_pages", row) do
    %{
      site_id: site_id,
      import_id: import_id,
      date: get_date(row),
      hostname: row.dimensions |> Map.fetch!("hostName") |> String.replace_prefix("www.", ""),
      page: row.dimensions |> Map.fetch!("pagePath") |> URI.parse() |> Map.get(:path),
      visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
      visits: row.metrics |> Map.fetch!("sessions") |> parse_number(),
      pageviews: row.metrics |> Map.fetch!("screenPageViews") |> parse_number(),
      # NOTE: no exits metric in GA4 API currently
      exits: 0,
      total_time_on_page: row.metrics |> Map.fetch!("userEngagementDuration") |> parse_number(),
      total_time_on_page_visits: row.metrics |> Map.fetch!("sessions") |> parse_number()
    }
  end

  defp new_from_report(site_id, import_id, "imported_entry_pages", row) do
    %{
      site_id: site_id,
      import_id: import_id,
      date: get_date(row),
      entry_page: row.dimensions |> Map.fetch!("landingPage"),
      visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
      entrances: row.metrics |> Map.fetch!("sessions") |> parse_number(),
      visit_duration: row.metrics |> Map.fetch!("userEngagementDuration") |> parse_number(),
      pageviews: row.metrics |> Map.fetch!("screenPageViews") |> parse_number(),
      bounces: row.metrics |> Map.fetch!("bounces") |> parse_number()
    }
  end

  # NOTE: no exit pages metrics in GA4 API available for now
  # defp new_from_report(site_id, import_id, "imported_exit_pages", row) do
  #   %{
  #     site_id: site_id,
  #     import_id: import_id,
  #     date: get_date(row),
  #     exit_page: Map.fetch!(row.dimensions, "exitPage"),
  #     visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
  #     exits: row.metrics |> Map.fetch!("sessions") |> parse_number(),
  #     visit_duration: row.metrics |> Map.fetch!("userEngagementDuration") |> parse_number(),
  #     pageviews: row.metrics |> Map.fetch!("screenPageViews") |> parse_number(),
  #     bounces: row.metrics |> Map.fetch!("bounces") |> parse_number()
  #   }
  # end

  defp new_from_report(site_id, import_id, "imported_custom_events", row) do
    %{
      site_id: site_id,
      import_id: import_id,
      date: get_date(row),
      name: row.dimensions |> Map.fetch!("eventName") |> maybe_override_event_name(),
      link_url: row.dimensions |> Map.fetch!("linkUrl"),
      visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
      events: row.metrics |> Map.fetch!("eventCount") |> parse_number()
    }
  end

  defp new_from_report(site_id, import_id, "imported_locations", row) do
    country_code = row.dimensions |> Map.fetch!("countryId") |> default_if_missing("")
    city_name = row.dimensions |> Map.fetch!("city") |> default_if_missing("")
    city_data = Location.get_city(city_name, country_code)

    %{
      site_id: site_id,
      import_id: import_id,
      date: get_date(row),
      country: country_code,
      region: row.dimensions |> Map.fetch!("region") |> default_if_missing(""),
      city: city_data && city_data.id,
      visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
      visits: row.metrics |> Map.fetch!("sessions") |> parse_number(),
      pageviews: row.metrics |> Map.fetch!("screenPageViews") |> parse_number(),
      bounces: row.metrics |> Map.fetch!("bounces") |> parse_number(),
      visit_duration: row.metrics |> Map.fetch!("userEngagementDuration") |> parse_number()
    }
  end

  defp new_from_report(site_id, import_id, "imported_devices", row) do
    %{
      site_id: site_id,
      import_id: import_id,
      date: get_date(row),
      device: row.dimensions |> Map.fetch!("deviceCategory") |> String.capitalize(),
      visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
      visits: row.metrics |> Map.fetch!("sessions") |> parse_number(),
      pageviews: row.metrics |> Map.fetch!("screenPageViews") |> parse_number(),
      bounces: row.metrics |> Map.fetch!("bounces") |> parse_number(),
      visit_duration: row.metrics |> Map.fetch!("userEngagementDuration") |> parse_number()
    }
  end

  @browser_google_to_plausible %{
    "User-Agent:Opera" => "Opera",
    "Mozilla Compatible Agent" => "Mobile App",
    "Android Webview" => "Mobile App",
    "Android Browser" => "Mobile App",
    "Safari (in-app)" => "Mobile App",
    "User-Agent: Mozilla" => "Firefox",
    "(not set)" => ""
  }

  defp new_from_report(site_id, import_id, "imported_browsers", row) do
    browser = Map.fetch!(row.dimensions, "browser")

    %{
      site_id: site_id,
      import_id: import_id,
      date: get_date(row),
      browser: Map.get(@browser_google_to_plausible, browser, browser),
      # Does not exist in GA4 API
      browser_version: nil,
      visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
      visits: row.metrics |> Map.fetch!("sessions") |> parse_number(),
      pageviews: row.metrics |> Map.fetch!("screenPageViews") |> parse_number(),
      bounces: row.metrics |> Map.fetch!("bounces") |> parse_number(),
      visit_duration: row.metrics |> Map.fetch!("userEngagementDuration") |> parse_number()
    }
  end

  @os_google_to_plausible %{
    "Macintosh" => "Mac",
    "Linux" => "GNU/Linux",
    "(not set)" => ""
  }

  defp new_from_report(site_id, import_id, "imported_operating_systems", row) do
    os = Map.fetch!(row.dimensions, "operatingSystem")

    %{
      site_id: site_id,
      import_id: import_id,
      date: get_date(row),
      operating_system: Map.get(@os_google_to_plausible, os, os),
      operating_system_version: row.dimensions |> Map.fetch!("operatingSystemVersion"),
      visitors: row.metrics |> Map.fetch!("totalUsers") |> parse_number(),
      visits: row.metrics |> Map.fetch!("sessions") |> parse_number(),
      pageviews: row.metrics |> Map.fetch!("screenPageViews") |> parse_number(),
      bounces: row.metrics |> Map.fetch!("bounces") |> parse_number(),
      visit_duration: row.metrics |> Map.fetch!("userEngagementDuration") |> parse_number()
    }
  end

  defp get_date(%{dimensions: %{"date" => date}}) do
    date
    |> Timex.parse!("%Y%m%d", :strftime)
    |> NaiveDateTime.to_date()
  end

  defp default_if_missing(value, default \\ nil)
  defp default_if_missing(value, default) when value in @missing_values, do: default
  defp default_if_missing(value, _default), do: value

  defp parse_source(nil), do: nil
  defp parse_source("(direct)"), do: nil
  defp parse_source("google"), do: "Google"
  defp parse_source("bing"), do: "Bing"
  defp parse_source("duckduckgo"), do: "DuckDuckGo"

  defp parse_source(ref) do
    Plausible.Ingestion.Source.parse("https://" <> ref)
  end
end
```

## File: `lib/plausible/imported/import_sources.ex`
```
defmodule Plausible.Imported.ImportSources do
  @moduledoc """
  Definitions of import sources.
  """

  @sources [
    Plausible.Imported.GoogleAnalytics4,
    Plausible.Imported.UniversalAnalytics,
    Plausible.Imported.NoopImporter,
    Plausible.Imported.CSVImporter
  ]

  @sources_map Map.new(@sources, &{&1.name(), &1})

  @source_names Enum.map(@sources, & &1.name())

  @spec names() :: [atom()]
  def names(), do: @source_names

  @spec by_name(atom()) :: module()
  def by_name(name) do
    Map.fetch!(@sources_map, name)
  end
end
```

## File: `lib/plausible/imported/importer.ex`
```
defmodule Plausible.Imported.Importer do
  @moduledoc """
  Behaviour that should be implemented for each import source.

  All imports are executed as background jobs run via `Plausible.Workers.ImportAnalytics`
  Oban worker. Each import source must define a module conforming `Importer` behaviour.

  The callbacks that need to be implemented:

  * `name/0` - Returns import source name as an atom. Example: `:universal_analytics`.
  * `label/0` - Descriptive, display friendly name of the source.
    Example: "Google Analytics".
  * `email_template/0` - Name of the email template to use for notifications in
    `PlausibleWeb.Email` (`import_success` and `import_failure`). The template
    should have content customized for a particular source.
  * `parse_args/1` - Receives Oban job arguments coming from `new_import/3`. Whatever
    options were passed to `new_import/3` will be present in the input map with string
    keys and values serialized to primitives. If, for instance `start_date: ~D[2024-01-03]`
    is passed as an option, `parse_args/1` receives `%{..., "start_date" => "2024-01-03"}`.
    The expectation is parsing the map values producing a keyword list of options to
    pass to `import_data/2`.
  * `import_data/2` - Receives site import struct and options produced by `parse_args/1`.
    This is where all the import processing is done. The way the import is implemented
    is entirely arbitrary except the requirement that the process as a whole must
    by synchronous. The callback is expected to return either `:ok` or `{:ok, %{...}}`
    on successful import or `{:error, ...}` on failure. The map in success tuple is
    used for updating site import struct and is passed to `on_success/2` callback.
    Please note that error tuple should be only returned on errors that can't be
    recovered from. For transient errors, the import should throw an exception or
    simply crash. The error tuple has an alternative `{error, reason, opts}` form,
    where `opts` allow to skip purging imported data so far via `skip_purge?` flag
    and skip marking the import as failed and notifying the user via `skip_mark_failed?`
    flag. Both flags are booleans.
  * `before_start/2` - Optional callback run right before scheduling import job. It's
    expected to either return `{:ok, site_import}` for the import to proceed
    or `{:error, ...}` tuple, which will be returned from `new_import/3` call.
    The `site_import` can be altered or replaced at this stage. The second argument
    are opts passed to `new_import/3`.
  * `on_success/2` - Optional callback run once site import is completed. Receives map
    returned from `import_data/2`. Expected to always return `:ok`.
  * `on_failure/1` - Optional callback run when import job fails permanently.

  All sources must be added to the list in `Plausible.Imported.ImportSources`.

  In order to schedule a new import job using a given source, respective importer's
  `new_import/3` function must be called. It accepts site, user who is doing the import
  and any options necessary to carry out the import.

  There's an expectation that `start_date` and `end_date` are provided either as options
  passed to `new_import/3` or data in map returned from `import_data/2`. If these parameters
  are not provided, the import will eventually crash. These parameters define time range
  of imported data which is in turn used for efficient querying.

  Logic running inside `import_data/2` is expected to populated all `imported_*` tables
  in ClickHouse with `import_id` column set to site import's ID.

  Managing any configuration or authentication prior to running import is outside of
  scope of importer logic and is expected to be implemented separately.

  ## Running import fully synchronously

  In case it's necessary to run the whole import job fully synchronously, the
  `Plausible.Workers.ImportAnalytics` worker sends an `Oban.Notifier` message
  on completion, failure or transient failure of the import.

  A basic usage scenario looks like this:

  ```elixir
  {:ok, job} = Plausible.Imported.NoopImporter.new_import(
    site,
    user,
    start_date: ~D[2005-01-01],
    end_date: Date.utc_today(),
    # this option is necessary to setup the calling process as listener
    listen?: true
  )

  import_id = job.args[:import_id]

  receive do
    {:notification, :analytics_imports_jobs, %{"event" => "complete", "import_id" => ^import_id}} ->
      IO.puts("Job completed")

    {:notification, :analytics_imports_jobs, %{"event" => "transient_fail", "import_id" => ^import_id}} ->
      IO.puts("Job failed transiently")

    {:notification, :analytics_imports_jobs, %{"event" => "fail", "import_id" => ^import_id}} ->
      IO.puts("Job failed permanently")
  after
    15_000 ->
      IO.puts("Job didn't finish in 15 seconds")
  end
  ```

  In a more realistic scenario, job scheduling will be done inside a GenServer process
  like LiveView, where notifications can be listened for via `handle_info/2`.
  """

  alias Plausible.Imported
  alias Plausible.Imported.SiteImport
  alias Plausible.Repo

  @callback name() :: atom()
  @callback label() :: String.t()
  @callback email_template() :: String.t()
  @callback parse_args(map()) :: Keyword.t()
  @callback import_data(SiteImport.t(), Keyword.t()) ::
              :ok | {:error, any()} | {:error, any(), Keyword.t()}
  @callback before_start(SiteImport.t(), Keyword.t()) :: {:ok, SiteImport.t()} | {:error, any()}
  @callback on_success(SiteImport.t(), map()) :: :ok
  @callback on_failure(SiteImport.t()) :: :ok

  defmacro __using__(_opts) do
    quote do
      @behaviour Plausible.Imported.Importer

      @spec new_import(Plausible.Site.t(), Plausible.Auth.User.t(), Keyword.t()) ::
              {:ok, Oban.Job.t()} | {:error, Ecto.Changeset.t() | :import_in_progress | any()}
      def new_import(site, user, opts) do
        Plausible.Imported.Importer.new_import(name(), site, user, opts, &before_start/2)
      end

      @doc false
      @spec run_import(SiteImport.t(), map()) :: {:ok, SiteImport.t()} | {:error, :any}
      def run_import(site_import, args) do
        Plausible.Imported.Importer.run_import(
          site_import,
          args,
          &parse_args/1,
          &import_data/2,
          &on_success/2
        )
      end

      @doc false
      @spec mark_failed(SiteImport.t()) :: SiteImport.t()
      def mark_failed(site_import) do
        site_import =
          site_import
          |> SiteImport.fail_changeset()
          |> Repo.update!()

        :ok = on_failure(site_import)

        site_import
      end

      @impl true
      def before_start(site_import, _opts), do: {:ok, site_import}

      @impl true
      def on_success(_site_import, _extra_data), do: :ok

      @impl true
      def on_failure(_site_import), do: :ok

      defoverridable before_start: 2, on_success: 2, on_failure: 1
    end
  end

  @doc false
  def new_import(source, site, user, opts, before_start_fun) do
    import_params =
      opts
      |> Keyword.take([:label, :start_date, :end_date, :legacy])
      |> Keyword.put(:source, source)
      |> Map.new()

    Repo.transaction(fn ->
      result =
        site
        |> SiteImport.create_changeset(user, import_params)
        |> Repo.insert()

      with {:ok, site_import} <- result,
           {:ok, site_import} <- before_start_fun.(site_import, opts),
           {:ok, job} <- schedule_job(site_import, opts) do
        job
      else
        {:error, error} ->
          Repo.rollback(error)
      end
    end)
  end

  @doc false
  def run_import(site_import, args, parse_args_fun, import_fun, on_success_fun) do
    site_import =
      site_import
      |> SiteImport.start_changeset()
      |> Repo.update!()
      |> Repo.preload(:site)

    import_opts = parse_args_fun.(args)

    case import_fun.(site_import, import_opts) do
      :ok ->
        {:ok, mark_complete(site_import, %{}, on_success_fun)}

      {:ok, extra_data} ->
        {:ok, mark_complete(site_import, extra_data, on_success_fun)}

      {:error, error} ->
        {:error, error, []}

      {:error, error, opts} ->
        {:error, error, opts}
    end
  end

  @oban_channel :analytics_imports_jobs

  @doc false
  def notify(site_import, event) do
    Oban.Notifier.notify(Oban, @oban_channel, %{
      "event" => event,
      "import_id" => site_import.id,
      "site_id" => site_import.site_id
    })
  end

  @doc """
  Allows to explicitly start listening for importer job notifications.

  Listener must explicitly filter out a subset of imports that apply to the given context.
  """
  @spec listen() :: :ok
  def listen() do
    :ok = Oban.Notifier.listen([@oban_channel])
  end

  defp schedule_job(site_import, opts) do
    {listen?, opts} = Keyword.pop(opts, :listen?, false)
    {job_opts, opts} = Keyword.pop(opts, :job_opts, [])

    if listen? do
      :ok = listen()
    end

    if not Imported.other_imports_in_progress?(site_import) do
      opts
      |> Keyword.put(:import_id, site_import.id)
      |> Map.new()
      |> Plausible.Workers.ImportAnalytics.new(job_opts)
      |> Oban.insert()
    else
      {:error, :import_in_progress}
    end
  end

  defp mark_complete(site_import, extra_data, on_success_fun) do
    site_import =
      site_import
      |> SiteImport.complete_changeset(extra_data)
      |> Repo.update!()

    :ok = on_success_fun.(site_import, extra_data)

    site_import
  end
end
```

## File: `lib/plausible/imported/location.ex`
```
defmodule Plausible.Imported.Location do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_locations" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :country, :string
    field :region, :string
    field :city, Ch, type: "UInt64"
    field :visitors, Ch, type: "UInt64"
    field :visits, Ch, type: "UInt64"
    field :visit_duration, Ch, type: "UInt64"
    field :pageviews, Ch, type: "UInt64"
    field :bounces, Ch, type: "UInt32"
  end
end
```

## File: `lib/plausible/imported/noop_importer.ex`
```
defmodule Plausible.Imported.NoopImporter do
  @moduledoc """
  Stub import implementation.
  """

  use Plausible.Imported.Importer

  @impl true
  def name(), do: :noop

  @impl true
  def label(), do: "Noop"

  # reusing existing template from another source
  @impl true
  def email_template(), do: "google_analytics_import.html"

  @impl true
  def parse_args(opts), do: opts

  @impl true
  def import_data(_site_import, %{"error" => true}), do: {:error, "Something went wrong"}
  def import_data(_site_import, %{"crash" => true}), do: raise("boom")
  def import_data(_site_import, _opts), do: :ok

  @impl true
  def before_start(site_import, _opts) do
    send(self(), {:before_start, site_import.id})

    {:ok, site_import}
  end

  @impl true
  def on_success(site_import, _extra_data) do
    send(self(), {:on_success, site_import.id})

    :ok
  end

  @impl true
  def on_failure(site_import) do
    send(self(), {:on_failure, site_import.id})

    :ok
  end
end
```

## File: `lib/plausible/imported/operating_system.ex`
```
defmodule Plausible.Imported.OperatingSystem do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_operating_systems" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :operating_system, :string
    field :operating_system_version, :string
    field :visitors, Ch, type: "UInt64"
    field :visits, Ch, type: "UInt64"
    field :visit_duration, Ch, type: "UInt64"
    field :pageviews, Ch, type: "UInt64"
    field :bounces, Ch, type: "UInt32"
  end
end
```

## File: `lib/plausible/imported/page.ex`
```
defmodule Plausible.Imported.Page do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_pages" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :hostname, :string
    field :page, :string
    field :visits, Ch, type: "UInt64"
    field :visitors, Ch, type: "UInt64"
    field :pageviews, Ch, type: "UInt64"
    field :exits, Ch, type: "UInt64"
    field :total_scroll_depth, Ch, type: "UInt64"
    field :total_scroll_depth_visits, Ch, type: "UInt64"
    field :total_time_on_page, Ch, type: "UInt64"
    field :total_time_on_page_visits, Ch, type: "UInt64"
  end
end
```

## File: `lib/plausible/imported/site_import.ex`
```
defmodule Plausible.Imported.SiteImport do
  @moduledoc """
  Site import schema.
  """

  use Ecto.Schema

  import Ecto.Changeset

  alias Plausible.Auth.User
  alias Plausible.Imported.ImportSources
  alias Plausible.Site

  @statuses [:pending, :importing, :completed, :failed]

  @type t() :: %__MODULE__{}

  schema "site_imports" do
    field :start_date, :date
    field :end_date, :date
    field :label, :string
    field :source, Ecto.Enum, values: ImportSources.names()
    field :status, Ecto.Enum, values: @statuses
    field :legacy, :boolean, default: false
    field :has_scroll_depth, :boolean, default: false

    belongs_to :site, Site
    belongs_to :imported_by, User

    timestamps()
  end

  for status <- @statuses do
    defmacro unquote(status)(), do: unquote(status)
  end

  @spec label(t()) :: String.t()
  def label(%{source: source, label: label}) do
    build_label(ImportSources.by_name(source).label(), label)
  end

  @spec create_changeset(Site.t(), User.t(), map()) :: Ecto.Changeset.t()
  def create_changeset(site, user, params) do
    %__MODULE__{}
    |> cast(params, [:label, :source, :start_date, :end_date, :legacy])
    |> validate_required([:source])
    |> put_assoc(:site, site)
    |> put_assoc(:imported_by, user)
    |> put_change(:status, pending())
  end

  @spec start_changeset(t()) :: Ecto.Changeset.t()
  def start_changeset(site_import) do
    site_import
    |> change(status: importing())
  end

  @spec complete_changeset(t(), map()) :: Ecto.Changeset.t()
  def complete_changeset(site_import, params \\ %{}) do
    site_import
    |> cast(params, [:start_date, :end_date])
    |> put_change(:status, completed())
    |> validate_required([:start_date, :end_date])
  end

  @spec fail_changeset(t()) :: Ecto.Changeset.t()
  def fail_changeset(site_import) do
    change(site_import, status: failed())
  end

  defp build_label(source, nil), do: source
  defp build_label(source, label), do: "#{source} (#{label})"
end
```

## File: `lib/plausible/imported/source.ex`
```
defmodule Plausible.Imported.Source do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_sources" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :source, :string
    field :channel, Ch, type: "LowCardinality(String)"
    field :referrer, :string
    field :utm_source, :string
    field :utm_medium, :string
    field :utm_campaign, :string
    field :utm_content, :string
    field :utm_term, :string
    field :visitors, Ch, type: "UInt64"
    field :visits, Ch, type: "UInt64"
    field :visit_duration, Ch, type: "UInt64"
    field :pageviews, Ch, type: "UInt64"
    field :bounces, Ch, type: "UInt32"
  end
end
```

## File: `lib/plausible/imported/universal_analytics.ex`
```
defmodule Plausible.Imported.UniversalAnalytics do
  @moduledoc """
  Import implementation for Universal Analytics.

  NOTE: As importing from UA is no longer supported, this module
  is only used to support rendering existing imports.
  """

  use Plausible.Imported.Importer

  @impl true
  def name(), do: :universal_analytics

  @impl true
  def label(), do: "Google Analytics"

  @impl true
  def email_template(), do: "google_analytics_import.html"

  @impl true
  def parse_args(_args) do
    raise "Importing data not supported"
  end

  @impl true
  def import_data(_site_import, _opts) do
    raise "Importing data not supported"
  end
end
```

## File: `lib/plausible/imported/visitor.ex`
```
defmodule Plausible.Imported.Visitor do
  @moduledoc false
  use Ecto.Schema

  @primary_key false
  schema "imported_visitors" do
    field :site_id, Ch, type: "UInt64"
    field :import_id, Ch, type: "UInt64"
    field :date, :date
    field :visitors, Ch, type: "UInt64"
    field :pageviews, Ch, type: "UInt64"
    field :bounces, Ch, type: "UInt64"
    field :visits, Ch, type: "UInt64"
    field :visit_duration, Ch, type: "UInt64"
  end
end
```

## File: `lib/plausible/ingest_repo.ex`
```
defmodule Plausible.IngestRepo do
  @moduledoc """
  Write-centric Clickhouse access interface
  """

  use Ecto.Repo,
    otp_app: :plausible,
    adapter: Ecto.Adapters.ClickHouse

  defmacro __using__(_) do
    quote do
      alias Plausible.IngestRepo
      import Ecto
      import Ecto.Query, only: [from: 1, from: 2]
    end
  end

  def clustered_table?(table) do
    replica_count(table) > 1
  end

  def replica_count(table) do
    {:ok, %{rows: [[count]]}} =
      query("SELECT sum(active_replicas) FROM system.replicas WHERE table = '#{table}'")

    count
  end
end
```

## File: `lib/plausible/ingestion/acquisition.ex`
```
defmodule Plausible.Ingestion.Acquisition do
  @moduledoc """
  This module is responsible for figuring out acquisition channel from event referrer_source.

  Acquisition channel is the marketing channel where people come from and convert and help
  users to understand and improve their marketing flow.

  Note it uses priv/ga4-source-categories.csv as a source, which comes from https://support.google.com/analytics/answer/9756891?hl=en.

  Notable differences from GA4 that have been implemented just for Plausible:
  1. The @custom_source_categories module attribute contains a list of custom source categories that we have manually
  added based on our own judgement and user feedback. For example we treat AI tools (ChatGPT, Perplexity) as search engines.
  2. Google is in a privileged position to analyze paid traffic from within their own network. The biggest use-case is auto-tagged adwords campaigns.
  We do our best by categorizing as paid search when source is Google and the url has `gclid` parameter. Same for source Bing and `msclkid` url parameter.
  3. The @paid_sources module attribute in Plausible.Ingestion.Source contains a list of utm_sources that we will automatically categorize as paid traffic
  regardless of the medium. Examples are `yt-ads`, `facebook_ad`, `adwords`, etc. See also: Plausible.Ingestion.Source.paid_source?/1
  """

  @external_resource "priv/ga4-source-categories.csv"
  @custom_source_categories [
    {"hacker news", "SOURCE_CATEGORY_SOCIAL"},
    {"yahoo!", "SOURCE_CATEGORY_SEARCH"},
    {"gmail", "SOURCE_CATEGORY_EMAIL"},
    {"telegram", "SOURCE_CATEGORY_SOCIAL"},
    {"slack", "SOURCE_CATEGORY_SOCIAL"},
    {"producthunt", "SOURCE_CATEGORY_SOCIAL"},
    {"github", "SOURCE_CATEGORY_SOCIAL"},
    {"steamcommunity.com", "SOURCE_CATEGORY_SOCIAL"},
    {"statics.teams.cdn.office.net", "SOURCE_CATEGORY_SOCIAL"},
    {"vkontakte", "SOURCE_CATEGORY_SOCIAL"},
    {"threads", "SOURCE_CATEGORY_SOCIAL"},
    {"ecosia", "SOURCE_CATEGORY_SEARCH"},
    {"perplexity", "SOURCE_CATEGORY_SEARCH"},
    {"brave", "SOURCE_CATEGORY_SEARCH"},
    {"chatgpt.com", "SOURCE_CATEGORY_SEARCH"},
    {"temu.com", "SOURCE_CATEGORY_SHOPPING"},
    {"discord", "SOURCE_CATEGORY_SOCIAL"},
    {"sogou", "SOURCE_CATEGORY_SEARCH"},
    {"microsoft teams", "SOURCE_CATEGORY_SOCIAL"}
  ]
  @source_categories Application.app_dir(:plausible, "priv/ga4-source-categories.csv")
                     |> File.read!()
                     |> NimbleCSV.RFC4180.parse_string(skip_headers: false)
                     |> Enum.map(fn [source, category] -> {source, category} end)
                     |> then(&(@custom_source_categories ++ &1))
                     |> Enum.into(%{})

  def source_categories(), do: @source_categories

  def get_channel(source, utm_medium, utm_campaign, utm_source, click_id_param) do
    get_channel_lowered(
      String.downcase(source || ""),
      String.downcase(utm_medium || ""),
      String.downcase(utm_campaign || ""),
      String.downcase(utm_source || ""),
      click_id_param
    )
  end

  defp get_channel_lowered(source, utm_medium, utm_campaign, utm_source, click_id_param) do
    cond do
      cross_network?(utm_campaign) -> "Cross-network"
      paid_shopping?(source, utm_campaign, utm_medium) -> "Paid Shopping"
      paid_search?(source, utm_medium, utm_source, click_id_param) -> "Paid Search"
      paid_social?(source, utm_medium, utm_source) -> "Paid Social"
      paid_video?(source, utm_medium, utm_source) -> "Paid Video"
      display?(utm_medium) -> "Display"
      paid_other?(utm_medium) -> "Paid Other"
      organic_shopping?(source, utm_campaign) -> "Organic Shopping"
      organic_social?(source, utm_medium) -> "Organic Social"
      organic_video?(source, utm_medium) -> "Organic Video"
      search_source?(source) -> "Organic Search"
      email?(source, utm_source, utm_medium) -> "Email"
      affiliates?(utm_medium) -> "Affiliates"
      audio?(utm_medium) -> "Audio"
      sms?(utm_source, utm_medium) -> "SMS"
      mobile_push_notifications?(source, utm_medium) -> "Mobile Push Notifications"
      referral?(source, utm_medium) -> "Referral"
      true -> "Direct"
    end
  end

  defp cross_network?(utm_campaign) do
    String.contains?(utm_campaign, "cross-network")
  end

  defp paid_shopping?(source, utm_campaign, utm_medium) do
    (shopping_source?(source) or shopping_campaign?(utm_campaign)) and paid_medium?(utm_medium)
  end

  defp paid_search?(source, utm_medium, utm_source, click_id_param) do
    (search_source?(source) and paid_medium?(utm_medium)) or
      (search_source?(source) and paid_source?(utm_source)) or
      (source == "google" and click_id_param == "gclid") or
      (source == "bing" and click_id_param == "msclkid")
  end

  defp paid_social?(source, utm_medium, utm_source) do
    (social_source?(source) and paid_medium?(utm_medium)) or
      (social_source?(source) and paid_source?(utm_source))
  end

  defp paid_video?(source, utm_medium, utm_source) do
    (video_source?(source) and paid_medium?(utm_medium)) or
      (video_source?(source) and paid_source?(utm_source))
  end

  defp display?(utm_medium) do
    utm_medium in [
      "display",
      "banner",
      "expandable",
      "interstitial",
      "cpm"
    ]
  end

  defp paid_other?(utm_medium) do
    paid_medium?(utm_medium)
  end

  defp organic_shopping?(source, utm_campaign) do
    shopping_source?(source) or shopping_campaign?(utm_campaign)
  end

  defp organic_social?(source, utm_medium) do
    social_source?(source) or
      utm_medium in [
        "social",
        "social-network",
        "social-media",
        "sm",
        "social network",
        "social media"
      ]
  end

  defp organic_video?(source, utm_medium) do
    video_source?(source) or String.contains?(utm_medium, "video")
  end

  defp referral?(source, utm_medium) do
    utm_medium in ["referral", "app", "link"] or source !== ""
  end

  @email_tags ["email", "e-mail", "e_mail", "e mail", "newsletter"]
  defp email?(source, utm_source, utm_medium) do
    email_source?(source) or
      String.contains?(utm_source, @email_tags) or
      String.contains?(utm_medium, @email_tags)
  end

  defp affiliates?(utm_medium) do
    utm_medium == "affiliate"
  end

  defp audio?(utm_medium) do
    utm_medium == "audio"
  end

  defp sms?(utm_source, utm_medium) do
    utm_source == "sms" or utm_medium == "sms"
  end

  defp mobile_push_notifications?(source, utm_medium) do
    String.ends_with?(utm_medium, "push") or
      String.contains?(utm_medium, ["mobile", "notification"]) or
      source == "firebase"
  end

  defp shopping_source?(source) do
    @source_categories[source] == "SOURCE_CATEGORY_SHOPPING"
  end

  defp search_source?(source) do
    @source_categories[source] == "SOURCE_CATEGORY_SEARCH"
  end

  defp social_source?(source) do
    @source_categories[source] == "SOURCE_CATEGORY_SOCIAL"
  end

  defp video_source?(source) do
    @source_categories[source] == "SOURCE_CATEGORY_VIDEO"
  end

  defp email_source?(source) do
    @source_categories[source] == "SOURCE_CATEGORY_EMAIL"
  end

  defp shopping_campaign?(utm_campaign) do
    Regex.match?(~r/^(.*(([^a-df-z]|^)shop|shopping).*)$/, utm_campaign)
  end

  defp paid_medium?(utm_medium) do
    Regex.match?(~r/^(.*cp.*|ppc|retargeting|paid.*)$/, utm_medium)
  end

  defp paid_source?(utm_source) do
    Plausible.Ingestion.Source.paid_source?(utm_source)
  end
end
```

## File: `lib/plausible/ingestion/city_overrides.ex`
```
defmodule Plausible.Ingestion.CityOverrides do
  @moduledoc false

  @overrides %{
    # Austria
    # Gemeindebezirk Floridsdorf -> Vienna
    2_779_467 => 2_761_369,
    # Gemeindebezirk Leopoldstadt -> Vienna
    2_772_614 => 2_761_369,
    # Gemeindebezirk Landstrasse -> Vienna
    2_773_040 => 2_761_369,
    # Gemeindebezirk Donaustadt -> Vienna
    2_780_851 => 2_761_369,
    # Gemeindebezirk Favoriten -> Vienna
    2_779_776 => 2_761_369,
    # Gemeindebezirk Währing -> Vienna
    2_762_091 => 2_761_369,
    # Gemeindebezirk Wieden -> Vienna
    2_761_393 => 2_761_369,
    # Gemeindebezirk Innere Stadt -> Vienna
    2_775_259 => 2_761_369,
    # Gemeindebezirk Alsergrund -> Vienna
    2_782_729 => 2_761_369,
    # Gemeindebezirk Liesing -> Vienna
    2_772_484 => 2_761_369,
    # Urfahr -> Linz
    2_762_518 => 2_772_400,

    # Canada
    # Old Toronto -> Toronto
    8_436_019 => 6_167_865,
    # Etobicoke -> Toronto
    5_950_267 => 6_167_865,
    # East York -> Toronto
    5_946_235 => 6_167_865,
    # Scarborough -> Toronto
    6_948_711 => 6_167_865,
    # North York -> Toronto
    6_091_104 => 6_167_865,

    # Czech republic
    # Praha 5 -> Prague
    11_951_220 => 3_067_696,
    # Praha 4 -> Prague
    11_951_218 => 3_067_696,
    # Praha 11 -> Prague
    11_951_232 => 3_067_696,
    # Praha 10 -> Prague
    11_951_210 => 3_067_696,
    # Praha 4 -> Prague
    8_378_772 => 3_067_696,

    # Denmark
    # København SV -> Copenhagen
    11_747_123 => 2_618_425,
    # København NV -> Copenhagen
    11_746_894 => 2_618_425,
    # Odense S -> Odense
    11_746_825 => 2_615_876,
    # Odense M -> Odense
    11_746_974 => 2_615_876,
    # Odense SØ -> Odense
    11_746_888 => 2_615_876,
    # Aarhus C -> Aarhus
    11_746_746 => 2_624_652,
    # Aarhus N -> Aarhus
    11_746_890 => 2_624_652,

    # Estonia
    # Kristiine linnaosa -> Tallinn
    11_050_530 => 588_409,
    # Kesklinna linnaosa -> Tallinn
    11_053_706 => 588_409,
    # Lasnamäe linnaosa -> Tallinn
    11_050_526 => 588_409,
    # Põhja-Tallinna linnaosa -> Tallinn
    11_049_594 => 588_409,
    # Mustamäe linnaosa -> Tallinn
    11_050_531 => 588_409,
    # Haabersti linnaosa -> Tallinn
    11_053_707 => 588_409,
    # Viimsi -> Tallinn
    587_629 => 588_409,

    # Germany
    # Bezirk Tempelhof-Schöneberg -> Berlin
    3_336_297 => 2_950_159,
    # Bezirk Mitte -> Berlin
    2_870_912 => 2_950_159,
    # Bezirk Charlottenburg-Wilmersdorf -> Berlin
    3_336_294 => 2_950_159,
    # Bezirk Friedrichshain-Kreuzberg -> Berlin
    3_336_295 => 2_950_159,
    # Moosach -> Munich
    8_351_447 => 2_867_714,
    # Schwabing-Freimann -> Munich
    8_351_448 => 2_867_714,
    # Stadtbezirk 06 -> Düsseldorf
    6_947_276 => 2_934_246,
    # Stadtbezirk 04 -> Düsseldorf
    6_947_274 => 2_934_246,
    # Köln-Ehrenfeld -> Köln
    6_947_479 => 2_886_242,
    # Köln-Lindenthal- -> Köln
    6_947_481 => 2_886_242,
    # Beuel -> Bonn
    2_949_619 => 2_946_447,
    # Innenstadt I -> Frankfurt am Main
    6_946_225 => 2_925_533,
    # Innenstadt II -> Frankfurt am Main
    6_946_226 => 2_925_533,
    # Innenstadt III -> Frankfurt am Main
    6_946_227 => 2_925_533,

    # India
    # Navi Mumbai -> Mumbai
    6_619_347 => 1_275_339,

    # Mexico
    # Miguel Hidalgo Villa Olímpica -> Mexico city
    11_561_026 => 3_530_597,
    # Zedec Santa Fe -> Mexico city
    3_517_471 => 3_530_597,
    #  Fuentes del Pedregal-> Mexico city
    11_562_596 => 3_530_597,
    #  Centro -> Mexico city
    9_179_691 => 3_530_597,
    #  Cuauhtémoc-> Mexico city
    12_266_959 => 3_530_597,

    # Netherlands
    # Schiphol-Rijk -> Amsterdam
    10_173_838 => 2_759_794,
    # Westpoort -> Amsterdam
    11_525_047 => 2_759_794,
    # Amsterdam-Zuidoost -> Amsterdam
    6_544_881 => 2_759_794,
    # Loosduinen -> The Hague
    11_525_037 => 2_747_373,
    # Laak -> The Hague
    11_525_042 => 2_747_373,

    # Norway
    # Nordre Aker District -> Oslo
    6_940_981 => 3_143_244,

    # Romania
    # Sector 1 -> Bucharest,
    11_055_041 => 683_506,
    # Sector 2 -> Bucharest
    11_055_040 => 683_506,
    # Sector 3 -> Bucharest
    11_055_044 => 683_506,
    # Sector 4 -> Bucharest
    11_055_042 => 683_506,
    # Sector 5 -> Bucharest
    11_055_043 => 683_506,
    # Sector 6 -> Bucharest
    11_055_039 => 683_506,
    # Bucuresti -> Bucharest
    6_691_781 => 683_506,

    # Slovakia
    # Bratislava -> Bratislava
    3_343_955 => 3_060_972,

    # Sweden
    # Södermalm -> Stockholm
    2_676_209 => 2_673_730,

    # Switzerland
    # Vorstädte -> Basel
    11_789_440 => 2_661_604,
    # Zürich (Kreis 11) / Oerlikon -> Zürich
    2_659_310 => 2_657_896,
    # Zürich (Kreis 3) / Alt-Wiedikon -> Zürich
    2_658_007 => 2_657_896,
    # Zürich (Kreis 5) -> Zürich
    6_295_521 => 2_657_896,
    # Zürich (Kreis 1) / Hochschulen -> Zürich
    6_295_489 => 2_657_896,

    # UK
    # Shadwell -> London
    6_690_595 => 2_643_743,
    # City of London -> London
    2_643_741 => 2_643_743,
    # South Bank -> London
    6_545_251 => 2_643_743,
    # Soho -> London
    6_545_173 => 2_643_743,
    # Whitechapel -> London
    2_634_112 => 2_643_743,
    # King's Cross -> London
    6_690_589 => 2_643_743,
    # Poplar -> London
    2_640_091 => 2_643_743,
    # Hackney -> London
    2_647_694 => 2_643_743
  }
  def get(key, default), do: Map.get(@overrides, key, default)
end
```

## File: `lib/plausible/ingestion/counters.ex`
```
defmodule Plausible.Ingestion.Counters do
  @moduledoc """
  This is instrumentation necessary for keeping track of per-domain
  internal metrics. Due to metric labels cardinality (domain x metric_name),
  these statistics are not suitable for prometheus/grafana exposure,
  hence an internal storage is used.

  The module installs `Counters.TelemetryHandler` and periodically
  flushes the internal counter aggregates via `Counters.Buffer` interface.

  The underlying database schema is running `SummingMergeTree` engine.
  To take advantage of automatic roll-ups it provides, upon dispatching the
  buffered records to Clickhouse this module transforms each `event_timebucket`
  aggregate into a 1-minute resolution.

  Clickhouse connection is set to insert counters asynchronously every time
  a pool checkout is made. Those properties are reverted once the insert is done
  (or naturally, if the connection crashes).
  """

  @behaviour :gen_cycle

  require Logger

  alias Plausible.Ingestion.Counters.Buffer
  alias Plausible.Ingestion.Counters.Record
  alias Plausible.Ingestion.Counters.TelemetryHandler
  alias Plausible.AsyncInsertRepo

  @interval :timer.seconds(10)

  @spec child_spec(Keyword.t()) :: Supervisor.child_spec() | :ignore
  def child_spec(opts) do
    buffer_name = Keyword.get(opts, :buffer_name, __MODULE__)

    %{
      id: buffer_name,
      start: {:gen_cycle, :start_link, [{:local, buffer_name}, __MODULE__, opts]}
    }
  end

  @spec enabled?() :: boolean()
  def enabled?() do
    Application.fetch_env!(:plausible, __MODULE__)[:enabled] == true
  end

  @impl true
  def init_cycle(opts) do
    Process.flag(:trap_exit, true)
    buffer_name = Keyword.get(opts, :buffer_name, __MODULE__)
    force_start? = Keyword.get(opts, :force_start?, false)

    if enabled?() or force_start? do
      buffer = Buffer.new(buffer_name, opts)
      :ok = TelemetryHandler.install(buffer)

      interval = Keyword.get(opts, :interval, @interval)

      {:ok, {interval, buffer}}
    else
      :ignore
    end
  end

  @impl true
  def handle_cycle(buffer, now \\ DateTime.utc_now()) do
    case Buffer.flush(buffer, now) do
      [] ->
        :noop

      records ->
        records =
          Enum.map(records, fn {bucket, metric, domain, tracker_script_version, value} ->
            %{
              event_timebucket: to_0_minute_datetime(bucket),
              metric: metric,
              site_id: Plausible.Site.Cache.get_site_id(domain),
              domain: domain,
              tracker_script_version: tracker_script_version,
              value: value
            }
          end)

        try do
          {_, _} = AsyncInsertRepo.insert_all(Record, records)
        catch
          _, thrown ->
            Sentry.capture_message(
              "Caught an error when trying to flush ingest counters.",
              extra: %{
                number_of_records: Enum.count(records),
                error: inspect(thrown)
              }
            )
        end
    end

    {:continue_hibernated, buffer}
  end

  @impl true
  def handle_info(:stop, _state) do
    {:stop, :normal}
  end

  def handle_info(_msg, state) do
    {:continue, state}
  end

  @impl true
  def terminate(_reason, buffer) do
    # we'll travel in time to flush everything regardless of current bucket completion
    future = DateTime.utc_now() |> DateTime.add(60, :second)
    handle_cycle(buffer, future)
    :ok
  end

  @spec stop(pid()) :: :ok
  def stop(pid) do
    send(pid, :stop)
    :ok
  end

  defp to_0_minute_datetime(unix_ts) when is_integer(unix_ts) do
    unix_ts
    |> DateTime.from_unix!()
    |> DateTime.truncate(:second)
    |> Map.replace(:second, 0)
  end
end
```

## File: `lib/plausible/ingestion/counters/buffer.ex`
```
defmodule Plausible.Ingestion.Counters.Buffer do
  @moduledoc """
  A buffer aggregating counters for internal metrics, within 10 seconds time buckets.

  See `Plausible.Ingestion.Counters` for integration.

  Flushing is by default possible only once the 10s bucket is complete
  (its window has moved). This is to avoid race conditions
  when clearing up the buffer on dequeue - because there is no atomic "get and delete",
  and items are buffered concurrently, there is a gap between get and delete
  in which items written may disappear otherwise.

  `aggregate_bucket_fn` and `flush_boundary_fn` control that semantics and
  are configurable only for test purposes.
  """

  defstruct [:buffer_name, :aggregate_bucket_fn, :flush_boundary_fn]

  alias Plausible.Ingestion.Counters.Record

  @type t() :: %__MODULE__{}
  @type unix_timestamp() :: pos_integer()
  @type bucket_fn_opt() ::
          {:aggregate_bucket_fn, (NaiveDateTime.t() -> unix_timestamp())}
          | {:flush_boundary_fn, (DateTime.t() -> unix_timestamp())}

  @ets_opts [
    :public,
    :ordered_set,
    :named_table,
    write_concurrency: true
  ]

  @spec new(atom(), [bucket_fn_opt()]) :: t()
  def new(buffer_name, opts \\ []) do
    ^buffer_name = :ets.new(buffer_name, @ets_opts)

    aggregate_bucket_fn = Keyword.get(opts, :aggregate_bucket_fn, &bucket_10s/1)
    flush_boundary_fn = Keyword.get(opts, :flush_boundary_fn, &previous_10s/1)

    %__MODULE__{
      buffer_name: buffer_name,
      aggregate_bucket_fn: aggregate_bucket_fn,
      flush_boundary_fn: flush_boundary_fn
    }
  end

  @spec aggregate(
          t(),
          binary(),
          binary(),
          timestamp :: NaiveDateTime.t(),
          tracker_script_version :: integer()
        ) :: t()
  def aggregate(
        %__MODULE__{buffer_name: buffer_name, aggregate_bucket_fn: bucket_fn} = buffer,
        metric,
        domain,
        timestamp,
        tracker_script_version
      ) do
    bucket =
      bucket_fn.(timestamp)

    :ets.update_counter(
      buffer_name,
      {bucket, metric, domain, tracker_script_version},
      {2, 1},
      {{bucket, metric, domain, tracker_script_version}, 0}
    )

    buffer
  end

  @spec flush(t(), now :: DateTime.t()) :: [Record.t()]
  def flush(
        %__MODULE__{buffer_name: buffer_name, flush_boundary_fn: flush_boundary_fn},
        now \\ DateTime.utc_now()
      ) do
    boundary = flush_boundary_fn.(now)

    match = {{:"$1", :"$2", :"$3", :"$4"}, :"$5"}
    guard = {:"=<", :"$1", boundary}
    select = {{:"$1", :"$2", :"$3", :"$4", :"$5"}}

    match_specs_read = [{match, [guard], [select]}]
    match_specs_delete = [{match, [guard], [true]}]

    case :ets.select(buffer_name, match_specs_read) do
      [] ->
        []

      data ->
        :ets.select_delete(buffer_name, match_specs_delete)
        data
    end
  end

  @spec bucket_10s(NaiveDateTime.t()) :: unix_timestamp()
  def bucket_10s(datetime) do
    datetime
    |> DateTime.from_naive!("Etc/UTC")
    |> DateTime.truncate(:second)
    |> Map.replace(:second, div(datetime.second, 10) * 10)
    |> DateTime.to_unix()
  end

  @spec previous_10s(DateTime.t()) :: unix_timestamp()
  def previous_10s(datetime) do
    datetime
    |> DateTime.add(-10, :second)
    |> DateTime.to_unix()
  end
end
```

## File: `lib/plausible/ingestion/counters/record.ex`
```
defmodule Plausible.Ingestion.Counters.Record do
  @moduledoc """
  Clickhouse schema for storing ingest counter metrics
  """
  use Ecto.Schema

  @type t() :: %__MODULE__{}

  @primary_key false
  schema "ingest_counters" do
    field :event_timebucket, :utc_datetime
    field :site_id, Ch, type: "Nullable(UInt64)"
    field :domain, Ch, type: "LowCardinality(String)"
    field :metric, Ch, type: "LowCardinality(String)"
    field :value, Ch, type: "UInt64"
    field :tracker_script_version, Ch, type: "UInt16"
  end
end
```

## File: `lib/plausible/ingestion/counters/telemetry_handler.ex`
```
defmodule Plausible.Ingestion.Counters.TelemetryHandler do
  @moduledoc """
  Subscribes to telemetry events emitted by `Plausible.Ingestion.Event`.
  Every time a request derived event is either dispatched to clickhouse or dropped,
  a telemetry event is emitted respectively. That event is captured here,
  its metadata is extracted and sent for internal stats aggregation via
  `Counters.Buffer` interface.
  """
  alias Plausible.Ingestion.Counters
  alias Plausible.Ingestion.Event

  @event_dropped Event.telemetry_event_dropped()
  @event_buffered Event.telemetry_event_buffered()

  @telemetry_events [@event_dropped, @event_buffered]
  @telemetry_handler &__MODULE__.handle_event/4

  @spec install(Counters.Buffer.t()) :: :ok
  def install(%Counters.Buffer{buffer_name: buffer_name} = buffer) do
    :ok =
      :telemetry.attach_many(
        "ingest-counters-#{buffer_name}",
        @telemetry_events,
        @telemetry_handler,
        buffer
      )
  end

  @spec handle_event([atom()], any(), map(), Counters.Buffer.t()) :: :ok
  def handle_event(
        @event_dropped,
        _measurements,
        %{
          domain: domain,
          reason: reason,
          request_timestamp: timestamp,
          tracker_script_version: tracker_script_version
        },
        buffer
      ) do
    Counters.Buffer.aggregate(
      buffer,
      "dropped_#{reason}",
      domain,
      timestamp,
      tracker_script_version
    )

    :ok
  end

  def handle_event(
        @event_buffered,
        _measurements,
        %{
          domain: domain,
          request_timestamp: timestamp,
          tracker_script_version: tracker_script_version
        },
        buffer
      ) do
    Counters.Buffer.aggregate(buffer, "buffered", domain, timestamp, tracker_script_version)
    :ok
  end
end
```

## File: `lib/plausible/ingestion/event.ex`
```
defmodule Plausible.Ingestion.Event do
  @moduledoc """
  This module exposes the `build_and_buffer/1` function capable of
  turning %Plausible.Ingestion.Request{} into a series of events that in turn
  are uniformly either buffered in batches (to Clickhouse) or dropped
  (e.g. due to spam blocklist) from the processing pipeline.
  """
  use Plausible
  alias Plausible.Ingestion.Request
  alias Plausible.ClickhouseEventV2
  alias Plausible.Site.GateKeeper

  defstruct domain: nil,
            site: nil,
            clickhouse_event_attrs: %{},
            clickhouse_session_attrs: %{},
            clickhouse_event: nil,
            dropped?: false,
            drop_reason: nil,
            request: nil,
            salts: nil,
            changeset: nil

  @verification_user_agent Plausible.InstallationSupport.user_agent()

  @type drop_reason() ::
          :bot
          | :spam_referrer
          | GateKeeper.policy()
          | :invalid
          | :dc_ip
          | :site_ip_blocklist
          | :site_country_blocklist
          | :site_page_blocklist
          | :site_hostname_allowlist
          | :verification_agent
          | :lock_timeout
          | :no_session_for_engagement

  @type t() :: %__MODULE__{
          domain: String.t() | nil,
          site: %Plausible.Site{} | nil,
          clickhouse_event_attrs: map(),
          clickhouse_session_attrs: map(),
          clickhouse_event: %ClickhouseEventV2{} | nil,
          dropped?: boolean(),
          drop_reason: drop_reason(),
          request: Request.t(),
          salts: map(),
          changeset: %Ecto.Changeset{}
        }

  @spec build_and_buffer(Request.t(), Keyword.t()) :: {:ok, %{buffered: [t()], dropped: [t()]}}
  def build_and_buffer(%Request{domains: domains} = request, context \\ []) do
    processed_events =
      if spam_referrer?(request) do
        for domain <- domains, do: drop(new(domain, request), :spam_referrer)
      else
        Enum.reduce(domains, [], fn domain, acc ->
          # credo:disable-for-next-line Credo.Check.Refactor.Nesting
          case GateKeeper.check(domain) do
            {:allow, site} ->
              processed =
                domain
                |> new(site, request)
                |> process_unless_dropped(pipeline(), context)

              [processed | acc]

            {:deny, reason} ->
              [drop(new(domain, request), reason) | acc]
          end
        end)
      end

    {dropped, buffered} = Enum.split_with(processed_events, & &1.dropped?)
    {:ok, %{dropped: dropped, buffered: buffered}}
  end

  @spec telemetry_event_buffered() :: [atom()]
  def telemetry_event_buffered() do
    [:plausible, :ingest, :event, :buffered]
  end

  @spec telemetry_event_dropped() :: [atom()]
  def telemetry_event_dropped() do
    [:plausible, :ingest, :event, :dropped]
  end

  @spec telemetry_pipeline_step_duration() :: [atom()]
  def telemetry_pipeline_step_duration() do
    [:plausible, :ingest, :pipeline, :step]
  end

  @spec telemetry_ua_parse_timeout() :: [atom()]
  def telemetry_ua_parse_timeout() do
    [:plausible, :ingest, :user_agent_parse, :timeout]
  end

  @spec emit_telemetry_ua_parse_timeout() :: :ok
  def emit_telemetry_ua_parse_timeout() do
    :telemetry.execute(telemetry_ua_parse_timeout(), %{}, %{})
  end

  @spec emit_telemetry_buffered(t()) :: :ok
  def emit_telemetry_buffered(event) do
    :telemetry.execute(telemetry_event_buffered(), %{}, %{
      domain: event.domain,
      request_timestamp: event.request.timestamp,
      tracker_script_version: event.request.tracker_script_version
    })
  end

  @spec emit_telemetry_dropped(t(), drop_reason()) :: :ok
  def emit_telemetry_dropped(event, reason) do
    :telemetry.execute(
      telemetry_event_dropped(),
      %{},
      %{
        domain: event.domain,
        reason: reason,
        request_timestamp: event.request.timestamp,
        tracker_script_version: event.request.tracker_script_version
      }
    )
  end

  defp pipeline() do
    [
      drop_verification_agent: &drop_verification_agent/2,
      drop_datacenter_ip: &drop_datacenter_ip/2,
      drop_shield_rule_hostname: &drop_shield_rule_hostname/2,
      drop_shield_rule_page: &drop_shield_rule_page/2,
      drop_shield_rule_ip: &drop_shield_rule_ip/2,
      put_geolocation: &put_geolocation/2,
      drop_shield_rule_country: &drop_shield_rule_country/2,
      put_user_agent: &put_user_agent/2,
      put_basic_info: &put_basic_info/2,
      put_source_info: &put_source_info/2,
      maybe_infer_medium: &maybe_infer_medium/2,
      put_props: &put_props/2,
      put_revenue: &put_revenue/2,
      put_salts: &put_salts/2,
      put_user_id: &put_user_id/2,
      validate_clickhouse_event: &validate_clickhouse_event/2,
      register_session: &register_session/2,
      write_to_buffer: &write_to_buffer/2
    ]
  end

  defp process_unless_dropped(%__MODULE__{} = initial_event, pipeline, context) do
    Enum.reduce_while(pipeline, initial_event, fn {step_name, step_fn}, acc_event ->
      Plausible.PromEx.Plugins.PlausibleMetrics.measure_duration(
        telemetry_pipeline_step_duration(),
        fn -> execute_step(step_fn, acc_event, context) end,
        %{step: "#{step_name}"}
      )
    end)
  end

  defp execute_step(step_fn, acc_event, context) do
    case step_fn.(acc_event, context) do
      %__MODULE__{dropped?: true} = dropped -> {:halt, dropped}
      %__MODULE__{dropped?: false} = event -> {:cont, event}
    end
  end

  defp new(domain, request) do
    struct!(__MODULE__, domain: domain, request: request)
  end

  defp new(domain, site, request) do
    struct!(__MODULE__, domain: domain, site: site, request: request)
  end

  defp drop(%__MODULE__{} = event, reason, attrs \\ []) do
    fields =
      attrs
      |> Keyword.put(:dropped?, true)
      |> Keyword.put(:drop_reason, reason)

    emit_telemetry_dropped(event, reason)
    struct!(event, fields)
  end

  defp update_event_attrs(%__MODULE__{} = event, %{} = attrs) do
    struct!(event, clickhouse_event_attrs: Map.merge(event.clickhouse_event_attrs, attrs))
  end

  defp update_session_attrs(%__MODULE__{} = event, %{} = attrs) do
    struct!(event, clickhouse_session_attrs: Map.merge(event.clickhouse_session_attrs, attrs))
  end

  defp drop_verification_agent(%__MODULE__{} = event, _context) do
    case event.request.user_agent do
      @verification_user_agent ->
        drop(event, :verification_agent)

      _ ->
        event
    end
  end

  defp drop_datacenter_ip(%__MODULE__{} = event, _context) do
    case event.request.ip_classification do
      "dc_ip" ->
        drop(event, :dc_ip)

      _any ->
        event
    end
  end

  defp drop_shield_rule_ip(%__MODULE__{} = event, _context) do
    if Plausible.Shields.ip_blocked?(event.domain, event.request.remote_ip) do
      drop(event, :site_ip_blocklist)
    else
      event
    end
  end

  defp drop_shield_rule_hostname(%__MODULE__{} = event, _context) do
    if Plausible.Shields.hostname_allowed?(event.domain, event.request.hostname) do
      event
    else
      drop(event, :site_hostname_allowlist)
    end
  end

  defp drop_shield_rule_page(%__MODULE__{} = event, _context) do
    if Plausible.Shields.page_blocked?(event.domain, event.request.pathname) do
      drop(event, :site_page_blocklist)
    else
      event
    end
  end

  defp put_user_agent(%__MODULE__{} = event, _context) do
    case parse_user_agent(event.request) do
      {:ok, %UAInspector.Result{client: %UAInspector.Result.Client{name: "Headless Chrome"}}} ->
        drop(event, :bot)

      {:ok, %UAInspector.Result.Bot{}} ->
        drop(event, :bot)

      {:ok, %UAInspector.Result{} = user_agent} ->
        update_session_attrs(event, %{
          operating_system: os_name(user_agent),
          operating_system_version: os_version(user_agent),
          browser: browser_name(user_agent),
          browser_version: browser_version(user_agent),
          screen_size: screen_size(user_agent)
        })

      _any ->
        event
    end
  end

  defp put_basic_info(%__MODULE__{} = event, _context) do
    update_event_attrs(event, %{
      domain: event.domain,
      site_id: event.site.id,
      timestamp: event.request.timestamp,
      name: event.request.event_name,
      hostname: event.request.hostname,
      pathname: event.request.pathname,
      scroll_depth: event.request.scroll_depth,
      engagement_time: event.request.engagement_time,
      interactive?: event.request.interactive?
    })
  end

  defp put_source_info(%__MODULE__{} = event, _context) do
    query_params = event.request.query_params

    tagged_source =
      query_params["utm_source"] ||
        query_params["source"] ||
        query_params["ref"]

    update_session_attrs(event, %{
      referrer_source: Plausible.Ingestion.Source.resolve(event.request),
      referrer: Plausible.Ingestion.Source.format_referrer(event.request),
      click_id_param: get_click_id_param(event.request.query_params),
      utm_source: tagged_source,
      utm_medium: query_params["utm_medium"],
      utm_campaign: query_params["utm_campaign"],
      utm_content: query_params["utm_content"],
      utm_term: query_params["utm_term"]
    })
  end

  defp maybe_infer_medium(%__MODULE__{} = event, _context) do
    inferred_medium =
      case event.clickhouse_session_attrs do
        %{utm_medium: medium} when is_binary(medium) -> medium
        %{utm_medium: nil, referrer_source: "Google", click_id_param: "gclid"} -> "(gclid)"
        %{utm_medium: nil, referrer_source: "Bing", click_id_param: "msclkid"} -> "(msclkid)"
        _ -> nil
      end

    update_session_attrs(event, %{utm_medium: inferred_medium})
  end

  defp put_geolocation(%__MODULE__{} = event, _context) do
    case event.request.ip_classification do
      "anonymous_vpn_ip" ->
        update_session_attrs(event, %{country_code: "A1"})

      _any ->
        result = Plausible.Ingestion.Geolocation.lookup(event.request.remote_ip) || %{}
        update_session_attrs(event, result)
    end
  end

  defp drop_shield_rule_country(
         %__MODULE__{domain: domain, clickhouse_session_attrs: %{country_code: cc}} = event,
         _context
       )
       when is_binary(domain) and is_binary(cc) do
    if Plausible.Shields.country_blocked?(domain, cc) do
      drop(event, :site_country_blocklist)
    else
      event
    end
  end

  defp drop_shield_rule_country(%__MODULE__{} = event, _context), do: event

  defp put_props(%__MODULE__{request: %{props: %{} = props}} = event, _context) do
    # defensive: ensuring the keys/values are always in the same order
    {keys, values} = Enum.unzip(props)

    update_event_attrs(event, %{
      "meta.key": keys,
      "meta.value": values
    })
  end

  defp put_props(%__MODULE__{} = event, _context), do: event

  defp put_revenue(event, _context) do
    on_ee do
      attrs = Plausible.Ingestion.Event.Revenue.get_revenue_attrs(event)
      update_event_attrs(event, attrs)
    else
      event
    end
  end

  defp put_salts(%__MODULE__{} = event, _context) do
    %{event | salts: Plausible.Session.Salts.fetch()}
  end

  defp put_user_id(%__MODULE__{} = event, _context) do
    update_event_attrs(event, %{
      user_id:
        generate_user_id(
          event.request,
          event.domain,
          event.clickhouse_event_attrs.hostname,
          event.salts.current
        )
    })
  end

  defp validate_clickhouse_event(%__MODULE__{} = event, _context) do
    clickhouse_event =
      event
      |> Map.fetch!(:clickhouse_event_attrs)
      |> ClickhouseEventV2.new()

    case Ecto.Changeset.apply_action(clickhouse_event, nil) do
      {:ok, valid_clickhouse_event} ->
        %{event | clickhouse_event: valid_clickhouse_event}

      {:error, changeset} ->
        drop(event, :invalid, changeset: changeset)
    end
  end

  defp register_session(%__MODULE__{} = event, context) do
    write_buffer_insert =
      Keyword.get(context, :session_write_buffer_insert, &Plausible.Session.WriteBuffer.insert/1)

    previous_user_id =
      generate_user_id(
        event.request,
        event.domain,
        event.clickhouse_event.hostname,
        event.salts.previous
      )

    session_result =
      Plausible.Session.CacheStore.on_event(
        event.clickhouse_event,
        event.clickhouse_session_attrs,
        previous_user_id,
        buffer_insert: write_buffer_insert
      )

    case session_result do
      {:ok, :no_session_for_engagement} ->
        drop(event, :no_session_for_engagement)

      {:error, :timeout} ->
        drop(event, :lock_timeout)

      {:ok, session} ->
        %{
          event
          | clickhouse_event: ClickhouseEventV2.merge_session(event.clickhouse_event, session)
        }
    end
  end

  defp write_to_buffer(%__MODULE__{clickhouse_event: clickhouse_event} = event, _context) do
    {:ok, _} = Plausible.Event.WriteBuffer.insert(clickhouse_event)
    emit_telemetry_buffered(event)
    event
  end

  @click_id_params ["gclid", "gbraid", "wbraid", "msclkid", "fbclid", "twclid"]

  defp get_click_id_param(nil), do: nil

  defp get_click_id_param(query_params) do
    @click_id_params
    |> Enum.find(fn param_name -> Map.has_key?(query_params, param_name) end)
  end

  @parse_user_agent_timeout 200
  defp parse_user_agent(%Request{user_agent: user_agent}) when is_binary(user_agent) do
    Plausible.Cache.Adapter.fetch(:user_agents, user_agent, fn ->
      parse_user_agent_safe(user_agent)
    end)
  end

  defp parse_user_agent(request), do: request

  defp parse_user_agent_safe(user_agent) do
    task =
      Task.Supervisor.async_nolink(
        {:via, PartitionSupervisor, {Plausible.UserAgentParseTaskSupervisor, self()}},
        fn ->
          UAInspector.parse(user_agent)
        end
      )

    case Task.yield(task, @parse_user_agent_timeout) || Task.shutdown(task) do
      {:ok, result} ->
        {:ok, result}

      nil ->
        emit_telemetry_ua_parse_timeout()
        {:error, :timeout}
    end
  end

  defp browser_name(ua) do
    case ua.client do
      :unknown -> ""
      %UAInspector.Result.Client{name: "Mobile Safari"} -> "Safari"
      %UAInspector.Result.Client{name: "Chrome Mobile"} -> "Chrome"
      %UAInspector.Result.Client{name: "Chrome Mobile iOS"} -> "Chrome"
      %UAInspector.Result.Client{name: "Firefox Mobile"} -> "Firefox"
      %UAInspector.Result.Client{name: "Firefox Mobile iOS"} -> "Firefox"
      %UAInspector.Result.Client{name: "Opera Mobile"} -> "Opera"
      %UAInspector.Result.Client{name: "Opera Mini"} -> "Opera"
      %UAInspector.Result.Client{name: "Opera Mini iOS"} -> "Opera"
      %UAInspector.Result.Client{name: "Yandex Browser Lite"} -> "Yandex Browser"
      %UAInspector.Result.Client{name: "Chrome Webview"} -> "Mobile App"
      %UAInspector.Result.Client{type: "mobile app"} -> "Mobile App"
      client -> client.name
    end
  end

  @mobile_types [
    "smartphone",
    "feature phone",
    "portable media player",
    "phablet",
    "wearable",
    "camera"
  ]
  @tablet_types ["car browser", "tablet"]
  @desktop_types ["tv", "console", "desktop"]
  alias UAInspector.Result.Device

  defp screen_size(ua) do
    case ua.device do
      %Device{type: t} when t in @mobile_types ->
        "Mobile"

      %Device{type: t} when t in @tablet_types ->
        "Tablet"

      %Device{type: t} when t in @desktop_types ->
        "Desktop"

      _ ->
        nil
    end
  end

  defp browser_version(ua) do
    case ua.client do
      :unknown -> ""
      %UAInspector.Result.Client{type: "mobile app"} -> ""
      client -> major_minor(client.version)
    end
  end

  defp os_name(ua) do
    case ua.os do
      :unknown -> ""
      os -> os.name
    end
  end

  defp os_version(ua) do
    case ua.os do
      :unknown -> ""
      os -> major_minor(os.version)
    end
  end

  defp major_minor(version) do
    case version do
      :unknown ->
        ""

      version ->
        version
        |> String.split(".")
        |> Enum.take(2)
        |> Enum.join(".")
    end
  end

  defp generate_user_id(request, domain, hostname, salt) do
    cond do
      is_nil(salt) ->
        nil

      is_nil(domain) ->
        nil

      true ->
        user_agent = request.user_agent || ""
        root_domain = get_root_domain(hostname)

        SipHash.hash!(salt, user_agent <> request.remote_ip <> domain <> root_domain)
    end
  end

  defp get_root_domain("(none)"), do: "(none)"

  defp get_root_domain(hostname) do
    case :inet.parse_ipv4_address(String.to_charlist(hostname)) do
      {:ok, _} ->
        hostname

      {:error, :einval} ->
        PublicSuffix.registrable_domain(hostname) || hostname
    end
  end

  defp spam_referrer?(%Request{referrer: referrer}) when is_binary(referrer) do
    URI.parse(referrer).host
    |> Request.sanitize_hostname()
    |> ReferrerBlocklist.is_spammer?()
  end

  defp spam_referrer?(_), do: false
end
```

## File: `lib/plausible/ingestion/geolocation.ex`
```
defmodule Plausible.Ingestion.Geolocation do
  @moduledoc false

  def lookup(ip_address) do
    case Plausible.Geo.lookup(ip_address) do
      %{} = entry ->
        country_code =
          entry
          |> get_in(["country", "iso_code"])
          |> ignore_unknown_country()

        city_geoname_id = country_code && get_in(entry, ["city", "geoname_id"])
        city_geoname_id = Plausible.Ingestion.CityOverrides.get(city_geoname_id, city_geoname_id)

        %{
          country_code: country_code,
          subdivision1_code: subdivision1_code(country_code, entry),
          subdivision2_code: subdivision2_code(country_code, entry),
          city_geoname_id: city_geoname_id
        }

      nil ->
        nil
    end
  end

  defp subdivision1_code(country_code, %{"subdivisions" => [%{"iso_code" => iso_code} | _rest]})
       when not is_nil(country_code) do
    country_code <> "-" <> iso_code
  end

  defp subdivision1_code(_, _), do: nil

  defp subdivision2_code(country_code, %{
         "subdivisions" => [_first, %{"iso_code" => iso_code} | _rest]
       })
       when not is_nil(country_code) do
    country_code <> "-" <> iso_code
  end

  defp subdivision2_code(_, _), do: nil

  @ignored_countries [
    # Worldwide
    "ZZ",
    # Disputed territory
    "XX",
    # Tor exit node
    "T1"
  ]
  defp ignore_unknown_country(code) when code in @ignored_countries, do: nil
  defp ignore_unknown_country(country), do: country
end
```

## File: `lib/plausible/ingestion/request.ex`
```
defmodule Plausible.Ecto.EventName do
  @moduledoc """
    Custom type for event name. Accepts Strings and Integers and stores them as String. Returns
    cast error if any other type is provided. Accepting integers is important for 404 tracking.
  """

  use Ecto.Type
  def type, do: :string

  def cast(val) when is_binary(val), do: {:ok, val}
  def cast(val) when is_integer(val), do: {:ok, Integer.to_string(val)}

  def cast(_), do: :error
  def load(val), do: {:ok, val}
  def dump(val), do: {:ok, val}
end

defmodule Plausible.Ingestion.Request do
  @moduledoc """
  The %Plausible.Ingestion.Request{} struct stores all needed fields
  to create an event downstream. Pre-eliminary validation is made
  to detect user errors early.
  """

  use Ecto.Schema
  use Plausible
  alias Ecto.Changeset

  @max_url_size 2_000
  @missing_scroll_depth 255
  @missing_engagement_time 0

  # :KLUDGE: Old version of tracker script sent huge values for engagement time. Ignore
  # these while users might still have the old script cached.
  @too_large_engagement_time :timer.hours(30 * 24)

  @blank_engagement_error_message "engagement event requires a valid integer value for at least one of 'sd' or 'e' fields"

  def too_large_engagement_time(), do: @too_large_engagement_time
  def blank_engagement_error_message(), do: @blank_engagement_error_message

  @primary_key false
  embedded_schema do
    field :remote_ip, :string
    field :user_agent, :string
    field :event_name, Plausible.Ecto.EventName
    field :uri, :map
    field :hostname, :string
    field :referrer, :string
    field :domains, {:array, :string}
    field :ip_classification, :string
    field :hash_mode, :integer
    field :pathname, :string
    field :props, :map
    field :scroll_depth, :integer
    field :engagement_time, :integer
    field :tracker_script_version, :integer, default: 0
    field :interactive?, :boolean, default: true

    on_ee do
      field :revenue_source, :map
    end

    field :query_params, :map

    field :timestamp, :naive_datetime
  end

  @type t() :: %__MODULE__{}

  @spec build(Plug.Conn.t(), NaiveDateTime.t()) :: {:ok, t()} | {:error, Changeset.t()}
  @doc """
  Builds and initially validates %Plausible.Ingestion.Request{} struct from %Plug.Conn{}.
  """
  def build(%Plug.Conn{} = conn, now \\ NaiveDateTime.utc_now()) do
    changeset =
      %__MODULE__{}
      |> Changeset.change()
      |> Changeset.put_change(
        :timestamp,
        NaiveDateTime.truncate(now, :second)
      )

    case parse_body(conn) do
      {:ok, request_body} ->
        changeset
        |> put_ip_classification(conn)
        |> put_remote_ip(conn)
        |> put_uri(request_body)
        |> put_hostname()
        |> put_user_agent(conn)
        |> put_request_params(request_body)
        |> put_referrer(request_body)
        |> put_pathname()
        |> put_props(request_body)
        |> put_engagement_fields(request_body)
        |> put_query_params()
        |> put_revenue_source(request_body)
        |> put_interactive(request_body)
        |> put_tracker_script_version(request_body)
        |> map_domains(request_body)
        |> Changeset.validate_required([
          :event_name,
          :hostname,
          :pathname,
          :timestamp
        ])
        |> Changeset.validate_length(:event_name, max: 120)
        |> Changeset.apply_action(nil)

      {:error, :invalid_json} ->
        {:error, Changeset.add_error(changeset, :request, "Unable to parse request body as json")}
    end
  end

  on_ee do
    defp put_revenue_source(changeset, request_body) do
      Plausible.Ingestion.Request.Revenue.put_revenue_source(changeset, request_body)
    end
  else
    defp put_revenue_source(changeset, _request_body), do: changeset
  end

  defp put_remote_ip(changeset, conn) do
    Changeset.put_change(changeset, :remote_ip, PlausibleWeb.RemoteIP.get(conn))
  end

  defp parse_body(conn) do
    case conn.body_params do
      %Plug.Conn.Unfetched{} ->
        with max_length <- conn.assigns[:read_body_limit] || 1_000_000,
             {:ok, body, _conn} <-
               Plug.Conn.read_body(conn, length: max_length, read_length: max_length),
             {:ok, params} when is_map(params) <- Jason.decode(body) do
          {:ok, params}
        else
          _ -> {:error, :invalid_json}
        end

      params ->
        {:ok, params}
    end
  end

  defp put_request_params(changeset, %{} = request_body) do
    Changeset.cast(
      changeset,
      %{
        event_name: request_body["n"] || request_body["name"],
        hash_mode: request_body["h"] || request_body["hashMode"]
      },
      [:event_name, :hash_mode]
    )
  end

  defp put_referrer(changeset, %{} = request_body) do
    referrer = request_body["r"] || request_body["referrer"]

    if is_binary(referrer) do
      referrer = String.slice(referrer, 0..(@max_url_size - 1))
      Changeset.put_change(changeset, :referrer, referrer)
    else
      changeset
    end
  end

  defp put_pathname(changeset) do
    uri = Changeset.get_field(changeset, :uri)
    hash_mode = Changeset.get_field(changeset, :hash_mode)
    pathname = get_pathname(uri, hash_mode)
    Changeset.put_change(changeset, :pathname, pathname)
  end

  defp maybe_set_props_path_to_pathname(props_in_request, changeset) do
    if Plausible.Goals.SystemGoals.sync_props_path_with_pathname?(
         Changeset.get_field(changeset, :event_name),
         props_in_request
       ) do
      # "path" props is added to the head of the props enum to avoid it being cut off
      [{"path", Changeset.get_field(changeset, :pathname)}] ++ props_in_request
    else
      props_in_request
    end
  end

  defp map_domains(changeset, %{} = request_body) do
    raw = request_body["d"] || request_body["domain"]
    raw = if is_binary(raw), do: String.trim(raw)

    case raw do
      "" ->
        Changeset.add_error(changeset, :domain, "can't be blank")

      raw when is_binary(raw) ->
        domains =
          raw
          |> String.split(",")
          |> Enum.map(&sanitize_hostname/1)

        Changeset.put_change(changeset, :domains, domains)

      nil ->
        from_uri = sanitize_hostname(Changeset.get_field(changeset, :uri))

        if from_uri do
          Changeset.put_change(changeset, :domains, [from_uri])
        else
          Changeset.add_error(changeset, :domain, "can't be blank")
        end
    end
  end

  @disallowed_schemes ~w(data)
  defp put_uri(changeset, %{} = request_body) do
    with url when is_binary(url) <- request_body["u"] || request_body["url"],
         url when byte_size(url) <= @max_url_size <- url,
         %URI{} = uri when uri.scheme not in @disallowed_schemes <- URI.parse(url) do
      Changeset.put_change(changeset, :uri, uri)
    else
      nil -> Changeset.add_error(changeset, :url, "is required")
      %URI{} -> Changeset.add_error(changeset, :url, "scheme is not allowed")
      _ -> Changeset.add_error(changeset, :url, "must be a valid url")
    end
  end

  defp put_hostname(changeset) do
    host =
      case Changeset.get_field(changeset, :uri) do
        %{host: host} when is_binary(host) and host != "" -> sanitize_hostname(host)
        _ -> "(none)"
      end

    Changeset.put_change(changeset, :hostname, host)
  end

  @max_props 30
  defp put_props(changeset, %{} = request_body) do
    props =
      (request_body["m"] || request_body["meta"] || request_body["p"] || request_body["props"])
      |> Plausible.Helpers.JSON.decode_or_fallback()
      |> Enum.reduce([], &filter_bad_props/2)
      |> maybe_set_props_path_to_pathname(changeset)
      |> Enum.take(@max_props)
      |> Map.new()

    changeset
    |> Changeset.put_change(:props, props)
    |> validate_props()
  end

  defp put_interactive(changeset, %{} = request_body) do
    case request_body["i"] || request_body["interactive"] do
      interactive? when is_boolean(interactive?) ->
        Changeset.put_change(changeset, :interactive?, interactive?)

      _ ->
        changeset
    end
  end

  defp filter_bad_props({k, v}, acc) do
    cond do
      Enum.any?([k, v], &(is_list(&1) or is_map(&1))) -> acc
      Enum.any?([k, v], &(String.trim_leading(to_string(&1)) == "")) -> acc
      true -> [{to_string(k), to_string(v)} | acc]
    end
  end

  @max_prop_key_length Plausible.Props.max_prop_key_length()
  @max_prop_value_length Plausible.Props.max_prop_value_length()
  defp validate_props(changeset) do
    case Changeset.get_field(changeset, :props) do
      props ->
        Enum.reduce_while(props, changeset, fn
          {key, value}, changeset
          when byte_size(key) > @max_prop_key_length or
                 byte_size(value) > @max_prop_value_length ->
            {:halt,
             Changeset.add_error(
               changeset,
               :props,
               "keys should have at most #{@max_prop_key_length} bytes and values #{@max_prop_value_length} bytes"
             )}

          _, changeset ->
            {:cont, changeset}
        end)
    end
  end

  defp put_engagement_fields(changeset, %{} = request_body) do
    if Changeset.get_field(changeset, :event_name) == "engagement" do
      scroll_depth = parse_scroll_depth(request_body["sd"])
      engagement_time = parse_engagement_time(request_body["e"])

      case {scroll_depth, engagement_time} do
        {@missing_scroll_depth, @missing_engagement_time} ->
          changeset
          |> Changeset.add_error(
            :event_name,
            "engagement event requires a valid integer value for at least one of 'sd' or 'e' fields"
          )

        _ ->
          changeset
          |> Changeset.put_change(:scroll_depth, scroll_depth)
          |> Changeset.put_change(:engagement_time, engagement_time)
      end
    else
      changeset
    end
  end

  defp put_tracker_script_version(changeset, %{} = request_body) do
    case request_body["v"] do
      version when is_integer(version) ->
        Changeset.put_change(changeset, :tracker_script_version, version)

      _ ->
        changeset
    end
  end

  defp put_query_params(changeset) do
    case Changeset.get_field(changeset, :uri) do
      %{query: query} when is_binary(query) ->
        Changeset.put_change(changeset, :query_params, URI.decode_query(query))

      _any ->
        changeset
    end
  end

  defp put_ip_classification(changeset, %Plug.Conn{} = conn) do
    value =
      conn
      |> Plug.Conn.get_req_header("x-plausible-ip-type")
      |> List.first()

    Changeset.put_change(changeset, :ip_classification, value)
  end

  defp put_user_agent(changeset, %Plug.Conn{} = conn) do
    user_agent =
      conn
      |> Plug.Conn.get_req_header("user-agent")
      |> List.first()

    Changeset.put_change(changeset, :user_agent, user_agent)
  end

  defp get_pathname(nil, _hash_mode), do: "/"

  defp get_pathname(uri, hash_mode) do
    pathname =
      (uri.path || "/")
      |> URI.decode()
      |> String.trim_trailing()

    if hash_mode == 1 && uri.fragment do
      pathname <> "#" <> URI.decode(uri.fragment)
    else
      pathname
    end
  end

  @doc """
  Removes the "www" part of a hostname.
  """
  def sanitize_hostname(%URI{host: hostname}) do
    sanitize_hostname(hostname)
  end

  def sanitize_hostname(hostname) when is_binary(hostname) do
    hostname
    |> String.trim()
    |> String.replace_prefix("www.", "")
  end

  def sanitize_hostname(nil) do
    nil
  end

  defp parse_scroll_depth(sd) when is_binary(sd) do
    case Integer.parse(sd) do
      {sd_int, ""} -> parse_scroll_depth(sd_int)
      _ -> @missing_scroll_depth
    end
  end

  defp parse_scroll_depth(sd) when is_integer(sd) and sd >= 0 and sd <= 100, do: sd
  defp parse_scroll_depth(sd) when is_integer(sd) and sd > 100, do: 100
  defp parse_scroll_depth(_), do: @missing_scroll_depth

  defp parse_engagement_time(et) when is_binary(et) do
    case Integer.parse(et) do
      {et_int, ""} -> parse_engagement_time(et_int)
      _ -> @missing_engagement_time
    end
  end

  defp parse_engagement_time(et)
       when is_integer(et) and et >= 0 and et < @too_large_engagement_time,
       do: et

  defp parse_engagement_time(_), do: @missing_engagement_time
end

defimpl Jason.Encoder, for: URI do
  def encode(uri, _opts), do: [?", URI.to_string(uri), ?"]
end

defimpl Jason.Encoder, for: Plausible.Ingestion.Request do
  @fields Plausible.Ingestion.Request.__schema__(:fields)
  def encode(request, opts) do
    request
    |> Map.take(@fields)
    |> Jason.Encode.map(opts)
  end
end
```

## File: `lib/plausible/ingestion/source.ex`
```
defmodule Plausible.Ingestion.Source do
  @moduledoc """
  Resolves the `source` dimension from a combination of `referer` header and either `utm_source`, `source`, or `ref` query parameter.

  """
  alias Plausible.Ingestion.Request

  @external_resource "priv/custom_sources.json"
  @custom_sources Application.app_dir(:plausible, "priv/custom_sources.json")
                  |> File.read!()
                  |> Jason.decode!()

  @paid_sources Map.keys(@custom_sources)
                |> Enum.filter(&String.ends_with?(&1, ["ads", "ad"]))
                |> then(&["adwords" | &1])
                |> MapSet.new()

  @external_resource "priv/ref_inspector/referers.yml"
  @referers_yaml Application.app_dir(:plausible, "priv/ref_inspector/referers.yml")

  yaml_reader = RefInspector.Config.yaml_file_reader()
  {:ok, db} = RefInspector.Database.Loader.load(@referers_yaml, yaml_reader)
  db = RefInspector.Database.Parser.parse(db)

  lookup =
    Enum.reduce(db, Map.new(), fn {_, entries}, lookup ->
      Enum.reduce(entries, lookup, fn {_, _, _, _, _, _, name}, lookup_inner ->
        Map.put(lookup_inner, String.downcase(name), name)
      end)
    end)

  lookup =
    Enum.reduce(@custom_sources, lookup, fn {key, val}, lookup ->
      lookup
      |> Map.put(key, val)
      |> Map.put(String.downcase(val), val)
    end)

  for {k, v} <- Enum.sort(lookup) do
    def src(unquote(k)), do: unquote(v)
  end

  def src(_), do: nil

  def paid_sources() do
    @paid_sources |> MapSet.to_list()
  end

  def paid_source?(source) do
    MapSet.member?(@paid_sources, source)
  end

  @doc """
  Resolves the source of a session based on query params and the `Referer` header.

  When a query parameter like `utm_source` is present, it will be prioritized over the `Referer` header. When the URL does not contain a source tag, we fall
  back to using `Referer` to determine the source. This module also takes care of certain transformations to make the data more useful for the user:
  1. The RefInspector library is used to categorize referrers into "known" sources. For example, when the referrer is google.com or google.co.uk,
  it will always be stored as "Google" which is more useful for marketers.
  2. On top of the standard RefInspector behaviour, we also keep a list of `custom_sources.json` which extends it with referrers that we have seen in the wild.
  For example, Wikipedia has many domains that need to be combined into a single known source. These could all in theory be [upstreamed](https://github.com/snowplow-referer-parser/referer-parser).
  3. When a known source is supplied in utm_source (or source, ref) query parameter, we merge it with our known sources in a case-insensitive manner.
  4. Our list of `custom_sources.json` also contains some commonly used utm_source shorthands for certain sources. URL tagging is a mess, and we can never do it
  perfectly, but at least we're making an effort for the most commonly used ones. For example, `ig -> Instagram` and `adwords -> Google`.
  """
  def resolve(request) do
    tagged_source =
      request.query_params["utm_source"] ||
        request.query_params["source"] ||
        request.query_params["ref"]

    source =
      cond do
        tagged_source -> tagged_source
        has_valid_referral?(request) -> parse(request.referrer)
        true -> nil
      end

    find_mapping(source)
  end

  def parse(ref) do
    case RefInspector.parse(ref).source do
      :unknown ->
        uri = URI.parse(String.trim(ref))
        format_referrer_host(uri)

      source ->
        source
    end
  end

  def find_mapping(nil), do: nil

  def find_mapping(source) do
    case src(String.downcase(source)) do
      name when is_binary(name) -> name
      _ -> source
    end
  end

  def format_referrer(request) do
    if has_valid_referral?(request) do
      referrer_uri = URI.parse(request.referrer)
      path = String.trim_trailing(referrer_uri.path || "", "/")
      format_referrer_host(referrer_uri) <> path
    end
  end

  defp has_valid_referral?(%Request{referrer: nil}), do: false

  defp has_valid_referral?(%Request{referrer: referrer, uri: uri}) do
    referrer_uri = URI.parse(referrer)

    valid_scheme? = referrer_uri.scheme in ["http", "https", "android-app"]
    valid_host? = !is_nil(referrer_uri.host) && byte_size(referrer_uri.host) > 0

    internal? =
      Request.sanitize_hostname(referrer_uri.host) == Request.sanitize_hostname(uri.host)

    local? = referrer_uri.host == "localhost"

    valid_scheme? and valid_host? and not internal? and not local?
  end

  defp format_referrer_host(uri) do
    protocol = if uri.scheme == "android-app", do: "android-app://", else: ""
    host = String.replace_prefix(uri.host, "www.", "")

    protocol <> host
  end
end
```

## File: `lib/plausible/ingestion/write_buffer.ex`
```
defmodule Plausible.Ingestion.WriteBuffer do
  @moduledoc false
  use GenServer
  require Logger

  alias Plausible.IngestRepo

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: Keyword.fetch!(opts, :name))
  end

  def insert(server, row_binary) do
    GenServer.cast(server, {:insert, row_binary})
  end

  def flush(server) do
    GenServer.call(server, :flush, :infinity)
  end

  @impl true
  def init(opts) do
    buffer = opts[:buffer] || []
    max_buffer_size = opts[:max_buffer_size] || default_max_buffer_size()
    flush_interval_ms = opts[:flush_interval_ms] || default_flush_interval_ms()

    Process.flag(:trap_exit, true)
    timer = Process.send_after(self(), :tick, flush_interval_ms)

    {:ok,
     %{
       buffer: buffer,
       timer: timer,
       name: Keyword.fetch!(opts, :name),
       insert_sql: Keyword.fetch!(opts, :insert_sql),
       insert_opts: Keyword.fetch!(opts, :insert_opts),
       header: Keyword.fetch!(opts, :header),
       buffer_size: IO.iodata_length(buffer),
       max_buffer_size: max_buffer_size,
       flush_interval_ms: flush_interval_ms
     }}
  end

  @impl true
  def handle_cast({:insert, row_binary}, state) do
    state = %{
      state
      | buffer: [state.buffer | row_binary],
        buffer_size: state.buffer_size + IO.iodata_length(row_binary)
    }

    if state.buffer_size >= state.max_buffer_size do
      Logger.notice("#{state.name} buffer full, flushing to ClickHouse")
      Process.cancel_timer(state.timer)
      do_flush(state)
      new_timer = Process.send_after(self(), :tick, state.flush_interval_ms)
      {:noreply, %{state | buffer: [], timer: new_timer, buffer_size: 0}}
    else
      {:noreply, state}
    end
  end

  @impl true
  def handle_info(:tick, state) do
    do_flush(state)
    timer = Process.send_after(self(), :tick, state.flush_interval_ms)
    {:noreply, %{state | buffer: [], buffer_size: 0, timer: timer}}
  end

  @impl true
  def handle_call(:flush, _from, state) do
    %{timer: timer, flush_interval_ms: flush_interval_ms} = state
    Process.cancel_timer(timer)
    do_flush(state)
    new_timer = Process.send_after(self(), :tick, flush_interval_ms)
    {:reply, :ok, %{state | buffer: [], buffer_size: 0, timer: new_timer}}
  end

  @impl true
  def terminate(_reason, %{name: name} = state) do
    Logger.notice("Flushing #{name} buffer before shutdown...")
    do_flush(state)
  end

  defp do_flush(state) do
    %{
      buffer: buffer,
      buffer_size: buffer_size,
      insert_opts: insert_opts,
      insert_sql: insert_sql,
      header: header,
      name: name
    } = state

    case buffer do
      [] ->
        nil

      _not_empty ->
        Logger.notice("Flushing #{buffer_size} byte(s) RowBinary from #{name}")
        IngestRepo.query!(insert_sql, [header | buffer], insert_opts)
    end
  end

  defp default_flush_interval_ms do
    Keyword.fetch!(Application.get_env(:plausible, IngestRepo), :flush_interval_ms)
  end

  defp default_max_buffer_size do
    Keyword.fetch!(Application.get_env(:plausible, IngestRepo), :max_buffer_size)
  end

  @doc false
  def compile_time_prepare(schema) do
    fields =
      schema.__schema__(:fields)
      |> Enum.reject(&(&1 in fields_to_ignore()))

    types =
      Enum.map(fields, fn field ->
        type = schema.__schema__(:type, field) || raise "missing type for #{field}"

        type
        |> Ecto.Type.type()
        |> Ecto.Adapters.ClickHouse.Schema.remap_type(schema, field)
      end)

    encoding_types = Ch.RowBinary.encoding_types(types)

    header =
      fields
      |> Enum.map(&to_string/1)
      |> Ch.RowBinary.encode_names_and_types(types)
      |> IO.iodata_to_binary()

    insert_sql =
      "INSERT INTO #{schema.__schema__(:source)} (#{Enum.join(fields, ", ")}) FORMAT RowBinaryWithNamesAndTypes"

    %{
      fields: fields,
      types: types,
      encoding_types: encoding_types,
      header: header,
      insert_sql: insert_sql,
      insert_opts: [
        command: :insert,
        encode: false,
        source: schema.__schema__(:source),
        cast_params: []
      ]
    }
  end

  defp fields_to_ignore(), do: [:acquisition_channel, :interactive?]
end
```

## File: `lib/plausible/installation_support/check.ex`
```
defmodule Plausible.InstallationSupport.Check do
  @moduledoc """
  Behaviour to be implemented by a specific installation support check.

  `report_progress_as()` doesn't necessarily reflect the actual check
  description, it serves as a user-facing message grouping mechanism,
  to prevent frequent message flashing when checks rotate often.

  Each check operates on `%Plausible.InstallationSupport.State{}` and is
  expected to return it, optionally modified, by all means. `perform_safe/1`
  is used to guarantee no exceptions are thrown by faulty implementations,
  not to interrupt LiveView.
  """
  @type state() :: Plausible.InstallationSupport.State.t()
  @callback report_progress_as() :: String.t()
  @callback perform(state()) :: state()

  defmacro __using__(_) do
    quote do
      import Plausible.InstallationSupport.State
      alias Plausible.InstallationSupport.State

      require Logger

      @behaviour Plausible.InstallationSupport.Check

      def perform_safe(state) do
        perform(state)
      catch
        _, e ->
          Logger.error(
            "Error running check #{inspect(__MODULE__)} on #{state.url}: #{inspect(e)}"
          )

          put_diagnostics(state, service_error: e)
      end
    end
  end
end
```

## File: `lib/plausible/installation_support/check_runner.ex`
```
defmodule Plausible.InstallationSupport.CheckRunner do
  @moduledoc """
  Takes two arguments:

  1. A `%Plausible.InstallationSupport.State{}` struct - the `diagnostics`
     field is a struct representing the set of diagnostics shared between
     all the checks in this flow.

  2. A list of modules implementing `Plausible.InstallationSupport.Check`
     behaviour.

  Checks are normally run asynchronously, except when synchronous
  execution is optionally required for tests. Slowdowns can be optionally
  added, the user doesn't benefit from running the checks too quickly.
  """

  def run(state, checks, opts) do
    async? = Keyword.get(opts, :async?, true)
    slowdown = Keyword.get(opts, :slowdown, 500)

    if async? do
      Task.start_link(fn -> do_run(state, checks, slowdown) end)
    else
      do_run(state, checks, slowdown)
    end
  end

  defp do_run(state, checks, slowdown) do
    state =
      Enum.reduce(
        checks,
        state,
        fn check, state ->
          state
          |> notify_check_start(check, slowdown)
          |> check.perform_safe()
        end
      )

    notify_all_checks_done(state, slowdown)
  end

  defp notify_check_start(state, check, slowdown) do
    if is_pid(state.report_to) do
      if is_integer(slowdown) and slowdown > 0, do: :timer.sleep(slowdown)
      send(state.report_to, {:check_start, {check, state}})
    end

    state
  end

  defp notify_all_checks_done(state, slowdown) do
    if is_pid(state.report_to) do
      if is_integer(slowdown) and slowdown > 0, do: :timer.sleep(slowdown)
      send(state.report_to, {:all_checks_done, state})
    end

    state
  end
end
```

## File: `lib/plausible/installation_support/checks/csp.ex`
```
defmodule Plausible.InstallationSupport.Checks.CSP do
  @moduledoc """
  Scans the Content Security Policy header to ensure that the Plausible domain is allowed.
  See `Plausible.InstallationSupport.LegacyVerification.Checks` for the execution sequence.
  """
  use Plausible.InstallationSupport.Check

  @impl true
  def report_progress_as, do: "We're visiting your site to ensure that everything is working"

  @impl true
  def perform(%State{assigns: %{headers: headers}} = state) do
    case headers["content-security-policy"] do
      [policy] ->
        directives = String.split(policy, ";")

        allowed? =
          Enum.any?(directives, fn directive ->
            String.contains?(directive, PlausibleWeb.Endpoint.host())
          end)

        if allowed? do
          state
        else
          put_diagnostics(state, disallowed_via_csp?: true)
        end

      _ ->
        state
    end
  end

  def perform(state), do: state
end
```

## File: `lib/plausible/installation_support/checks/fetch_body.ex`
```
defmodule Plausible.InstallationSupport.Checks.FetchBody do
  @moduledoc """
  Fetches the body of the site and extracts the HTML document, if available, for
  further processing. See `Plausible.InstallationSupport.LegacyVerification.Checks`
  for the execution sequence.
  """
  use Plausible.InstallationSupport.Check

  @impl true
  def report_progress_as, do: "We're visiting your site to ensure that everything is working"

  @impl true

  def perform(%State{url: "https://" <> _ = url} = state) do
    fetch_body_opts = Application.get_env(:plausible, __MODULE__)[:req_opts] || []

    opts =
      Keyword.merge(
        [
          base_url: url,
          max_redirects: 4,
          max_retries: 3,
          retry_log_level: :warning
        ],
        fetch_body_opts
      )

    {req, resp} = opts |> Req.new() |> Req.Request.run_request()

    case resp do
      %Req.Response{body: body}
      when is_binary(body) ->
        state
        |> assign(final_domain: req.url.host)
        |> extract_document(resp)

      _ ->
        state
    end
  end

  defp extract_document(state, response) do
    with true <- html?(response),
         {:ok, document} <- Floki.parse_document(response.body) do
      state
      |> assign(raw_body: response.body, document: document, headers: response.headers)
      |> put_diagnostics(body_fetched?: true)
    else
      _ ->
        state
    end
  end

  defp html?(%Req.Response{headers: headers}) do
    headers
    |> Map.get("content-type", "")
    |> List.wrap()
    |> List.first()
    |> String.contains?("text/html")
  end
end
```

## File: `lib/plausible/installation_support/checks/installation.ex`
```
defmodule Plausible.InstallationSupport.Checks.Installation do
  require Logger

  @verifier_code_path "priv/tracker/installation_support/verifier-v1.js"
  @external_resource @verifier_code_path

  # On CI, the file might not be present for static checks so we default to empty string
  @verifier_code (case File.read(Application.app_dir(:plausible, @verifier_code_path)) do
                    {:ok, content} -> content
                    {:error, _} -> ""
                  end)

  # Puppeteer wrapper function that executes the vanilla JS verifier code.

  # ### NO AUTOMATIC TEST COVERAGE

  # Unfortunately, as things stand today, this Puppeteer wrapper logic
  # cannot be tested without spinning up a real Browserless instance or
  # bringing in a bunch of test deps for Puppeteer. Therefore, take extra
  # care when changing this and make sure to run manual tests on local
  # browserless (`make browserless`) before releasing an update.

  # ### TRICKY: Handling client side JS navigation.

  # We've seen numerous cases where client JS navigates or refreshes the
  # page after load. Any such JS behaviour destroys the Puppeteer page
  # context, meaning that our verifier execution gets interrupted and we
  # end up in the `catch` clause.

  # To make our best effort verifying these sites, we retry (up to twice)
  # running the verifier again if we encounter this specific error.

  # Important: On retries, we work with the client-modified page context
  # instead of calling `page.goto(context.url)` again (which would most
  # likely result in another interruptive navigation).
  @puppeteer_wrapper_code """
  export default async function({ page, context }) {
    const MAX_RETRIES = 2

    async function attemptVerification() {
      await page.evaluate(() => {
        #{@verifier_code}
      });

      return await page.evaluate(async (expectedDataDomain, debug) => {
        return await window.verifyPlausibleInstallation(expectedDataDomain, debug);
      }, context.expectedDataDomain, context.debug);
    }

    try {
      await page.setUserAgent(context.userAgent);
      await page.goto(context.url);

      for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
        try {
          return await attemptVerification()
        } catch (error) {
          const shouldRetry = typeof error?.message === 'string' && error.message.toLowerCase().includes('execution context')

          if (shouldRetry && attempt <= MAX_RETRIES) {
            // Brief delay before retry
            await new Promise(resolve => setTimeout(resolve, 500))
            continue
          }

          throw error
        }
      }
    } catch (error) {
      const msg = error.message ? error.message : JSON.stringify(error)
      return {data: {completed: false, error: msg}}
    }
  }
  """

  @moduledoc """
  Calls the browserless.io service (local instance can be spawned with `make browserless`)
  and runs verifier script via the [function API](https://docs.browserless.io/HTTP-APIs/function).

  The verification uses a vanilla JS script that runs in the browser context,
  performing a comprehensive Plausible installation verification. Providing
  the following information:

  - `data.snippetsFoundInHead` - plausible snippets found in <head>

  - `data.snippetsFoundInBody` - plausible snippets found in <body>

  - `data.plausibleInstalled` - whether or not the `plausible()` window function was found

  - `data.callbackStatus` - integer. 202 indicates that the server acknowledged the test event.
                            The test event ingestion is discarded based on user-agent, see:
                            `Plausible.InstallationSupport.user_agent/0`

  - `data.dataDomainMismatch` - whether or not script[data-domain] mismatched with site.domain

  - `data.proxyLikely` - whether the script[src] is not a plausible.io URL

  - `data.manualScriptExtension` - whether the site is using script.manual.js

  - `data.unknownAttributes` - whether the script tag has any unknown attributes

  - `data.wordpressPlugin` - whether or not there's a `<meta>` tag with the WP plugin version

  - `data.wordpressLikely` - whether or not the site is built on WordPress

  - `data.gtmLikely` - whether or not the site uses GTM

  - `data.cookieBannerLikely` - whether or not there's a cookie banner blocking Plausible
  """
  use Plausible.InstallationSupport.Check

  @impl true
  def report_progress_as, do: "We're verifying that your visitors are being counted correctly"

  @impl true
  def perform(%State{url: url, data_domain: data_domain} = state) do
    opts = [
      headers: %{content_type: "application/json"},
      body:
        Jason.encode!(%{
          code: @puppeteer_wrapper_code,
          context: %{
            expectedDataDomain: data_domain,
            url: Plausible.InstallationSupport.URL.bust_url(url),
            userAgent: Plausible.InstallationSupport.user_agent(),
            debug: Application.get_env(:plausible, :environment) == "dev"
          }
        }),
      retry: :transient,
      retry_log_level: :warning,
      max_retries: 2
    ]

    extra_opts = Application.get_env(:plausible, __MODULE__)[:req_opts] || []
    opts = Keyword.merge(opts, extra_opts)

    case Req.post(Plausible.InstallationSupport.browserless_function_api_endpoint(), opts) do
      {:ok, %{status: 200, body: %{"data" => %{"completed" => true} = js_data}}} ->
        emit_telemetry_and_log(state.diagnostics, js_data, data_domain)

        put_diagnostics(state,
          plausible_installed?: js_data["plausibleInstalled"],
          callback_status: js_data["callbackStatus"]
        )

      {:ok, %{status: status, body: %{"data" => %{"error" => error}}}} ->
        Logger.warning(
          "[VERIFICATION] Browserless JS error (data_domain='#{data_domain}'): #{inspect(error)}"
        )

        put_diagnostics(state, plausible_installed?: false, service_error: status)

      {:ok, %{status: status, body: body}} ->
        Logger.warning(
          "[VERIFICATION] Unexpected Browserless response (data_domain='#{data_domain}'): status=#{status}, body=#{inspect(body)}"
        )

        put_diagnostics(state, plausible_installed?: false, service_error: status)

      {:error, %{reason: reason}} ->
        Logger.warning(
          "[VERIFICATION] Browserless request error (data_domain='#{data_domain}'): #{inspect(reason)}"
        )

        put_diagnostics(state, plausible_installed?: false, service_error: reason)
    end
  end

  def telemetry_event(true = _diff), do: [:plausible, :verification, :js_elixir_diff]
  def telemetry_event(false = _diff), do: [:plausible, :verification, :js_elixir_match]

  def emit_telemetry_and_log(elixir_data, js_data, data_domain) do
    diffs =
      for {diff, elixir_diagnostic, js_diagnostic} <- [
            {:data_domain_mismatch_diff, :data_domain_mismatch?, "dataDomainMismatch"},
            {:proxy_likely_diff, :proxy_likely?, "proxyLikely"},
            {:manual_script_extension_diff, :manual_script_extension?, "manualScriptExtension"},
            {:unknown_attributes_diff, :snippet_unknown_attributes?, "unknownAttributes"},
            {:wordpress_plugin_diff, :wordpress_plugin?, "wordpressPlugin"},
            {:wordpress_likely_diff, :wordpress_likely?, "wordpressLikely"},
            {:gtm_likely_diff, :gtm_likely?, "gtmLikely"},
            {:cookie_banner_likely_diff, :cookie_banner_likely?, "cookieBannerLikely"}
          ] do
        case {Map.get(elixir_data, elixir_diagnostic), js_data[js_diagnostic]} do
          {true, false} -> {diff, -1}
          {false, true} -> {diff, 1}
          {_, _} -> {diff, 0}
        end
      end
      |> Map.new()
      |> Map.merge(%{
        snippets_head_diff: js_data["snippetsFoundInHead"] - elixir_data.snippets_found_in_head,
        snippets_body_diff: js_data["snippetsFoundInBody"] - elixir_data.snippets_found_in_body
      })
      |> Map.reject(fn {_k, v} -> v == 0 end)

    any_diff? = map_size(diffs) > 0

    if any_diff? do
      info =
        %{
          domain: data_domain,
          plausible_installed_js: js_data["plausibleInstalled"],
          callback_status_js: js_data["callbackStatus"]
        }
        |> Map.merge(diffs)

      Logger.warning("[VERIFICATION] js_elixir_diff: #{inspect(info)}")
    end

    :telemetry.execute(telemetry_event(any_diff?), %{})
  end
end
```

## File: `lib/plausible/installation_support/checks/installation_v2.ex`
```
defmodule Plausible.InstallationSupport.Checks.InstallationV2 do
  require Logger

  path = Application.app_dir(:plausible, "priv/tracker/installation_support/verifier-v2.js")
  # On CI, the file might not be present for static checks so we create an empty one
  File.touch!(path)

  @verifier_code File.read!(path)
  @external_resource "priv/tracker/installation_support/verifier-v2.js"

  @function_check_timeout 10_000

  # Puppeteer wrapper function that executes the vanilla JS verifier code
  @puppeteer_wrapper_code """
  export default async function({ page, context }) {
    try {
      await page.setUserAgent(context.userAgent);
      const response = await page.goto(context.url);

      await page.evaluate(() => {
        #{@verifier_code}
      });

      return await page.evaluate(async ({ responseHeaders, debug, timeoutMs, cspHostToCheck }) => {
        return await window.verifyPlausibleInstallation({ responseHeaders, debug, timeoutMs, cspHostToCheck });
      }, {
        timeoutMs: context.timeoutMs,
        responseHeaders: response.headers(),
        debug: context.debug,
        cspHostToCheck: context.cspHostToCheck
      });
    } catch (error) {
      return {
        data: {
          completed: false,
          error: {
            message: error?.message ?? JSON.stringify(error),
          }
        }
      }
    }
  }
  """

  @moduledoc """
  Calls the browserless.io service (local instance can be spawned with `make browserless`)
  and runs verifier script via the [function API](https://docs.browserless.io/HTTP-APIs/function).
  """
  use Plausible.InstallationSupport.Check

  @impl true
  def report_progress_as, do: "We're verifying that your visitors are being counted correctly"

  @impl true
  def perform(%State{url: url} = state) do
    opts = [
      headers: %{content_type: "application/json"},
      body:
        JSON.encode!(%{
          code: @puppeteer_wrapper_code,
          context: %{
            cspHostToCheck: PlausibleWeb.Endpoint.host(),
            timeoutMs: @function_check_timeout,
            url: Plausible.InstallationSupport.URL.bust_url(url),
            userAgent: Plausible.InstallationSupport.user_agent(),
            debug: Application.get_env(:plausible, :environment) == "dev"
          }
        }),
      retry: :transient,
      retry_log_level: :warning,
      max_retries: 2
    ]

    extra_opts = Application.get_env(:plausible, __MODULE__)[:req_opts] || []
    opts = Keyword.merge(opts, extra_opts)

    case Req.post(Plausible.InstallationSupport.browserless_function_api_endpoint(), opts) do
      {:ok, %{body: body, status: status}} ->
        handle_browserless_response(state, body, status)

      {:error, %{reason: reason}} ->
        Logger.warning(warning_message("Browserless request error: #{inspect(reason)}", state))

        put_diagnostics(state, service_error: reason)
    end
  end

  defp handle_browserless_response(
         state,
         %{"data" => %{"completed" => completed} = data},
         _status
       ) do
    if completed do
      put_diagnostics(
        state,
        disallowed_by_csp: data["disallowedByCsp"],
        plausible_is_on_window: data["plausibleIsOnWindow"],
        plausible_is_initialized: data["plausibleIsInitialized"],
        plausible_version: data["plausibleVersion"],
        plausible_variant: data["plausibleVariant"],
        test_event: data["testEvent"],
        cookie_banner_likely: data["cookieBannerLikely"],
        service_error: nil
      )
    else
      Logger.warning(
        warning_message(
          "Browserless function returned with completed: false, error.message: #{inspect(data["error"]["message"])}",
          state
        )
      )

      put_diagnostics(state, service_error: data["error"]["message"])
    end
  end

  defp handle_browserless_response(state, _body, status) do
    error = "Unhandled browserless response with status: #{status}"
    Logger.warning(warning_message(error, state))

    put_diagnostics(state, service_error: error)
  end

  defp warning_message(message, state) do
    "[VERIFICATION v2] #{message} (data_domain='#{state.data_domain}')"
  end
end
```

## File: `lib/plausible/installation_support/checks/installation_v2_cache_bust.ex`
```
defmodule Plausible.InstallationSupport.Checks.InstallationV2CacheBust do
  @moduledoc """
  If the output of previous checks can not be interpreted as successful,
  as a last resort, we try to bust the cache of the site under test by adding a query parameter to the URL,
  and running InstallationV2 again.

  Whatever the result from the rerun, that is what we use to interpret the installation.

  The idea is to make sure that any issues we detect will be about the latest version of their website.

  We also want to avoid reporting a successful installation if it took a special cache-busting action to make it work.
  """

  require Logger
  alias Plausible.InstallationSupport
  use Plausible.InstallationSupport.Check

  @impl true
  def report_progress_as, do: "We're verifying that your visitors are being counted correctly"

  @impl true
  def perform(%State{url: url} = state) do
    if InstallationSupport.Verification.Checks.interpret_diagnostics(state) ==
         %InstallationSupport.Result{ok?: true} do
      state
    else
      url_that_maybe_busts_cache =
        Plausible.InstallationSupport.URL.bust_url(url)

      state_after_cache_bust =
        Plausible.InstallationSupport.Checks.InstallationV2.perform(%{
          state
          | url: url_that_maybe_busts_cache
        })

      put_diagnostics(state_after_cache_bust, diagnostics_are_from_cache_bust: true)
    end
  end
end
```

## File: `lib/plausible/installation_support/checks/scan_body.ex`
```
defmodule Plausible.InstallationSupport.Checks.ScanBody do
  @moduledoc """
  Naive way of detecting GTM and WordPress powered sites.
  """
  use Plausible.InstallationSupport.Check

  @impl true
  def report_progress_as, do: "We're visiting your site to ensure that everything is working"

  @impl true
  def perform(%State{assigns: %{raw_body: body}} = state) when is_binary(body) do
    state
    |> scan_wp_plugin()
    |> scan_gtm()
    |> scan_wp()
    |> scan_cookie_banners()
  end

  def perform(state), do: state

  defp scan_wp_plugin(%{assigns: %{document: document}} = state) do
    case Floki.find(document, ~s|meta[name="plausible-analytics-version"]|) do
      [] ->
        state

      [_] ->
        state
        |> assign(skip_wordpress_check: true)
        |> put_diagnostics(wordpress_likely?: true, wordpress_plugin?: true)
    end
  end

  defp scan_wp_plugin(state) do
    state
  end

  @gtm_signatures [
    "googletagmanager.com/gtm.js"
  ]

  defp scan_gtm(state) do
    if Enum.any?(@gtm_signatures, &String.contains?(state.assigns.raw_body, &1)) do
      put_diagnostics(state, gtm_likely?: true)
    else
      state
    end
  end

  @wordpress_signatures [
    "wp-content",
    "wp-includes",
    "wp-json"
  ]

  defp scan_wp(%{assigns: %{skip_wordpress_check: true}} = state) do
    state
  end

  defp scan_wp(state) do
    if Enum.any?(@wordpress_signatures, &String.contains?(state.assigns.raw_body, &1)) do
      put_diagnostics(state, wordpress_likely?: true)
    else
      state
    end
  end

  defp scan_cookie_banners(%{assigns: %{raw_body: body}} = state) do
    # We'll start with CookieBot. Not using the selectors yet, as seen at
    # https://github.com/cavi-au/Consent-O-Matic/blob/master/rules/cookiebot.json
    # because those don't seem to be appearing without JS evaluation.
    # If this ever becomes an issue, we'll have to move that check to headless.
    if String.contains?(body, "cookiebot") do
      put_diagnostics(state, cookie_banner_likely?: true)
    else
      state
    end
  end

  defp scan_cookie_banners(state) do
    state
  end
end
```

## File: `lib/plausible/installation_support/checks/snippet.ex`
```
defmodule Plausible.InstallationSupport.Checks.Snippet do
  @moduledoc """
  The check looks for Plausible snippets and tries to address the common
  integration issues, such as bad placement, data-domain typos, unknown
  attributes frequently added by performance optimization plugins, etc.
  """
  use Plausible.InstallationSupport.Check

  @impl true
  def report_progress_as, do: "We're looking for the Plausible snippet on your site"

  @impl true
  def perform(%State{assigns: %{document: document}} = state) do
    in_head = Floki.find(document, "head script[data-domain][src]")
    in_body = Floki.find(document, "body script[data-domain][src]")

    all = in_head ++ in_body

    put_diagnostics(state,
      snippets_found_in_head: Enum.count(in_head),
      snippets_found_in_body: Enum.count(in_body),
      proxy_likely?: proxy_likely?(all),
      manual_script_extension?: manual_script_extension?(all),
      snippet_unknown_attributes?: unknown_attributes?(all),
      data_domain_mismatch?:
        data_domain_mismatch?(all, state.data_domain, state.assigns[:final_domain])
    )
  end

  def perform(state), do: state

  defp manual_script_extension?(nodes) do
    nodes
    |> Floki.attribute("src")
    |> Enum.any?(&String.contains?(&1, "manual."))
  end

  defp proxy_likely?(nodes) do
    nodes
    |> Floki.attribute("src")
    |> Enum.any?(&(not String.starts_with?(&1, PlausibleWeb.Endpoint.url())))
  end

  @known_attributes [
    "data-domain",
    "src",
    "defer",
    "data-api",
    "data-exclude",
    "data-include",
    "data-cfasync"
  ]

  defp unknown_attributes?(nodes) do
    Enum.any?(nodes, fn {_, attrs, _} ->
      Enum.any?(attrs, fn
        {"type", "text/javascript"} ->
          false

        {"event-" <> _, _} ->
          false

        {key, _} ->
          key not in @known_attributes
      end)
    end)
  end

  defp data_domain_mismatch?(nodes, data_domain, final_data_domain) do
    nodes
    |> Floki.attribute("data-domain")
    |> Enum.any?(fn script_data_domain ->
      multiple = String.split(script_data_domain, ",")

      data_domain not in multiple and final_data_domain not in multiple
    end)
  end
end
```

## File: `lib/plausible/installation_support/checks/snippet_cache_bust.ex`
```
defmodule Plausible.InstallationSupport.Checks.SnippetCacheBust do
  @moduledoc """
  A naive way of trying to figure out whether the latest site contents
  is wrapped with some CDN/caching layer.

  In case no snippets were found, we'll try to bust the cache by appending
  a random query parameter and re-run `FetchBody` and `Snippet` checks.
  If the result is different this time, we'll assume cache likely.
  """
  use Plausible.InstallationSupport.Check

  alias Plausible.InstallationSupport.{LegacyVerification, Checks, URL}

  @impl true
  def report_progress_as, do: "We're looking for the Plausible snippet on your site"

  @impl true
  def perform(
        %State{
          url: url,
          diagnostics: %LegacyVerification.Diagnostics{
            snippets_found_in_head: 0,
            snippets_found_in_body: 0,
            body_fetched?: true
          }
        } = state
      ) do
    state2 =
      %{state | url: URL.bust_url(url)}
      |> Checks.FetchBody.perform()
      |> Checks.ScanBody.perform()
      |> Checks.Snippet.perform()

    if state2.diagnostics.snippets_found_in_head > 0 or
         state2.diagnostics.snippets_found_in_body > 0 do
      put_diagnostics(state2, snippet_found_after_busting_cache?: true)
    else
      state
    end
  end

  def perform(state), do: state
end
```

## File: `lib/plausible/installation_support/detection.ex`
```
defmodule Plausible.InstallationSupport.Detection do
  @moduledoc """
  Exposes a perform function which visits the given URL via a Browserless
  /function API call, and in a returns the following diagnostics:

  * v1_detected (optional - detection can take up to 3s)
  * gtm_likely
  * wordpress_likely
  * wordpress_plugin

  These diagnostics are used to determine what installation type to recommend,
  and whether to provide a notice for upgrading an existing v1 integration to v2.
  """
  require Logger
  alias Plausible.InstallationSupport

  @detector_code_path "priv/tracker/installation_support/detector.js"
  @external_resource @detector_code_path

  # On CI, the file might not be present for static checks so we default to empty string
  @detector_code (case File.read(Application.app_dir(:plausible, @detector_code_path)) do
                    {:ok, content} -> content
                    {:error, _} -> ""
                  end)

  # Puppeteer wrapper function that executes the vanilla JS verifier code
  @puppeteer_wrapper_code """
  export default async function({ page, context }) {
    try {
      await page.setUserAgent(context.userAgent);
      await page.goto(context.url);

      await page.evaluate(() => {
        #{@detector_code}
      });

      return await page.evaluate(async (detectV1, debug) => {
        return await window.scanPageBeforePlausibleInstallation(detectV1, debug);
      }, context.detectV1, context.debug);
    } catch (error) {
      const msg = error.message ? error.message : JSON.stringify(error)
      return {data: {completed: false, error: msg}}
    }
  }
  """

  def perform(url, opts \\ []) do
    req_opts =
      [
        headers: %{content_type: "application/json"},
        body:
          Jason.encode!(%{
            code: @puppeteer_wrapper_code,
            context: %{
              url: url,
              userAgent: InstallationSupport.user_agent(),
              detectV1: Keyword.get(opts, :detect_v1?, false),
              debug: Application.get_env(:plausible, :environment) == "dev"
            }
          }),
        retry: :transient,
        retry_log_level: :warning,
        max_retries: 2
      ]
      |> Keyword.merge(Application.get_env(:plausible, __MODULE__)[:req_opts] || [])

    case Req.post(InstallationSupport.browserless_function_api_endpoint(), req_opts) do
      {:ok, %{status: 200, body: %{"data" => %{"completed" => true} = js_data}}} ->
        {:ok,
         %{
           v1_detected: js_data["v1Detected"],
           gtm_likely: js_data["gtmLikely"],
           wordpress_likely: js_data["wordpressLikely"],
           wordpress_plugin: js_data["wordpressPlugin"]
         }}

      {:ok, %{body: %{"data" => %{"error" => error}}}} ->
        Logger.warning("[DETECTION] Browserless JS error (url='#{url}'): #{inspect(error)}")

        {:error, {:browserless, error}}

      {:error, %{reason: reason}} ->
        Logger.warning("[DETECTION] Browserless request error (url='#{url}'): #{inspect(reason)}")

        {:error, {:req, reason}}
    end
  end
end
```

## File: `lib/plausible/installation_support/installation_support.ex`
```
defmodule Plausible.InstallationSupport do
  @moduledoc """
  This top level module is the middle ground between pre-installation
  site scans and verification of whether Plausible has been installed
  correctly.

  Defines the user-agent used by Elixir-native HTTP requests as well
  as headless browser checks on the client side via Browserless.
  """
  use Plausible

  on_ee do
    def user_agent() do
      "Plausible Verification Agent - if abused, contact support@plausible.io"
    end

    def browserless_function_api_endpoint() do
      config = Application.fetch_env!(:plausible, __MODULE__)
      token = Keyword.fetch!(config, :token)
      endpoint = Keyword.fetch!(config, :endpoint)
      Path.join(endpoint, "function?token=#{token}&stealth")
    end
  else
    def browserless_function_api_endpoint() do
      "Browserless API should not be called on Community Edition"
    end

    def user_agent() do
      "Plausible Community Edition"
    end
  end
end
```

## File: `lib/plausible/installation_support/legacy_verification/checks.ex`
```
defmodule Plausible.InstallationSupport.LegacyVerification.Checks do
  @moduledoc """
  Checks that are performed during v1 site verification.

  In async execution, each check notifies the caller by sending a message to it.
  """
  alias Plausible.InstallationSupport.LegacyVerification
  alias Plausible.InstallationSupport.{State, CheckRunner, Checks}

  require Logger

  @checks [
    Checks.FetchBody,
    Checks.CSP,
    Checks.ScanBody,
    Checks.Snippet,
    Checks.SnippetCacheBust,
    Checks.Installation
  ]

  def run(url, data_domain, opts \\ []) do
    checks = Keyword.get(opts, :checks, @checks)
    report_to = Keyword.get(opts, :report_to, self())
    async? = Keyword.get(opts, :async?, true)
    slowdown = Keyword.get(opts, :slowdown, 500)

    init_state =
      %State{
        url: url,
        data_domain: data_domain,
        report_to: report_to,
        diagnostics: %LegacyVerification.Diagnostics{}
      }

    CheckRunner.run(init_state, checks,
      async?: async?,
      report_to: report_to,
      slowdown: slowdown
    )
  end

  def interpret_diagnostics(%State{} = state) do
    LegacyVerification.Diagnostics.interpret(
      state.diagnostics,
      state.url
    )
  end
end
```

## File: `lib/plausible/installation_support/legacy_verification/diagnostics.ex`
```
defmodule Plausible.InstallationSupport.LegacyVerification.Diagnostics do
  @moduledoc """
  Module responsible for translating diagnostics to user-friendly errors and recommendations.
  """
  require Logger

  @errors Plausible.InstallationSupport.LegacyVerification.Errors.all()

  defstruct plausible_installed?: false,
            snippets_found_in_head: 0,
            snippets_found_in_body: 0,
            snippet_found_after_busting_cache?: false,
            snippet_unknown_attributes?: false,
            disallowed_via_csp?: false,
            service_error: nil,
            body_fetched?: false,
            wordpress_likely?: false,
            cookie_banner_likely?: false,
            gtm_likely?: false,
            callback_status: 0,
            proxy_likely?: false,
            manual_script_extension?: false,
            data_domain_mismatch?: false,
            wordpress_plugin?: false

  @type t :: %__MODULE__{}

  alias Plausible.InstallationSupport.Result
  @spec interpret(t(), String.t()) :: Result.t()
  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          snippets_found_in_head: 1,
          snippets_found_in_body: 0,
          callback_status: callback_status,
          snippet_found_after_busting_cache?: false,
          service_error: nil,
          data_domain_mismatch?: false
        },
        _url
      )
      when callback_status in [200, 202] do
    %Result{ok?: true}
  end

  def interpret(
        %__MODULE__{plausible_installed?: false, gtm_likely?: true, disallowed_via_csp?: true},
        _url
      ) do
    error(@errors.csp)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          gtm_likely?: true,
          cookie_banner_likely?: true,
          wordpress_plugin?: false
        },
        _url
      ) do
    error(@errors.gtm_cookie_banner)
  end

  def interpret(
        %__MODULE__{plausible_installed?: false, gtm_likely?: true, wordpress_plugin?: false},
        _url
      ) do
    error(@errors.gtm)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          snippets_found_in_head: 1,
          disallowed_via_csp?: true,
          proxy_likely?: false
        },
        _url
      ) do
    error(@errors.csp)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          snippets_found_in_head: 0,
          snippets_found_in_body: 0,
          body_fetched?: true,
          service_error: nil,
          wordpress_likely?: false
        },
        _url
      ) do
    error(@errors.no_snippet)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          snippets_found_in_head: 0,
          snippets_found_in_body: 0,
          body_fetched?: true,
          gtm_likely?: false,
          callback_status: callback_status
        },
        _url
      )
      when is_integer(callback_status) and callback_status > 202 do
    error(@errors.no_snippet)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          snippets_found_in_head: 0,
          snippets_found_in_body: 0,
          body_fetched?: true,
          service_error: nil,
          wordpress_likely?: true
        },
        _url
      ) do
    error(@errors.no_snippet_wp)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          body_fetched?: false
        },
        _url
      ) do
    error(@errors.unreachable)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          service_error: :timeout
        },
        _url
      ) do
    error(@errors.generic)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          service_error: service_error
        },
        _url
      )
      when not is_nil(service_error) do
    error(@errors.temporary)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          service_error: nil,
          body_fetched?: false
        },
        _url
      ) do
    error(@errors.unreachable)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          wordpress_likely?: false,
          callback_status: -1
        },
        _url
      ) do
    error(@errors.generic)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          wordpress_likely?: true,
          wordpress_plugin?: false,
          callback_status: -1
        },
        _url
      ) do
    error(@errors.old_script_wp_no_plugin)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          wordpress_likely?: true,
          wordpress_plugin?: true,
          callback_status: -1
        },
        _url
      ) do
    error(@errors.old_script_wp_plugin)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          callback_status: callback_status,
          proxy_likely?: true
        },
        _url
      )
      when callback_status in [0, 500] do
    error(@errors.proxy_misconfigured)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          snippets_found_in_head: 1,
          proxy_likely?: true,
          wordpress_likely?: true,
          wordpress_plugin?: false
        },
        _url
      ) do
    error(@errors.proxy_wp_no_plugin)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          snippets_found_in_head: 1,
          proxy_likely?: true,
          wordpress_likely?: false
        },
        _url
      ) do
    error(@errors.proxy_general)
  end

  def interpret(%__MODULE__{data_domain_mismatch?: true}, "https://" <> domain) do
    error(@errors.different_data_domain, domain: domain)
  end

  def interpret(
        %__MODULE__{
          snippets_found_in_head: count_head,
          snippets_found_in_body: count_body,
          manual_script_extension?: false
        },
        _url
      )
      when count_head + count_body > 1 do
    error(@errors.multiple_snippets)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          callback_status: callback_status,
          snippet_found_after_busting_cache?: true,
          wordpress_likely?: true,
          wordpress_plugin?: true
        },
        _url
      )
      when callback_status in [200, 202] do
    error(@errors.cache_wp_plugin)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          callback_status: callback_status,
          snippet_found_after_busting_cache?: true,
          wordpress_likely?: true,
          wordpress_plugin?: false
        },
        _url
      )
      when callback_status in [200, 202] do
    error(@errors.cache_wp_no_plugin)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          callback_status: 202,
          snippet_found_after_busting_cache?: true,
          wordpress_likely?: false
        },
        _url
      ) do
    error(@errors.cache_general)
  end

  def interpret(%__MODULE__{snippets_found_in_head: 0, snippets_found_in_body: n}, _url)
      when n >= 1 do
    error(@errors.snippet_in_body)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          snippet_unknown_attributes?: true,
          wordpress_likely?: true,
          wordpress_plugin?: true
        },
        _url
      ) do
    error(@errors.illegal_attrs_wp_plugin)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          snippet_unknown_attributes?: true,
          wordpress_likely?: true,
          wordpress_plugin?: false
        },
        _url
      ) do
    error(@errors.illegal_attrs_wp_no_plugin)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: false,
          snippet_unknown_attributes?: true,
          wordpress_likely?: false
        },
        _url
      ) do
    error(@errors.illegal_attrs_general)
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          snippets_found_in_head: 0,
          snippets_found_in_body: 0,
          callback_status: callback_status,
          snippet_found_after_busting_cache?: false,
          service_error: nil
        },
        _url
      )
      when callback_status in [200, 202] do
    %Result{ok?: true}
  end

  def interpret(
        %__MODULE__{
          plausible_installed?: true,
          snippets_found_in_head: count_head,
          snippets_found_in_body: count_body,
          callback_status: callback_status,
          service_error: nil,
          manual_script_extension?: true
        },
        _url
      )
      when count_head + count_body > 1 and callback_status in [200, 202] do
    %Result{ok?: true}
  end

  def interpret(diagnostics, url) do
    Sentry.capture_message("Unhandled case for site verification",
      extra: %{
        message: inspect(diagnostics),
        url: url,
        hash: :erlang.phash2(diagnostics)
      }
    )

    error(@errors.unknown)
  end

  defp error(error) do
    %Result{
      ok?: false,
      errors: [error.message],
      recommendations: [%{text: error.recommendation, url: error.url}]
    }
  end

  defp error(error, assigns) do
    recommendation = EEx.eval_string(error.recommendation, assigns: assigns)
    error(%{error | recommendation: recommendation})
  end
end
```

## File: `lib/plausible/installation_support/legacy_verification/errors.ex`
```
defmodule Plausible.InstallationSupport.LegacyVerification.Errors do
  @moduledoc """
  A go-to definition of all legacy verification errors
  """

  @errors %{
    gtm: %{
      message: "We encountered an issue with your Plausible integration",
      recommendation:
        "As you're using Google Tag Manager, you'll need to use a GTM-specific Plausible snippet",
      url: "https://plausible.io/docs/google-tag-manager"
    },
    gtm_cookie_banner: %{
      message: "We couldn't verify your website",
      recommendation:
        "As you're using Google Tag Manager, you'll need to use a GTM-specific Plausible snippet. Please make sure no cookie consent banner is blocking our script",
      url: "https://plausible.io/docs/google-tag-manager"
    },
    csp: %{
      message: "We encountered an issue with your site's CSP",
      recommendation:
        "Please add plausible.io domain specifically to the allowed list of domains in your Content Security Policy (CSP)",
      url:
        "https://plausible.io/docs/troubleshoot-integration#does-your-site-use-a-content-security-policy-csp"
    },
    unreachable: %{
      message: "We couldn't reach your site",
      recommendation:
        "If your site is running at a different location, please manually check your integration",
      url: "https://plausible.io/docs/troubleshoot-integration"
    },
    no_snippet: %{
      message: "We couldn't find the Plausible snippet",
      recommendation: "Please insert the snippet into your site",
      url: "https://plausible.io/docs/plausible-script"
    },
    no_snippet_wp: %{
      message: "We couldn't find the Plausible snippet on your site",
      recommendation:
        "Please install and activate our WordPress plugin to start counting your visitors",
      url: "https://plausible.io/wordpress-analytics-plugin"
    },
    temporary: %{
      message: "We encountered a temporary problem",
      recommendation: "Please try again in a few minutes or manually check your integration",
      url:
        "https://plausible.io/docs/troubleshoot-integration#how-to-manually-check-your-integration"
    },
    generic: %{
      message: "We couldn't automatically verify your website",
      recommendation:
        "Please manually check your integration by following the instructions provided",
      url:
        "https://plausible.io/docs/troubleshoot-integration#how-to-manually-check-your-integration"
    },
    old_script_wp_no_plugin: %{
      message: "We couldn't verify your website",
      recommendation:
        "You're running an older version of our script so we cannot verify it. Please use our WordPress plugin instead",
      url: "https://plausible.io/wordpress-analytics-plugin"
    },
    old_script_wp_plugin: %{
      message: "We couldn't verify your website",
      recommendation:
        "You're running an older version of our script so we cannot verify it. Please re-enable the proxy in our plugin",
      url: "https://plausible.io/wordpress-analytics-plugin"
    },
    proxy_misconfigured: %{
      message: "We encountered an error with your Plausible proxy",
      recommendation: "Please check whether you've configured the /event route correctly",
      url: "https://plausible.io/docs/proxy/introduction"
    },
    proxy_wp_no_plugin: %{
      message: "We encountered an error with your Plausible proxy",
      recommendation:
        "Please re-enable the proxy in our WordPress plugin to start counting your visitors",
      url: "https://plausible.io/wordpress-analytics-plugin"
    },
    proxy_general: %{
      message: "We encountered an error with your Plausible proxy",
      recommendation: "Please check your proxy configuration to make sure it's set up correctly",
      url: "https://plausible.io/docs/proxy/introduction"
    },
    multiple_snippets: %{
      message: "We've found multiple Plausible snippets",
      recommendation: "Please ensure that only one snippet is used",
      url:
        "https://plausible.io/docs/troubleshoot-integration#did-you-insert-multiple-plausible-snippets-into-your-site"
    },
    cache_wp_plugin: %{
      message: "We encountered an issue with your site cache",
      recommendation:
        "Please clear your WordPress cache to ensure that the latest version is displayed to your visitors",
      url: "https://plausible.io/wordpress-analytics-plugin"
    },
    cache_wp_no_plugin: %{
      message: "We encountered an issue with your site cache",
      recommendation:
        "Please install and activate our WordPress plugin to start counting your visitors",
      url: "https://plausible.io/wordpress-analytics-plugin"
    },
    cache_general: %{
      message: "We encountered an issue with your site cache",
      recommendation:
        "Please clear your cache (or wait for your provider to clear it) to ensure that the latest version is displayed to your visitors",
      url:
        "https://plausible.io/docs/troubleshoot-integration#have-you-cleared-the-cache-of-your-site"
    },
    snippet_in_body: %{
      message: "Plausible snippet is placed in the body",
      recommendation: "Please relocate the snippet to the header of your site",
      url: "https://plausible.io/docs/troubleshoot-integration"
    },
    different_data_domain: %{
      message: "Your data-domain is different",
      recommendation: "Please ensure that the data-domain matches <%= @domain %> exactly",
      url:
        "https://plausible.io/docs/troubleshoot-integration#have-you-added-the-correct-data-domain-attribute-in-the-plausible-snippet"
    },
    illegal_attrs_wp_plugin: %{
      message: "A performance optimization plugin seems to have altered our snippet",
      recommendation:
        "Please whitelist our script in your performance optimization plugin to stop it from changing our snippet",
      url:
        "https://plausible.io/docs/troubleshoot-integration#has-some-other-plugin-altered-our-snippet"
    },
    illegal_attrs_wp_no_plugin: %{
      message: "A performance optimization plugin seems to have altered our snippet",
      recommendation:
        "Please install and activate our WordPress plugin to avoid the most common plugin conflicts",
      url: "https://plausible.io/wordpress-analytics-plugin"
    },
    illegal_attrs_general: %{
      message: "Something seems to have altered our snippet",
      recommendation:
        "Please manually check your integration to make sure that nothing prevents our script from working",
      url:
        "https://plausible.io/docs/troubleshoot-integration#has-some-other-plugin-altered-our-snippet"
    },
    unknown: %{
      message: "Your Plausible integration is not working",
      recommendation:
        "Please manually check your integration to make sure that the Plausible snippet has been inserted correctly",
      url:
        "https://plausible.io/docs/troubleshoot-integration#how-to-manually-check-your-integration"
    }
  }

  def all(), do: @errors

  for {_, %{message: message, recommendation: recommendation} = e} <- @errors do
    if String.ends_with?(message, ".") or String.ends_with?(recommendation, ".") do
      raise "Error message/recommendation should not end with a period: #{inspect(e)}"
    end
  end
end
```

## File: `lib/plausible/installation_support/result.ex`
```
defmodule Plausible.InstallationSupport.Result do
  @moduledoc """
  Diagnostics interpretation result.
  """
  defstruct ok?: false, errors: [], recommendations: []
  @type t :: %__MODULE__{}
end
```

## File: `lib/plausible/installation_support/state.ex`
```
defmodule Plausible.InstallationSupport.State do
  @moduledoc """
  The state to be shared across check during site installation support.

  Assigns are meant to be used to communicate between checks, while
  `diagnostics` are specific to the check group being executed.
  """

  defstruct url: nil,
            data_domain: nil,
            report_to: nil,
            assigns: %{},
            diagnostics: %{}

  @type diagnostics_type ::
          Plausible.InstallationSupport.LegacyVerification.Diagnostics.t()
          | Plausible.InstallationSupport.Verification.Diagnostics.t()

  @type t :: %__MODULE__{
          url: String.t() | nil,
          data_domain: String.t() | nil,
          report_to: pid() | nil,
          assigns: map(),
          diagnostics: diagnostics_type()
        }

  def assign(%__MODULE__{} = state, assigns) do
    %{state | assigns: Map.merge(state.assigns, Enum.into(assigns, %{}))}
  end

  def put_diagnostics(%__MODULE__{} = state, diagnostics) when is_list(diagnostics) do
    %{state | diagnostics: struct!(state.diagnostics, diagnostics)}
  end

  def put_diagnostics(%__MODULE__{} = state, diagnostics) do
    put_diagnostics(state, List.wrap(diagnostics))
  end
end
```

## File: `lib/plausible/installation_support/url.ex`
```
defmodule Plausible.InstallationSupport.URL do
  @moduledoc """
  URL utilities for installation support, including cache busting functionality.
  """

  def bust_url(url) do
    cache_invalidator = abs(:erlang.unique_integer())
    update_url(url, cache_invalidator)
  end

  defp update_url(url, invalidator) do
    url
    |> URI.parse()
    |> then(fn uri ->
      updated_query =
        (uri.query || "")
        |> URI.decode_query()
        |> Map.put("plausible_verification", invalidator)
        |> URI.encode_query()

      struct!(uri, query: updated_query)
    end)
    |> to_string()
  end
end
```

## File: `lib/plausible/installation_support/verification/checks.ex`
```
defmodule Plausible.InstallationSupport.Verification.Checks do
  @moduledoc """
  Checks that are performed during tracker script installation verification.

  In async execution, each check notifies the caller by sending a message to it.
  """
  alias Plausible.InstallationSupport.Verification
  alias Plausible.InstallationSupport.{State, CheckRunner, Checks}

  require Logger

  @checks [
    Checks.InstallationV2,
    Checks.InstallationV2CacheBust
  ]

  def run(url, data_domain, installation_type, opts \\ []) do
    checks = Keyword.get(opts, :checks, @checks)
    report_to = Keyword.get(opts, :report_to, self())
    async? = Keyword.get(opts, :async?, true)
    slowdown = Keyword.get(opts, :slowdown, 500)

    init_state =
      %State{
        url: url,
        data_domain: data_domain,
        report_to: report_to,
        diagnostics: %Verification.Diagnostics{
          selected_installation_type: installation_type
        }
      }

    CheckRunner.run(init_state, checks,
      async?: async?,
      report_to: report_to,
      slowdown: slowdown
    )
  end

  def interpret_diagnostics(%State{} = state) do
    Verification.Diagnostics.interpret(
      state.diagnostics,
      state.data_domain,
      state.url
    )
  end
end
```

## File: `lib/plausible/installation_support/verification/diagnostics.ex`
```
defmodule Plausible.InstallationSupport.Verification.Diagnostics do
  @moduledoc """
  Module responsible for translating diagnostics to user-friendly errors and recommendations.
  """
  require Logger

  # in this struct, nil means indeterminate
  defstruct selected_installation_type: nil,
            disallowed_by_csp: nil,
            plausible_is_on_window: nil,
            plausible_is_initialized: nil,
            plausible_version: nil,
            plausible_variant: nil,
            diagnostics_are_from_cache_bust: nil,
            test_event: nil,
            cookie_banner_likely: nil,
            service_error: nil

  @type t :: %__MODULE__{}

  alias Plausible.InstallationSupport.Result

  defmodule Error do
    @moduledoc """
    Error that has compile-time enforced checks for the attributes.
    """

    @enforce_keys [:message, :recommendation]
    defstruct [:message, :recommendation, :url]

    def new!(attrs) do
      message = Map.fetch!(attrs, :message)

      if String.ends_with?(message, ".") do
        raise ArgumentError, "Error message must not end with a period: #{inspect(message)}"
      end

      if String.ends_with?(attrs[:recommendation], ".") do
        raise ArgumentError,
              "Error recommendation must not end with a period: #{inspect(attrs[:recommendation])}"
      end

      if is_binary(attrs[:url]) and not String.starts_with?(attrs[:url], "https://plausible.io") do
        raise ArgumentError,
              "Recommendation url must start with 'https://plausible.io': #{inspect(attrs[:url])}"
      end

      struct!(__MODULE__, attrs)
    end
  end

  @error_unexpected_domain Error.new!(%{
                             message: "Plausible test event is not for this site",
                             recommendation:
                               "Please check that the snippet on your site matches the installation instructions exactly",
                             url:
                               "https://plausible.io/docs/troubleshoot-integration#how-to-manually-check-your-integration"
                           })
  @error_succeeds_only_after_cache_bust Error.new!(%{
                                          message: "We detected an issue with your site's cache",
                                          recommendation:
                                            "Please clear the cache for your site to ensure that your visitors will load the latest version of your site that has Plausible correctly installed",
                                          url:
                                            "https://plausible.io/docs/troubleshoot-integration#have-you-cleared-the-cache-of-your-site"
                                        })
  @spec interpret(t(), String.t(), String.t()) :: Result.t()
  def interpret(
        %__MODULE__{
          plausible_is_on_window: true,
          plausible_is_initialized: true,
          test_event: %{
            "normalizedBody" => %{
              "domain" => domain
            },
            "responseStatus" => response_status
          },
          service_error: nil,
          diagnostics_are_from_cache_bust: diagnostics_are_from_cache_bust
        } = diagnostics,
        expected_domain,
        url
      )
      when response_status in [200, 202] do
    domain_is_expected? = domain == expected_domain

    cond do
      domain_is_expected? and diagnostics_are_from_cache_bust ->
        error(@error_succeeds_only_after_cache_bust)

      domain_is_expected? ->
        success()

      not domain_is_expected? ->
        error(@error_unexpected_domain)

      true ->
        unknown_error(diagnostics, url)
    end
  end

  @error_csp_disallowed Error.new!(%{
                          message:
                            "We encountered an issue with your site's Content Security Policy (CSP)",
                          recommendation:
                            "Please add plausible.io domain specifically to the allowed list of domains in your site's CSP",
                          url:
                            "https://plausible.io/docs/troubleshoot-integration#does-your-site-use-a-content-security-policy-csp"
                        })
  def interpret(
        %__MODULE__{
          disallowed_by_csp: true,
          service_error: nil
        },
        _expected_domain,
        _url
      ) do
    error(@error_csp_disallowed)
  end

  def interpret(%__MODULE__{} = diagnostics, _expected_domain, url),
    do: unknown_error(diagnostics, url)

  defp success() do
    %Result{ok?: true}
  end

  defp error(%Error{} = error) do
    %Result{
      ok?: false,
      errors: [error.message],
      recommendations: [%{text: error.recommendation, url: error.url}]
    }
  end

  @unknown_error Error.new!(%{
                   message: "Your Plausible integration is not working",
                   recommendation:
                     "Please manually check your integration to make sure that the Plausible snippet has been inserted correctly",
                   url:
                     "https://plausible.io/docs/troubleshoot-integration#how-to-manually-check-your-integration"
                 })
  defp unknown_error(diagnostics, url) do
    Sentry.capture_message("Unhandled case for site verification (v2)",
      extra: %{
        message: inspect(diagnostics),
        url: url,
        hash: :erlang.phash2(diagnostics)
      }
    )

    error(@unknown_error)
  end
end
```

## File: `lib/plausible/mailer.ex`
```
defmodule Plausible.Mailer do
  use Bamboo.Mailer, otp_app: :plausible
  require Logger

  @spec send(Bamboo.Email.t()) :: :ok | {:error, :unknown_error}
  def send(email) do
    try do
      deliver_now!(email)
    rescue
      e ->
        # this message is ignored by Sentry, only appears in logs
        log = "Failed to send e-mail:\n\n  " <> Exception.format(:error, e, __STACKTRACE__)
        # Sentry report is built entirely from crash_reason
        crash_reason = {e, __STACKTRACE__}

        Logger.error(log, crash_reason: crash_reason)
        {:error, :unknown_error}
    else
      _sent_email -> :ok
    end
  end
end
```

## File: `lib/plausible/migration_utils.ex`
```
defmodule Plausible.MigrationUtils do
  @moduledoc """
  Base module for to use in Clickhouse migrations
  """

  use Plausible

  alias Plausible.IngestRepo

  def on_cluster_statement(table) do
    if(IngestRepo.clustered_table?(table), do: "ON CLUSTER '{cluster}'", else: "")
  end

  # See https://clickhouse.com/docs/en/sql-reference/dictionaries#clickhouse for context
  def dictionary_connection_params() do
    IngestRepo.config()
    |> Enum.map(fn
      {:database, database} -> "DB '#{database}'"
      {:username, username} -> "USER '#{username}'"
      {:password, password} -> "PASSWORD '#{password}'"
      _ -> nil
    end)
    |> Enum.reject(&is_nil/1)
    |> Enum.join(" ")
  end

  def table_settings() do
    IngestRepo.config()
    |> Keyword.get(:table_settings)
    |> Enum.reject(fn {_, v} -> is_nil(v) end)
  end

  def table_settings_expr(type \\ :prefix) do
    expr = Enum.map_join(table_settings(), ", ", fn {k, v} -> "#{k} = #{encode(v)}" end)

    case {table_settings(), type} do
      {[], _} -> ""
      {_, :prefix} -> "SETTINGS #{expr}"
      {_, :suffix} -> ", #{expr}"
    end
  end

  def enterprise_edition?(), do: ee?()

  def community_edition?(), do: ce?()

  defp encode(value) when is_number(value), do: value
  defp encode(value) when is_binary(value), do: "'#{value}'"
end
```

## File: `lib/plausible/open_telemetry.ex`
```
defmodule Plausible.OpenTelemetry do
  @moduledoc false

  require OpenTelemetry.Tracer, as: Tracer

  def add_site_attributes(site) do
    case site do
      %Plausible.Site{} = site ->
        Tracer.set_attributes([
          {"plausible.site.id", site.id},
          {"plausible.site.domain", site.domain}
        ])

      id when is_integer(id) ->
        Tracer.set_attributes([{"plausible.site.id", id}])

      _any ->
        :ignore
    end
  end

  def add_user_attributes(user) do
    case user do
      %Plausible.Auth.User{} = user ->
        Tracer.set_attributes([
          {"plausible.user.id", user.id},
          {"plausible.user.name", user.name},
          {"plausible.user.email", user.email}
        ])

      id when is_integer(id) ->
        Tracer.set_attributes([{"plausible.user.id", id}])

      _any ->
        :ignore
    end
  end

  # https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/resource/semantic_conventions/README.md#service
  def resource_attributes(runtime_metadata) do
    [
      {"service.name", "analytics"},
      {"service.namespace", "plausible"},
      {"service.instance.app_host", runtime_metadata[:app_host]},
      {"service.instance.id", runtime_metadata[:host]},
      {"service.version", runtime_metadata[:version]}
    ]
  end
end
```

## File: `lib/plausible/open_telemetry/sampler.ex`
```
defmodule Plausible.OpenTelemetry.Sampler do
  @moduledoc """
  [Custom OpenTelemetry sampler](https://hexdocs.pm/opentelemetry/readme.html#samplers)
  implementation that ignores particular traces to reduce noise. Ingestion
  HTTP requests and queries to Oban tables are ignored, for example.

  For non-ignored traces, implements trace ID ratio-based sampling following the method
  from [built-in sampler](https://github.com/open-telemetry/opentelemetry-erlang/blob/main/apps/opentelemetry/src/otel_sampler_trace_id_ratio_based.erl).
  """

  import Bitwise, only: [&&&: 2]

  # mask for extracting first 64 bits of trace ID
  # 2^63 - 1
  @max_value 9_223_372_036_854_775_807

  @behaviour :otel_sampler
  require OpenTelemetry.Tracer, as: Tracer

  @routes_to_ignore ["/api/event", "/api/event/", "/api//event", "//api/event"]
  @tables_to_ignore ["oban_jobs", "site_imports"]

  @impl true
  def setup(%{ratio: ratio}) when is_number(ratio) do
    %{ratio: ratio, id_upper_bound: ratio * @max_value}
  end

  @impl true
  def description(%{ratio: ratio}) do
    "#{inspect(__MODULE__)}{ratio=#{ratio}}"
  end

  @impl true
  def should_sample(context, trace_id, _links, _name, _kind, attributes, config) do
    tracestate = context |> Tracer.current_span_ctx() |> OpenTelemetry.Span.tracestate()

    case attributes do
      %{"db.instance": _db, source: source} when source in @tables_to_ignore ->
        {:drop, [], tracestate}

      %{"http.target": http_target} when http_target in @routes_to_ignore ->
        {:drop, [], tracestate}

      _any ->
        {decide(trace_id, config.id_upper_bound), [], tracestate}
    end
  end

  defp decide(trace_id, id_upper_bound) when is_integer(trace_id) and trace_id > 0 do
    lower_64_bits = trace_id &&& @max_value

    if abs(lower_64_bits) < id_upper_bound do
      :record_and_sample
    else
      :drop
    end
  end

  defp decide(_, _), do: :drop
end
```

## File: `lib/plausible/pagination.ex`
```
defmodule Plausible.Pagination do
  @moduledoc """
  Cursor-based pagination.
  """

  @limit 10
  @maximum_limit 100

  @spec paginate(Ecto.Queryable.t(), map(), Keyword.t(), Keyword.t()) :: Paginator.Page.t()
  def paginate(queryable, params, opts, repo_opts \\ []) do
    opts = Keyword.merge([limit: @limit, maximum_limit: @maximum_limit], opts)

    Paginator.paginate(
      queryable,
      Keyword.merge(opts, to_pagination_opts(params)),
      Plausible.Repo,
      repo_opts
    )
  end

  defp to_pagination_opts(params) do
    Enum.reduce(params, Keyword.new(), fn
      {"after", cursor}, acc ->
        Keyword.put(acc, :after, cursor)

      {"before", cursor}, acc ->
        Keyword.put(acc, :before, cursor)

      {"limit", limit}, acc ->
        limit = to_int(limit)

        if limit > 0 and limit <= @maximum_limit do
          Keyword.put(acc, :limit, limit)
        else
          acc
        end

      _, acc ->
        acc
    end)
  end

  defp to_int(x) when is_binary(x), do: String.to_integer(x)
  defp to_int(x) when is_integer(x), do: x
end
```

## File: `lib/plausible/plugins/api/capabilities.ex`
```
defmodule Plausible.Plugins.API.Capabilities do
  @moduledoc """
  Context module for querying API capabilities
  """
  require Plausible.Billing.Feature
  alias Plausible.Billing.Feature

  @spec get(Plug.Conn.t()) :: {:ok, map()}
  def get(conn) do
    conn = PlausibleWeb.Plugs.AuthorizePluginsAPI.call(conn, send_error?: false)

    site = conn.assigns[:authorized_site]

    features =
      if site do
        site = Plausible.Repo.preload(site, :team)

        Feature.list()
        |> Enum.map(fn mod ->
          result = mod.check_availability(site.team)
          feature = mod |> Module.split() |> List.last()
          {feature, result == :ok}
        end)
      else
        Enum.map(Feature.list_short_names(), &{&1, false})
      end

    {:ok,
     %{
       authorized: not is_nil(site),
       data_domain: site && site.domain,
       features: Enum.into(features, %{})
     }}
  end
end
```

## File: `lib/plausible/plugins/api/custom_props.ex`
```
defmodule Plausible.Plugins.API.CustomProps do
  @moduledoc """
  Plugins API context module for Custom Props.
  All high level Custom Props operations should be implemented here.
  """

  @spec enable(Plausible.Site.t(), String.t() | [String.t()]) ::
          {:ok, [String.t()]} | {:error, :upgrade_required | Ecto.Changeset.t()}
  def enable(site, prop_or_props) do
    case Plausible.Props.allow(site, prop_or_props) do
      {:ok, site} ->
        {:ok, site.allowed_event_props}

      error ->
        error
    end
  end

  @spec disable(Plausible.Site.t(), String.t() | [String.t()]) ::
          :ok | {:error, Ecto.Changeset.t()}
  def disable(site, prop_or_props) do
    case Plausible.Props.disallow(site, prop_or_props) do
      {:ok, _site} -> :ok
      error -> error
    end
  end
end
```

## File: `lib/plausible/plugins/api/goals.ex`
```
defmodule Plausible.Plugins.API.Goals do
  @moduledoc """
  Plugins API context module for Goals.
  All high level Goal operations should be implemented here.
  """
  use Plausible

  import Plausible.Pagination

  alias Plausible.Repo
  alias PlausibleWeb.Plugins.API.Schemas.Goal.CreateRequest

  @type create_request() ::
          CreateRequest.CustomEvent.t()
          | CreateRequest.Revenue.t()
          | CreateRequest.Pageview.t()

  @spec create(
          Plausible.Site.t(),
          create_request() | list(create_request())
        ) ::
          {:ok, list(Plausible.Goal.t())}
          | {:error, Ecto.Changeset.t()}
          | {:error, :upgrade_required}
  def create(site, goal_or_goals) do
    Repo.transaction(fn -> find_or_create(site, goal_or_goals) end)
  end

  @spec get_goals(Plausible.Site.t(), map()) :: {:ok, Paginator.Page.t()}
  def get_goals(site, params) do
    query = Plausible.Goals.for_site_query(site, preload_funnels?: false)

    {:ok, paginate(query, params, cursor_fields: [{:id, :desc}])}
  end

  @spec get(Plausible.Site.t(), pos_integer()) :: nil | Plausible.Goal.t()
  def get(site, id) when is_integer(id) do
    Plausible.Goals.get(site, id)
  end

  @spec delete(Plausible.Site.t(), [pos_integer()] | pos_integer()) :: :ok
  def delete(site, id_or_ids) do
    Plausible.Repo.transaction(fn ->
      id_or_ids
      |> List.wrap()
      |> Enum.each(fn id when is_integer(id) ->
        Plausible.Goals.delete(id, site)
      end)
    end)

    :ok
  end

  defp convert_to_create_params(%CreateRequest.CustomEvent{goal: %{event_name: event_name}}) do
    %{"goal_type" => "event", "event_name" => event_name}
  end

  defp convert_to_create_params(%CreateRequest.Revenue{
         goal: %{event_name: event_name, currency: currency}
       }) do
    %{"goal_type" => "event", "event_name" => event_name, "currency" => currency}
  end

  defp convert_to_create_params(%CreateRequest.Pageview{goal: %{path: page_path}}) do
    %{"goal_type" => "page", "page_path" => page_path}
  end

  defp find_or_create(site, goal_or_goals) do
    goal_or_goals
    |> List.wrap()
    |> Enum.map(fn goal ->
      case Plausible.Goals.find_or_create(site, convert_to_create_params(goal)) do
        {:ok, goal} ->
          goal

        {:error, changeset} ->
          Repo.rollback(changeset)
      end
    end)
  end
end
```

## File: `lib/plausible/plugins/api/shared_links.ex`
```
defmodule Plausible.Plugins.API.SharedLinks do
  @moduledoc """
  Plugins API context module for Shared Links.
  All high level Shared Links operations should be implemented here.
  """
  import Ecto.Query
  import Plausible.Pagination

  alias Plausible.Repo

  @spec get_shared_links(Plausible.Site.t(), map()) :: {:ok, Paginator.Page.t()}
  def get_shared_links(site, params) do
    query =
      from l in Plausible.Site.SharedLink,
        where: l.site_id == ^site.id,
        order_by: [desc: l.id]

    {:ok, paginate(query, params, cursor_fields: [{:id, :desc}])}
  end

  @spec get(Plausible.Site.t(), pos_integer() | String.t()) :: nil | Plausible.Site.SharedLink.t()
  def get(site, id) when is_integer(id) do
    get_by_id(site, id)
  end

  def get(site, name) when is_binary(name) do
    get_by_name(site, name)
  end

  @spec get_or_create(Plausible.Site.t(), String.t(), String.t() | nil) ::
          {:ok, Plausible.Site.SharedLink.t()}
  def get_or_create(site, name, password \\ nil) do
    case get_by_name(site, name) do
      nil ->
        Plausible.Sites.create_shared_link(site, name,
          password: password,
          skip_feature_check?: true,
          skip_special_name_check?: true
        )

      shared_link ->
        {:ok, shared_link}
    end
  end

  defp get_by_id(site, id) do
    Repo.one(
      from l in Plausible.Site.SharedLink,
        where: l.site_id == ^site.id,
        where: l.id == ^id
    )
  end

  defp get_by_name(site, name) do
    Repo.one(
      from l in Plausible.Site.SharedLink,
        where: l.site_id == ^site.id,
        where: l.name == ^name
    )
  end
end
```

## File: `lib/plausible/plugins/api/token.ex`
```
defmodule Plausible.Plugins.API.Token do
  @moduledoc """
  Ecto schema for Plugins API Tokens.
  Tokens are stored hashed and require a description.

  Tokens are considered secret, although the Plugins API
  by nature will expose very little, if any, destructive/insecure operations.

  The raw token version is meant to be presented to the user upon creation.
  It is prefixed with a plain text identifier allowing source scanning
  for leaked secrets.
  """
  use Plausible
  use Ecto.Schema
  import Ecto.Changeset

  alias Plausible.Site

  @type t() :: %__MODULE__{}

  @primary_key {:id, :binary_id, autogenerate: true}
  schema "plugins_api_tokens" do
    timestamps()
    field(:token_hash, :binary)
    field(:description, :string)
    field(:hint, :string)
    field(:last_used_at, :naive_datetime)

    belongs_to(:site, Site)
  end

  @spec generate(String.t()) :: map()
  def generate(random_bytes \\ random_bytes()) do
    raw = prefixed(random_bytes)
    hash = hash(raw)

    %{
      raw: raw,
      hash: hash
    }
  end

  @spec hash(String.t()) :: binary()
  def hash(raw) do
    :crypto.hash(:sha256, raw)
  end

  @fields [:description, :site_id]
  @required_fields [:description, :site, :token_hash, :hint]

  @spec insert_changeset(Site.t(), map(), map()) :: Ecto.Changeset.t()
  def insert_changeset(site, %{hash: hash, raw: raw}, attrs \\ %{}) do
    %__MODULE__{}
    |> cast(attrs, @fields)
    |> put_change(:token_hash, hash)
    |> put_change(:hint, String.slice(raw, -4, 4))
    |> put_assoc(:site, site)
    |> validate_required(@required_fields)
  end

  @doc """
  Raw tokens are prefixed so that tools like
  https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning
  can scan repositories for accidental secret commits.
  """
  def prefix() do
    on_ee do
      env = Application.get_env(:plausible, :environment)

      case env do
        "prod" -> "plausible-plugin"
        env -> "plausible-plugin-#{env}"
      end
    else
      "plausible-plugin-selfhost"
    end
  end

  @spec last_used_humanize(t()) :: String.t()
  def last_used_humanize(token) do
    diff =
      if token.last_used_at do
        now = NaiveDateTime.utc_now()
        NaiveDateTime.diff(now, token.last_used_at, :minute)
      end

    cond do
      is_nil(diff) -> "Not yet"
      diff < 5 -> "Just recently"
      diff < 30 -> "Several minutes ago"
      diff < 70 -> "An hour ago"
      diff < 24 * 60 -> "Hours ago"
      diff < 24 * 60 * 2 -> "Yesterday"
      diff < 24 * 60 * 7 -> "Sometime this week"
      true -> "Long time ago"
    end
  end

  defp prefixed(random_bytes) do
    Enum.join([prefix(), random_bytes], "-")
  end

  defp random_bytes() do
    30 |> :crypto.strong_rand_bytes() |> Base.encode64()
  end
end
```

## File: `lib/plausible/plugins/api/tokens.ex`
```
defmodule Plausible.Plugins.API.Tokens do
  @moduledoc """
  Context module for Plugins API Tokens.
  Exposes high-level operation for token-based authentication flows.
  """
  alias Plausible.Plugins.API.Token
  alias Plausible.Site
  alias Plausible.Repo

  import Ecto.Query

  @spec create(Site.t(), String.t()) ::
          {:ok, Token.t(), String.t()} | {:error, Ecto.Changeset.t()}
  def create(%Site{} = site, description, generated_token \\ Token.generate()) do
    with changeset <- Token.insert_changeset(site, generated_token, %{description: description}),
         {:ok, saved_token} <- Repo.insert(changeset) do
      {:ok, saved_token, generated_token.raw}
    end
  end

  @spec find(String.t()) :: {:ok, Token.t()} | {:error, :not_found}
  def find(raw) do
    found =
      Repo.one(
        from(t in Token,
          inner_join: s in Site,
          on: s.id == t.site_id,
          where: t.token_hash == ^Token.hash(raw),
          preload: [:site]
        )
      )

    if found do
      {:ok, found}
    else
      {:error, :not_found}
    end
  end

  @spec delete(Site.t(), String.t()) :: :ok
  def delete(site, token_id) do
    Repo.delete_all(from(t in Token, where: t.site_id == ^site.id and t.id == ^token_id))
    :ok
  end

  @spec list(Site.t()) :: {:ok, [Token.t()]}
  def list(site) do
    Repo.all(
      from(t in Token, where: t.site_id == ^site.id, order_by: [desc: t.inserted_at, desc: t.id])
    )
  end

  @spec any?(Site.t()) :: boolean()
  def any?(site) do
    Repo.exists?(from(t in Token, where: t.site_id == ^site.id))
  end

  @spec update_last_seen(Token.t(), NaiveDateTime.t()) :: {:ok, Token.t()}
  def update_last_seen(token, now \\ NaiveDateTime.utc_now()) do
    # we don't need very precise timestamp tracking, and to spare postgres we only
    # update that timestamp in 5m windows - this is mostly to help users reason
    # about what token they have, in case of rotations
    now = NaiveDateTime.truncate(now, :second)
    last_used = token.last_used_at

    if is_nil(last_used) or NaiveDateTime.diff(now, last_used, :minute) > 5 do
      token
      |> Ecto.Changeset.change(%{last_used_at: now})
      |> Repo.update()
    else
      {:ok, token}
    end
  end
end
```

## File: `lib/plausible/prom_ex.ex`
```
defmodule Plausible.PromEx do
  use PromEx, otp_app: :plausible

  alias PromEx.Plugins

  @plugins [
    Plugins.Application,
    Plugins.Beam,
    Plugins.PhoenixLiveView,
    {Plugins.Phoenix, router: PlausibleWeb.Router, endpoint: PlausibleWeb.Endpoint},
    {Plugins.Ecto,
     repos: [
       Plausible.Repo,
       Plausible.ClickhouseRepo,
       Plausible.IngestRepo,
       Plausible.AsyncInsertRepo
     ]},
    Plausible.PromEx.Plugins.PlausibleMetrics
  ]

  @impl true
  if Mix.env() in [:test, :ce_test] do
    # PromEx tries to query Oban's DB tables in order to retrieve metrics.
    # During tests, however, this is pointless as Oban is in manual mode,
    # and that leads to connection ownership clashes.
    def plugins do
      @plugins
    end
  else
    def plugins do
      [Plugins.Oban | @plugins]
    end
  end

  @impl true
  def dashboard_assigns do
    [
      datasource_id: "grafanacloud-prom",
      default_selected_interval: "30s"
    ]
  end

  @impl true
  def dashboards do
    [
      {:prom_ex, "application.json"},
      {:prom_ex, "beam.json"},
      {:prom_ex, "phoenix.json"},
      {:prom_ex, "ecto.json"},
      {:prom_ex, "oban.json"}
    ]
  end
end
```

## File: `lib/plausible/prom_ex/buckets.ex`
```
defmodule Plausible.PromEx.Buckets do
  @moduledoc """
  Adapts `Peep` for `PromEx`.

  Based on `Peep.Buckets.Custom` and `TelemetryMetricsPrometheus.Core`.
  """

  @behaviour Peep.Buckets

  @impl true
  def config(%Telemetry.Metrics.Distribution{reporter_options: reporter_options}) do
    # PromEx configures buckets with `:reporter_options`
    buckets = Keyword.fetch!(reporter_options, :buckets)

    if Enum.empty?(buckets) do
      raise ArgumentError, "expected buckets list to be non-empty, got #{inspect(buckets)}"
    end

    unless Enum.all?(buckets, &is_number/1) do
      raise ArgumentError,
            "expected buckets list to contain only numbers, got #{inspect(buckets)}"
    end

    unless buckets == Enum.uniq(Enum.sort(buckets)) do
      raise ArgumentError, "expected buckets to be ordered ascending, got #{inspect(buckets)}"
    end

    number_of_buckets = length(buckets)

    int_tree = :gb_trees.from_orddict(int_buckets(buckets, nil, 0))

    float_tree =
      Enum.map(buckets, &(&1 * 1.0))
      |> Enum.with_index()
      |> :gb_trees.from_orddict()

    upper_bound =
      buckets
      |> Enum.with_index()
      |> Map.new(fn {boundary, bucket_idx} -> {bucket_idx, to_string(boundary * 1.0)} end)

    %{
      number_of_buckets: number_of_buckets,
      int_tree: int_tree,
      float_tree: float_tree,
      upper_bound: upper_bound
    }
  end

  @impl true
  def number_of_buckets(config) do
    config.number_of_buckets
  end

  @impl true
  def bucket_for(number, config) when is_integer(number) do
    case :gb_trees.larger(number, config.int_tree) do
      {_, bucket_idx} -> bucket_idx
      :none -> config.number_of_buckets
    end
  end

  def bucket_for(number, config) when is_float(number) do
    case :gb_trees.larger(number, config.float_tree) do
      {_, bucket_idx} -> bucket_idx
      :none -> config.number_of_buckets
    end
  end

  @impl true
  def upper_bound(bucket_idx, config) do
    Map.get(config.upper_bound, bucket_idx, "+Inf")
  end

  defp int_buckets([], _prev, _counter) do
    []
  end

  defp int_buckets([curr | tail], prev, counter) do
    case ceil(curr) do
      ^prev -> int_buckets(tail, prev, counter + 1)
      curr -> [{curr, counter} | int_buckets(tail, curr, counter + 1)]
    end
  end
end
```

## File: `lib/plausible/prom_ex/striped_peep.ex`
```
defmodule Plausible.PromEx.StripedPeep do
  @moduledoc """
  "Striped" storage based on `PromEx.Storage.Peep`.
  """

  @behaviour PromEx.Storage

  @impl true
  def scrape(name) do
    Peep.get_all_metrics(name)
    |> Peep.Prometheus.export()
    |> IO.iodata_to_binary()
  end

  @impl true
  def child_spec(name, metrics) do
    opts = [
      name: name,
      metrics: metrics,
      storage: :striped
    ]

    Peep.child_spec(opts)
  end
end
```

## File: `lib/plausible/props.ex`
```
defmodule Plausible.Props do
  @moduledoc """
  Context module for handling custom event props.
  """

  import Ecto.Query

  @type prop :: String.t()

  @max_props 300
  def max_props, do: @max_props

  @max_prop_key_length 300
  def max_prop_key_length, do: @max_prop_key_length

  @max_prop_value_length 2000
  def max_prop_value_length, do: @max_prop_value_length

  # NOTE: Keep up to date with `Plausible.Imported.imported_custom_props/0`.
  @internal_keys ~w(url path search_query)

  @doc """
  Lists prop keys used internally.

  These props should be allowed by default, and should not be displayed in the
  props settings page. For example, `url` is a special prop key used for file
  downloads and outbound links. It doesn't make sense to remove this prop key
  from the allow list, or to suggest users to add this prop key.
  """
  def internal_keys, do: @internal_keys

  @doc """
  Returns the custom props allowed in queries for the given site. There are
  two factors deciding whether a custom property is allowed for a site.

  ### 1. Subscription plan including the props feature.

  Internally used keys (i.e. `#{inspect(@internal_keys)}`) are always allowed,
  even for plans that don't include props. For any other props, access to the
  Custom Properties feature is required.

  ### 2. The site having an `allowed_event_props` list configured.

  For customers with a configured `allowed_event_props` list, this function
  returns that list (+ internally used keys). That helps to filter out garbage
  props which people might not want to see in their dashboards.

  With the `bypass_setup?` boolean option you can override the requirement of
  the site having set up props in the `allowed_event_props` list. For example,
  this is currently used for fetching allowed properties in Stats API queries
  in order to ensure the props feature access.

  Since `allowed_event_props` was added after the props feature had already
  been used for a while, there are sites with `allowed_event_props = nil`. For
  those sites, all custom properties that exist in the database are allowed to
  be queried.
  """
  @spec allowed_for(Plausible.Site.t()) :: [prop()] | :all
  def allowed_for(site, opts \\ []) do
    site = Plausible.Repo.preload(site, :team)
    internal_keys = Plausible.Props.internal_keys()
    props_enabled? = Plausible.Billing.Feature.Props.check_availability(site.team) == :ok
    bypass_setup? = Keyword.get(opts, :bypass_setup?)

    cond do
      props_enabled? && is_nil(site.allowed_event_props) -> :all
      props_enabled? && bypass_setup? -> :all
      props_enabled? -> site.allowed_event_props ++ internal_keys
      true -> internal_keys
    end
  end

  @spec allow(Plausible.Site.t(), [prop()] | prop()) ::
          {:ok, Plausible.Site.t()} | {:error, Ecto.Changeset.t()} | {:error, :upgrade_required}
  @doc """
  Allows a prop key or a list of props keys to be included in ClickHouse
  queries. Allowing prop keys does not affect ingestion, as we don't want any
  data to be dropped or lost.
  """
  def allow(site, prop_or_props) do
    with site <- Plausible.Repo.preload(site, :team),
         :ok <- ensure_prop_key_accessible(prop_or_props, site.team) do
      site
      |> allow_changeset(prop_or_props)
      |> Plausible.Repo.update()
    end
  end

  def allow_changeset(site, prop_or_props) do
    old_props = site.allowed_event_props || []
    new_props = List.wrap(prop_or_props) ++ old_props

    changeset(site, new_props)
  end

  @spec disallow(Plausible.Site.t(), [prop()] | prop()) ::
          {:ok, Plausible.Site.t()} | {:error, Ecto.Changeset.t()}
  @doc """
  Removes previously allowed prop key(s) from the allow list. This means this
  prop key won't be included in ClickHouse queries. This doesn't drop any
  ClickHouse data, nor affects ingestion.
  """
  def disallow(site, prop_or_props) do
    allowed_event_props = site.allowed_event_props || []

    site
    |> changeset(allowed_event_props -- List.wrap(prop_or_props))
    |> Plausible.Repo.update()
  end

  defp changeset(site, props) do
    props =
      props
      |> Enum.map(&String.trim/1)
      |> Enum.uniq()

    site
    |> Ecto.Changeset.change(allowed_event_props: props)
    |> Ecto.Changeset.validate_length(:allowed_event_props, max: @max_props)
    |> Ecto.Changeset.validate_change(:allowed_event_props, fn field, allowed_props ->
      if Enum.all?(allowed_props, &valid?/1),
        do: [],
        else: [{field, "must be between 1 and #{@max_prop_key_length} characters"}]
    end)
  end

  @spec allow_existing_props(Plausible.Site.t()) ::
          {:ok, Plausible.Site.t()} | {:error, :upgrade_required}
  @doc """
  Allows the #{@max_props} most frequent props keys for a specific site over
  the past 6 months.
  """
  def allow_existing_props(%Plausible.Site{} = site) do
    props_to_allow =
      site
      |> suggest_keys_to_allow()
      |> Enum.filter(&valid?/1)

    allow(site, props_to_allow)
  end

  def ensure_prop_key_accessible(prop_keys, team) when is_list(prop_keys) do
    Enum.reduce_while(prop_keys, :ok, fn prop_key, :ok ->
      case ensure_prop_key_accessible(prop_key, team) do
        :ok -> {:cont, :ok}
        error -> {:halt, error}
      end
    end)
  end

  def ensure_prop_key_accessible(prop_key, team) do
    if prop_key in @internal_keys do
      :ok
    else
      Plausible.Billing.Feature.Props.check_availability(team)
    end
  end

  @spec suggest_keys_to_allow(Plausible.Site.t(), non_neg_integer()) :: [String.t()]
  @doc """
  Queries the events table to fetch the #{@max_props} most frequent prop keys
  for a specific site over the past 6 months, excluding keys that are already
  allowed.
  """
  def suggest_keys_to_allow(%Plausible.Site{} = site, limit \\ @max_props) do
    allowed_event_props = site.allowed_event_props || []

    unnested_keys =
      from e in Plausible.ClickhouseEventV2,
        where: e.site_id == ^site.id,
        where: fragment("? > (NOW() - INTERVAL 6 MONTH)", e.timestamp),
        select: %{key: fragment("arrayJoin(?)", field(e, :"meta.key"))}

    Plausible.ClickhouseRepo.all(
      from uk in subquery(unnested_keys),
        where: uk.key not in ^allowed_event_props,
        where: uk.key not in ^@internal_keys,
        group_by: uk.key,
        select: uk.key,
        order_by: {:desc, count(uk.key)},
        limit: ^limit
    )
  end

  defp valid?(key) do
    String.length(key) in 1..@max_prop_key_length
  end

  @doc """
  Returns whether the site has configured custom props or not.
  """
  def configured?(%Plausible.Site{allowed_event_props: allowed_event_props}) do
    is_list(allowed_event_props) && length(allowed_event_props) > 0
  end
end
```

## File: `lib/plausible/purge.ex`
```
defmodule Plausible.Purge do
  @moduledoc """
  Deletes data from a site.

  Stats are stored on Clickhouse, and unlike other databases data deletion is
  done asynchronously.

  All import tables have MergeTree's deduplication mechanism _disabled_ by setting
  `replicated_deduplication_window` from default 100 to 0. When enabled, every insert
  into a given table is compared against hashes of 100 previous inserts (as complete
  parts, not concrete rows) and ignored when match is found. The prupose of that
  mechanism is making inserts of exact same batches idempotent when retrying them
  shortly after - for instance due to timeout, when the client can't easily tell if
  previous insert succeeded or not. Deduplication, however, only considers inserts,
  not mutations. Deletions do not affect stored hashes, so further inserts of parts
  that were deleted will still be treated as duplicates. That's why this feature
  is disabled for import tables.

  Although deletions are asynchronous, the parts to delete are "remembered", so there's
  no risk of overlapping deletion causing problems with import following right after it.

  IMPORTANT: Deletion requires revision if/when import tables get moved to sharded CH
  cluster setup. Mutation queries, which have to be run with `ON CLUSTER` in such setup,
  dispatch independent queries across shards and those queries can start at different
  times. This in turn means risk of deletions corrupting data of follow-up inserts
  in some edge cases. Ideally, imported entries should be unique for a given import
  - an extra `import_id` column can be introduced, holding identifier.  Last processed
  import identifier should be stored with other site data and should be used for scoping
  imported stats queries. No longer used imports can then be safely removed fully
  asynchronously.

  - [Clickhouse `ALTER TABLE ... DELETE` Statement](https://clickhouse.com/docs/en/sql-reference/statements/alter/delete)
  - [Synchronicity of `ALTER` Queries](https://clickhouse.com/docs/en/sql-reference/statements/alter/#synchronicity-of-alter-queries)
  """

  alias Plausible.Repo

  @spec delete_imported_stats!(Plausible.Site.t() | Plausible.Imported.SiteImport.t()) :: :ok
  @doc """
  Deletes imported stats from and clears the `stats_start_date` field.

  The `stats_start_date` is expected to get repopulated the next time
  `Plausible.Sites.stats_start_date/1` is called.

  If the input argument is a site, all imported stats are deleted. If it's a site import,
  only imported stats for that import are deleted.
  """
  def delete_imported_stats!(%Plausible.Site{} = site) do
    Enum.each(Plausible.Imported.tables(), fn table ->
      sql = "ALTER TABLE #{table} DELETE WHERE site_id = {$0:UInt64}"
      Ecto.Adapters.SQL.query!(Plausible.ImportDeletionRepo, sql, [site.id])
    end)

    Plausible.Sites.clear_stats_start_date!(site)

    :ok
  end

  def delete_imported_stats!(%Plausible.Imported.SiteImport{} = site_import) do
    site_import = Repo.preload(site_import, :site)
    delete_imported_stats!(site_import.site, site_import.id)

    if site_import.legacy do
      delete_imported_stats!(site_import.site, 0)
    end

    :ok
  end

  def delete_imported_stats!(%Plausible.Site{} = site, import_id) do
    Enum.each(Plausible.Imported.tables(), fn table ->
      sql = "ALTER TABLE #{table} DELETE WHERE site_id = {$0:UInt64} AND import_id = {$1:UInt64}"

      Ecto.Adapters.SQL.query!(Plausible.ImportDeletionRepo, sql, [site.id, import_id])
    end)

    Plausible.Sites.clear_stats_start_date!(site)

    :ok
  end

  @spec delete_native_stats!(Plausible.Site.t()) :: :ok
  @doc """
  Move stats pointers so that no historical stats are available.
  """
  def delete_native_stats!(site) do
    reset!(site)

    :ok
  end

  def reset!(site) do
    site
    |> Ecto.Changeset.change(
      native_stats_start_at: NaiveDateTime.utc_now() |> NaiveDateTime.truncate(:second),
      stats_start_date: nil
    )
    |> Plausible.Repo.update!()
  end
end
```

## File: `lib/plausible/rate_limit.ex`
```
defmodule Plausible.RateLimit do
  @moduledoc """
  Thin wrapper around `:ets.update_counter/4` and a
  clean-up process to act as a rate limiter.
  """

  use GenServer

  @doc """
  Starts the process that creates and cleans the ETS table.

  Accepts the following options:
    - `GenServer.option()`
    - `:table` for the ETS table name, defaults to `#{__MODULE__}`
    - `:clean_period` for how often to perform garbage collection
  """
  @spec start_link([GenServer.option() | {:table, atom} | {:clean_period, pos_integer}]) ::
          GenServer.on_start()
  def start_link(opts) do
    {gen_opts, opts} = Keyword.split(opts, [:debug, :name, :spawn_opt, :hibernate_after])
    GenServer.start_link(__MODULE__, opts, gen_opts)
  end

  @doc """
  Checks the rate-limit for a key.
  """
  @spec check_rate(:ets.table(), key, scale, limit, increment) :: {:allow, count} | {:deny, limit}
        when key: term,
             scale: pos_integer,
             limit: pos_integer,
             increment: pos_integer,
             count: pos_integer
  def check_rate(table \\ __MODULE__, key, scale, limit, increment \\ 1) do
    bucket = div(now(), scale)
    full_key = {key, bucket}
    expires_at = (bucket + 1) * scale

    count =
      case :ets.lookup(table, full_key) do
        [{_, counter, _expires_at}] ->
          :atomics.add_get(counter, 1, increment)

        [] ->
          counter = :atomics.new(1, signed: false)

          case :ets.insert_new(table, {full_key, counter, expires_at}) do
            true ->
              :atomics.add_get(counter, 1, increment)

            false ->
              [{_, counter, _expires_at}] = :ets.lookup(table, full_key)
              :atomics.add_get(counter, 1, increment)
          end
      end

    if count <= limit, do: {:allow, count}, else: {:deny, limit}
  end

  @impl true
  def init(opts) do
    clean_period = Keyword.fetch!(opts, :clean_period)
    table = Keyword.get(opts, :table, __MODULE__)

    ^table =
      :ets.new(table, [
        :named_table,
        :set,
        :public,
        {:read_concurrency, true},
        {:write_concurrency, :auto},
        {:decentralized_counters, true}
      ])

    schedule(clean_period)
    {:ok, %{table: table, clean_period: clean_period}}
  end

  @impl true
  def handle_info(:clean, state) do
    clean(state.table)
    schedule(state.clean_period)
    {:noreply, state}
  end

  defp schedule(clean_period) do
    Process.send_after(self(), :clean, clean_period)
  end

  defp clean(table) do
    ms = [{{{:_, :_}, :_, :"$1"}, [], [{:<, :"$1", {:const, now()}}]}]
    :ets.select_delete(table, ms)
  end

  @compile inline: [now: 0]
  defp now do
    System.system_time(:millisecond)
  end
end
```

## File: `lib/plausible/repo.ex`
```
defmodule Plausible.Repo do
  use Ecto.Repo,
    otp_app: :plausible,
    adapter: Ecto.Adapters.Postgres

  use Scrivener, page_size: 24

  use Plausible.Audit.Repo

  defmacro __using__(_) do
    quote do
      alias Plausible.Repo
      import Ecto
      import Ecto.Query, only: [from: 1, from: 2]
    end
  end
end
```

## File: `lib/plausible/request_logger.ex`
```
defmodule Plausible.RequestLogger do
  @moduledoc """
  Custom request logger which:
  - Includes query parameters on the same line
  - Includes request duration on the same line
  """

  require Logger

  def log_request(_, %{duration: duration}, %{conn: conn}, _) do
    duration_ms = System.convert_time_unit(duration, :native, :millisecond)
    path = path_with_params(conn.request_path, conn.query_string)

    Logger.info("(#{conn.status}) #{conn.method} #{path} took #{duration_ms}ms")
  end

  defp path_with_params(request_path, ""), do: request_path
  defp path_with_params(request_path, query_string), do: request_path <> "?" <> query_string
end
```

## File: `lib/plausible/s3.ex`
```
defmodule Plausible.S3 do
  @moduledoc """
  Helper functions for S3 exports/imports.
  """

  @doc """
  Returns the pre-configured S3 bucket for CSV exports.

      config :plausible, Plausible.S3,
        exports_bucket: System.fetch_env!("S3_EXPORTS_BUCKET")

  Example:

      iex> exports_bucket()
      "test-exports"

  """
  @spec exports_bucket :: String.t()
  def exports_bucket, do: config(:exports_bucket)

  @doc """
  Returns the pre-configured S3 bucket for CSV imports.

      config :plausible, Plausible.S3,
        imports_bucket: System.fetch_env!("S3_IMPORTS_BUCKET")

  Example:

      iex> imports_bucket()
      "test-imports"

  """
  @spec imports_bucket :: String.t()
  def imports_bucket, do: config(:imports_bucket)

  defp config, do: Application.fetch_env!(:plausible, __MODULE__)
  defp config(key), do: Keyword.fetch!(config(), key)

  @doc """
  Presigns an upload for an imported file.

  In the current implementation the bucket always goes into the path component.

  Example:

      iex> upload = import_presign_upload(_site_id = 123, _filename = "imported_browsers.csv")
      iex> true = String.ends_with?(upload.s3_url, "/test-imports/123/imported_browsers.csv")
      iex> true = String.contains?(upload.presigned_url, "/test-imports/123/imported_browsers.csv?X-Amz-Algorithm=AWS4-HMAC-SHA256&")

  """
  def import_presign_upload(site_id, filename) do
    config = ExAws.Config.new(:s3)
    s3_path = Path.join(Integer.to_string(site_id), filename)
    bucket = imports_bucket()
    {:ok, presigned_url} = ExAws.S3.presigned_url(config, :put, bucket, s3_path)
    %{s3_url: extract_s3_url(presigned_url), presigned_url: presigned_url}
  end

  # to make ClickHouse see MinIO in dev and test envs we replace
  # the host in the S3 URL with host.docker.internal or whatever's set in $MINIO_HOST_FOR_CLICKHOUSE
  if Mix.env() in [:dev, :test, :ce_dev, :ce_test] do
    defp extract_s3_url(presigned_url) do
      [s3_url, _] = String.split(presigned_url, "?")
      default_ch_host = unless System.get_env("CI"), do: "host.docker.internal"
      ch_host = System.get_env("MINIO_HOST_FOR_CLICKHOUSE", default_ch_host)
      URI.to_string(%URI{URI.parse(s3_url) | host: ch_host})
    end
  else
    defp extract_s3_url(presigned_url) do
      [s3_url, _] = String.split(presigned_url, "?")
      s3_url
    end
  end

  @doc """
  Chunks and uploads Zip archive to the provided S3 destination.

  In the current implementation the bucket always goes into the path component.
  """
  @spec export_upload_multipart(Enumerable.t(), String.t(), Path.t(), String.t()) :: :ok
  def export_upload_multipart(stream, s3_bucket, s3_path, filename) do
    # 5 MiB is the smallest chunk size AWS S3 supports
    chunk_into_parts(stream, 5 * 1024 * 1024)
    |> ExAws.S3.upload(s3_bucket, s3_path,
      content_disposition: Plausible.Exports.content_disposition(filename),
      content_type: "application/zip",
      timeout: :infinity
    )
    |> ExAws.request!()

    :ok
  end

  @doc """
  Returns a presigned URL to download the exported Zip archive from S3.
  The URL expires in 300 seconds, which should be enough for a redirect.

  In the current implementation the bucket always goes into the path component.
  """
  @spec download_url(String.t(), Path.t()) :: :uri_string.uri_string()
  def download_url(s3_bucket, s3_path) do
    config = ExAws.Config.new(:s3)

    {:ok, download_url} =
      ExAws.S3.presigned_url(config, :get, s3_bucket, s3_path, expires_in: 300)

    download_url
  end

  defp chunk_into_parts(stream, min_part_size) do
    Stream.chunk_while(
      stream,
      _acc = %{buffer_size: 0, buffer: [], min_part_size: min_part_size},
      _chunk_fun = &buffer_until_big_enough/2,
      _after_fun = &flush_leftovers/1
    )
  end

  defp buffer_until_big_enough(data, acc) do
    %{buffer_size: prev_buffer_size, buffer: prev_buffer, min_part_size: min_part_size} = acc
    new_buffer_size = prev_buffer_size + IO.iodata_length(data)
    new_buffer = [prev_buffer | data]

    if new_buffer_size > min_part_size do
      # NOTE: PR to make ExAws.Operation.ExAws.Operation.S3.put_content_length_header/3 accept iodata
      {:cont, IO.iodata_to_binary(new_buffer), %{acc | buffer_size: 0, buffer: []}}
    else
      {:cont, %{acc | buffer_size: new_buffer_size, buffer: new_buffer}}
    end
  end

  defp flush_leftovers(acc) do
    # NOTE: PR to make ExAws.Operation.ExAws.Operation.S3.put_content_length_header/3 accept iodata
    {:cont, IO.iodata_to_binary(acc.buffer), %{acc | buffer_size: 0, buffer: []}}
  end

  @doc """
  Returns `access_key_id` and `secret_access_key` to be used by ClickHouse during imports from S3.

  Example:

      iex> import_clickhouse_credentials()
      %{access_key_id: "minioadmin", secret_access_key: "minioadmin"}

  """
  @spec import_clickhouse_credentials ::
          %{access_key_id: String.t(), secret_access_key: String.t()}
  def import_clickhouse_credentials do
    %{access_key_id: access_key_id, secret_access_key: secret_access_key} = ExAws.Config.new(:s3)
    %{access_key_id: access_key_id, secret_access_key: secret_access_key}
  end
end
```

## File: `lib/plausible/s3/client.ex`
```
defmodule Plausible.S3.Client do
  @moduledoc false
  @behaviour ExAws.Request.HttpClient

  @impl true
  def request(method, url, body, headers, opts) do
    req = Finch.build(method, url, headers, body)

    case Finch.request(req, Plausible.Finch, opts) do
      {:ok, %Finch.Response{status: status, headers: headers, body: body}} ->
        {:ok, %{status_code: status, headers: headers, body: body}}

      {:error, reason} ->
        {:error, %{reason: reason}}
    end
  end
end
```

## File: `lib/plausible/segments/filters.ex`
```
defmodule Plausible.Segments.Filters do
  @moduledoc """
  This module contains functions that enable resolving segments in filters.
  """
  alias Plausible.Segments
  alias Plausible.Stats.Filters

  @max_segment_filters_count 10

  @doc """
  Finds unique segment IDs used in query filters.

  ## Examples
    iex> get_segment_ids([[:not, [:is, "segment", [10, 20]]], [:contains, "visit:entry_page", ["blog"]]])
    {:ok, [10, 20]}

    iex> get_segment_ids([[:and, [[:is, "segment", Enum.to_list(1..6)], [:is, "segment", Enum.to_list(1..6)]]]])
    {:error, "Invalid filters. You can only use up to 10 segment filters in a query."}
  """
  def get_segment_ids(filters) do
    ids =
      filters
      |> Filters.traverse()
      |> Enum.flat_map(fn
        {[_operation, "segment", clauses], _} -> clauses
        _ -> []
      end)

    if length(ids) > @max_segment_filters_count do
      {:error,
       "Invalid filters. You can only use up to #{@max_segment_filters_count} segment filters in a query."}
    else
      {:ok, Enum.uniq(ids)}
    end
  end

  def preload_needed_segments(%Plausible.Site{} = site, filters) do
    with {:ok, segment_ids} <- get_segment_ids(filters),
         {:ok, segments} <-
           Segments.get_many(
             site,
             segment_ids,
             fields: [:id, :segment_data]
           ),
         {:ok, segments_by_id} <-
           {:ok,
            Enum.into(
              segments,
              %{},
              fn %Segments.Segment{id: id, segment_data: segment_data} ->
                case Filters.QueryParser.parse_filters(segment_data["filters"]) do
                  {:ok, filters} -> {id, filters}
                  _ -> {id, nil}
                end
              end
            )},
         :ok <-
           if(Enum.any?(segment_ids, fn id -> is_nil(Map.get(segments_by_id, id)) end),
             do: {:error, "Invalid filters. Some segments don't exist or aren't accessible."},
             else: :ok
           ) do
      {:ok, segments_by_id}
    end
  end

  defp expand_first_level_and_filters(filter) do
    case filter do
      [:and, clauses] -> clauses
      filter -> [filter]
    end
  end

  defp replace_segment_with_filter_tree([_, "segment", clauses], preloaded_segments) do
    if length(clauses) == 1 do
      [[:and, Map.get(preloaded_segments, Enum.at(clauses, 0))]]
    else
      [[:or, Enum.map(clauses, fn id -> [:and, Map.get(preloaded_segments, id)] end)]]
    end
  end

  defp replace_segment_with_filter_tree(_filter, _preloaded_segments) do
    nil
  end

  @doc """
  ## Examples

    iex> resolve_segments([[:is, "visit:entry_page", ["/home"]]], %{})
    {:ok, [[:is, "visit:entry_page", ["/home"]]]}

    iex> resolve_segments([[:is, "visit:entry_page", ["/home"]], [:is, "segment", [1]]], %{1 => [[:contains, "visit:entry_page", ["blog"]], [:is, "visit:country", ["PL"]]]})
    {:ok, [
      [:is, "visit:entry_page", ["/home"]],
      [:contains, "visit:entry_page", ["blog"]],
      [:is, "visit:country", ["PL"]]
    ]}

    iex> resolve_segments([[:is, "visit:entry_page", ["/home"]], [:is, "segment", [1]], [:is, "segment", [2]]], %{1 => [[:is, "visit:country", ["PL"]]], 2 => [[:is, "event:goal", ["Signup"]]]})
    {:ok, [
      [:is, "visit:entry_page", ["/home"]],
      [:is, "visit:country", ["PL"]],
      [:is, "event:goal", ["Signup"]]
    ]}


    iex> resolve_segments([[:is, "segment", [1, 2]]], %{1 => [[:contains, "event:goal", ["Singup"]], [:is, "visit:country", ["PL"]]], 2 => [[:contains, "event:goal", ["Sauna"]], [:is, "visit:country", ["EE"]]]})
    {:ok, [
      [:or, [
        [:and, [[:contains, "event:goal", ["Singup"]], [:is, "visit:country", ["PL"]]]],
        [:and, [[:contains, "event:goal", ["Sauna"]], [:is, "visit:country", ["EE"]]]]]
      ]
    ]}
  """
  def resolve_segments(original_filters, preloaded_segments) do
    if map_size(preloaded_segments) > 0 do
      {:ok,
       original_filters
       |> Filters.transform_filters(fn f ->
         replace_segment_with_filter_tree(f, preloaded_segments)
       end)
       |> Filters.transform_filters(&expand_first_level_and_filters/1)}
    else
      {:ok, original_filters}
    end
  end
end
```

## File: `lib/plausible/segments/segment.ex`
```
defmodule Plausible.Segments.Segment do
  @moduledoc """
  Schema for segments. Segments are saved filter combinations.
  """
  use Plausible
  use Ecto.Schema
  import Ecto.Changeset

  @segment_types [:personal, :site]

  @type t() :: %__MODULE__{}

  schema "segments" do
    field :name, :string
    field :type, Ecto.Enum, values: @segment_types
    field :segment_data, :map

    # owner ID can be null (aka segment is dangling) when the original owner is deassociated from the site
    # the segment is dangling until another user edits it: the editor becomes the new owner
    belongs_to :owner, Plausible.Auth.User, foreign_key: :owner_id
    belongs_to :site, Plausible.Site

    timestamps()
  end

  def changeset(segment, attrs) do
    segment
    |> cast(attrs, [
      :name,
      :segment_data,
      :site_id,
      :type,
      :owner_id
    ])
    |> validate_required([:name, :segment_data, :site_id, :type, :owner_id])
    |> validate_length(:name, count: :bytes, min: 1, max: 255)
    |> foreign_key_constraint(:site_id)
    |> foreign_key_constraint(:owner_id)
    |> validate_only_known_properties_present()
    |> validate_segment_data_filters()
    |> validate_segment_data_labels()
    |> validate_json_byte_length(:segment_data, max: 5 * 1024)
  end

  defp validate_only_known_properties_present(%Ecto.Changeset{} = changeset) do
    case get_field(changeset, :segment_data) do
      segment_data when is_map(segment_data) ->
        if Enum.any?(Map.keys(segment_data) -- ["filters", "labels"]) do
          add_error(
            changeset,
            :segment_data,
            "must not contain any other property except \"filters\" and \"labels\""
          )
        else
          changeset
        end

      _ ->
        changeset
    end
  end

  defp validate_segment_data_filters(%Ecto.Changeset{} = changeset) do
    case get_field(changeset, :segment_data) do
      %{"filters" => filters} when is_list(filters) and length(filters) > 0 ->
        changeset

      _ ->
        add_error(
          changeset,
          :segment_data,
          "property \"filters\" must be an array with at least one member"
        )
    end
  end

  defp validate_segment_data_labels(%Ecto.Changeset{} = changeset) do
    case get_field(changeset, :segment_data) do
      %{"labels" => labels} when not is_map(labels) ->
        add_error(changeset, :segment_data, "property \"labels\" must be map or nil")

      _ ->
        changeset
    end
  end

  defp validate_json_byte_length(%Ecto.Changeset{} = changeset, field_key, opts) do
    field = get_field(changeset, field_key)
    max = Keyword.get(opts, :max, 0)

    if :erlang.byte_size(Jason.encode!(field)) > max do
      add_error(changeset, field_key, "should be at most %{count} byte(s)", count: max)
    else
      changeset
    end
  end

  def validate_segment_data_if_exists(
        %Plausible.Site{} = _site,
        nil = _segment_data,
        _restricted_depth?
      ),
      do: :ok

  def validate_segment_data_if_exists(%Plausible.Site{} = site, segment_data, restricted_depth?),
    do: validate_segment_data(site, segment_data, restricted_depth?)

  def validate_segment_data(
        %Plausible.Site{} = site,
        %{"filters" => filters},
        restricted_depth?
      ) do
    with {:ok, %Plausible.Stats.Query{filters: parsed_filters}} <-
           build_naive_query_from_segment_data(site, filters),
         :ok <- maybe_validate_filters_depth(parsed_filters, restricted_depth?) do
      :ok
    else
      {:error, message} ->
        reformat_filters_errors(message)

      :error_deep_filters_not_supported ->
        reformat_filters_errors("Invalid filters. Deep filters are not supported.")
    end
  end

  @doc """
    This function builds a simple query using the filters from Plausibe.Segment.segment_data
    to test whether the filters used in the segment stand as legitimate query filters.
    If they don't, it indicates an error with the filters that must be passed to the client,
    so they could reconfigure the filters.
  """
  def build_naive_query_from_segment_data(%Plausible.Site{} = site, filters),
    do:
      Plausible.Stats.Query.build(
        site,
        :internal,
        %{
          "site_id" => site.domain,
          "metrics" => ["visitors"],
          "date_range" => "7d",
          "filters" => filters
        },
        %{}
      )

  @doc """
    This function handles the error from building the naive query that is used to validate segment filters.
    If the error is only about filters, it's marked as :invalid_filters error and ultimately forwarded to client.
    If the error is not only about filters, the client can't do anything about the situation,
    and the error message is returned as-is.

    ### Examples
    iex> reformat_filters_errors(~s(#/metrics/0 Invalid metric "Visitors"\\n#/filters/0 Invalid filter "A"))
    {:error, ~s(#/metrics/0 Invalid metric "Visitors"\\n#/filters/0 Invalid filter "A")}

    iex> reformat_filters_errors(~s(#/filters/0 Invalid filter "A"\\n#/filters/1 Invalid filter "B"))
    {:error, {:invalid_filters, ~s(#/filters/0 Invalid filter "A"\\n#/filters/1 Invalid filter "B")}}

    iex> reformat_filters_errors("Invalid filters. Dimension `event:goal` can only be filtered at the top level.")
    {:error, {:invalid_filters, "Invalid filters. Dimension `event:goal` can only be filtered at the top level."}}
  """
  def reformat_filters_errors(message) do
    lines = String.split(message, "\n")

    if Enum.all?(lines, fn line ->
         String.starts_with?(line, "#/filters/") or String.starts_with?(line, "Invalid filters.")
       end) do
      {:error, {:invalid_filters, message}}
    else
      {:error, message}
    end
  end

  @spec maybe_validate_filters_depth([any()], boolean()) ::
          :ok | :error_deep_filters_not_supported
  defp maybe_validate_filters_depth(filters, restricted_depth?)

  defp maybe_validate_filters_depth(_filters, false), do: :ok

  defp maybe_validate_filters_depth(filters, true) do
    if Enum.all?(filters, &dashboard_compatible_filter?/1) do
      :ok
    else
      :error_deep_filters_not_supported
    end
  end

  defp dashboard_compatible_filter?(filter) do
    case filter do
      [operation, dimension, _clauses] when is_atom(operation) and is_binary(dimension) -> true
      [:has_not_done, _] -> true
      _ -> false
    end
  end
end

defimpl Jason.Encoder, for: Plausible.Segments.Segment do
  def encode(%Plausible.Segments.Segment{} = segment, opts) do
    %{
      id: segment.id,
      name: segment.name,
      type: segment.type,
      segment_data: segment.segment_data,
      owner_id: segment.owner_id,
      owner_name: if(is_nil(segment.owner_id), do: nil, else: segment.owner.name),
      inserted_at: segment.inserted_at,
      updated_at: segment.updated_at
    }
    |> Jason.Encode.map(opts)
  end
end
```

## File: `lib/plausible/segments/segments.ex`
```
defmodule Plausible.Segments do
  @moduledoc """
  Module for accessing Segments.
  """
  alias Plausible.Segments.Segment
  alias Plausible.Repo
  import Ecto.Query

  @roles_with_personal_segments [:billing, :viewer, :editor, :admin, :owner, :super_admin]
  @roles_with_maybe_site_segments [:editor, :admin, :owner, :super_admin]

  @type error_not_enough_permissions() :: {:error, :not_enough_permissions}
  @type error_segment_not_found() :: {:error, :segment_not_found}
  @type error_segment_limit_reached() :: {:error, :segment_limit_reached}
  @type error_invalid_segment() :: {:error, {:invalid_segment, Keyword.t()}}
  @type unknown_error() :: {:error, any()}

  @max_segments 500

  def get_all_for_site(%Plausible.Site{} = site, site_role) do
    fields = [:id, :name, :type, :inserted_at, :updated_at, :segment_data]

    cond do
      site_role in [:public] ->
        {:ok,
         Repo.all(
           from(segment in Segment,
             select: ^fields,
             where: segment.site_id == ^site.id,
             order_by: [desc: segment.updated_at, desc: segment.id]
           )
         )}

      site_role in @roles_with_personal_segments or site_role in @roles_with_maybe_site_segments ->
        fields = fields ++ [:owner_id]

        {:ok,
         Repo.all(
           from(segment in Segment,
             select: ^fields,
             where: segment.site_id == ^site.id,
             order_by: [desc: segment.updated_at, desc: segment.id],
             preload: [:owner]
           )
         )}

      true ->
        {:error, :not_enough_permissions}
    end
  end

  @spec get_many(Plausible.Site.t(), list(pos_integer()), Keyword.t()) ::
          {:ok, [Segment.t()]}
  def get_many(%Plausible.Site{} = _site, segment_ids, _opts)
      when segment_ids == [] do
    {:ok, []}
  end

  def get_many(%Plausible.Site{} = site, segment_ids, opts)
      when is_list(segment_ids) do
    fields = Keyword.get(opts, :fields, [:id])

    query =
      from(segment in Segment,
        select: ^fields,
        where: segment.site_id == ^site.id,
        where: segment.id in ^segment_ids
      )

    {:ok, Repo.all(query)}
  end

  @spec get_one(pos_integer(), Plausible.Site.t(), atom(), pos_integer() | nil) ::
          {:ok, Segment.t()}
          | error_not_enough_permissions()
          | error_segment_not_found()
  def get_one(user_id, site, site_role, segment_id) do
    if site_role in roles_with_personal_segments() do
      case do_get_one(user_id, site.id, segment_id) do
        %Segment{} = segment -> {:ok, segment}
        nil -> {:error, :segment_not_found}
      end
    else
      {:error, :not_enough_permissions}
    end
  end

  @spec insert_one(pos_integer(), Plausible.Site.t(), atom(), map()) ::
          {:ok, Segment.t()}
          | error_not_enough_permissions()
          | error_invalid_segment()
          | error_segment_limit_reached()
          | unknown_error()

  def insert_one(
        user_id,
        %Plausible.Site{} = site,
        site_role,
        %{} = params
      ) do
    with :ok <- can_insert_one?(site, site_role, params),
         %{valid?: true} = changeset <-
           Segment.changeset(
             %Segment{},
             Map.merge(params, %{"site_id" => site.id, "owner_id" => user_id})
           ),
         :ok <-
           Segment.validate_segment_data(site, params["segment_data"], true) do
      {:ok, changeset |> Repo.insert!() |> Repo.preload(:owner)}
    else
      %{valid?: false, errors: errors} ->
        {:error, {:invalid_segment, errors}}

      {:error, {:invalid_filters, message}} ->
        {:error, {:invalid_segment, segment_data: {message, []}}}

      {:error, _type} = error ->
        error
    end
  end

  @spec update_one(pos_integer(), Plausible.Site.t(), atom(), pos_integer(), map()) ::
          {:ok, Segment.t()}
          | error_not_enough_permissions()
          | error_invalid_segment()
          | unknown_error()

  def update_one(
        user_id,
        %Plausible.Site{} = site,
        site_role,
        segment_id,
        %{} = params
      ) do
    with {:ok, segment} <- get_one(user_id, site, site_role, segment_id),
         :ok <- can_update_one?(site, site_role, params, segment.type),
         %{valid?: true} = changeset <-
           Segment.changeset(
             segment,
             Map.merge(params, %{"owner_id" => user_id})
           ),
         :ok <-
           Segment.validate_segment_data_if_exists(
             site,
             params["segment_data"],
             true
           ) do
      Repo.update!(changeset)

      {:ok, Repo.reload!(segment) |> Repo.preload(:owner)}
    else
      %{valid?: false, errors: errors} ->
        {:error, {:invalid_segment, errors}}

      {:error, {:invalid_filters, message}} ->
        {:error, {:invalid_segment, segment_data: {message, []}}}

      {:error, _type} = error ->
        error
    end
  end

  def update_goal_in_segments(
        %Plausible.Site{} = site,
        %Plausible.Goal{} = stale_goal,
        %Plausible.Goal{} = updated_goal
      ) do
    # Looks for a pattern like ["is", "event:goal", [...<goal_name>...]] in the filters structure.
    # Added a bunch of whitespace matchers to make sure it's tolerant of valid JSON formatting
    goal_filter_regex =
      ~s(.*?\\[\s*"is",\s*"event:goal",\s*\\[.*?"#{Regex.escape(stale_goal.display_name)}".*?\\]\s*\\].*?)

    segments_to_update =
      from(
        s in Segment,
        where: s.site_id == ^site.id,
        where: fragment("?['filters']::text ~ ?", s.segment_data, ^goal_filter_regex)
      )

    stale_goal_name = stale_goal.display_name

    for segment <- Repo.all(segments_to_update) do
      updated_filters =
        Plausible.Stats.Filters.transform_filters(segment.segment_data["filters"], fn
          ["is", "event:goal", clauses] ->
            new_clauses =
              Enum.map(clauses, fn
                ^stale_goal_name -> updated_goal.display_name
                clause -> clause
              end)

            [["is", "event:goal", new_clauses]]

          _ ->
            nil
        end)

      updated_segment_data = Map.put(segment.segment_data, "filters", updated_filters)

      from(
        s in Segment,
        where: s.id == ^segment.id,
        update: [set: [segment_data: ^updated_segment_data]]
      )
      |> Repo.update_all([])
    end

    :ok
  end

  def after_user_removed_from_site(site, user) do
    Repo.delete_all(
      from segment in Segment,
        where: segment.site_id == ^site.id,
        where: segment.owner_id == ^user.id,
        where: segment.type == :personal
    )

    Repo.update_all(
      from(segment in Segment,
        where: segment.site_id == ^site.id,
        where: segment.owner_id == ^user.id,
        where: segment.type == :site,
        update: [set: [owner_id: nil]]
      ),
      []
    )
  end

  def after_user_removed_from_team(team, user) do
    team_sites_q =
      from(
        site in Plausible.Site,
        where: site.team_id == ^team.id,
        where: parent_as(:segment).site_id == site.id
      )

    Repo.delete_all(
      from segment in Segment,
        as: :segment,
        where: segment.owner_id == ^user.id,
        where: segment.type == :personal,
        where: exists(team_sites_q)
    )

    Repo.update_all(
      from(segment in Segment,
        as: :segment,
        where: segment.owner_id == ^user.id,
        where: segment.type == :site,
        where: exists(team_sites_q),
        update: [set: [owner_id: nil]]
      ),
      []
    )
  end

  def user_removed(user) do
    Repo.delete_all(
      from segment in Segment,
        as: :segment,
        where: segment.owner_id == ^user.id,
        where: segment.type == :personal
    )

    #  Site segments are set to owner=null via ON DELETE SET NULL
  end

  def delete_one(user_id, %Plausible.Site{} = site, site_role, segment_id) do
    with {:ok, segment} <- get_one(user_id, site, site_role, segment_id) do
      cond do
        segment.type == :site and site_role in roles_with_maybe_site_segments() ->
          {:ok, do_delete_one(segment)}

        segment.type == :personal and site_role in roles_with_personal_segments() ->
          {:ok, do_delete_one(segment)}

        true ->
          {:error, :not_enough_permissions}
      end
    end
  end

  @spec do_get_one(pos_integer(), pos_integer(), pos_integer() | nil) ::
          Segment.t() | nil
  defp do_get_one(user_id, site_id, segment_id)

  defp do_get_one(_user_id, _site_id, nil) do
    nil
  end

  defp do_get_one(user_id, site_id, segment_id) do
    query =
      from(segment in Segment,
        where: segment.site_id == ^site_id,
        where: segment.id == ^segment_id,
        where: segment.type == :site or segment.owner_id == ^user_id,
        preload: [:owner]
      )

    Repo.one(query)
  end

  defp do_delete_one(segment) do
    Repo.delete!(segment)
    segment
  end

  defp can_update_one?(%Plausible.Site{} = site, site_role, params, existing_segment_type) do
    updating_to_site_segment? = params["type"] == "site"

    cond do
      (existing_segment_type == :site or
         updating_to_site_segment?) and site_role in roles_with_maybe_site_segments() and
          site_segments_available?(site) ->
        :ok

      existing_segment_type == :personal and not updating_to_site_segment? and
          site_role in roles_with_personal_segments() ->
        :ok

      true ->
        {:error, :not_enough_permissions}
    end
  end

  defp can_insert_one?(%Plausible.Site{} = site, site_role, params) do
    cond do
      count_segments(site.id) >= @max_segments ->
        {:error, :segment_limit_reached}

      params["type"] == "site" and site_role in roles_with_maybe_site_segments() and
          site_segments_available?(site) ->
        :ok

      params["type"] == "personal" and
          site_role in roles_with_personal_segments() ->
        :ok

      true ->
        {:error, :not_enough_permissions}
    end
  end

  defp count_segments(site_id) do
    from(segment in Segment,
      where: segment.site_id == ^site_id
    )
    |> Repo.aggregate(:count, :id)
  end

  def roles_with_personal_segments(), do: [:viewer, :editor, :admin, :owner, :super_admin]
  def roles_with_maybe_site_segments(), do: [:editor, :admin, :owner, :super_admin]

  def site_segments_available?(%Plausible.Site{} = site),
    do: Plausible.Billing.Feature.SiteSegments.check_availability(site.team) == :ok

  @doc """
  iex> serialize_first_error([{"name", {"should be at most %{count} byte(s)", [count: 255]}}])
  "name should be at most 255 byte(s)"
  """
  def serialize_first_error(errors) do
    {field, {message, opts}} = List.first(errors)

    formatted_message =
      Enum.reduce(opts, message, fn {key, value}, acc ->
        String.replace(acc, "%{#{key}}", to_string(value))
      end)

    "#{field} #{formatted_message}"
  end
end
```

## File: `lib/plausible/sentry/client.ex`
```
defmodule Plausible.Sentry.Client do
  @behaviour Sentry.HTTPClient

  defguardp is_redirect(status) when is_integer(status) and status >= 300 and status < 400

  require Logger

  def post(url, headers, body) do
    req_opts = Application.get_env(:plausible, __MODULE__)[:finch_request_opts] || []

    :post
    |> Finch.build(url, headers, body)
    |> Finch.request(Plausible.Finch, req_opts)
    |> handle_response()
  end

  defp handle_response(resp) do
    case resp do
      {:ok, %{status: status, headers: _}} when is_redirect(status) ->
        # Just playing safe here. hackney client didn't support those; redirects are opt-in in hackney
        Logger.warning("Sentry returned a redirect that is not handled yet.")
        {:error, :stop}

      {:ok, %{status: status, body: body, headers: headers}} ->
        {:ok, status, headers, body}

      {:error, error} = e ->
        Logger.warning("Sentry call failed with: #{inspect(error)}")
        e
    end
  end
end
```

## File: `lib/plausible/session/balancer.ex`
```
defmodule Plausible.Session.Balancer do
  @moduledoc "Serialize session processing to avoid explicit locks"
  use GenServer

  def start_link(id) do
    GenServer.start_link(__MODULE__, id, name: via(id))
  end

  @impl true
  def init(id) do
    {:ok, %{id: id}}
  end

  def dispatch(user_id, fun, opts) do
    timeout = Keyword.fetch!(opts, :timeout)
    local? = Keyword.get(opts, :local?, false)

    if local? do
      fun.()
    else
      worker = :erlang.phash2(user_id, Plausible.Session.BalancerSupervisor.size()) + 1
      [{pid, _}] = Registry.lookup(Plausible.Session.Balancer.Registry, worker)
      GenServer.call(pid, {:process, fun}, timeout)
    end
  end

  @impl true
  def handle_call({:process, fun}, _from, state) do
    try do
      response = fun.()
      {:reply, response, state}
    rescue
      e ->
        {:reply, {:error, e}, state}
    end
  end

  defp via(id), do: {:via, Registry, {Plausible.Session.Balancer.Registry, id}}
end
```

## File: `lib/plausible/session/balancer_supervisor.ex`
```
defmodule Plausible.Session.BalancerSupervisor do
  @moduledoc "Serialize session processing to avoid explicit locks"
  use Supervisor

  if Mix.env() in [:test, :ce_test] do
    def size(),
      do: 10
  else
    def size(), do: 100
  end

  def start_link(_) do
    Supervisor.start_link(__MODULE__, size(), name: __MODULE__)
  end

  def init(size) do
    children =
      for id <- 1..size do
        %{
          id: id,
          start: {Plausible.Session.Balancer, :start_link, [id]},
          restart: :permanent
        }
      end

    Supervisor.init(
      [
        {Registry, [keys: :unique, name: Plausible.Session.Balancer.Registry]} | children
      ],
      strategy: :one_for_one
    )
  end
end
```

## File: `lib/plausible/session/cache_store.ex`
```
defmodule Plausible.Session.CacheStore do
  require Logger
  alias Plausible.Session.WriteBuffer

  @lock_timeout 1000

  @lock_telemetry_event [:plausible, :sessions, :cache, :lock]

  def lock_telemetry_event, do: @lock_telemetry_event

  def on_event(event, session_attributes, prev_user_id, opts \\ []) do
    buffer_insert = Keyword.get(opts, :buffer_insert, &WriteBuffer.insert/1)
    skip_balancer? = Keyword.get(opts, :skip_balancer?, false)
    lock_requested_at = System.monotonic_time()

    try do
      response =
        Plausible.Session.Balancer.dispatch(
          event.user_id,
          fn ->
            lock_duration = System.monotonic_time() - lock_requested_at
            :telemetry.execute(@lock_telemetry_event, %{duration: lock_duration}, %{})

            found_session =
              find_session(event, event.user_id) || find_session(event, prev_user_id)

            handle_event(event, found_session, session_attributes, buffer_insert)
          end,
          timeout: @lock_timeout,
          local?: skip_balancer?
        )

      case response do
        {:error, e} -> raise e
        _ -> {:ok, response}
      end
    catch
      :exit, {:timeout, _} ->
        Sentry.capture_message("Timeout while handling session event")
        {:error, :timeout}
    end
  end

  defp handle_event(%{name: "engagement"} = event, found_session, _, _) do
    if found_session do
      # Make sure the session is kept active in the in-memory session cache
      refresh_session_cache(found_session, event.timestamp)

      found_session
    else
      :no_session_for_engagement
    end
  end

  defp handle_event(event, found_session, session_attributes, buffer_insert) do
    if found_session do
      updated_session = update_session(found_session, event)
      buffer_insert.([%{found_session | sign: -1}, %{updated_session | sign: 1}])
      update_session_cache(updated_session)
    else
      new_session = new_session_from_event(event, session_attributes)
      buffer_insert.([new_session])
      update_session_cache(new_session)
    end
  end

  defp find_session(_domain, nil), do: nil

  defp find_session(event, user_id) do
    from_cache = Plausible.Cache.Adapter.get(:sessions, {event.site_id, user_id})

    case from_cache do
      nil ->
        nil

      session ->
        if NaiveDateTime.diff(event.timestamp, session.timestamp, :minute) <= 30 do
          session
        end
    end
  end

  defp update_session_cache(session) do
    key = {session.site_id, session.user_id}
    Plausible.Cache.Adapter.put(:sessions, key, session, dirty?: true)
    session
  end

  defp refresh_session_cache(session, timestamp) do
    session
    |> Map.put(:timestamp, timestamp)
    |> update_session_cache()
  end

  defp update_session(session, event) do
    pageview? = event.name == "pageview"
    pageviews = if(pageview?, do: session.pageviews + 1, else: session.pageviews)

    %{
      session
      | timestamp: event.timestamp,
        entry_page:
          if(session.entry_page == "" and pageview?,
            do: event.pathname,
            else: session.entry_page
          ),
        hostname:
          if(pageview? and session.hostname == "",
            do: event.hostname,
            else: session.hostname
          ),
        exit_page: if(pageview?, do: event.pathname, else: session.exit_page),
        exit_page_hostname: if(pageview?, do: event.hostname, else: session.exit_page_hostname),
        is_bounce:
          if(session.is_bounce,
            do: not (pageviews >= 2 or (event.interactive? and not pageview?)),
            else: session.is_bounce
          ),
        duration: NaiveDateTime.diff(event.timestamp, session.start) |> abs,
        pageviews: pageviews,
        events: session.events + 1
    }
  end

  defp new_session_from_event(event, session_attributes) do
    %Plausible.ClickhouseSessionV2{
      sign: 1,
      session_id: Plausible.ClickhouseSessionV2.random_uint64(),
      hostname: if(event.name == "pageview", do: event.hostname, else: ""),
      site_id: event.site_id,
      user_id: event.user_id,
      entry_page: if(event.name == "pageview", do: event.pathname, else: ""),
      exit_page: if(event.name == "pageview", do: event.pathname, else: ""),
      exit_page_hostname: if(event.name == "pageview", do: event.hostname, else: ""),
      is_bounce: event.name == "pageview" or not event.interactive?,
      duration: 0,
      pageviews: if(event.name == "pageview", do: 1, else: 0),
      events: 1,
      referrer: Map.get(session_attributes, :referrer),
      click_id_param: Map.get(session_attributes, :click_id_param),
      referrer_source: Map.get(session_attributes, :referrer_source),
      utm_medium: Map.get(session_attributes, :utm_medium),
      utm_source: Map.get(session_attributes, :utm_source),
      utm_campaign: Map.get(session_attributes, :utm_campaign),
      utm_content: Map.get(session_attributes, :utm_content),
      utm_term: Map.get(session_attributes, :utm_term),
      country_code: Map.get(session_attributes, :country_code),
      subdivision1_code: Map.get(session_attributes, :subdivision1_code),
      subdivision2_code: Map.get(session_attributes, :subdivision2_code),
      city_geoname_id: Map.get(session_attributes, :city_geoname_id),
      screen_size: Map.get(session_attributes, :screen_size),
      operating_system: Map.get(session_attributes, :operating_system),
      operating_system_version: Map.get(session_attributes, :operating_system_version),
      browser: Map.get(session_attributes, :browser),
      browser_version: Map.get(session_attributes, :browser_version),
      timestamp: event.timestamp,
      start: event.timestamp,
      "entry_meta.key": Map.get(event, :"meta.key"),
      "entry_meta.value": Map.get(event, :"meta.value")
    }
  end
end
```

## File: `lib/plausible/session/salts.ex`
```
defmodule Plausible.Session.Salts do
  use GenServer
  use Plausible.Repo

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: opts[:name] || __MODULE__)
  end

  @impl true
  def init(opts) do
    name = opts[:name] || __MODULE__
    now = opts[:now] || DateTime.utc_now()
    clean_old_salts(now)

    ^name =
      :ets.new(name, [
        :named_table,
        :set,
        :protected,
        {:read_concurrency, true}
      ])

    refresh(name, now)

    {:ok, name}
  end

  def refresh(name, now) do
    salts = Repo.all(from s in "salts", select: s.salt, order_by: [desc: s.id], limit: 2)

    state =
      case salts do
        [current, prev] ->
          %{previous: prev, current: current}

        [current] ->
          %{previous: nil, current: current}

        [] ->
          new = generate_and_persist_new_salt(now)
          %{previous: nil, current: new}
      end

    true = :ets.insert(name, {:state, state})
    interval = Application.get_env(:plausible, __MODULE__)[:interval] || :timer.seconds(90)
    Process.send_after(self(), {:refresh, now}, interval)
    :ok
  end

  def rotate(name \\ __MODULE__, now \\ DateTime.utc_now()) do
    GenServer.call(name, {:rotate, now})
  end

  def fetch(name \\ __MODULE__) do
    [state: state] = :ets.lookup(name, :state)
    state
  end

  @impl true
  def handle_call({:rotate, now}, _from, name) do
    current = fetch(name).current
    clean_old_salts(now)

    state =
      %{
        current: generate_and_persist_new_salt(now),
        previous: current
      }

    true = :ets.insert(name, {:state, state})
    {:reply, :ok, name}
  end

  @impl true
  def handle_info({:refresh, now}, name) do
    refresh(name, now)
    {:noreply, name}
  end

  defp generate_and_persist_new_salt(now) do
    salt = :crypto.strong_rand_bytes(16)
    Repo.insert_all("salts", [%{salt: salt, inserted_at: now}])
    salt
  end

  defp clean_old_salts(now) do
    h48_ago =
      DateTime.shift(now, hour: -48)

    Repo.delete_all(from s in "salts", where: s.inserted_at < ^h48_ago)
  end
end
```

## File: `lib/plausible/session/transfer.ex`
```
defmodule Plausible.Session.Transfer do
  @moduledoc """
  Cross-deployment transfer for `:sessions` cache.

  It works by establishing a client-server architecture where:
  - The "replica" one-time task retrieves `:sessions` data from other OS processes via Unix domain sockets
  - The "primary" server process responds to requests for `:sessions` data via Unix domain sockets
  - The "alive" process waits on shutdown for at least one replica, for 15 seconds
  """

  @behaviour Supervisor

  require Logger
  alias Plausible.Session.Transfer.{TinySock, Alive}
  alias Plausible.{Cache, ClickhouseSessionV2, Session}

  @cmd_list_cache_names :list
  @cmd_dump_cache :get
  @cmd_takeover_done :done

  def telemetry_event, do: [:plausible, :sessions, :takeover]

  @doc """
  Starts the `:sessions` transfer supervisor.

  Options:
  - `:name` - the name of the supervisor (default: `Plausible.Session.Transfer`)
  - `:base_path` - the base path for the Unix domain sockets (required)
  """
  def start_link(opts) do
    name = Keyword.get(opts, :name, __MODULE__)
    base_path = Keyword.fetch!(opts, :base_path)
    Supervisor.start_link(__MODULE__, base_path, name: name)
  end

  @impl true
  def init(nil) do
    Logger.notice(
      "Session transfer: ignoring, no socket base path configured (make sure ENABLE_SESSION_TRANSFER/PERSISTENT_CACHE_DIR are set)"
    )

    :ignore
  end

  def init(base_path) do
    File.mkdir_p!(base_path)

    replica =
      Supervisor.child_spec(
        {Task, fn -> init_takeover(base_path) end},
        id: :transfer_replica
      )

    given_counter = :counters.new(1, [])
    parent = self()

    primary =
      {TinySock,
       base_path: base_path,
       handler: fn message -> handle_replica(message, parent, given_counter) end}

    alive =
      Supervisor.child_spec(
        {Alive,
         _until = fn ->
           result = :counters.get(given_counter, 1) > 0

           Logger.notice(
             "Session transfer delayed shut down. Checking if session takeover happened?: #{result}"
           )

           result
         end},
        shutdown: :timer.seconds(15)
      )

    Logger.notice("Session transfer init: #{base_path}")
    Supervisor.init([replica, primary, alive], strategy: :one_for_one)
  end

  @doc """
  Returns `true` if the transfer has been attempted (successfully or not).
  Returns `false` if the transfer is still in progress.
  """
  def attempted?(transfer_sup \\ __MODULE__) do
    result = not replica_alive?(transfer_sup)
    Logger.notice("Session transfer attempted?: #{result}")
    result
  end

  @doc """
  Returns the child specification for the `:sessions` transfer supervisor.
  See `start_link/1` for options.
  """
  def child_spec(opts) do
    %{
      id: __MODULE__,
      start: {__MODULE__, :start_link, [opts]},
      type: :supervisor,
      restart: :temporary
    }
  end

  defp handle_replica(request, parent, given_counter) do
    Logger.notice(
      "Session transfer message received at #{node()}: #{inspect(request, limit: 10)}"
    )

    case request do
      {@cmd_list_cache_names, session_version} ->
        if session_version == session_version() and attempted?(parent) do
          Cache.Adapter.get_names(:sessions)
        else
          []
        end

      {@cmd_dump_cache, cache} ->
        Cache.Adapter.cache2list(cache)

      @cmd_takeover_done ->
        :counters.add(given_counter, 1, 1)
    end
  end

  defp init_takeover(base_path) do
    started = System.monotonic_time()

    base_path
    |> TinySock.list!()
    |> Enum.sort_by(&file_stat_ctime/1, :asc)
    |> Enum.each(&request_takeover/1)

    :telemetry.execute(telemetry_event(), %{duration: System.monotonic_time() - started})
  end

  defp request_takeover(sock) do
    Logger.notice("Session transfer: requesting takeover at #{node()}")

    with {:ok, names} <- TinySock.call(sock, {@cmd_list_cache_names, session_version()}) do
      tasks = Enum.map(names, fn name -> Task.async(fn -> takeover_cache(sock, name) end) end)
      Task.await_many(tasks, :timer.seconds(10))
    end
  after
    Logger.notice("Session transfer: marking takeover as done at #{node()}")
    TinySock.call(sock, @cmd_takeover_done)
  end

  defp takeover_cache(sock, cache) do
    Logger.notice("Session transfer: requesting cache #{cache} dump at #{node()}")

    with {:ok, records} <- TinySock.call(sock, {@cmd_dump_cache, cache}) do
      Enum.each(records, fn record ->
        {key, %ClickhouseSessionV2{} = session} = record
        Cache.Adapter.put(:sessions, key, session)
      end)

      Logger.notice("Session transfer: restored cache #{cache} at #{node()}")
    end
  end

  defp file_stat_ctime(path) do
    case File.stat(path) do
      {:ok, stat} -> stat.ctime
      {:error, _} -> nil
    end
  end

  defp session_version do
    [
      ClickhouseSessionV2.module_info(:md5),
      Cache.Adapter.module_info(:md5),
      Session.CacheStore.module_info(:md5),
      Session.Transfer.module_info(:md5)
    ]
  end

  defp replica_alive?(transfer_sup) do
    children = Supervisor.which_children(transfer_sup)

    replica =
      Enum.find_value(children, fn {id, pid, _, _} -> id == :transfer_replica && pid end)

    is_pid(replica) and Process.alive?(replica)
  catch
    :exit, {:noproc, _} -> false
  end
end
```

## File: `lib/plausible/session/transfer/alive.ex`
```
defmodule Plausible.Session.Transfer.Alive do
  @moduledoc false
  use GenServer

  @spec start_link((-> boolean)) :: GenServer.on_start()
  def start_link(until) do
    GenServer.start_link(__MODULE__, until)
  end

  @impl true
  def init(until) when is_function(until, 0) do
    Process.flag(:trap_exit, true)
    {:ok, until}
  end

  @impl true
  def terminate(_reason, until) do
    loop(until)
  end

  defp loop(until) do
    case until.() do
      true ->
        :ok

      false ->
        :timer.sleep(500)
        loop(until)
    end
  end
end
```

## File: `lib/plausible/session/transfer/tinysock.ex`
```
defmodule Plausible.Session.Transfer.TinySock do
  @moduledoc false
  use GenServer
  require Logger

  @tag_data "tinysock"
  @tag_size byte_size(@tag_data)

  def start_link(opts) do
    base_path = Keyword.fetch!(opts, :base_path)
    handler = Keyword.fetch!(opts, :handler)
    GenServer.start_link(__MODULE__, {base_path, handler})
  end

  @impl true
  def init({base_path, handler}) do
    File.mkdir_p!(base_path)
    socket = sock_listen_or_retry!(base_path)

    Process.flag(:trap_exit, true)
    state = %{socket: socket, handler: handler}
    for _ <- 1..10, do: spawn_acceptor(state)

    {:ok, state}
  end

  @spec list!(Path.t()) :: [Path.t()]
  def list!(base_path) do
    for @tag_data <> _rand = name <- File.ls!(base_path) do
      Path.join(base_path, name)
    end
  end

  @spec call(Path.t(), term, timeout) :: {:ok, reply :: term} | {:error, :timeout | :inet.posix()}
  def call(sock_path, message, timeout \\ :timer.seconds(5)) do
    with {:ok, socket} <- sock_connect_or_rm(sock_path, timeout) do
      try do
        with :ok <- sock_send(socket, :erlang.term_to_iovec(message)) do
          sock_recv(socket, timeout)
        end
      after
        sock_shut_and_close(socket)
      end
    end
  end

  @impl true
  def handle_cast(:accepted, state) do
    spawn_acceptor(state)
    {:noreply, state}
  end

  @impl true
  def handle_info({:EXIT, pid, reason}, state) do
    case reason do
      :normal ->
        {:noreply, state}

      :emfile ->
        Logger.error("tinysock ran out of file descriptors, stopping")
        {:stop, reason, state}

      reason ->
        log = "tinysock request handler #{inspect(pid)} terminating\n" <> format_error(reason)
        Logger.error(log, crash_reason: reason)
        {:noreply, state}
    end
  end

  defp format_error(reason) do
    case reason do
      {e, stacktrace} when is_list(stacktrace) -> Exception.format(:error, e, stacktrace)
      _other -> Exception.format(:exit, reason)
    end
  end

  @impl true
  def terminate(reason, %{socket: socket}) do
    with {:ok, {:local, path}} <- :inet.sockname(socket), do: File.rm(path)
    reason
  end

  defp spawn_acceptor(%{socket: socket, handler: handler}) do
    :proc_lib.spawn_link(__MODULE__, :accept, [_parent = self(), socket, handler])
  end

  @doc false
  def accept(parent, listen_socket, handler) do
    case :gen_tcp.accept(listen_socket, :infinity) do
      {:ok, socket} ->
        GenServer.cast(parent, :accepted)
        handle_message(socket, handler)

      {:error, reason} ->
        exit(reason)
    end
  end

  defp handle_message(socket, handler) do
    {:ok, message} = sock_recv(socket, _timeout = :timer.seconds(5))
    sock_send(socket, :erlang.term_to_iovec(handler.(message)))
  after
    sock_shut_and_close(socket)
  end

  @listen_opts mode: :binary, active: false, backlog: 1024
  @connect_opts mode: :binary, active: false

  defp sock_listen_or_retry!(base_path) do
    sock_name = @tag_data <> Base.url_encode64(:crypto.strong_rand_bytes(4), padding: false)
    sock_path = Path.join(base_path, sock_name)

    case :gen_tcp.listen(0, [{:ifaddr, {:local, sock_path}} | @listen_opts]) do
      {:ok, socket} -> socket
      {:error, :eaddrinuse} -> sock_listen_or_retry!(base_path)
      {:error, reason} -> raise File.Error, path: sock_path, reason: reason, action: "bind"
    end
  end

  defp sock_connect_or_rm(sock_path, timeout) do
    case :gen_tcp.connect({:local, sock_path}, 0, @connect_opts, timeout) do
      {:ok, socket} ->
        {:ok, socket}

      {:error, reason} = error ->
        if reason != :timeout do
          # removes stale socket file
          # possible - but unlikely - race condition
          File.rm(sock_path)
        end

        error
    end
  end

  @dialyzer :no_improper_lists
  defp sock_send(socket, data) do
    :gen_tcp.send(socket, [<<@tag_data, IO.iodata_length(data)::64-little>> | data])
  end

  defp sock_recv(socket, timeout) do
    with {:ok, <<@tag_data, size::64-little>>} <- :gen_tcp.recv(socket, @tag_size + 8, timeout),
         {:ok, binary} <- sock_recv_continue(socket, size, timeout, []) do
      try do
        {:ok, :erlang.binary_to_term(binary, [:safe])}
      rescue
        e -> {:error, e}
      end
    end
  end

  @five_mb 5 * 1024 * 1024

  # for larger messages (>64MB) we need to read in chunks or we get {:error, :enomem}
  defp sock_recv_continue(socket, size, timeout, acc) do
    with {:ok, data} <- :gen_tcp.recv(socket, min(size, @five_mb), timeout) do
      acc = [acc | data]

      case size - byte_size(data) do
        0 -> {:ok, IO.iodata_to_binary(acc)}
        left -> sock_recv_continue(socket, left, timeout, acc)
      end
    end
  end

  defp sock_shut_and_close(socket) do
    :gen_tcp.shutdown(socket, :read_write)
    :gen_tcp.close(socket)
  end
end
```

## File: `lib/plausible/session/write_buffer.ex`
```
defmodule Plausible.Session.WriteBuffer do
  @moduledoc false

  %{
    header: header,
    insert_sql: insert_sql,
    insert_opts: insert_opts,
    fields: fields,
    encoding_types: encoding_types
  } =
    Plausible.Ingestion.WriteBuffer.compile_time_prepare(Plausible.ClickhouseSessionV2)

  def child_spec(opts) do
    opts =
      Keyword.merge(opts,
        name: __MODULE__,
        header: unquote(header),
        insert_sql: unquote(insert_sql),
        insert_opts: unquote(insert_opts)
      )

    Plausible.Ingestion.WriteBuffer.child_spec(opts)
  end

  def insert(sessions) do
    row_binary =
      sessions
      |> Enum.map(fn %{is_bounce: is_bounce} = session ->
        {:ok, is_bounce} = Plausible.ClickhouseSessionV2.BoolUInt8.dump(is_bounce)
        session = %{session | is_bounce: is_bounce}
        Enum.map(unquote(fields), fn field -> Map.fetch!(session, field) end)
      end)
      |> Ch.RowBinary._encode_rows(unquote(encoding_types))
      |> IO.iodata_to_binary()

    :ok = Plausible.Ingestion.WriteBuffer.insert(__MODULE__, row_binary)
    {:ok, sessions}
  end

  def flush do
    Plausible.Ingestion.WriteBuffer.flush(__MODULE__)
  end
end
```

## File: `lib/plausible/shield/country_rule.ex`
```
defmodule Plausible.Shield.CountryRule do
  @moduledoc """
  Schema for Country Block List
  """
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @primary_key {:id, :binary_id, autogenerate: true}
  schema "shield_rules_country" do
    belongs_to :site, Plausible.Site
    field :country_code, :string
    field :action, Ecto.Enum, values: [:deny, :allow], default: :deny
    field :added_by, :string

    # If `from_cache?` is set, the struct might be incomplete - see `Plausible.Site.Shield.Rules.Country.Cache`
    field :from_cache?, :boolean, virtual: true, default: false
    timestamps()
  end

  def changeset(rule, attrs) do
    rule
    |> cast(attrs, [:site_id, :country_code])
    |> validate_required([:site_id, :country_code])
    |> validate_length(:country_code, is: 2)
    |> validate_change(:country_code, fn :country_code, cc ->
      if cc in Enum.map(Location.Country.all(), & &1.alpha_2) do
        []
      else
        [country_code: "is invalid"]
      end
    end)
    |> unique_constraint(:country_code,
      name: :shield_rules_country_site_id_country_code_index
    )
  end
end
```

## File: `lib/plausible/shield/country_rule_cache.ex`
```
defmodule Plausible.Shield.CountryRuleCache do
  @moduledoc """
  Allows retrieving Country Rules by domain and country code
  """
  alias Plausible.Shield.CountryRule

  import Ecto.Query
  use Plausible.Cache

  @cache_name :country_blocklist_by_domain

  @cached_schema_fields ~w(
    id
    country_code
    action
  )a

  @impl true
  def name(), do: @cache_name

  @impl true
  def child_id(), do: :cache_country_blocklist

  @impl true
  def count_all() do
    Plausible.Repo.aggregate(CountryRule, :count)
  end

  @impl true
  def base_db_query() do
    from rule in CountryRule,
      inner_join: s in assoc(rule, :site),
      select: {
        s.domain,
        s.domain_changed_from,
        %{struct(rule, ^@cached_schema_fields) | from_cache?: true}
      }
  end

  @impl true
  def get_from_source({domain, country_code}) do
    query =
      base_db_query()
      |> where([rule, site], rule.country_code == ^country_code and site.domain == ^domain)

    case Plausible.Repo.one(query) do
      {_, _, rule} -> %CountryRule{rule | from_cache?: false}
      _any -> nil
    end
  end

  @impl true
  def unwrap_cache_keys(items) do
    Enum.reduce(items, [], fn
      {domain, nil, object}, acc ->
        [{{domain, String.upcase(object.country_code)}, object} | acc]

      {domain, domain_changed_from, object}, acc ->
        [
          {{domain, String.upcase(object.country_code)}, object},
          {{domain_changed_from, String.upcase(object.country_code)}, object} | acc
        ]
    end)
  end
end
```

## File: `lib/plausible/shield/hostname_rule.ex`
```
defmodule Plausible.Shield.HostnameRule do
  @moduledoc """
  Schema for Hostnames allow list
  """
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @primary_key {:id, :binary_id, autogenerate: true}
  schema "shield_rules_hostname" do
    belongs_to :site, Plausible.Site
    field :hostname, :string
    field :hostname_pattern, Plausible.Ecto.Types.CompiledRegex
    field :action, Ecto.Enum, values: [:deny, :allow], default: :allow
    field :added_by, :string

    # If `from_cache?` is set, the struct might be incomplete - see `Plausible.Site.Shield.Rules.IP.Cache`
    field :from_cache?, :boolean, virtual: true, default: false
    timestamps()
  end

  def changeset(rule \\ %__MODULE__{}, attrs) do
    rule
    |> cast(attrs, [:site_id, :hostname])
    |> validate_required([:site_id, :hostname])
    |> validate_length(:hostname, max: 250)
    |> store_regex()
    |> unique_constraint(:hostname_pattern,
      name: :shield_rules_hostname_site_id_hostname_pattern_index,
      error_key: :hostname,
      message: "rule already exists"
    )
  end

  defp store_regex(changeset) do
    case fetch_change(changeset, :hostname) do
      {:ok, hostname} ->
        hostname
        |> build_regex()
        |> verify_and_put_regex(changeset)

      :error ->
        changeset
    end
  end

  defp build_regex(hostname) do
    regex =
      hostname
      |> Regex.escape()
      |> String.replace("\\*\\*", ".*")
      |> String.replace("\\*", ".*")

    "^#{regex}$"
  end

  defp verify_and_put_regex(regex, changeset) do
    case Regex.compile(regex) do
      {:ok, _} ->
        put_change(changeset, :hostname_pattern, regex)

      {:error, _} ->
        add_error(changeset, :hostname, "could not compile regular expression")
    end
  end
end
```

## File: `lib/plausible/shield/hostname_rule_cache.ex`
```
defmodule Plausible.Shield.HostnameRuleCache do
  @moduledoc """
  Allows retrieving Hostname Rules by domain
  """
  alias Plausible.Shield.HostnameRule

  import Ecto.Query
  use Plausible.Cache

  @cache_name :hostname_allowlist_by_domain

  @cached_schema_fields ~w(
    id
    hostname_pattern
    action
  )a

  @impl true
  def name(), do: @cache_name

  @impl true
  def child_id(), do: :cache_hostname_blocklist

  @impl true
  def count_all() do
    Plausible.Repo.aggregate(HostnameRule, :count)
  end

  @impl true
  def base_db_query() do
    from rule in HostnameRule,
      inner_join: s in assoc(rule, :site),
      select: {
        s.domain,
        s.domain_changed_from,
        %{struct(rule, ^@cached_schema_fields) | from_cache?: true}
      }
  end

  @impl true
  def get_from_source(domain) do
    query =
      base_db_query()
      |> where([..., site], site.domain == ^domain)

    case Plausible.Repo.all(query) do
      [_ | _] = results ->
        Enum.map(results, fn {_, _, rule} ->
          %HostnameRule{rule | from_cache?: false}
        end)

      _ ->
        nil
    end
  end

  @impl true
  def unwrap_cache_keys(items) do
    Enum.reduce(items, [], fn
      {domain, nil, object}, acc ->
        [{domain, object} | acc]

      {domain, domain_changed_from, object}, acc ->
        [
          {domain, object},
          {domain_changed_from, object} | acc
        ]
    end)
  end
end
```

## File: `lib/plausible/shield/ip_rule.ex`
```
defmodule Plausible.Shield.IPRule do
  @moduledoc """
  Schema for IP block list
  """
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @primary_key {:id, :binary_id, autogenerate: true}
  schema "shield_rules_ip" do
    belongs_to :site, Plausible.Site
    field :inet, EctoNetwork.INET
    field :action, Ecto.Enum, values: [:deny, :allow], default: :deny
    field :description, :string
    field :added_by, :string

    # If `from_cache?` is set, the struct might be incomplete - see `Plausible.Site.Shield.Rules.IP.Cache`
    field :from_cache?, :boolean, virtual: true, default: false
    timestamps()
  end

  def changeset(rule, attrs) do
    rule
    |> cast(attrs, [:site_id, :inet, :description])
    |> validate_required([:site_id, :inet])
    |> disallow_netmask(:inet)
    |> unique_constraint(:inet,
      name: :shield_rules_ip_site_id_inet_index
    )
  end

  defp disallow_netmask(changeset, field) do
    case get_field(changeset, field) do
      %Postgrex.INET{netmask: netmask} when netmask != 32 and netmask != 128 ->
        add_error(changeset, field, "netmask unsupported")

      _ ->
        changeset
    end
  end
end
```

## File: `lib/plausible/shield/ip_rule_cache.ex`
```
defmodule Plausible.Shield.IPRuleCache do
  @moduledoc """
  Allows retrieving IP Rules by domain and IP
  """
  alias Plausible.Shield.IPRule

  import Ecto.Query
  use Plausible.Cache

  @cache_name :ip_blocklist_by_domain

  @cached_schema_fields ~w(
    id
    inet
    action
  )a

  @impl true
  def name(), do: @cache_name

  @impl true
  def child_id(), do: :cache_ip_blocklist

  @impl true
  def count_all() do
    Plausible.Repo.aggregate(IPRule, :count)
  end

  @impl true
  def base_db_query() do
    from rule in IPRule,
      inner_join: s in assoc(rule, :site),
      select: {
        s.domain,
        s.domain_changed_from,
        %{struct(rule, ^@cached_schema_fields) | from_cache?: true}
      }
  end

  @impl true
  def get_from_source({domain, address}) do
    query =
      base_db_query()
      |> where([rule, site], rule.inet == ^address and site.domain == ^domain)

    case Plausible.Repo.one(query) do
      {_, _, rule} -> %IPRule{rule | from_cache?: false}
      _any -> nil
    end
  end

  @impl true
  def unwrap_cache_keys(items) do
    Enum.reduce(items, [], fn
      {domain, nil, object}, acc ->
        [{{domain, to_string(object.inet)}, object} | acc]

      {domain, domain_changed_from, object}, acc ->
        [
          {{domain, to_string(object.inet)}, object},
          {{domain_changed_from, to_string(object.inet)}, object} | acc
        ]
    end)
  end
end
```

## File: `lib/plausible/shield/page_rule.ex`
```
defmodule Plausible.Shield.PageRule do
  @moduledoc """
  Schema for Pages block list
  """
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @primary_key {:id, :binary_id, autogenerate: true}
  schema "shield_rules_page" do
    belongs_to :site, Plausible.Site
    field :page_path, :string
    field :page_path_pattern, Plausible.Ecto.Types.CompiledRegex
    field :action, Ecto.Enum, values: [:deny, :allow], default: :deny
    field :added_by, :string

    # If `from_cache?` is set, the struct might be incomplete - see `Plausible.Site.Shield.Rules.IP.Cache`
    field :from_cache?, :boolean, virtual: true, default: false
    timestamps()
  end

  def changeset(rule \\ %__MODULE__{}, attrs) do
    rule
    |> cast(attrs, [:site_id, :page_path])
    |> validate_required([:site_id, :page_path])
    |> validate_length(:page_path, max: 250)
    |> validate_change(:page_path, fn :page_path, p ->
      if not String.starts_with?(p, "/") do
        [page_path: "must start with /"]
      else
        []
      end
    end)
    |> store_regex()
    |> unique_constraint(:page_path_pattern,
      name: :shield_rules_page_site_id_page_path_pattern_index,
      error_key: :page_path,
      message: "rule already exists"
    )
  end

  defp store_regex(changeset) do
    case get_field(changeset, :page_path) do
      "/" <> _ = page_path ->
        regex =
          page_path
          |> Regex.escape()
          |> String.replace("\\*\\*", ".*")
          |> String.replace("\\*", ".*")

        regex = "^#{regex}$"

        verify_valid_regex(changeset, regex)

      _ ->
        changeset
    end
  end

  defp verify_valid_regex(changeset, regex) do
    case Regex.compile(regex) do
      {:ok, _} ->
        put_change(changeset, :page_path_pattern, regex)

      {:error, _} ->
        add_error(changeset, :page_path, "could not compile regular expression")
    end
  end
end
```

## File: `lib/plausible/shield/page_rule_cache.ex`
```
defmodule Plausible.Shield.PageRuleCache do
  @moduledoc """
  Allows retrieving Page Rules by domain
  """
  alias Plausible.Shield.PageRule

  import Ecto.Query
  use Plausible.Cache

  @cache_name :page_blocklist_by_domain

  @cached_schema_fields ~w(
    id
    page_path_pattern
    action
  )a

  @impl true
  def name(), do: @cache_name

  @impl true
  def child_id(), do: :cache_page_blocklist

  @impl true
  def count_all() do
    Plausible.Repo.aggregate(PageRule, :count)
  end

  @impl true
  def base_db_query() do
    from rule in PageRule,
      inner_join: s in assoc(rule, :site),
      select: {
        s.domain,
        s.domain_changed_from,
        %{struct(rule, ^@cached_schema_fields) | from_cache?: true}
      }
  end

  @impl true
  def get_from_source(domain) do
    query =
      base_db_query()
      |> where([..., site], site.domain == ^domain)

    case Plausible.Repo.one(query) do
      {_, _, rule} -> %PageRule{rule | from_cache?: false}
      _any -> nil
    end
  end

  @impl true
  def unwrap_cache_keys(items) do
    Enum.reduce(items, [], fn
      {domain, nil, object}, acc ->
        [{domain, object} | acc]

      {domain, domain_changed_from, object}, acc ->
        [
          {domain, object},
          {domain_changed_from, object} | acc
        ]
    end)
  end
end
```

## File: `lib/plausible/shields.ex`
```
defmodule Plausible.Shields do
  @moduledoc """
  Contextual interface for shields.
  """
  import Ecto.Query
  alias Plausible.Repo
  alias Plausible.Shield
  alias Plausible.Site

  @maximum_ip_rules 30
  def maximum_ip_rules(), do: @maximum_ip_rules

  @maximum_country_rules 30
  def maximum_country_rules(), do: @maximum_country_rules

  @maximum_page_rules 30
  def maximum_page_rules(), do: @maximum_page_rules

  @maximum_hostname_rules 10
  def maximum_hostname_rules(), do: @maximum_hostname_rules

  @spec list_ip_rules(Site.t() | non_neg_integer()) :: [Shield.IPRule.t()]
  def list_ip_rules(site_or_id) do
    list(Shield.IPRule, site_or_id)
  end

  @spec hostname_allowed?(Site.t() | String.t(), String.t()) :: boolean()
  def hostname_allowed?(%Site{domain: domain}, hostname) do
    hostname_allowed?(domain, hostname)
  end

  def hostname_allowed?(domain, hostname) when is_binary(domain) and is_binary(hostname) do
    hostname_rules = Shield.HostnameRuleCache.get(domain)

    if hostname_rules do
      hostname_rules
      |> List.wrap()
      |> Enum.find_value(false, fn rule ->
        rule.action == :allow and
          Regex.match?(rule.hostname_pattern, hostname)
      end)
    else
      true
    end
  end

  @spec allowed_hostname_patterns(Site.t() | String.t()) :: list(String.t()) | :all
  def allowed_hostname_patterns(%Site{domain: domain}) do
    allowed_hostname_patterns(domain)
  end

  def allowed_hostname_patterns(domain) when is_binary(domain) do
    hostname_rules = Shield.HostnameRuleCache.get(domain)

    if hostname_rules do
      hostname_rules
      |> List.wrap()
      |> Enum.map(&Regex.source(&1.hostname_pattern))
    else
      :all
    end
  end

  @spec ip_blocked?(Site.t() | String.t(), String.t()) :: boolean()
  def ip_blocked?(%Site{domain: domain}, address) do
    ip_blocked?(domain, address)
  end

  def ip_blocked?(domain, address) when is_binary(domain) and is_binary(address) do
    case Shield.IPRuleCache.get({domain, address}) do
      %Shield.IPRule{action: :deny} ->
        true

      _ ->
        false
    end
  end

  @spec page_blocked?(Site.t() | String.t(), String.t()) :: boolean()
  def page_blocked?(%Site{domain: domain}, address) do
    page_blocked?(domain, address)
  end

  def page_blocked?(domain, pathname) when is_binary(domain) and is_binary(pathname) do
    page_rules = Shield.PageRuleCache.get(domain)

    if page_rules do
      page_rules
      |> List.wrap()
      |> Enum.find_value(false, fn rule ->
        rule.action == :deny and Regex.match?(rule.page_path_pattern, pathname)
      end)
    else
      false
    end
  end

  @spec country_blocked?(Site.t() | String.t(), String.t()) :: boolean()
  def country_blocked?(%Site{domain: domain}, country_code) do
    country_blocked?(domain, country_code)
  end

  def country_blocked?(domain, country_code) when is_binary(domain) and is_binary(country_code) do
    case Shield.CountryRuleCache.get({domain, String.upcase(country_code)}) do
      %Shield.CountryRule{action: :deny} ->
        true

      _ ->
        false
    end
  end

  @spec add_ip_rule(Site.t() | non_neg_integer(), map(), Keyword.t()) ::
          {:ok, Shield.IPRule.t()} | {:error, Ecto.Changeset.t()}
  def add_ip_rule(site_or_id, params, opts \\ []) do
    opts =
      Keyword.put(opts, :limit, {:inet, @maximum_ip_rules})

    add(Shield.IPRule, site_or_id, params, opts)
  end

  @spec remove_ip_rule(Site.t() | non_neg_integer(), String.t()) :: :ok
  def remove_ip_rule(site_or_id, rule_id) do
    remove(Shield.IPRule, site_or_id, rule_id)
  end

  @spec count_ip_rules(Site.t() | non_neg_integer()) :: non_neg_integer()
  def count_ip_rules(site_or_id) do
    count(Shield.IPRule, site_or_id)
  end

  @spec list_country_rules(Site.t() | non_neg_integer()) :: [Shield.CountryRule.t()]
  def list_country_rules(site_or_id) do
    list(Shield.CountryRule, site_or_id)
  end

  @spec add_country_rule(Site.t() | non_neg_integer(), map(), Keyword.t()) ::
          {:ok, Shield.CountryRule.t()} | {:error, Ecto.Changeset.t()}
  def add_country_rule(site_or_id, params, opts \\ []) do
    opts = Keyword.put(opts, :limit, {:country_code, @maximum_country_rules})
    add(Shield.CountryRule, site_or_id, params, opts)
  end

  @spec remove_country_rule(Site.t() | non_neg_integer(), String.t()) :: :ok
  def remove_country_rule(site_or_id, rule_id) do
    remove(Shield.CountryRule, site_or_id, rule_id)
  end

  @spec count_country_rules(Site.t() | non_neg_integer()) :: non_neg_integer()
  def count_country_rules(site_or_id) do
    count(Shield.CountryRule, site_or_id)
  end

  @spec list_page_rules(Site.t() | non_neg_integer()) :: [Shield.PageRule.t()]
  def list_page_rules(site_or_id) do
    list(Shield.PageRule, site_or_id)
  end

  @spec add_page_rule(Site.t() | non_neg_integer(), map(), Keyword.t()) ::
          {:ok, Shield.PageRule.t()} | {:error, Ecto.Changeset.t()}
  def add_page_rule(site_or_id, params, opts \\ []) do
    opts = Keyword.put(opts, :limit, {:page_path, @maximum_page_rules})
    add(Shield.PageRule, site_or_id, params, opts)
  end

  @spec remove_page_rule(Site.t() | non_neg_integer(), String.t()) :: :ok
  def remove_page_rule(site_or_id, rule_id) do
    remove(Shield.PageRule, site_or_id, rule_id)
  end

  @spec count_page_rules(Site.t() | non_neg_integer()) :: non_neg_integer()
  def count_page_rules(site_or_id) do
    count(Shield.PageRule, site_or_id)
  end

  @spec list_hostname_rules(Site.t() | non_neg_integer()) :: [Shield.HostnameRule.t()]
  def list_hostname_rules(site_or_id) do
    list(Shield.HostnameRule, site_or_id)
  end

  @spec add_hostname_rule(Site.t() | non_neg_integer(), map(), Keyword.t()) ::
          {:ok, Shield.HostnameRule.t()} | {:error, Ecto.Changeset.t()}
  def add_hostname_rule(site_or_id, params, opts \\ []) do
    opts = Keyword.put(opts, :limit, {:hostname, @maximum_hostname_rules})
    add(Shield.HostnameRule, site_or_id, params, opts)
  end

  @spec remove_hostname_rule(Site.t() | non_neg_integer(), String.t()) :: :ok
  def remove_hostname_rule(site_or_id, rule_id) do
    remove(Shield.HostnameRule, site_or_id, rule_id)
  end

  @spec count_hostname_rules(Site.t() | non_neg_integer()) :: non_neg_integer()
  def count_hostname_rules(site_or_id) do
    count(Shield.HostnameRule, site_or_id)
  end

  defp list(schema, %Site{id: id}) do
    list(schema, id)
  end

  defp list(schema, site_id) when is_integer(site_id) do
    Repo.all(
      from r in schema,
        where: r.site_id == ^site_id,
        order_by: [desc: r.inserted_at]
    )
  end

  defp add(schema, %Site{id: id}, params, opts) do
    add(schema, id, params, opts)
  end

  defp add(schema, site_id, params, opts) when is_integer(site_id) do
    {field, max} = Keyword.fetch!(opts, :limit)

    Repo.transaction(fn ->
      result =
        if count(schema, site_id) >= max do
          changeset =
            schema
            |> struct(site_id: site_id)
            |> schema.changeset(params)
            |> Ecto.Changeset.add_error(field, "maximum reached")

          {:error, changeset}
        else
          schema
          |> struct(site_id: site_id, added_by: format_added_by(opts[:added_by]))
          |> schema.changeset(params)
          |> Repo.insert()
        end

      case result do
        {:ok, rule} -> rule
        {:error, changeset} -> Repo.rollback(changeset)
      end
    end)
  end

  defp remove(schema, %Site{id: id}, rule_id) do
    remove(schema, id, rule_id)
  end

  defp remove(schema, site_id, rule_id) when is_integer(site_id) do
    Repo.delete_all(from(r in schema, where: r.site_id == ^site_id and r.id == ^rule_id))
    :ok
  end

  defp count(schema, %Site{id: id}) do
    count(schema, id)
  end

  defp count(schema, site_id) when is_integer(site_id) do
    Repo.aggregate(from(r in schema, where: r.site_id == ^site_id), :count)
  end

  defp format_added_by(nil), do: ""
  defp format_added_by(%Plausible.Auth.User{} = user), do: "#{user.name} <#{user.email}>"
end
```

## File: `lib/plausible/site.ex`
```
defmodule Plausible.Site do
  @moduledoc """
  Site schema
  """
  use Ecto.Schema
  use Plausible
  import Ecto.Changeset
  alias Plausible.Site.GoogleAuth

  @type t() :: %__MODULE__{}

  @derive {Jason.Encoder, only: [:domain, :timezone]}
  schema "sites" do
    field :domain, :string
    field :timezone, :string, default: "Etc/UTC"
    field :public, :boolean
    field :stats_start_date, :date
    field :native_stats_start_at, :naive_datetime
    field :allowed_event_props, {:array, :string}
    field :conversions_enabled, :boolean, default: true
    field :props_enabled, :boolean, default: true
    field :funnels_enabled, :boolean, default: true
    field :legacy_time_on_page_cutoff, :date, default: ~D[1970-01-01]

    field :ingest_rate_limit_scale_seconds, :integer, default: 60
    # default is set via changeset/2
    field :ingest_rate_limit_threshold, :integer

    field :domain_changed_from, :string
    field :domain_changed_at, :naive_datetime

    # NOTE: needed by `SiteImports` data migration script
    embeds_one :imported_data, Plausible.Site.ImportedData, on_replace: :update

    # NOTE: new teams relations
    belongs_to :team, Plausible.Teams.Team
    has_many :guest_memberships, Plausible.Teams.GuestMembership
    has_many :guest_invitations, Plausible.Teams.GuestInvitation

    has_one :tracker_script_configuration, Plausible.Site.TrackerScriptConfiguration

    has_many :goals, Plausible.Goal, preload_order: [desc: :id]
    has_many :revenue_goals, Plausible.Goal, where: [currency: {:not, nil}]
    has_one :google_auth, GoogleAuth
    has_one :weekly_report, Plausible.Site.WeeklyReport
    has_one :monthly_report, Plausible.Site.MonthlyReport
    has_many :ownerships, through: [:team, :ownerships], preload_order: [asc: :id]
    has_many :owners, through: [:team, :owners]

    # If `from_cache?` is set, the struct might be incomplete - see `Plausible.Site.Cache`.
    # Use `Plausible.Repo.reload!(cached_site)` to pre-fill missing fields if
    # strictly necessary.
    field :from_cache?, :boolean, virtual: true, default: false

    # Used in the context of paginated sites list to order in relation to
    # user's membership state. Currently it can be either "invitation",
    # "pinned_site" or "site", where invitations are first.
    field :entry_type, :string, virtual: true
    field :memberships, {:array, :map}, virtual: true
    field :invitations, {:array, :map}, virtual: true
    field :pinned_at, :naive_datetime, virtual: true

    has_many :completed_imports, Plausible.Imported.SiteImport, where: [status: :completed]

    timestamps()
  end

  def new_for_team(team, params) do
    params
    |> new()
    |> put_assoc(:team, team)
  end

  def new(params), do: changeset(%__MODULE__{}, params)

  on_ee do
    @domain_unique_error """
    This domain cannot be registered. Perhaps one of your colleagues registered it? If that's not the case, please contact support@plausible.io
    """
  else
    @domain_unique_error """
    This domain cannot be registered. Perhaps one of your colleagues registered it?
    """
  end

  def changeset(site, attrs \\ %{}) do
    site
    |> cast(attrs, [:domain, :timezone, :legacy_time_on_page_cutoff])
    |> clean_domain()
    |> validate_required([:domain, :timezone])
    |> validate_timezone()
    |> validate_domain_format()
    |> validate_domain_reserved_characters()
    |> unique_constraint(:domain,
      message: @domain_unique_error
    )
    |> unique_constraint(:domain,
      name: "domain_change_disallowed",
      message: @domain_unique_error
    )
    |> put_change(
      :ingest_rate_limit_threshold,
      Application.get_env(:plausible, __MODULE__)[:default_ingest_threshold]
    )
  end

  def update_changeset(site, attrs \\ %{}, opts \\ []) do
    at =
      opts
      |> Keyword.get(:at, NaiveDateTime.utc_now())
      |> NaiveDateTime.truncate(:second)

    site
    |> changeset(attrs)
    |> handle_domain_change(at)
  end

  def crm_changeset(site, attrs) do
    site
    |> cast(attrs, [
      :timezone,
      :public,
      :native_stats_start_at,
      :ingest_rate_limit_threshold,
      :ingest_rate_limit_scale_seconds
    ])
    |> validate_required([:timezone, :public])
    |> validate_number(:ingest_rate_limit_scale_seconds,
      greater_than_or_equal_to: 1,
      message: "must be at least 1 second"
    )
    |> validate_number(:ingest_rate_limit_threshold,
      greater_than_or_equal_to: 0,
      message: "must be empty, zero or positive"
    )
  end

  def tz_offset(site, utc_now \\ DateTime.utc_now()) do
    case DateTime.shift_zone(utc_now, site.timezone) do
      {:ok, datetime} ->
        datetime.utc_offset + datetime.std_offset

      res ->
        Sentry.capture_message("Unable to determine timezone offset for",
          extra: %{site: site, result: res}
        )

        0
    end
  end

  def make_public(site) do
    change(site, public: true)
  end

  def make_private(site) do
    change(site, public: false)
  end

  def set_stats_start_date(site, val) do
    change(site, stats_start_date: val)
  end

  def set_native_stats_start_at(site, val) do
    change(site, native_stats_start_at: val)
  end

  defp clean_domain(changeset) do
    clean_domain =
      (get_field(changeset, :domain) || "")
      |> String.downcase()
      |> String.trim()
      |> String.replace_leading("http://", "")
      |> String.replace_leading("https://", "")
      |> String.trim("/")
      |> String.replace_leading("www.", "")

    change(changeset, %{domain: clean_domain})
  end

  # https://tools.ietf.org/html/rfc3986#section-2.2
  @uri_reserved_chars ~w(: ? # [ ] @ ! $ & ' \( \) * + , ; =)
  defp validate_domain_reserved_characters(changeset) do
    domain = get_field(changeset, :domain) || ""

    if String.contains?(domain, @uri_reserved_chars) do
      add_error(
        changeset,
        :domain,
        "must not contain URI reserved characters #{@uri_reserved_chars}"
      )
    else
      changeset
    end
  end

  defp validate_domain_format(changeset) do
    validate_format(changeset, :domain, ~r/^[-\.\\\/:\p{L}\d]*$/u,
      message: "only letters, numbers, slashes and period allowed"
    )
  end

  defp handle_domain_change(changeset, at) do
    new_domain = get_change(changeset, :domain)

    if new_domain do
      changeset
      |> put_change(:domain_changed_from, changeset.data.domain)
      |> put_change(:domain_changed_at, at)
      |> unique_constraint(:domain,
        name: "domain_change_disallowed",
        message: @domain_unique_error
      )
      |> unique_constraint(:domain_changed_from,
        message: @domain_unique_error
      )
    else
      changeset
    end
  end

  defp validate_timezone(changeset) do
    tz = get_field(changeset, :timezone)

    if Timex.is_valid_timezone?(tz) do
      changeset
    else
      add_error(changeset, :timezone, "is invalid")
    end
  end
end

defimpl FunWithFlags.Actor, for: Plausible.Site do
  def id(%{domain: domain}) do
    "site:#{domain}"
  end
end
```

## File: `lib/plausible/site/cache.ex`
```
defmodule Plausible.Site.Cache do
  @moduledoc """
  The cache allows lookups by both `domain` and `domain_changed_from`
  fields - this is to allow traffic from sites whose domains changed within a certain
  grace period (see: `Plausible.Site.Transfer`).

  To differentiate cached Site structs from those retrieved directly from the
  database, a virtual schema field `from_cache?: true` is set.
  This indicates the `Plausible.Site` struct is incomplete in comparison to its
  database counterpart -- to spare bandwidth and query execution time,
  only selected database columns are retrieved and cached.

  The `@cached_schema_fields` attribute defines the list of DB columns
  queried on each cache refresh.

  Also see tests for more comprehensive examples.
  """
  require Logger

  import Ecto.Query

  alias Plausible.Site

  use Plausible.Cache

  @cache_name :sites_by_domain

  @cached_schema_fields ~w(
    id
    domain
    domain_changed_from
    ingest_rate_limit_scale_seconds
    ingest_rate_limit_threshold
   )a

  @impl true
  def name(), do: @cache_name

  @impl true
  def child_id(), do: :cache_sites

  @impl true
  def count_all() do
    Plausible.Repo.aggregate(Site, :count)
  end

  @impl true
  def base_db_query() do
    from s in Site,
      left_join: rg in assoc(s, :revenue_goals),
      inner_join: team in assoc(s, :team),
      select: {
        s.domain,
        s.domain_changed_from,
        %{struct(s, ^@cached_schema_fields) | from_cache?: true}
      },
      preload: [revenue_goals: rg, team: team]
  end

  @impl true
  def get_from_source(domain) do
    query = from s in base_db_query(), where: s.domain == ^domain

    case Plausible.Repo.one(query) do
      {_, _, site} -> %Site{site | from_cache?: false}
      _any -> nil
    end
  end

  @spec get_site_id(String.t(), Keyword.t()) :: pos_integer() | nil
  def get_site_id(domain, opts \\ []) do
    case get(domain, opts) do
      %{id: site_id} ->
        site_id

      nil ->
        nil
    end
  end

  @spec touch_site!(Site.t(), DateTime.t()) :: Site.t()
  def touch_site!(site, now) do
    now =
      now
      |> DateTime.truncate(:second)
      |> DateTime.to_naive()

    site
    |> Ecto.Changeset.change(updated_at: now)
    |> Plausible.Repo.update!()
  end

  @impl true
  def unwrap_cache_keys(items) do
    Enum.reduce(items, [], fn
      {domain, nil, object}, acc ->
        [{domain, object} | acc]

      {domain, domain_changed_from, object}, acc ->
        [{domain, object}, {domain_changed_from, object} | acc]
    end)
  end
end
```

## File: `lib/plausible/site/domain.ex`
```
defmodule Plausible.Site.Domain do
  @expire_threshold_hours 72

  @moduledoc """
  Basic interface for domain changes.

  Once `Plausible.DataMigration.NumericIDs` schema migration is ready, 
  domain change operation will be enabled, accessible to the users.

  We will set a transition period of #{@expire_threshold_hours} hours
  during which, both old and new domains, will be accepted as traffic
  identifiers to the same site. 

  A periodic worker will call the `expire/0` function to end it where applicable.
  See: `Plausible.Workers.ExpireDomainChangeTransitions`.

  The underlying changeset for domain change (see: `Plausible.Site`) relies
  on database trigger installed via `Plausible.Repo.Migrations.AllowDomainChange`
  Postgres migration. The trigger checks if either `domain` or `domain_changed_from`
  exist to ensure unicity.
  """

  alias Plausible.Site
  alias Plausible.Repo

  import Ecto.Query

  @spec expire_change_transitions(integer()) :: {:ok, non_neg_integer()}
  def expire_change_transitions(expire_threshold_hours \\ @expire_threshold_hours) do
    {updated, _} =
      Repo.update_all(
        from(s in Site,
          where: s.domain_changed_at < ago(^expire_threshold_hours, "hour")
        ),
        set: [
          domain_changed_from: nil,
          domain_changed_at: nil
        ]
      )

    {:ok, updated}
  end

  @spec change(Site.t(), String.t(), Keyword.t()) ::
          {:ok, Site.t()} | {:error, Ecto.Changeset.t()}
  def change(%Site{} = site, new_domain, opts \\ []) do
    changeset = Site.update_changeset(site, %{domain: new_domain}, opts)

    changeset =
      if is_nil(changeset.errors[:domain]) and is_nil(changeset.changes[:domain]) do
        Ecto.Changeset.add_error(
          changeset,
          :domain,
          "New domain must be different than the current one"
        )
      else
        changeset
      end

    Repo.update(changeset)
  end
end
```

## File: `lib/plausible/site/gate_keeper.ex`
```
defmodule Plausible.Site.GateKeeper do
  @type policy() :: :allow | :not_found | :block | :throttle | :payment_required
  @policy_for_non_existing_sites :not_found

  @type t() :: {:allow, Plausible.Site.t()} | {:deny, policy()}

  @moduledoc """
  Thin wrapper around `Plausible.RateLimit` for gate keeping domain-specific events
  during the ingestion phase. When the site is allowed, gate keeping
  check returns `:allow`, otherwise a `:deny` tagged tuple is returned
  with one of the following policy markers:
    * `:not_found` (indicates site not found in cache)
    * `:block` (indicates disabled sites)
    * `:throttle` (indicates rate limiting)

  Rate Limiting buckets are configured per site (externally via the CRM).
  See: `Plausible.Site`

  To look up each site's configuration, the RateLimiter fetches
  a Site by domain using `Plausible.Cache` interface.

  The module defines two policies outside the regular bucket inspection:
    * when the site is not found in cache: #{@policy_for_non_existing_sites}
    * when the underlying rate limiting mechanism returns
      an internal error: :allow
  """
  alias Plausible.{Site, RateLimit}
  alias Plausible.Site.Cache

  require Logger

  @spec check(String.t(), Keyword.t()) :: t()
  def check(domain, opts \\ []) when is_binary(domain) do
    case policy(domain, opts) do
      {:allow, site} -> {:allow, site}
      other -> {:deny, other}
    end
  end

  @spec key(String.t()) :: String.t()
  def key(domain) do
    "ingest:site:#{domain}"
  end

  defp policy(domain, opts) when is_binary(domain) do
    with from_cache <- Cache.get(domain, Keyword.get(opts, :cache_opts, [])),
         site = %Site{team: %{accept_traffic_until: accept_traffic_until}} <- from_cache do
      if not is_nil(accept_traffic_until) and
           Date.after?(Date.utc_today(), accept_traffic_until) do
        :payment_required
      else
        check_rate_limit(site, opts)
      end
    else
      _ ->
        @policy_for_non_existing_sites
    end
  end

  defp check_rate_limit(%Site{ingest_rate_limit_threshold: nil} = site, _opts) do
    {:allow, site}
  end

  defp check_rate_limit(%Site{ingest_rate_limit_threshold: 0}, _opts) do
    :block
  end

  defp check_rate_limit(%Site{ingest_rate_limit_threshold: threshold} = site, opts)
       when is_integer(threshold) do
    key = Keyword.get(opts, :key, key(site.domain))
    scale_ms = site.ingest_rate_limit_scale_seconds * 1_000

    case RateLimit.check_rate(key, scale_ms, threshold) do
      {:deny, _} -> :throttle
      {:allow, _} -> {:allow, site}
    end
  end
end
```

## File: `lib/plausible/site/google_auth.ex`
```
defmodule Plausible.Site.GoogleAuth do
  use Ecto.Schema
  import Ecto.Changeset

  schema "google_auth" do
    field :email, :string
    field :property, :string
    field :refresh_token, :string
    field :access_token, :string
    field :expires, :naive_datetime

    belongs_to :user, Plausible.Auth.User
    belongs_to :site, Plausible.Site

    timestamps()
  end

  def changeset(auth, attrs \\ %{}) do
    auth
    |> cast(attrs, [:refresh_token, :access_token, :expires, :email, :user_id, :site_id])
    |> validate_required([:refresh_token, :access_token, :expires, :email, :user_id, :site_id])
    |> unique_constraint(:site)
  end

  def set_property(auth, attrs \\ %{}) do
    auth
    |> cast(attrs, [:property])
  end
end
```

## File: `lib/plausible/site/imported_data.ex`
```
defmodule Plausible.Site.ImportedData do
  @moduledoc """
  Embedded schema for analytics imports

  NOTE: needed by `SiteImports` data migration script
  """
  use Ecto.Schema

  @type t() :: %__MODULE__{}

  embedded_schema do
    field :start_date, :date
    field :end_date, :date
    field :source, :string
    field :status, :string
  end
end
```

## File: `lib/plausible/site/monthly_report.ex`
```
defmodule Plausible.Site.MonthlyReport do
  use Ecto.Schema
  import Ecto.Changeset

  schema "monthly_reports" do
    field :recipients, {:array, :string}
    belongs_to :site, Plausible.Site

    timestamps()
  end

  def changeset(settings, attrs \\ %{}) do
    settings
    |> cast(attrs, [:site_id, :recipients])
    |> validate_required([:site_id, :recipients])
    |> unique_constraint(:site_id)
  end

  def add_recipient(report, recipient) do
    report
    |> change(recipients: report.recipients ++ [recipient])
  end

  def remove_recipient(report, recipient) do
    report
    |> change(recipients: List.delete(report.recipients, recipient))
  end
end
```

## File: `lib/plausible/site/removal.ex`
```
defmodule Plausible.Site.Removal do
  @moduledoc """
  A site deletion service stub.
  """
  use Plausible

  alias Plausible.Repo
  alias Plausible.Teams

  import Ecto.Query

  @spec run(Plausible.Site.t()) :: {:ok, map()}
  def run(site) do
    Repo.transaction(fn ->
      site = Repo.preload(site, :team)

      result = Repo.delete_all(from(s in Plausible.Site, where: s.domain == ^site.domain))

      Teams.Memberships.prune_guests(site.team)
      Teams.Invitations.prune_guest_invitations(site.team)

      on_ee do
        Plausible.Billing.SiteLocker.update_for(site.team, send_email?: false)
      end

      %{delete_all: result}
    end)
  end
end
```

## File: `lib/plausible/site/shared_link.ex`
```
defmodule Plausible.Site.SharedLink do
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  schema "shared_links" do
    belongs_to :site, Plausible.Site
    field :name, :string
    field :slug, :string
    field :password_hash, :string
    field :password, :string, virtual: true

    timestamps()
  end

  def changeset(link, attrs \\ %{}, opts \\ []) do
    link
    |> cast(attrs, [:slug, :password, :name])
    |> validate_required([:slug, :name])
    |> validate_special_name(opts)
    |> unique_constraint(:slug)
    |> unique_constraint(:name, name: :shared_links_site_id_name_index)
    |> hash_password()
  end

  defp validate_special_name(changeset, opts) do
    name = get_change(changeset, :name)

    if name not in Plausible.Sites.shared_link_special_names() ||
         Keyword.get(opts, :skip_special_name_check?, false) do
      changeset
    else
      changeset |> add_error(:name, "This name is reserved. Please choose another one")
    end
  end

  defp hash_password(link) do
    case link.changes[:password] do
      nil ->
        link

      password ->
        hash = Plausible.Auth.Password.hash(password)
        change(link, password_hash: hash)
    end
  end
end
```

## File: `lib/plausible/site/tracker_script_configuration.ex`
```
defmodule Plausible.Site.TrackerScriptConfiguration do
  @moduledoc """
  Schema for tracker script configuration
  """
  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @primary_key {:id, Plausible.Ecto.Types.Nanoid, autogenerate: true}
  schema "tracker_script_configuration" do
    field :installation_type, Ecto.Enum, values: [:manual, :wordpress, :gtm, nil]

    field :track_404_pages, :boolean, default: false
    field :hash_based_routing, :boolean, default: false
    field :outbound_links, :boolean, default: false
    field :file_downloads, :boolean, default: false
    field :revenue_tracking, :boolean, default: false
    field :tagged_events, :boolean, default: false
    field :form_submissions, :boolean, default: false
    field :pageview_props, :boolean, default: false

    belongs_to :site, Plausible.Site

    timestamps()
  end

  def installation_changeset(struct, params) do
    struct
    |> cast(params, [
      :installation_type,
      :track_404_pages,
      :hash_based_routing,
      :outbound_links,
      :file_downloads,
      :revenue_tracking,
      :tagged_events,
      :form_submissions,
      :pageview_props,
      :site_id
    ])
    |> validate_required([:site_id])
  end

  def plugins_api_changeset(struct, params) do
    struct
    |> cast(params, [
      :installation_type,
      :hash_based_routing,
      :outbound_links,
      :file_downloads,
      :form_submissions,
      :site_id
    ])
    |> validate_required([:site_id])
  end
end
```

## File: `lib/plausible/site/traffic_change_notification.ex`
```
defmodule Plausible.Site.TrafficChangeNotification do
  @moduledoc """
  Configuration schema for site-specific traffic change notifications.
  """
  use Ecto.Schema
  import Ecto.Changeset

  # legacy table name since traffic drop notifications were introduced
  schema "spike_notifications" do
    field :recipients, {:array, :string}
    field :threshold, :integer
    field :last_sent, :naive_datetime
    field :type, Ecto.Enum, values: [:spike, :drop], default: :spike
    belongs_to :site, Plausible.Site

    timestamps()
  end

  def changeset(schema, attrs) do
    schema
    |> cast(attrs, [:site_id, :recipients, :threshold, :type])
    |> validate_required([:site_id, :recipients, :threshold, :type])
    |> validate_number(:threshold, greater_than_or_equal_to: 1)
    |> unique_constraint([:site_id, :type])
  end

  def add_recipient(schema, recipient) do
    schema
    |> change(recipients: schema.recipients ++ [recipient])
  end

  def remove_recipient(schema, recipient) do
    schema
    |> change(recipients: List.delete(schema.recipients, recipient))
  end

  def was_sent(schema, now) do
    schema |> change(last_sent: now)
  end
end
```

## File: `lib/plausible/site/user_preference.ex`
```
defmodule Plausible.Site.UserPreference do
  @moduledoc """
  User-specific site preferences schema
  """

  use Ecto.Schema
  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @options [:pinned_at]

  schema "site_user_preferences" do
    field :pinned_at, :naive_datetime

    belongs_to :user, Plausible.Auth.User
    belongs_to :site, Plausible.Site

    timestamps()
  end

  defmacro options, do: @options

  def changeset(user, site, attrs \\ %{}) do
    %__MODULE__{}
    |> cast(attrs, @options)
    |> put_assoc(:user, user)
    |> put_assoc(:site, site)
  end
end
```

## File: `lib/plausible/site/weekly_report.ex`
```
defmodule Plausible.Site.WeeklyReport do
  use Ecto.Schema
  import Ecto.Changeset

  schema "weekly_reports" do
    field :recipients, {:array, :string}
    belongs_to :site, Plausible.Site

    timestamps()
  end

  def changeset(settings, attrs \\ %{}) do
    settings
    |> cast(attrs, [:site_id, :recipients])
    |> validate_required([:site_id, :recipients])
    |> unique_constraint(:site_id)
  end

  def add_recipient(report, recipient) do
    report
    |> change(recipients: report.recipients ++ [recipient])
  end

  def remove_recipient(report, recipient) do
    report
    |> change(recipients: List.delete(report.recipients, recipient))
  end
end
```

## File: `lib/plausible/sites.ex`
```
defmodule Plausible.Sites do
  @moduledoc """
  Sites context functions.
  """
  use Plausible

  import Ecto.Query

  alias Plausible.{Auth, Repo, Site, Teams, Billing}
  alias Plausible.Billing.Feature.SharedLinks
  alias Plausible.Site.SharedLink

  require Plausible.Site.UserPreference

  @shared_link_special_names ["WordPress - Shared Dashboard"]
  @doc """
  Special shared link names are used to distinguish between those
  created by the Plugins API, and those created in any other way
  (i.e. via Sites API or in the Dashboard Site Settings UI).

  The intent is to give our WP plugin the ability to display an
  embedded dashboard even when the user's subscription does not
  support the shared links feature.

  A shared link with a special name can only be created via the
  plugins API, and it will not show up under the list of shared
  links in Site Settings > Visibility.

  Once created with the special name, the link will be accessible
  even when the team does not have access to SharedLinks feature.
  """
  def shared_link_special_names(), do: @shared_link_special_names

  def get_by_domain(domain) do
    Repo.get_by(Site, domain: domain)
  end

  def get_by_domain!(domain) do
    Repo.get_by!(Site, domain: domain)
  end

  @spec toggle_pin(Auth.User.t(), Site.t()) ::
          {:ok, Site.UserPreference.t()} | {:error, :too_many_pins}
  def toggle_pin(user, site) do
    pinned_at =
      if site.pinned_at do
        nil
      else
        NaiveDateTime.utc_now()
      end

    with :ok <- check_user_pin_limit(user, pinned_at) do
      {:ok, set_option(user, site, :pinned_at, pinned_at)}
    end
  end

  @pins_limit 9

  defp check_user_pin_limit(_user, nil), do: :ok

  defp check_user_pin_limit(user, _) do
    pins_count =
      from(up in Site.UserPreference,
        where: up.user_id == ^user.id and not is_nil(up.pinned_at)
      )
      |> Repo.aggregate(:count)

    if pins_count + 1 > @pins_limit do
      {:error, :too_many_pins}
    else
      :ok
    end
  end

  @spec set_option(Auth.User.t(), Site.t(), atom(), any()) :: Site.UserPreference.t()
  def set_option(user, site, option, value) when option in Site.UserPreference.options() do
    Plausible.Sites.get_for_user!(user, site.domain)

    user
    |> Site.UserPreference.changeset(site, %{option => value})
    |> Repo.insert!(
      conflict_target: [:user_id, :site_id],
      # This way of conflict handling enables doing upserts of options leaving
      # existing, unrelated values intact.
      on_conflict: from(p in Site.UserPreference, update: [set: [{^option, ^value}]]),
      returning: true
    )
  end

  defdelegate list(user, pagination_params, opts \\ []), to: Plausible.Teams.Sites

  defdelegate list_with_invitations(user, pagination_params, opts \\ []),
    to: Plausible.Teams.Sites

  def list_people(site) do
    owner_memberships =
      from(
        tm in Teams.Membership,
        inner_join: u in assoc(tm, :user),
        where: tm.team_id == ^site.team_id,
        where: tm.role == :owner,
        select: %{
          user: u,
          role: tm.role
        }
      )
      |> Repo.all()

    memberships =
      from(
        gm in Teams.GuestMembership,
        inner_join: tm in assoc(gm, :team_membership),
        inner_join: u in assoc(tm, :user),
        where: gm.site_id == ^site.id,
        select: %{
          user: u,
          role: gm.role
        }
      )
      |> Repo.all()

    memberships = owner_memberships ++ memberships

    invitations =
      from(
        gi in Teams.GuestInvitation,
        inner_join: ti in assoc(gi, :team_invitation),
        where: gi.site_id == ^site.id,
        select: %{
          invitation_id: gi.invitation_id,
          email: ti.email,
          role: gi.role
        }
      )
      |> Repo.all()

    site_transfers =
      from(
        st in Teams.SiteTransfer,
        where: st.site_id == ^site.id,
        select: %{
          invitation_id: st.transfer_id,
          email: st.email,
          role: :owner
        }
      )
      |> Repo.all()

    %{memberships: memberships, invitations: site_transfers ++ invitations}
  end

  @spec list_guests_query(Site.t(), Keyword.t()) :: Ecto.Query.t()
  def list_guests_query(site, opts \\ []) do
    guest_memberships =
      from(
        gm in Teams.GuestMembership,
        inner_join: tm in assoc(gm, :team_membership),
        inner_join: u in assoc(tm, :user),
        as: :user,
        where: gm.site_id == ^site.id,
        select: %{
          id: gm.id,
          inserted_at: gm.inserted_at,
          email: u.email,
          role: gm.role,
          status: "accepted"
        }
      )

    guest_memberships =
      if email = opts[:email] do
        guest_memberships |> where([user: u], u.email == ^email)
      else
        guest_memberships
      end

    guest_invitations =
      from(
        gi in Teams.GuestInvitation,
        inner_join: ti in assoc(gi, :team_invitation),
        as: :team_invitation,
        where: gi.site_id == ^site.id,
        select: %{
          id: gi.id,
          inserted_at: gi.inserted_at,
          email: ti.email,
          role: gi.role,
          status: "invited"
        }
      )

    guest_invitations =
      if email = opts[:email] do
        guest_invitations |> where([team_invitation: ti], ti.email == ^email)
      else
        guest_invitations
      end

    guests = union_all(guest_memberships, ^guest_invitations)

    from(g in subquery(guests),
      select: %{
        id: g.id,
        inserted_at: g.inserted_at,
        email: g.email,
        role: g.role,
        status: g.status
      },
      order_by: [desc: g.inserted_at, desc: g.id]
    )
  end

  @spec for_user_query(Auth.User.t(), Teams.Team.t() | nil) :: Ecto.Query.t()
  def for_user_query(user, team \\ nil) do
    query =
      from(s in Site,
        as: :site,
        inner_join: t in assoc(s, :team),
        as: :team,
        inner_join: tm in assoc(t, :team_memberships),
        as: :team_memberships,
        left_join: gm in assoc(tm, :guest_memberships),
        as: :guest_memberships,
        where: tm.user_id == ^user.id,
        order_by: [desc: s.id]
      )

    if team do
      where(
        query,
        [team_memberships: tm, guest_memberships: gm, site: s],
        tm.role != :guest and tm.team_id == ^team.id
      )
    else
      where(
        query,
        [team_memberships: tm, guest_memberships: gm, site: s],
        tm.role != :guest or gm.site_id == s.id
      )
    end
  end

  def create(user, params, team \\ nil) do
    Ecto.Multi.new()
    |> Ecto.Multi.put(:site_changeset, Site.new(params))
    |> Ecto.Multi.run(:create_team, fn _repo, _context ->
      cond do
        team && Teams.Memberships.can_add_site?(team, user) ->
          {:ok, Teams.with_subscription(team)}

        is_nil(team) ->
          with {:ok, team} <- Teams.get_or_create(user) do
            {:ok, Teams.with_subscription(team)}
          end

        true ->
          {:error, :permission_denied}
      end
    end)
    |> Ecto.Multi.run(:ensure_can_add_new_site, fn _repo, %{create_team: team} ->
      case Teams.Billing.ensure_can_add_new_site(team) do
        :ok -> {:ok, :proceed}
        error -> error
      end
    end)
    |> Ecto.Multi.run(:clear_changed_from, fn
      _repo, %{site_changeset: %{changes: %{domain: domain}}} ->
        case Plausible.Sites.get_for_user(user, domain, [:owner]) do
          %Site{domain_changed_from: ^domain} = site ->
            site
            |> Ecto.Changeset.change()
            |> Ecto.Changeset.put_change(:domain_changed_from, nil)
            |> Ecto.Changeset.put_change(:domain_changed_at, nil)
            |> Repo.update()

          _ ->
            {:ok, :ignore}
        end

      _repo, _context ->
        {:ok, :ignore}
    end)
    |> Ecto.Multi.insert(:site, fn %{site_changeset: site, create_team: team} ->
      Ecto.Changeset.put_assoc(site, :team, team)
    end)
    |> Ecto.Multi.run(:trial, fn _repo, %{create_team: team} ->
      if is_nil(team.trial_expiry_date) and is_nil(team.subscription) do
        Teams.start_trial(team)
        {:ok, :trial_started}
      else
        {:ok, :trial_already_started}
      end
    end)
    |> Ecto.Multi.run(:updated_lock, fn _repo, %{create_team: team} ->
      lock_state =
        if ee?() do
          Billing.SiteLocker.update_for(team, send_email?: false)
        else
          :unlocked
        end

      {:ok, lock_state}
    end)
    |> Repo.transaction()
  end

  @spec clear_stats_start_date!(Site.t()) :: Site.t()
  def clear_stats_start_date!(site) do
    site
    |> Ecto.Changeset.change(stats_start_date: nil)
    |> Plausible.Repo.update!()
  end

  @spec stats_start_date(Site.t()) :: Date.t() | nil
  @doc """
  Returns the date of the first event of the given site, or `nil` if the site
  does not have stats yet.

  If this is the first time the function is called for the site, it queries
  imported stats and Clickhouse, choosing the earliest start date and saves
  it in the sites table.
  """
  def stats_start_date(site)

  def stats_start_date(%Site{stats_start_date: %Date{} = date}) do
    date
  end

  def stats_start_date(%Site{} = site) do
    start_date =
      [
        Plausible.Imported.earliest_import_start_date(site),
        native_stats_start_date(site)
      ]
      |> Enum.reject(&is_nil/1)
      |> Enum.min(Date, fn -> nil end)

    if start_date do
      updated_site =
        site
        |> Site.set_stats_start_date(start_date)
        |> Repo.update!()

      updated_site.stats_start_date
    end
  end

  @spec native_stats_start_date(Site.t()) :: Date.t() | nil
  def native_stats_start_date(site) do
    Plausible.Stats.Clickhouse.pageview_start_date_local(site)
  end

  def has_stats?(site) do
    !!stats_start_date(site)
  end

  def create_shared_link(site, name, opts \\ []) do
    password = Keyword.get(opts, :password)
    site = Plausible.Repo.preload(site, :team)
    skip_feature_check? = Keyword.get(opts, :skip_feature_check?, false)

    if not skip_feature_check? and SharedLinks.check_availability(site.team) != :ok do
      {:error, :upgrade_required}
    else
      %SharedLink{site_id: site.id, slug: Nanoid.generate()}
      |> SharedLink.changeset(
        %{name: name, password: password},
        Keyword.take(opts, [:skip_special_name_check?])
      )
      |> Repo.insert()
    end
  end

  def shared_link_url(site, link) do
    base = PlausibleWeb.Endpoint.url()
    domain = "/share/#{URI.encode_www_form(site.domain)}"
    base <> domain <> "?auth=" <> link.slug
  end

  def update_legacy_time_on_page_cutoff!(site, cutoff) do
    site
    |> Ecto.Changeset.change()
    |> Ecto.Changeset.put_change(:legacy_time_on_page_cutoff, cutoff)
    |> Repo.update!()
  end

  def has_goals?(site) do
    Repo.exists?(
      from(g in Plausible.Goal,
        where: g.site_id == ^site.id
      )
    )
  end

  def get_for_user!(user, domain, roles \\ [:owner, :admin, :editor, :viewer]) do
    site =
      if :super_admin in roles and Plausible.Auth.is_super_admin?(user.id) do
        get_by_domain!(domain)
      else
        user.id
        |> get_for_user_query(domain, List.delete(roles, :super_admin))
        |> Repo.one!()
      end

    Repo.preload(site, :team)
  end

  def get_for_user(user, domain, roles \\ [:owner, :admin, :editor, :viewer]) do
    if :super_admin in roles and Plausible.Auth.is_super_admin?(user.id) do
      get_by_domain(domain)
    else
      user.id
      |> get_for_user_query(domain, List.delete(roles, :super_admin))
      |> Repo.one()
    end
  end

  defp get_for_user_query(user_id, domain, roles) do
    roles = Enum.map(roles, &to_string/1)

    from(s in Plausible.Site,
      join: t in assoc(s, :team),
      join: tm in assoc(t, :team_memberships),
      left_join: gm in assoc(tm, :guest_memberships),
      where: tm.user_id == ^user_id,
      where: coalesce(gm.role, tm.role) in ^roles,
      where: s.domain == ^domain or s.domain_changed_from == ^domain,
      where: is_nil(gm.id) or gm.site_id == s.id,
      select: s
    )
  end
end
```

## File: `lib/plausible/stats.ex`
```
defmodule Plausible.Stats do
  use Plausible
  use Plausible.ClickhouseRepo

  alias Plausible.Stats.{
    Breakdown,
    Aggregate,
    Timeseries,
    CurrentVisitors,
    FilterSuggestions,
    QueryRunner
  }

  def query(site, query) do
    QueryRunner.run(site, query)
  end

  def breakdown(site, query, metrics, pagination) do
    Breakdown.breakdown(site, query, metrics, pagination)
  end

  def aggregate(site, query, metrics) do
    Aggregate.aggregate(site, query, metrics)
  end

  def timeseries(site, query, metrics) do
    Timeseries.timeseries(site, query, metrics)
  end

  def current_visitors(site, duration \\ Duration.new!(minute: -5)) do
    CurrentVisitors.current_visitors(site, duration)
  end

  on_ee do
    def funnel(site, query, funnel) do
      Plausible.Stats.Funnel.funnel(site, query, funnel)
    end
  end

  def filter_suggestions(site, query, filter_name, filter_search) do
    FilterSuggestions.filter_suggestions(site, query, filter_name, filter_search)
  end

  def custom_prop_value_filter_suggestions(site, query, prop_key, filter_search) do
    FilterSuggestions.custom_prop_value_filter_suggestions(site, query, prop_key, filter_search)
  end
end
```

## File: `lib/plausible/stats/aggregate.ex`
```
defmodule Plausible.Stats.Aggregate do
  @moduledoc """
  Builds aggregate results for v1 of our stats API and dashboards.

  Avoid adding new logic here - update QueryBuilder etc instead.
  """

  use Plausible.ClickhouseRepo
  alias Plausible.Stats.{Query, QueryRunner, QueryResult, QueryOptimizer}

  def aggregate(site, query, metrics) do
    Query.trace(query, metrics)

    query =
      query
      |> Query.set(metrics: metrics, remove_unavailable_revenue_metrics: true)
      |> QueryOptimizer.optimize()

    %QueryResult{results: [entry], meta: meta} = QueryRunner.run(site, query)

    results =
      query.metrics
      |> Enum.with_index()
      |> Enum.map(fn {metric, index} ->
        {
          metric,
          metric_map(entry, index, metric)
        }
      end)
      |> Enum.into(%{})

    %{results: results, meta: meta}
  end

  def metric_map(
        %{metrics: metrics, comparison: %{metrics: comparison_metrics, change: change}},
        index,
        metric
      ) do
    %{
      value: get_value(metrics, index, metric),
      comparison_value: get_value(comparison_metrics, index, metric),
      change: Enum.at(change, index)
    }
  end

  def metric_map(%{metrics: metrics}, index, metric) do
    %{
      value: get_value(metrics, index, metric)
    }
  end

  def get_value(metric_list, index, metric) do
    metric_list
    |> Enum.at(index)
    |> maybe_round_value(metric)
  end

  @metrics_to_round [:bounce_rate, :visit_duration, :sample_percent]

  defp maybe_round_value(nil, _metric), do: nil
  defp maybe_round_value(value, metric) when metric in @metrics_to_round, do: round(value)
  defp maybe_round_value(value, _metric), do: value
end
```

## File: `lib/plausible/stats/base.ex`
```
defmodule Plausible.Stats.Base do
  use Plausible

  alias Plausible.Stats.{TableDecider, SQL}
  import Ecto.Query

  def base_event_query(query) do
    events_q = query_events(query)

    if TableDecider.events_join_sessions?(query) do
      sessions_q =
        from(
          s in query_sessions(query),
          select: %{session_id: s.session_id},
          where: s.sign == 1,
          group_by: s.session_id
        )

      from(
        e in events_q,
        join: sq in subquery(sessions_q),
        on: e.session_id == sq.session_id
      )
    else
      events_q
    end
  end

  defp query_events(query) do
    q = from(e in "events_v2", where: ^SQL.WhereBuilder.build(:events, query))

    on_ee do
      q = Plausible.Stats.Sampling.add_query_hint(q, query)
    end

    q
  end

  def query_sessions(query) do
    q = from(s in "sessions_v2", where: ^SQL.WhereBuilder.build(:sessions, query))

    on_ee do
      q = Plausible.Stats.Sampling.add_query_hint(q, query)
    end

    q
  end
end
```

## File: `lib/plausible/stats/breakdown.ex`
```
defmodule Plausible.Stats.Breakdown do
  @moduledoc """
  Builds breakdown results for v1 of our stats API and dashboards.

  Avoid adding new logic here - update QueryBuilder etc instead.
  """

  use Plausible.ClickhouseRepo
  use Plausible.Stats.SQL.Fragments

  alias Plausible.Stats.{Query, QueryRunner, QueryResult, QueryOptimizer, Comparisons}

  def breakdown(
        site,
        %Query{dimensions: [dimension], order_by: order_by} = query,
        metrics,
        {limit, page},
        _opts \\ []
      ) do
    transformed_metrics = transform_metrics(metrics, dimension)
    transformed_order_by = transform_order_by(order_by || [], dimension)

    query_with_metrics =
      query
      |> Query.set(
        metrics: transformed_metrics,
        # Concat client requested order with default order, overriding only if client explicitly requests it
        order_by:
          Enum.concat(transformed_order_by, infer_order_by(transformed_metrics, dimension))
          |> Enum.uniq_by(&elem(&1, 0)),
        dimensions: transform_dimensions(dimension),
        filters: query.filters ++ dimension_filters(dimension),
        pagination: %{limit: limit, offset: (page - 1) * limit},
        # Allow pageview and event metrics to be queried off of sessions table
        legacy_breakdown: true,
        remove_unavailable_revenue_metrics: true
      )
      |> QueryOptimizer.optimize()

    %QueryResult{results: results, meta: meta} = QueryRunner.run(site, query_with_metrics)

    %{
      results: build_breakdown_result(results, query_with_metrics, metrics),
      meta: meta
    }
  end

  def formatted_date_ranges(query) do
    formatted = %{
      date_range_label: format_date_range(query)
    }

    if query.include.comparisons do
      comparison_date_range_label =
        query
        |> Comparisons.get_comparison_query()
        |> format_date_range()

      Map.put(
        formatted,
        :comparison_date_range_label,
        comparison_date_range_label
      )
    else
      formatted
    end
  end

  defp build_breakdown_result(results, query, metrics) do
    dimension_keys = query.dimensions |> Enum.map(&result_key/1)

    results
    |> Enum.map(fn entry ->
      comparison_map =
        if entry[:comparison] do
          comparison =
            build_map(metrics, entry.comparison.metrics)
            |> Map.put(:change, build_map(metrics, entry.comparison.change))

          %{comparison: comparison}
        else
          %{}
        end

      build_map(dimension_keys, entry.dimensions)
      |> Map.merge(build_map(metrics, entry.metrics))
      |> Map.merge(comparison_map)
    end)
  end

  defp build_map(keys, values) do
    Enum.zip(keys, values) |> Map.new()
  end

  defp result_key("event:props:" <> custom_property), do: custom_property
  defp result_key("event:" <> key), do: key |> String.to_existing_atom()
  defp result_key("visit:" <> key), do: key |> String.to_existing_atom()
  defp result_key(dimension), do: dimension

  defp maybe_remap_to_group_conversion_rate(metric, dimension) do
    case {metric, dimension} do
      {:conversion_rate, "event:props:" <> _} -> :conversion_rate
      {:conversion_rate, "event:goal"} -> :conversion_rate
      {:conversion_rate, _} -> :group_conversion_rate
      _ -> metric
    end
  end

  defp transform_metrics(metrics, dimension) do
    metrics =
      if is_nil(metric_to_order_by(metrics)) do
        metrics ++ [:visitors]
      else
        metrics
      end

    Enum.map(metrics, fn metric -> maybe_remap_to_group_conversion_rate(metric, dimension) end)
  end

  defp transform_order_by(order_by, dimension) do
    Enum.map(order_by, fn {metric, direction} ->
      {maybe_remap_to_group_conversion_rate(metric, dimension), direction}
    end)
  end

  defp infer_order_by(metrics, "event:goal"),
    do: [{metric_to_order_by(metrics), :desc}]

  defp infer_order_by(metrics, dimension),
    do: [{metric_to_order_by(metrics), :desc}, {dimension, :asc}]

  defp metric_to_order_by(metrics) do
    Enum.find(metrics, &(&1 != :time_on_page))
  end

  def transform_dimensions("visit:browser_version"),
    do: ["visit:browser", "visit:browser_version"]

  def transform_dimensions("visit:os_version"), do: ["visit:os", "visit:os_version"]
  def transform_dimensions(dimension), do: [dimension]

  @filter_dimensions_not %{
    "visit:city" => [0],
    "visit:country" => ["\0\0", "ZZ"],
    "visit:region" => [""],
    "visit:utm_medium" => [""],
    "visit:utm_source" => [""],
    "visit:utm_campaign" => [""],
    "visit:utm_content" => [""],
    "visit:utm_term" => [""],
    "visit:entry_page" => [""],
    "visit:exit_page" => [""]
  }

  @extra_filter_dimensions Map.keys(@filter_dimensions_not)

  defp dimension_filters(dimension) when dimension in @extra_filter_dimensions do
    [[:is_not, dimension, Map.get(@filter_dimensions_not, dimension)]]
  end

  defp dimension_filters(_), do: []

  defp format_date_range(%Query{} = query) do
    year = query.now.year
    %Date.Range{first: first, last: last} = Query.date_range(query, trim_trailing: true)

    cond do
      first == last ->
        strfdate(first, first.year != year)

      first.year == last.year ->
        "#{strfdate(first, false)} - #{strfdate(last, year != last.year)}"

      true ->
        "#{strfdate(first, true)} - #{strfdate(last, true)}"
    end
  end

  defp strfdate(date, true = _include_year) do
    Calendar.strftime(date, "%-d %b %Y")
  end

  defp strfdate(date, false = _include_year) do
    Calendar.strftime(date, "%-d %b")
  end
end
```

## File: `lib/plausible/stats/clickhouse.ex`
```
defmodule Plausible.Stats.Clickhouse do
  use Plausible
  use Plausible.Repo
  use Plausible.ClickhouseRepo
  use Plausible.Stats.SQL.Fragments

  import Ecto.Query, only: [from: 2, dynamic: 1, dynamic: 2]

  alias Plausible.Timezones

  @spec pageview_start_date_local(Plausible.Site.t()) :: Date.t() | nil
  def pageview_start_date_local(site) do
    datetime =
      ClickhouseRepo.one(
        from(e in "events_v2",
          select: fragment("min(?)", e.timestamp),
          where: e.site_id == ^site.id,
          where: e.timestamp >= ^site.native_stats_start_at
        )
      )

    case datetime do
      # no stats for this domain yet
      ~N[1970-01-01 00:00:00] ->
        nil

      _ ->
        Timezones.to_date_in_timezone(datetime, site.timezone)
    end
  end

  def imported_pageview_count(site) do
    Plausible.ClickhouseRepo.one(
      from(i in "imported_visitors",
        where: i.site_id == ^site.id,
        select: sum(i.pageviews)
      )
    )
  end

  @spec imported_pageview_counts(Plausible.Site.t()) :: %{non_neg_integer() => non_neg_integer()}
  def imported_pageview_counts(site) do
    from(i in "imported_visitors",
      where: i.site_id == ^site.id,
      group_by: i.import_id,
      select: {i.import_id, sum(i.pageviews)}
    )
    |> Plausible.ClickhouseRepo.all()
    |> Map.new()
  end

  def usage_breakdown([sid | _] = site_ids, date_range) when is_integer(sid) do
    Enum.chunk_every(site_ids, 1000)
    |> Enum.map(fn site_ids ->
      fn ->
        ClickhouseRepo.one(
          from(e in "events_v2",
            where: e.site_id in ^site_ids,
            where: e.name != "engagement",
            where: fragment("toDate(?)", e.timestamp) >= ^date_range.first,
            where: fragment("toDate(?)", e.timestamp) <= ^date_range.last,
            select: {
              fragment("countIf(? = 'pageview')", e.name),
              fragment("countIf(? != 'pageview')", e.name)
            }
          )
        )
      end
    end)
    |> ClickhouseRepo.parallel_tasks(max_concurrency: 10)
    |> Enum.reduce(fn {pageviews, custom_events}, {pageviews_total, custom_events_total} ->
      {pageviews_total + pageviews, custom_events_total + custom_events}
    end)
  end

  def usage_breakdown([], _date_range), do: {0, 0}

  def current_visitors(site) do
    Plausible.Stats.current_visitors(site)
  end

  def current_visitors_12h(site) do
    Plausible.Stats.current_visitors(site, Duration.new!(hour: -12))
  end

  def has_pageviews?(site) do
    ClickhouseRepo.exists?(
      from(e in "events_v2",
        where:
          e.site_id == ^site.id and
            e.name == "pageview" and
            e.timestamp >=
              ^site.native_stats_start_at
      )
    )
  end

  @spec empty_24h_visitors_hourly_intervals([Plausible.Site.t()], NaiveDateTime.t()) :: map()
  def empty_24h_visitors_hourly_intervals(sites, now \\ NaiveDateTime.utc_now()) do
    sites
    |> Enum.map(fn site ->
      {site.domain,
       %{
         intervals: empty_24h_intervals(now),
         visitors: 0,
         change: 0
       }}
    end)
    |> Map.new()
  end

  @spec last_24h_visitors_hourly_intervals([Plausible.Site.t()], NaiveDateTime.t()) :: map()
  def last_24h_visitors_hourly_intervals(sites, now \\ NaiveDateTime.utc_now())
  def last_24h_visitors_hourly_intervals([], _), do: %{}

  def last_24h_visitors_hourly_intervals(sites, now) do
    site_id_to_domain_mapping = for site <- sites, do: {site.id, site.domain}, into: %{}
    now = now |> NaiveDateTime.truncate(:second)

    placeholder = empty_24h_visitors_hourly_intervals(sites, now)

    base_query = base_24h_events_query(sites)

    previous_query = visitors_24h_total(base_query, now, -48, -24)

    previous_result =
      previous_query
      |> ClickhouseRepo.all()
      |> Enum.reduce(%{}, fn
        %{total_visitors: total, site_id: site_id}, acc -> Map.put_new(acc, site_id, total)
      end)

    total_q = visitors_24h_total(base_query, now, -24, 0)

    current_q =
      from(
        e in base_query,
        join: total_q in subquery(total_q),
        on: e.site_id == total_q.site_id,
        where: e.timestamp >= ^NaiveDateTime.add(now, -24, :hour),
        where: e.timestamp <= ^now,
        select: %{
          site_id: e.site_id,
          interval: fragment("toStartOfHour(timestamp)"),
          visitors: uniq(e.user_id),
          total: fragment("any(total_visitors)")
        },
        group_by: [e.site_id, fragment("toStartOfHour(timestamp)")],
        order_by: [e.site_id, fragment("toStartOfHour(timestamp)")]
      )

    on_ee do
      current_q = Plausible.Stats.Sampling.add_query_hint(current_q)
    end

    result =
      current_q
      |> ClickhouseRepo.all()
      |> Enum.group_by(& &1.site_id)
      |> Enum.map(fn {site_id, entries} ->
        %{total: visitors} = List.first(entries)

        full_entries =
          (entries ++ empty_24h_intervals(now))
          |> Enum.uniq_by(& &1.interval)
          |> Enum.sort_by(& &1.interval, NaiveDateTime)

        change = Plausible.Stats.Compare.percent_change(previous_result[site_id], visitors) || 100

        {site_id_to_domain_mapping[site_id],
         %{intervals: full_entries, visitors: visitors, change: change}}
      end)
      |> Map.new()

    Map.merge(placeholder, result)
  end

  defp visitors_24h_total(base_query, now, offset1, offset2) do
    query =
      from e in base_query,
        where: e.timestamp >= ^NaiveDateTime.add(now, offset1, :hour),
        where: e.timestamp <= ^NaiveDateTime.add(now, offset2, :hour),
        select: %{
          site_id: e.site_id,
          total_visitors: fragment("toUInt64(round(uniq(user_id) * any(_sample_factor)))")
        },
        group_by: [e.site_id]

    on_ee do
      query = Plausible.Stats.Sampling.add_query_hint(query)
    end

    query
  end

  defp base_24h_events_query(sites) do
    cutoff_times_condition =
      Enum.reduce(sites, dynamic(false), fn
        %{native_stats_start_at: nil}, dynamic ->
          dynamic

        site, dynamic ->
          dynamic(
            [e],
            ^dynamic or (e.site_id == ^site.id and e.timestamp >= ^site.native_stats_start_at)
          )
      end)

    from e in "events_v2",
      where: e.site_id in ^Enum.map(sites, & &1.id),
      where: ^cutoff_times_condition
  end

  defp empty_24h_intervals(now) do
    first = NaiveDateTime.add(now, -23, :hour)
    {:ok, time} = Time.new(first.hour, 0, 0)
    first = NaiveDateTime.new!(NaiveDateTime.to_date(first), time)

    for offset <- 0..24 do
      %{
        interval: NaiveDateTime.add(first, offset, :hour),
        visitors: 0
      }
    end
  end
end
```

## File: `lib/plausible/stats/compare.ex`
```
defmodule Plausible.Stats.Compare do
  def calculate_change(:conversion_rate, old_value, new_value) do
    Float.round(new_value - old_value, 1)
  end

  def calculate_change(:exit_rate, old_value, new_value) do
    if is_float(old_value) and is_float(new_value) do
      Float.round(new_value - old_value, 1)
    end
  end

  def calculate_change(:bounce_rate, old_count, new_count) do
    if old_count > 0, do: new_count - old_count
  end

  def calculate_change(_metric, old_count, new_count) do
    percent_change(old_count, new_count)
  end

  def percent_change(nil, _new_count), do: nil
  def percent_change(_old_count, nil), do: nil

  def percent_change(%{value: old_count}, %{value: new_count}) do
    percent_change(old_count, new_count)
  end

  def percent_change(old_count, new_count) do
    cond do
      old_count == 0 and new_count > 0 ->
        100

      old_count == 0 and new_count == 0 ->
        0

      true ->
        round((new_count - old_count) / old_count * 100)
    end
  end
end
```

## File: `lib/plausible/stats/comparisons.ex`
```
defmodule Plausible.Stats.Comparisons do
  @moduledoc """
  This module provides functions for comparing query periods.

  It allows you to compare a given period with a previous period or with the
  same period from the previous year. For example, you can compare this month's
  main graph with last month or with the same month from last year.
  """

  alias Plausible.Stats
  alias Plausible.Stats.{Query, DateTimeRange, Time}

  @spec get_comparison_utc_time_range(Stats.Query.t(), map()) :: DateTimeRange.t()
  @doc """
  Generates a `DateTimeRange` for the comparison period by the given source query
  and comparison options.

  Currently only historical periods are supported for comparisons (not `realtime`
  and `30m` periods).

  ## Options
    * `mode` (required) - specifies the type of comparison and can be one of the
  following:

      * `"previous_period"` - shifts back the query by the same number of days the
        source query has.

      * `"year_over_year"` - shifts back the query by 1 year.

      * `"custom"` - compares the query using a custom date range. See `date_range` for
        more details.

    * `:date_range` - a ISO-8601 date string pair used when mode is `"custom"`.

    * `:match_day_of_week` - determines whether the comparison query should be
      adjusted to match the day of the week of the source query. When this option
      is set to true, the comparison query is shifted to start on the same day of
      the week as the source query, rather than on the exact same date. For
      example, if the source query starts on Sunday, January 1st, 2023 and the
      `year_over_year` comparison query is configured to `match_day_of_week`,
      it will be shifted to start on Sunday, January 2nd, 2022 instead of
      January 1st. Defaults to false.

  """
  def get_comparison_utc_time_range(%Stats.Query{} = source_query, options) do
    comparison_date_range = get_comparison_date_range(source_query, options)

    DateTimeRange.new!(
      comparison_date_range.first,
      comparison_date_range.last,
      source_query.timezone
    )
    |> DateTimeRange.to_timezone("Etc/UTC")
  end

  def get_comparison_query(
        %Query{comparison_utc_time_range: %DateTimeRange{} = comparison_range} = source_query
      ) do
    source_query
    |> Query.set(utc_time_range: comparison_range)
  end

  @doc """
  Builds comparison query that specifically filters for values appearing in the main query results.

  When querying for comparisons with dimensions and pagination, extra
  filters are added to ensure comparison query returns same set of results
  as main query.
  """
  def add_comparison_filters(comparison_query, main_results_list) do
    comparison_filters =
      Enum.flat_map(main_results_list, &build_comparison_filter(&1, comparison_query))

    comparison_query
    |> add_query_filters(comparison_filters)
  end

  defp add_query_filters(query, []), do: query

  defp add_query_filters(query, [filter]) do
    query
    |> Query.add_filter([:ignore_in_totals_query, filter])
    |> Query.set(pagination: nil)
  end

  defp add_query_filters(query, filters) do
    query
    |> Query.add_filter([:ignore_in_totals_query, [:or, filters]])
    |> Query.set(pagination: nil)
  end

  defp build_comparison_filter(%{dimensions: dimension_labels}, query) do
    query_filters =
      query.dimensions
      |> Enum.zip(dimension_labels)
      |> Enum.reject(fn {dimension, _label} -> Time.time_dimension?(dimension) end)
      |> Enum.map(fn {dimension, label} -> [:is, dimension, [label]] end)

    case query_filters do
      [] -> []
      [filter] -> [filter]
      filters -> [[:and, filters]]
    end
  end

  defp get_comparison_date_range(source_query, %{mode: "year_over_year"} = options) do
    source_date_range = Query.date_range(source_query, trim_trailing: true)

    start_date = source_date_range.first |> Date.shift(year: -1)
    diff_in_days = Date.diff(source_date_range.last, source_date_range.first)
    end_date = Date.add(start_date, diff_in_days)

    Date.range(start_date, end_date)
    |> maybe_match_day_of_week(source_date_range, options)
  end

  defp get_comparison_date_range(source_query, %{mode: "previous_period"} = options) do
    source_date_range = Query.date_range(source_query, trim_trailing: true)

    last = source_date_range.last
    diff_in_days = Date.diff(source_date_range.first, last) - 1

    new_first = Date.add(source_date_range.first, diff_in_days)
    new_last = Date.add(last, diff_in_days)

    Date.range(new_first, new_last)
    |> maybe_match_day_of_week(source_date_range, options)
  end

  defp get_comparison_date_range(source_query, %{mode: "custom"} = options) do
    DateTimeRange.to_date_range(options.date_range, source_query.timezone)
  end

  defp maybe_match_day_of_week(comparison_date_range, source_date_range, options) do
    if options[:match_day_of_week] do
      day_to_match = Date.day_of_week(source_date_range.first)

      new_first =
        shift_to_nearest(
          day_to_match,
          comparison_date_range.first,
          source_date_range.first
        )

      days_shifted = Date.diff(new_first, comparison_date_range.first)
      new_last = Date.add(comparison_date_range.last, days_shifted)

      Date.range(new_first, new_last)
    else
      comparison_date_range
    end
  end

  defp shift_to_nearest(day_of_week, date, reject) do
    if Date.day_of_week(date) == day_of_week do
      date
    else
      [next_occurring(day_of_week, date), previous_occurring(day_of_week, date)]
      |> Enum.sort_by(&Date.diff(date, &1))
      |> Enum.reject(&(&1 == reject))
      |> List.first()
    end
  end

  defp next_occurring(day_of_week, date) do
    days_to_add = day_of_week - Date.day_of_week(date)
    days_to_add = if days_to_add > 0, do: days_to_add, else: days_to_add + 7

    Date.add(date, days_to_add)
  end

  defp previous_occurring(day_of_week, date) do
    days_to_subtract = Date.day_of_week(date) - day_of_week
    days_to_subtract = if days_to_subtract > 0, do: days_to_subtract, else: days_to_subtract + 7

    Date.add(date, -days_to_subtract)
  end
end
```

## File: `lib/plausible/stats/current_visitors.ex`
```
defmodule Plausible.Stats.CurrentVisitors do
  use Plausible.ClickhouseRepo
  use Plausible.Stats.SQL.Fragments

  @spec current_visitors(Plausible.Site.t(), Duration.duration()) :: non_neg_integer
  def current_visitors(site, duration \\ Duration.new!(minute: -5)) do
    first_datetime =
      NaiveDateTime.utc_now()
      |> NaiveDateTime.shift(duration)
      |> NaiveDateTime.truncate(:second)

    ClickhouseRepo.one(
      from e in "events_v2",
        where: e.site_id == ^site.id,
        where: e.timestamp >= ^first_datetime,
        where: e.name != "engagement",
        select: uniq(e.user_id)
    )
  end
end
```

## File: `lib/plausible/stats/custom_props.ex`
```
defmodule Plausible.Stats.CustomProps do
  @moduledoc """
  Module for querying user defined 'custom properties'.
  """

  alias Plausible.Stats.Filters
  use Plausible.ClickhouseRepo
  import Plausible.Stats.Base

  def fetch_prop_names(site, query) do
    case Filters.get_toplevel_filter(query, "event:props:") do
      [_op, "event:props:" <> key | _rest] ->
        [key]

      _ ->
        from(e in base_event_query(query),
          join: meta in fragment("meta"),
          hints: "ARRAY",
          on: true,
          select: meta.key,
          distinct: true
        )
        |> maybe_allowed_props_only(site)
        |> ClickhouseRepo.all()
    end
  end

  def maybe_allowed_props_only(q, site) do
    case Plausible.Props.allowed_for(site) do
      :all -> q
      allowed_props -> from [..., m] in q, where: m.key in ^allowed_props
    end
  end
end
```

## File: `lib/plausible/stats/datetime_range.ex`
```
defmodule Plausible.Stats.DateTimeRange do
  @moduledoc """
  Defines a struct similar `Date.Range`, but with `DateTime` instead of `Date`.

  The structs should be created with the `new!/2` function.
  """

  @enforce_keys [:first, :last]
  defstruct [:first, :last]

  @type t() :: %__MODULE__{
          first: %DateTime{},
          last: %DateTime{}
        }

  @doc """
  Creates a `DateTimeRange` struct from the given `%Date{}` structs.

  The first datetime will become the first date at 00:00:00, and the last datetime
  will become the last date at 23:59:59. Both dates will be turned into `%DateTime{}`
  structs in the given timezone.
  """
  def new!(%Date{} = first, %Date{} = last, timezone) do
    first =
      case DateTime.new(first, ~T[00:00:00], timezone) do
        {:ok, datetime} -> datetime
        {:gap, _just_before, just_after} -> just_after
        {:ambiguous, _first_datetime, second_datetime} -> second_datetime
      end

    last =
      case DateTime.new(last, ~T[23:59:59], timezone) do
        {:ok, datetime} -> datetime
        {:gap, just_before, _just_after} -> just_before
        {:ambiguous, first_datetime, _second_datetime} -> first_datetime
      end

    new!(first, last)
  end

  def new!(%DateTime{} = first, %DateTime{} = last) do
    first = DateTime.truncate(first, :second)
    last = DateTime.truncate(last, :second)

    if DateTime.before?(first, last) do
      %__MODULE__{first: first, last: last}
    else
      %__MODULE__{first: last, last: first}
    end
  end

  def to_timezone(%__MODULE__{first: first, last: last}, timezone) do
    first = DateTime.shift_zone!(first, timezone)
    last = DateTime.shift_zone!(last, timezone)

    %__MODULE__{first: first, last: last}
  end

  def to_date_range(datetime_range, timezone) do
    %__MODULE__{first: first, last: last} = to_timezone(datetime_range, timezone)

    first = DateTime.to_date(first)
    last = DateTime.to_date(last)

    Date.range(first, last)
  end
end
```

## File: `lib/plausible/stats/email_report.ex`
```
defmodule Plausible.Stats.EmailReport do
  @moduledoc """
  This module exposes a `get/2` function that returns a map
  of stats needed for email reports. These stats include:

  * Total pageviews
  * Unique visitors
  * Bounce rate
  * A list of Top 5 sources (excluding "Direct / None")
  * A list of Top 5 pages

  where total pageviews, unique visitors, and bounce rate
  also include the change compared to previous period.
  """

  alias Plausible.Stats
  alias Plausible.Stats.{Query, QueryResult}

  @aggregate_metrics [:pageviews, :visitors, :bounce_rate]

  def get(site, query) do
    aggregate_and_compare(site, query)
    |> put_top_5_pages(site, query)
    |> put_top_5_sources(site, query)
  end

  defp aggregate_and_compare(site, query) do
    query =
      query
      |> Query.set(metrics: @aggregate_metrics)
      |> Query.set_include(:comparisons, %{mode: "previous_period"})
      |> Query.put_comparison_utc_time_range()

    %QueryResult{results: [result]} = Plausible.Stats.query(site, query)

    @aggregate_metrics
    |> Enum.with_index()
    |> Enum.map(fn {metric, idx} ->
      value = Enum.at(result.metrics, idx)
      change = Enum.at(result.comparison.change, idx)

      {metric, %{value: value, change: change}}
    end)
    |> Enum.into(%{})
  end

  defp put_top_5_pages(stats, site, query) do
    query = Query.set(query, dimensions: ["event:page"])
    %{results: pages} = Stats.breakdown(site, query, [:visitors], {5, 1})
    Map.put(stats, :pages, pages)
  end

  defp put_top_5_sources(stats, site, query) do
    query =
      query
      |> Query.add_filter([:is_not, "visit:source", ["Direct / None"]])
      |> Query.set(dimensions: ["visit:source"])

    %{results: sources} = Stats.breakdown(site, query, [:visitors], {5, 1})

    Map.put(stats, :sources, sources)
  end
end
```

## File: `lib/plausible/stats/filter_suggestions.ex`
```
defmodule Plausible.Stats.FilterSuggestions do
  use Plausible.Repo
  use Plausible.ClickhouseRepo
  use Plausible.Stats.SQL.Fragments

  import Plausible.Stats.Base
  import Ecto.Query

  alias Plausible.Stats.Query
  alias Plausible.Stats.Imported

  def filter_suggestions(site, query, "country", filter_search) do
    matches = Location.search_country(filter_search)

    q =
      from(
        e in query_sessions(query),
        group_by: e.country_code,
        order_by: [desc: fragment("count(*)")],
        select: e.country_code
      )
      |> Imported.merge_imported_country_suggestions(site, query)

    ClickhouseRepo.all(q)
    |> Enum.map(fn c -> Enum.find(matches, fn x -> x.alpha_2 == c end) end)
    |> Enum.filter(& &1)
    |> Enum.slice(0..24)
    |> Enum.map(fn match ->
      %{
        value: match.alpha_2,
        label: match.name
      }
    end)
  end

  def filter_suggestions(site, query, "region", "") do
    from(
      e in query_sessions(query),
      group_by: e.subdivision1_code,
      order_by: [desc: fragment("count(*)")],
      select: e.subdivision1_code,
      where: e.subdivision1_code != ""
    )
    |> Imported.merge_imported_region_suggestions(site, query)
    |> limit(24)
    |> ClickhouseRepo.all()
    |> Enum.map(fn c ->
      subdiv = Location.get_subdivision(c)

      if subdiv do
        %{
          value: c,
          label: subdiv.name
        }
      else
        %{
          value: c,
          label: c
        }
      end
    end)
  end

  def filter_suggestions(site, query, "region", filter_search) do
    matches = Location.search_subdivision(filter_search)
    filter_search = String.downcase(filter_search)

    q =
      from(
        e in query_sessions(query),
        group_by: e.subdivision1_code,
        order_by: [desc: fragment("count(*)")],
        select: e.subdivision1_code,
        where: e.subdivision1_code != ""
      )
      |> Imported.merge_imported_region_suggestions(site, query)

    ClickhouseRepo.all(q)
    |> Enum.map(fn c ->
      match = Enum.find(matches, fn x -> x.code == c end)

      cond do
        match ->
          match

        String.contains?(String.downcase(c), filter_search) ->
          %{
            code: c,
            name: c
          }

        true ->
          nil
      end
    end)
    |> Enum.filter(& &1)
    |> Enum.slice(0..24)
    |> Enum.map(fn subdiv ->
      %{
        value: subdiv.code,
        label: subdiv.name
      }
    end)
  end

  def filter_suggestions(site, query, "city", "") do
    from(
      e in query_sessions(query),
      group_by: e.city_geoname_id,
      order_by: [desc: fragment("count(*)")],
      select: e.city_geoname_id,
      where: e.city_geoname_id != 0
    )
    |> Imported.merge_imported_city_suggestions(site, query)
    |> limit(24)
    |> ClickhouseRepo.all()
    |> Enum.map(fn c ->
      city = Location.get_city(c)

      %{
        value: c,
        label: (city && city.name) || "N/A"
      }
    end)
  end

  def filter_suggestions(site, query, "city", filter_search) do
    filter_search = String.downcase(filter_search)

    q =
      from(
        e in query_sessions(query),
        group_by: e.city_geoname_id,
        order_by: [desc: fragment("count(*)")],
        select: e.city_geoname_id,
        where: e.city_geoname_id != 0
      )
      |> Imported.merge_imported_city_suggestions(site, query)
      |> limit(5000)

    ClickhouseRepo.all(q)
    |> Enum.map(fn c -> Location.get_city(c) end)
    |> Enum.filter(fn city ->
      city && String.contains?(String.downcase(city.name), filter_search)
    end)
    |> Enum.slice(0..24)
    |> Enum.map(fn c -> %{value: c.id, label: c.name} end)
  end

  def filter_suggestions(site, _query, "goal", filter_search) do
    site
    |> Plausible.Goals.for_site()
    |> Enum.map(& &1.display_name)
    |> Enum.filter(fn goal ->
      String.contains?(
        String.downcase(goal),
        String.downcase(filter_search)
      )
    end)
    |> wrap_suggestions()
  end

  def filter_suggestions(site, query, "prop_key", filter_search) do
    filter_query = if filter_search == nil, do: "%", else: "%#{filter_search}%"

    from(e in base_event_query(query),
      join: meta in "meta",
      hints: "ARRAY",
      on: true,
      as: :meta,
      select: meta.key,
      where: fragment("? ilike ?", meta.key, ^filter_query),
      group_by: meta.key,
      order_by: [desc: fragment("count(*)")],
      limit: 25
    )
    |> Plausible.Stats.CustomProps.maybe_allowed_props_only(site)
    |> ClickhouseRepo.all()
    |> wrap_suggestions()
  end

  def filter_suggestions(site, query, filter_name, filter_search) do
    filter_search = if filter_search == nil, do: "", else: filter_search

    filter_query =
      if Enum.member?(["entry_page", "page", "exit_page"], filter_name),
        do: "%#{String.replace(filter_search, "*", "")}%",
        else: "%#{filter_search}%"

    filter_name =
      case filter_name do
        "page" -> :pathname
        "entry_page" -> :entry_page
        "source" -> :referrer_source
        "channel" -> :acquisition_channel
        "os" -> :operating_system
        "os_version" -> :operating_system_version
        "screen" -> :screen_size
        "exit_page" -> :exit_page
        "utm_source" -> :utm_source
        "utm_medium" -> :utm_medium
        "utm_campaign" -> :utm_campaign
        "utm_content" -> :utm_content
        "utm_term" -> :utm_term
        "referrer" -> :referrer
        "browser" -> :browser
        "browser_version" -> :browser_version
        "operating_system" -> :operating_system
        "operating_system_version" -> :operating_system_version
        "screen_size" -> :screen_size
        "hostname" -> :hostname
      end

    base_q =
      if filter_name in [:pathname, :hostname] do
        base_event_query(query)
      else
        query_sessions(query)
      end

    from(e in base_q,
      where: fragment("? ilike ?", field(e, ^filter_name), ^filter_query),
      select: field(e, ^filter_name),
      group_by: ^filter_name,
      order_by: [desc: fragment("count(*)")]
    )
    |> apply_additional_filters(filter_name, site)
    |> Imported.merge_imported_filter_suggestions(
      site,
      query,
      filter_name,
      filter_query
    )
    |> limit(25)
    |> ClickhouseRepo.all()
    |> Enum.filter(fn suggestion -> suggestion != "" end)
    |> wrap_suggestions()
  end

  def custom_prop_value_filter_suggestions(_site, query, prop_key, filter_search) do
    filter_query = if filter_search == nil, do: "%", else: "%#{filter_search}%"

    none_q =
      from(
        e in base_event_query(Query.remove_top_level_filters(query, ["event:props:#{prop_key}"])),
        select: "(none)",
        where: not has_key(e, :meta, ^prop_key),
        limit: 1
      )

    search_q =
      from(e in base_event_query(query),
        select: get_by_key(e, :meta, ^prop_key),
        where:
          has_key(e, :meta, ^prop_key) and
            fragment(
              "? ilike ?",
              get_by_key(e, :meta, ^prop_key),
              ^filter_query
            ),
        group_by: get_by_key(e, :meta, ^prop_key),
        order_by: [desc: fragment("count(*)")],
        limit: 25
      )

    ClickhouseRepo.all(none_q)
    |> Kernel.++(ClickhouseRepo.all(search_q))
    |> wrap_suggestions()
  end

  defp apply_additional_filters(q, :hostname, site) do
    case Plausible.Shields.allowed_hostname_patterns(site.domain) do
      :all ->
        q

      limited_to when is_list(limited_to) ->
        from(e in q,
          where: fragment("multiMatchAny(?, ?)", e.hostname, ^limited_to)
        )
    end
  end

  defp apply_additional_filters(q, _, _), do: q

  defp wrap_suggestions(list) do
    Enum.map(list, fn val -> %{value: val, label: val} end)
  end
end
```

## File: `lib/plausible/stats/filters/filters.ex`
```
defmodule Plausible.Stats.Filters do
  @moduledoc """
  A module for parsing filters used in stat queries.
  """

  alias Plausible.Stats.Query
  alias Plausible.Stats.Filters.QueryParser
  alias Plausible.Stats.Filters.StatsAPIFilterParser

  @visit_props [
    :source,
    :channel,
    :referrer,
    :utm_medium,
    :utm_source,
    :utm_campaign,
    :utm_content,
    :utm_term,
    :screen,
    :device,
    :browser,
    :browser_version,
    :os,
    :os_version,
    :country,
    :region,
    :city,
    :country_name,
    :region_name,
    :city_name,
    :entry_page,
    :exit_page,
    :entry_page_hostname,
    :exit_page_hostname
  ]
  def visit_props(), do: @visit_props |> Enum.map(&to_string/1)

  @event_table_visit_props @visit_props --
                             [
                               :entry_page,
                               :exit_page,
                               :entry_page_hostname,
                               :exit_page_hostname
                             ]
  def event_table_visit_props(), do: @event_table_visit_props |> Enum.map(&to_string/1)

  @event_props [:name, :page, :goal, :hostname]

  def event_props(), do: @event_props |> Enum.map(&to_string/1)

  @doc """
  Parses different filter formats.

  Depending on the format and type of the `filters` argument, returns:

    * a parsed filter list, when `filters` is a filter expression string
    * the same list, when `filters` is a map

  Returns an empty list when argument type is unexpected (e.g. `nil`).

  ## Examples:

      iex> Filters.parse("visit:browser!=Chrome")
      [[:is_not, "visit:browser", ["Chrome"]]]

      iex> Filters.parse(nil)
      []
  """
  def parse(filters) when is_binary(filters) do
    case Jason.decode(filters) do
      {:ok, filters} when is_list(filters) -> parse(filters)
      {:ok, _} -> []
      {:error, err} -> StatsAPIFilterParser.parse_filter_expression(err.data)
    end
  end

  def parse(filters) when is_list(filters) do
    {:ok, parsed_filters} = QueryParser.parse_filters(filters)
    parsed_filters
  end

  def parse(_), do: []

  def without_prefix(dimension) do
    dimension
    |> String.split(":")
    |> List.last()
    |> String.to_existing_atom()
  end

  def dimensions_used_in_filters(filters, opts \\ []) do
    min_depth = Keyword.get(opts, :min_depth, 0)
    max_depth = Keyword.get(opts, :max_depth, 999)
    # :ignore or :only
    behavioral_filter_option = Keyword.get(opts, :behavioral_filters, nil)

    filters
    |> traverse(
      {0, false},
      fn {depth, is_behavioral_filter}, operator ->
        {depth + 1, is_behavioral_filter or operator in [:has_done, :has_not_done]}
      end
    )
    |> Enum.filter(fn {_filter, {depth, is_behavioral_filter}} ->
      matches_behavioral_filter_option? =
        case behavioral_filter_option do
          :ignore -> not is_behavioral_filter
          :only -> is_behavioral_filter
          _ -> true
        end

      depth >= min_depth and depth <= max_depth and matches_behavioral_filter_option?
    end)
    |> Enum.map(fn {[_operator, dimension | _rest], _depth} -> dimension end)
  end

  def filtering_on_dimension?(query, dimension, opts \\ []) do
    filters =
      case query do
        %Query{filters: filters} -> filters
        %{filters: filters} -> filters
        filters when is_list(filters) -> filters
      end

    dimension in dimensions_used_in_filters(filters, opts)
  end

  def all_leaf_filters(filters) do
    filters
    |> traverse(nil, fn _, _ -> nil end)
    |> Enum.map(fn {filter, _} -> filter end)
  end

  @doc """
  Gets the first top level filter with matching dimension (or nil).

  Only use in cases where it's known that filters are only set on the top level as it
  does not handle AND/OR/NOT!
  """
  def get_toplevel_filter(query, prefix) do
    Enum.find(query.filters, fn [_op, dimension | _rest] ->
      is_binary(dimension) and String.starts_with?(dimension, prefix)
    end)
  end

  def rename_dimensions_used_in_filter(filters, renames) do
    transform_filters(filters, fn
      [operation, dimension | rest] ->
        [[operation, Map.get(renames, dimension, dimension) | rest]]

      _subtree ->
        nil
    end)
  end

  @doc """
  Updates filters via `transformer`.

  Transformer will receive each node (filter, and/or/not subtree) of
  query and must return a list of nodes to replace it with or nil
  to ignore and look deeper.

  ## Examples
    iex> Filters.transform_filters([[:is, "visit:os", ["Linux"]], [:and, [[:is, "segment", [1]], [:is, "segment", [2]]]]], fn
    ...>    [_, "segment", _] -> [[:is, "segment", ["changed"]]]
    ...>    _ -> nil
    ...>  end)
    [[:is, "visit:os", ["Linux"]], [:and, [[:is, "segment", ["changed"]], [:is, "segment", ["changed"]]]]]
  """
  def transform_filters(filters, transformer) do
    filters
    |> Enum.flat_map(&transform_tree(&1, transformer))
  end

  defp transform_tree(filter, transformer) do
    case {transformer.(filter), filter} do
      # Transformer did not return that value - transform that subtree
      {nil, [operator, child_filter]}
      when operator in [:not, :ignore_in_totals_query, :has_done, :has_not_done] ->
        [transformed_child] = transform_tree(child_filter, transformer)
        [[operator, transformed_child]]

      {nil, [operator, filters]} when operator in [:and, :or] ->
        [[operator, transform_filters(filters, transformer)]]

      # Reached a leaf node, return existing value
      {nil, filter} ->
        [filter]

      # Transformer returned a value - don't transform that subtree
      {transformed_filters, _filter} ->
        transformed_filters
    end
  end

  @doc """
  Traverses a filter tree while accumulating state.
  """
  def traverse(filters, state \\ nil, state_transformer \\ fn state, _ -> state end) do
    filters
    |> Enum.flat_map(&traverse_tree(&1, state, state_transformer))
  end

  defp traverse_tree(filter, state, state_transformer) do
    case filter do
      [operation, child_filter]
      when operation in [:not, :ignore_in_totals_query, :has_done, :has_not_done] ->
        traverse_tree(child_filter, state_transformer.(state, operation), state_transformer)

      [operation, filters] when operation in [:and, :or] ->
        traverse(filters, state_transformer.(state, operation), state_transformer)

      # Leaf node
      _ ->
        [{filter, state}]
    end
  end
end
```

## File: `lib/plausible/stats/filters/query_parser.ex`
```
defmodule Plausible.Stats.Filters.QueryParser do
  @moduledoc false

  use Plausible

  alias Plausible.Stats.{TableDecider, Filters, Metrics, DateTimeRange, JSONSchema, Time}

  @default_include %{
    imports: false,
    # `include.imports_meta` can be true even when `include.imports`
    # is false. Even if we don't want to include imported data, we
    # might still want to know whether imported data can be toggled
    # on/off on the dashboard.
    imports_meta: false,
    time_labels: false,
    total_rows: false,
    comparisons: nil,
    legacy_time_on_page_cutoff: nil
  }

  @default_pagination %{
    limit: 10_000,
    offset: 0
  }

  def default_include(), do: @default_include

  def parse(site, schema_type, params, now \\ nil) when is_map(params) do
    {now, date} =
      if now do
        {now, DateTime.shift_zone!(now, site.timezone) |> DateTime.to_date()}
      else
        {DateTime.utc_now(:second), today(site)}
      end

    with :ok <- JSONSchema.validate(schema_type, params),
         {:ok, date} <- parse_date(site, Map.get(params, "date"), date),
         {:ok, raw_time_range} <-
           parse_time_range(site, Map.get(params, "date_range"), date, now),
         utc_time_range = raw_time_range |> DateTimeRange.to_timezone("Etc/UTC"),
         {:ok, metrics} <- parse_metrics(Map.get(params, "metrics", [])),
         {:ok, filters} <- parse_filters(Map.get(params, "filters", [])),
         {:ok, preloaded_segments} <-
           Plausible.Segments.Filters.preload_needed_segments(site, filters),
         {:ok, filters} <-
           Plausible.Segments.Filters.resolve_segments(filters, preloaded_segments),
         {:ok, dimensions} <- parse_dimensions(Map.get(params, "dimensions", [])),
         {:ok, order_by} <- parse_order_by(Map.get(params, "order_by")),
         {:ok, include} <- parse_include(Map.get(params, "include", %{}), site),
         {:ok, pagination} <- parse_pagination(Map.get(params, "pagination", %{})),
         {preloaded_goals, revenue_warning, revenue_currencies} <-
           preload_goals_and_revenue(site, metrics, filters, dimensions),
         query = %{
           metrics: metrics,
           filters: filters,
           utc_time_range: utc_time_range,
           dimensions: dimensions,
           order_by: order_by,
           timezone: site.timezone,
           include: include,
           pagination: pagination,
           preloaded_goals: preloaded_goals,
           revenue_warning: revenue_warning,
           revenue_currencies: revenue_currencies
         },
         :ok <- validate_order_by(query),
         :ok <- validate_custom_props_access(site, query),
         :ok <- validate_toplevel_only_filter_dimension(query),
         :ok <- validate_special_metrics_filters(query),
         :ok <- validate_behavioral_filters(query),
         :ok <- validate_filtered_goals_exist(query),
         :ok <- validate_revenue_metrics_access(site, query),
         :ok <- validate_metrics(query),
         :ok <- validate_include(query) do
      {:ok, query}
    end
  end

  def parse_date_range_pair(site, [from, to]) when is_binary(from) and is_binary(to) do
    with {:ok, date_range} <- date_range_from_date_strings(site, from, to) do
      {:ok, date_range |> DateTimeRange.to_timezone("Etc/UTC")}
    end
  end

  def parse_date_range_pair(_site, unknown), do: {:error, "Invalid date_range '#{i(unknown)}'."}

  defp parse_metrics(metrics) when is_list(metrics) do
    parse_list(metrics, &parse_metric/1)
  end

  defp parse_metric(metric_str) do
    case Metrics.from_string(metric_str) do
      {:ok, metric} -> {:ok, metric}
      _ -> {:error, "Unknown metric '#{i(metric_str)}'."}
    end
  end

  def parse_filters(filters) when is_list(filters) do
    parse_list(filters, &parse_filter/1)
  end

  def parse_filters(_invalid_metrics), do: {:error, "Invalid filters passed."}

  defp parse_filter(filter) do
    with {:ok, operator} <- parse_operator(filter),
         {:ok, second} <- parse_filter_second(operator, filter),
         {:ok, rest} <- parse_filter_rest(operator, filter) do
      {:ok, [operator, second | rest]}
    end
  end

  defp parse_operator(["is" | _rest]), do: {:ok, :is}
  defp parse_operator(["is_not" | _rest]), do: {:ok, :is_not}
  defp parse_operator(["matches" | _rest]), do: {:ok, :matches}
  defp parse_operator(["matches_not" | _rest]), do: {:ok, :matches_not}
  defp parse_operator(["matches_wildcard" | _rest]), do: {:ok, :matches_wildcard}
  defp parse_operator(["matches_wildcard_not" | _rest]), do: {:ok, :matches_wildcard_not}
  defp parse_operator(["contains" | _rest]), do: {:ok, :contains}
  defp parse_operator(["contains_not" | _rest]), do: {:ok, :contains_not}
  defp parse_operator(["and" | _rest]), do: {:ok, :and}
  defp parse_operator(["or" | _rest]), do: {:ok, :or}
  defp parse_operator(["not" | _rest]), do: {:ok, :not}
  defp parse_operator(["has_done" | _rest]), do: {:ok, :has_done}
  defp parse_operator(["has_not_done" | _rest]), do: {:ok, :has_not_done}
  defp parse_operator(filter), do: {:error, "Unknown operator for filter '#{i(filter)}'."}

  def parse_filter_second(operator, [_, filters | _rest]) when operator in [:and, :or],
    do: parse_filters(filters)

  def parse_filter_second(operator, [_, filter | _rest])
      when operator in [:not, :has_done, :has_not_done],
      do: parse_filter(filter)

  def parse_filter_second(_operator, filter), do: parse_filter_dimension(filter)

  defp parse_filter_dimension([_operator, filter_dimension | _rest] = filter) do
    parse_filter_dimension_string(filter_dimension, "Invalid filter '#{i(filter)}")
  end

  defp parse_filter_dimension(filter), do: {:error, "Invalid filter '#{i(filter)}'."}

  defp parse_filter_rest(operator, filter)
       when operator in [
              :is,
              :is_not,
              :matches,
              :matches_not,
              :matches_wildcard,
              :matches_wildcard_not,
              :contains,
              :contains_not
            ] do
    with {:ok, clauses} <- parse_clauses_list(filter),
         {:ok, modifiers} <- parse_filter_modifiers(Enum.at(filter, 3)) do
      {:ok, [clauses | modifiers]}
    end
  end

  defp parse_filter_rest(operator, _filter)
       when operator in [:not, :and, :or, :has_done, :has_not_done],
       do: {:ok, []}

  defp parse_clauses_list([operator, dimension, list | _rest] = filter) when is_list(list) do
    all_strings? = Enum.all?(list, &is_binary/1)
    all_integers? = Enum.all?(list, &is_integer/1)

    case {dimension, all_strings?} do
      {"visit:city", false} when all_integers? ->
        {:ok, list}

      {"visit:country", true} when operator in ["is", "is_not"] ->
        if Enum.all?(list, &(String.length(&1) == 2)) do
          {:ok, list}
        else
          {:error,
           "Invalid visit:country filter, visit:country needs to be a valid 2-letter country code."}
        end

      {"segment", _} when all_integers? ->
        {:ok, list}

      {_, true} when dimension !== "segment" ->
        {:ok, list}

      _ ->
        {:error, "Invalid filter '#{i(filter)}'."}
    end
  end

  defp parse_clauses_list(filter), do: {:error, "Invalid filter '#{i(filter)}'"}

  defp parse_filter_modifiers(modifiers) when is_map(modifiers) do
    {:ok, [atomize_keys(modifiers)]}
  end

  defp parse_filter_modifiers(nil) do
    {:ok, []}
  end

  defp parse_date(_site, date_string, _date) when is_binary(date_string) do
    case Date.from_iso8601(date_string) do
      {:ok, date} -> {:ok, date}
      _ -> {:error, "Invalid date '#{date_string}'."}
    end
  end

  defp parse_date(_site, _date_string, date) do
    {:ok, date}
  end

  defp parse_time_range(_site, date_range, _date, now) when date_range in ["realtime", "30m"] do
    duration_minutes =
      case date_range do
        "realtime" -> 5
        "30m" -> 30
      end

    first_datetime = DateTime.shift(now, minute: -duration_minutes)
    last_datetime = DateTime.shift(now, second: 5)

    {:ok, DateTimeRange.new!(first_datetime, last_datetime)}
  end

  defp parse_time_range(site, "day", date, _now) do
    {:ok, DateTimeRange.new!(date, date, site.timezone)}
  end

  defp parse_time_range(site, "month", date, _now) do
    last = date |> Date.end_of_month()
    first = last |> Date.beginning_of_month()
    {:ok, DateTimeRange.new!(first, last, site.timezone)}
  end

  defp parse_time_range(site, "year", date, _now) do
    last = date |> Timex.end_of_year()
    first = last |> Timex.beginning_of_year()
    {:ok, DateTimeRange.new!(first, last, site.timezone)}
  end

  defp parse_time_range(site, "all", date, _now) do
    start_date = Plausible.Sites.stats_start_date(site) || date

    {:ok, DateTimeRange.new!(start_date, date, site.timezone)}
  end

  defp parse_time_range(site, shorthand, date, _now) when is_binary(shorthand) do
    case Integer.parse(shorthand) do
      {n, "d"} when n > 0 and n <= 5_000 ->
        last = date |> Date.add(-1)
        first = date |> Date.add(-n)
        {:ok, DateTimeRange.new!(first, last, site.timezone)}

      {n, "mo"} when n > 0 and n <= 100 ->
        last = date |> Date.end_of_month()
        first = last |> Date.shift(month: -n + 1) |> Date.beginning_of_month()
        {:ok, DateTimeRange.new!(first, last, site.timezone)}

      _ ->
        {:error, "Invalid date_range #{i(shorthand)}"}
    end
  end

  defp parse_time_range(site, [from, to], _date, _now) when is_binary(from) and is_binary(to) do
    case date_range_from_date_strings(site, from, to) do
      {:ok, date_range} -> {:ok, date_range}
      {:error, _} -> date_range_from_timestamps(from, to)
    end
  end

  defp parse_time_range(_site, unknown, _date, _now),
    do: {:error, "Invalid date_range #{i(unknown)}"}

  defp date_range_from_date_strings(site, from, to) do
    with {:ok, from_date} <- Date.from_iso8601(from),
         {:ok, to_date} <- Date.from_iso8601(to) do
      {:ok, DateTimeRange.new!(from_date, to_date, site.timezone)}
    end
  end

  defp date_range_from_timestamps(from, to) do
    with {:ok, from_datetime, _offset} <- DateTime.from_iso8601(from),
         {:ok, to_datetime, _offset} <- DateTime.from_iso8601(to) do
      {:ok, DateTimeRange.new!(from_datetime, to_datetime)}
    else
      _ -> {:error, "Invalid date_range '#{i([from, to])}'."}
    end
  end

  defp today(site), do: DateTime.now!(site.timezone) |> DateTime.to_date()

  defp parse_dimensions(dimensions) when is_list(dimensions) do
    parse_list(
      dimensions,
      &parse_dimension_entry(&1, "Invalid dimensions '#{i(dimensions)}'")
    )
  end

  def parse_order_by(order_by) when is_list(order_by) do
    parse_list(order_by, &parse_order_by_entry/1)
  end

  def parse_order_by(nil), do: {:ok, nil}
  def parse_order_by(order_by), do: {:error, "Invalid order_by '#{i(order_by)}'."}

  defp parse_order_by_entry(entry) do
    with {:ok, value} <- parse_metric_or_dimension(entry),
         {:ok, order_direction} <- parse_order_direction(entry) do
      {:ok, {value, order_direction}}
    end
  end

  defp parse_dimension_entry(key, error_message) do
    case {
      parse_time(key),
      parse_filter_dimension_string(key)
    } do
      {{:ok, time}, _} -> {:ok, time}
      {_, {:ok, dimension}} -> {:ok, dimension}
      _ -> {:error, error_message}
    end
  end

  defp parse_metric_or_dimension([value, _] = entry) do
    case {
      parse_time(value),
      parse_metric(value),
      parse_filter_dimension_string(value)
    } do
      {{:ok, time}, _, _} -> {:ok, time}
      {_, {:ok, metric}, _} -> {:ok, metric}
      {_, _, {:ok, dimension}} -> {:ok, dimension}
      _ -> {:error, "Invalid order_by entry '#{i(entry)}'."}
    end
  end

  defp parse_time("time"), do: {:ok, "time"}
  defp parse_time("time:minute"), do: {:ok, "time:minute"}
  defp parse_time("time:hour"), do: {:ok, "time:hour"}
  defp parse_time("time:day"), do: {:ok, "time:day"}
  defp parse_time("time:week"), do: {:ok, "time:week"}
  defp parse_time("time:month"), do: {:ok, "time:month"}
  defp parse_time(_), do: :error

  defp parse_order_direction([_, "asc"]), do: {:ok, :asc}
  defp parse_order_direction([_, "desc"]), do: {:ok, :desc}
  defp parse_order_direction(entry), do: {:error, "Invalid order_by entry '#{i(entry)}'."}

  def parse_include(include, site) when is_map(include) do
    with {:ok, include} <- atomize_include_keys(include),
         {:ok, include} <- update_comparisons_date_range(include, site) do
      {:ok, Map.merge(@default_include, include)}
    end
  end

  def parse_include(include, _site), do: {:error, "Invalid include '#{i(include)}'."}

  defp atomize_include_keys(map) do
    expected_keys = @default_include |> Map.keys() |> Enum.map(&Atom.to_string/1)

    if Map.keys(map) |> Enum.all?(&(&1 in expected_keys)) do
      {:ok, atomize_keys(map)}
    else
      {:error, "Invalid include '#{i(map)}'."}
    end
  end

  defp update_comparisons_date_range(%{comparisons: %{date_range: date_range}} = include, site) do
    with {:ok, parsed_date_range} <- parse_date_range_pair(site, date_range) do
      {:ok, put_in(include, [:comparisons, :date_range], parsed_date_range)}
    end
  end

  defp update_comparisons_date_range(include, _site), do: {:ok, include}

  defp parse_pagination(pagination) when is_map(pagination) do
    {:ok, Map.merge(@default_pagination, atomize_keys(pagination))}
  end

  defp atomize_keys(map) when is_map(map) do
    Map.new(map, fn {key, value} ->
      key = String.to_existing_atom(key)
      {key, atomize_keys(value)}
    end)
  end

  defp atomize_keys(value), do: value

  defp parse_filter_dimension_string(dimension, error_message \\ "") do
    case dimension do
      "event:props:" <> property_name ->
        if String.length(property_name) > 0 do
          {:ok, dimension}
        else
          {:error, error_message}
        end

      "event:" <> key ->
        if key in Filters.event_props() do
          {:ok, dimension}
        else
          {:error, error_message}
        end

      "visit:" <> key ->
        if key in Filters.visit_props() do
          {:ok, dimension}
        else
          {:error, error_message}
        end

      "segment" ->
        {:ok, dimension}

      _ ->
        {:error, error_message}
    end
  end

  defp validate_order_by(query) do
    if query.order_by do
      valid_values = query.metrics ++ query.dimensions

      invalid_entry =
        Enum.find(query.order_by, fn {value, _direction} ->
          not Enum.member?(valid_values, value)
        end)

      case invalid_entry do
        nil ->
          :ok

        _ ->
          {:error,
           "Invalid order_by entry '#{i(invalid_entry)}'. Entry is not a queried metric or dimension."}
      end
    else
      :ok
    end
  end

  def preload_goals_and_revenue(site, metrics, filters, dimensions) do
    preloaded_goals =
      Plausible.Stats.Goals.preload_needed_goals(site, dimensions, filters)

    {revenue_warning, revenue_currencies} =
      preload_revenue(site, preloaded_goals, metrics, dimensions)

    {
      preloaded_goals,
      revenue_warning,
      revenue_currencies
    }
  end

  @only_toplevel ["event:goal", "event:hostname"]
  defp validate_toplevel_only_filter_dimension(query) do
    not_toplevel =
      query.filters
      |> Filters.dimensions_used_in_filters(min_depth: 1, behavioral_filters: :ignore)
      |> Enum.filter(&(&1 in @only_toplevel))

    if Enum.count(not_toplevel) > 0 do
      {:error,
       "Invalid filters. Dimension `#{List.first(not_toplevel)}` can only be filtered at the top level."}
    else
      :ok
    end
  end

  @special_metrics [:conversion_rate, :group_conversion_rate]
  defp validate_special_metrics_filters(query) do
    special_metric? = Enum.any?(@special_metrics, &(&1 in query.metrics))

    deep_custom_property? =
      query.filters
      |> Filters.dimensions_used_in_filters(min_depth: 1)
      |> Enum.any?(fn dimension -> String.starts_with?(dimension, "event:props:") end)

    if special_metric? and deep_custom_property? do
      {:error,
       "Invalid filters. When `conversion_rate` or `group_conversion_rate` metrics are used, custom property filters can only be used on top level."}
    else
      :ok
    end
  end

  defp validate_behavioral_filters(query) do
    query.filters
    |> Filters.traverse(0, fn behavioral_depth, operator ->
      if operator in [:has_done, :has_not_done] do
        behavioral_depth + 1
      else
        behavioral_depth
      end
    end)
    |> Enum.reduce_while(:ok, fn {[_operator, dimension | _rest], behavioral_depth}, :ok ->
      cond do
        behavioral_depth == 0 ->
          # ignore non-behavioral filters
          {:cont, :ok}

        behavioral_depth > 1 ->
          {:halt,
           {:error,
            "Invalid filters. Behavioral filters (has_done, has_not_done) cannot be nested."}}

        not String.starts_with?(dimension, "event:") ->
          {:halt,
           {:error,
            "Invalid filters. Behavioral filters (has_done, has_not_done) can only be used with event dimension filters."}}

        true ->
          {:cont, :ok}
      end
    end)
  end

  defp validate_filtered_goals_exist(query) do
    # Note: We don't check :contains goal filters since it's acceptable if they match nothing.
    goal_filter_clauses =
      query.filters
      |> Filters.all_leaf_filters()
      |> Enum.flat_map(fn
        [:is, "event:goal", clauses] -> clauses
        _ -> []
      end)

    if length(goal_filter_clauses) > 0 do
      configured_goal_names =
        query.preloaded_goals.all
        |> Enum.map(&Plausible.Goal.display_name/1)

      validate_list(goal_filter_clauses, &validate_goal_filter(&1, configured_goal_names))
    else
      :ok
    end
  end

  on_ee do
    alias Plausible.Stats.Goal.Revenue

    def preload_revenue(site, preloaded_goals, metrics, dimensions) do
      Revenue.preload(site, preloaded_goals, metrics, dimensions)
    end

    defp validate_revenue_metrics_access(site, query) do
      if Revenue.requested?(query.metrics) and not Revenue.available?(site) do
        {:error, "The owner of this site does not have access to the revenue metrics feature."}
      else
        :ok
      end
    end
  else
    defp preload_revenue(_site, _preloaded_goals, _metrics, _dimensions), do: {nil, %{}}

    defp validate_revenue_metrics_access(_site, _query), do: :ok
  end

  defp validate_goal_filter(clause, configured_goal_names) do
    if Enum.member?(configured_goal_names, clause) do
      :ok
    else
      {:error,
       "Invalid filters. The goal `#{clause}` is not configured for this site. Find out how to configure goals here: https://plausible.io/docs/stats-api#filtering-by-goals"}
    end
  end

  defp validate_custom_props_access(site, query) do
    allowed_props = Plausible.Props.allowed_for(site, bypass_setup?: true)

    validate_custom_props_access(site, query, allowed_props)
  end

  defp validate_custom_props_access(_site, _query, :all), do: :ok

  defp validate_custom_props_access(_site, query, allowed_props) do
    valid? =
      query.filters
      |> Filters.dimensions_used_in_filters()
      |> Enum.concat(query.dimensions)
      |> Enum.all?(fn
        "event:props:" <> prop -> prop in allowed_props
        _ -> true
      end)

    if valid? do
      :ok
    else
      {:error, "The owner of this site does not have access to the custom properties feature."}
    end
  end

  defp validate_metrics(query) do
    with :ok <- validate_list(query.metrics, &validate_metric(&1, query)) do
      TableDecider.validate_no_metrics_dimensions_conflict(query)
    end
  end

  defp validate_metric(metric, query) when metric in [:conversion_rate, :group_conversion_rate] do
    if Enum.member?(query.dimensions, "event:goal") or
         Filters.filtering_on_dimension?(query, "event:goal", behavioral_filters: :ignore) do
      :ok
    else
      {:error, "Metric `#{metric}` can only be queried with event:goal filters or dimensions."}
    end
  end

  defp validate_metric(:scroll_depth = metric, query) do
    page_dimension? = Enum.member?(query.dimensions, "event:page")
    toplevel_page_filter? = not is_nil(Filters.get_toplevel_filter(query, "event:page"))

    if page_dimension? or toplevel_page_filter? do
      :ok
    else
      {:error, "Metric `#{metric}` can only be queried with event:page filters or dimensions."}
    end
  end

  defp validate_metric(:exit_rate = metric, query) do
    case {query.dimensions, TableDecider.sessions_join_events?(query)} do
      {["visit:exit_page"], false} ->
        :ok

      {["visit:exit_page"], true} ->
        {:error, "Metric `#{metric}` cannot be queried when filtering on event dimensions."}

      _ ->
        {:error,
         "Metric `#{metric}` requires a `\"visit:exit_page\"` dimension. No other dimensions are allowed."}
    end
  end

  defp validate_metric(:views_per_visit = metric, query) do
    cond do
      Filters.filtering_on_dimension?(query, "event:page", behavioral_filters: :ignore) ->
        {:error, "Metric `#{metric}` cannot be queried with a filter on `event:page`."}

      length(query.dimensions) > 0 ->
        {:error, "Metric `#{metric}` cannot be queried with `dimensions`."}

      true ->
        :ok
    end
  end

  defp validate_metric(:time_on_page = metric, query) do
    cond do
      Enum.member?(query.dimensions, "event:page") ->
        :ok

      Filters.filtering_on_dimension?(query, "event:page", behavioral_filters: :ignore) ->
        :ok

      true ->
        {:error, "Metric `#{metric}` can only be queried with event:page filters or dimensions."}
    end
  end

  defp validate_metric(_, _), do: :ok

  defp validate_include(query) do
    time_dimension? = Enum.any?(query.dimensions, &Time.time_dimension?/1)

    if query.include.time_labels and not time_dimension? do
      {:error, "Invalid include.time_labels: requires a time dimension."}
    else
      :ok
    end
  end

  defp i(value), do: inspect(value, charlists: :as_lists)

  defp parse_list(list, parser_function) do
    Enum.reduce_while(list, {:ok, []}, fn value, {:ok, results} ->
      case parser_function.(value) do
        {:ok, result} -> {:cont, {:ok, results ++ [result]}}
        {:error, _} = error -> {:halt, error}
      end
    end)
  end

  defp validate_list(list, parser_function) do
    Enum.reduce_while(list, :ok, fn value, :ok ->
      case parser_function.(value) do
        :ok -> {:cont, :ok}
        {:error, _} = error -> {:halt, error}
      end
    end)
  end
end
```

## File: `lib/plausible/stats/filters/stats_api_filter_parser.ex`
```
defmodule Plausible.Stats.Filters.StatsAPIFilterParser do
  @moduledoc false

  @non_escaped_pipe_regex ~r/(?<!\\)\|/

  @doc """
  This function parses the filter expression given as a string.
  This filtering format is used by the public Stats API.
  """
  def parse_filter_expression(str) do
    filters = String.split(str, ";")

    Enum.map(filters, &parse_single_filter/1)
    |> Enum.reject(fn parsed -> parsed == :error end)
  end

  defp parse_single_filter(str) do
    case to_kv(str) do
      ["event:goal" = key, raw_value] ->
        parse_goal_filter(key, raw_value)

      [key, raw_value] ->
        is_negated? = String.contains?(str, "!=")
        is_list? = list_expression?(raw_value)
        is_wildcard? = wildcard_expression?(raw_value)

        final_value = remove_escape_chars(raw_value)

        cond do
          is_wildcard? && is_negated? -> [:matches_wildcard_not, key, [raw_value]]
          is_wildcard? -> [:matches_wildcard, key, [raw_value]]
          is_list? -> [:is, key, parse_member_list(raw_value)]
          is_negated? -> [:is_not, key, [final_value]]
          true -> [:is, key, [final_value]]
        end
        |> reject_invalid_country_codes()

      _ ->
        :error
    end
  end

  defp reject_invalid_country_codes([_op, "visit:country", code_or_codes | _rest] = filter) do
    code_or_codes
    |> List.wrap()
    |> Enum.reduce_while(filter, fn
      value, _ when byte_size(value) == 2 -> {:cont, filter}
      _, _ -> {:halt, :error}
    end)
  end

  defp reject_invalid_country_codes(filter), do: filter

  defp to_kv(str) do
    str
    |> String.trim()
    |> String.split(["==", "!="], trim: true)
    |> Enum.map(&String.trim/1)
  end

  defp parse_goal_filter(key, value) do
    is_list? = list_expression?(value)

    value =
      if is_list? do
        parse_member_list(value)
      else
        remove_escape_chars(value)
      end

    [:is, key, List.wrap(value)]
  end

  defp list_expression?(expression) do
    Regex.match?(@non_escaped_pipe_regex, expression)
  end

  defp wildcard_expression?(expression) do
    String.contains?(expression, "*")
  end

  defp parse_member_list(raw_value) do
    raw_value
    |> String.split(@non_escaped_pipe_regex)
    |> Enum.map(&remove_escape_chars/1)
  end

  defp remove_escape_chars(value) do
    String.replace(value, "\\|", "|")
  end
end
```

## File: `lib/plausible/stats/filters/utils.ex`
```
defmodule Plausible.Stats.Filters.Utils do
  @moduledoc false

  def page_regex(expr) do
    escaped =
      expr
      |> Regex.escape()
      |> String.replace("\\|", "|")
      |> String.replace("\\*\\*", ".*")
      |> String.replace("\\*", ".*")

    "^#{escaped}$"
  end
end
```

## File: `lib/plausible/stats/goal_suggestions.ex`
```
defmodule Plausible.Stats.GoalSuggestions do
  @moduledoc false

  alias Plausible.{Repo, ClickhouseRepo}
  alias Plausible.Stats.Query
  import Plausible.Stats.Base
  import Ecto.Query

  # As excluded goal names are interpolated as separate
  # parameters in the query, there's a risk of running
  # against max parameters limit. Given the failure mode
  # in this case is suggesting an event that is already
  # added as a goal, which will be validated when creating,
  # it's safe to trim exclusions list.
  @max_excluded 1000

  defmacrop visitors(e) do
    quote do
      selected_as(
        fragment("toUInt64(round(uniq(?)*any(_sample_factor)))", unquote(e).user_id),
        :visitors
      )
    end
  end

  def suggest_event_names(site, search_input, opts \\ []) do
    matches = "%#{search_input}%"

    site =
      site
      |> Repo.preload(:goals)

    excluded =
      opts
      |> Keyword.get(:exclude, [])
      |> Enum.take(@max_excluded)

    limit = Keyword.get(opts, :limit, 25)

    params = %{"with_imported" => "true", "period" => "6mo"}
    query = Query.from(site, params)

    native_q =
      from(e in base_event_query(query),
        where: fragment("? ilike ?", e.name, ^matches),
        where: e.name not in ["pageview", "engagement"],
        where: fragment("trim(?)", e.name) != "",
        where: e.name == fragment("trim(?)", e.name),
        where: e.name not in ^excluded,
        select: %{
          name: e.name,
          visitors: visitors(e)
        },
        order_by: selected_as(:visitors),
        group_by: e.name
      )
      |> maybe_set_limit(limit)

    date_range = Query.date_range(query)

    imported_q =
      from(i in "imported_custom_events",
        where: i.site_id == ^site.id,
        where: i.import_id in ^Plausible.Imported.complete_import_ids(site),
        where: i.date >= ^date_range.first and i.date <= ^date_range.last,
        where: i.visitors > 0,
        where: fragment("? ilike ?", i.name, ^matches),
        where: fragment("trim(?)", i.name) != "",
        where: i.name == fragment("trim(?)", i.name),
        where: i.name not in ^excluded,
        select: %{
          name: i.name,
          visitors: selected_as(sum(i.visitors), :visitors)
        },
        order_by: selected_as(:visitors),
        group_by: i.name
      )
      |> maybe_set_limit(limit)

    from(e in Ecto.Query.subquery(native_q),
      full_join: i in subquery(imported_q),
      on: e.name == i.name,
      select: selected_as(fragment("if(empty(?), ?, ?)", e.name, i.name, e.name), :name),
      order_by: [desc: e.visitors + i.visitors]
    )
    |> maybe_set_limit(limit)
    |> ClickhouseRepo.all()
    |> Enum.reject(&(String.length(&1) > Plausible.Goal.max_event_name_length()))
  end

  defp maybe_set_limit(q, :unlimited) do
    q
  end

  defp maybe_set_limit(q, limit) when is_integer(limit) and limit > 0 do
    limit(q, ^limit)
  end
end
```

## File: `lib/plausible/stats/goals.ex`
```
defmodule Plausible.Stats.Goals do
  @moduledoc """
  Stats code related to filtering and grouping by goals.
  """

  import Ecto.Query
  import Plausible.Stats.Filters.Utils, only: [page_regex: 1]

  alias Plausible.Stats.Filters

  @doc """
  Preloads goals data if needed for query-building and related work.
  """
  def preload_needed_goals(site, dimensions, filters) do
    if Enum.member?(dimensions, "event:goal") or
         Filters.filtering_on_dimension?(filters, "event:goal") do
      goals = Plausible.Goals.for_site(site)

      %{
        # When grouping by event:goal, later pipeline needs to know which goals match filters exactly.
        # This can affect both calculations whether all goals have the same revenue currency and
        # whether we should skip imports.
        matching_toplevel_filters: goals_matching_toplevel_filters(goals, filters),
        all: goals
      }
    else
      %{
        all: [],
        matching_toplevel_filters: []
      }
    end
  end

  @doc """
  Translates an event:goal filter into SQL. Similarly to other `add_filter` clauses in
  `Plausible.Stats.SQL.WhereBuilder`, returns an `Ecto.Query.dynamic` expression.

  Compared to other dimensions, filtering by goals works differently. First, we expect
  all goals to be preloaded into the query - this list of goals is what actually gets
  filtered by `operator` and `clauses`.

  With the resulting filtered list of goals, we build conditions for whether that goal
  was completed or not, and join those conditions with a logical OR.

  ### Options

  * `imported?` - when `true`, builds conditions on the `page` db field rather than
    `pathname`, and also skips the `e.name == "pageview"` check.
  """
  def add_filter(query, [operation, "event:goal", clauses | _] = filter, opts \\ [])
      when operation in [:is, :contains] do
    imported? = Keyword.get(opts, :imported?, false)

    Enum.reduce(clauses, false, fn clause, dynamic_statement ->
      condition =
        query.preloaded_goals.all
        |> filter_preloaded(filter, clause)
        |> build_condition(imported?)

      dynamic([e], ^condition or ^dynamic_statement)
    end)
  end

  @type goal_join_data() :: %{
          indices: [non_neg_integer()],
          types: [String.t()],
          event_names_imports: [String.t()],
          event_names_by_type: [String.t()],
          page_regexes: [String.t()],
          scroll_thresholds: [non_neg_integer()]
        }

  @doc """
  Returns data needed to perform a GROUP BY on goals in an ecto query.
  """
  @spec goal_join_data(Plausible.Stats.Query.t()) :: goal_join_data()
  def goal_join_data(query) do
    goals = query.preloaded_goals.matching_toplevel_filters

    %{
      indices: Enum.with_index(goals, 1) |> Enum.map(fn {_goal, idx} -> idx end),
      types: Enum.map(goals, &to_string(Plausible.Goal.type(&1))),
      # :TRICKY: This will contain "" for non-event goals
      event_names_imports: Enum.map(goals, &to_string(&1.event_name)),
      event_names_by_type:
        Enum.map(goals, fn goal ->
          case Plausible.Goal.type(goal) do
            :event -> goal.event_name
            :page -> "pageview"
            :scroll -> "engagement"
          end
        end),
      # :TRICKY: event goals are considered to match everything for the sake of efficient queries in query_builder.ex
      # See also Plausible.Stats.SQL.Expression#event_goal_join
      page_regexes:
        Enum.map(goals, fn goal ->
          case Plausible.Goal.type(goal) do
            :event -> ".?"
            :page -> Filters.Utils.page_regex(goal.page_path)
            :scroll -> Filters.Utils.page_regex(goal.page_path)
          end
        end),
      scroll_thresholds: Enum.map(goals, & &1.scroll_threshold)
    }
  end

  def toplevel_scroll_goal_filters?(query) do
    goal_filters? =
      Enum.any?(query.filters, fn
        [_, "event:goal", _] -> true
        _ -> false
      end)

    any_scroll_goals_preloaded? =
      query.preloaded_goals.matching_toplevel_filters
      |> Enum.any?(fn goal -> Plausible.Goal.type(goal) == :scroll end)

    goal_filters? and any_scroll_goals_preloaded?
  end

  defp filter_preloaded(goals, filter, clause) do
    Enum.filter(goals, fn goal -> matches?(goal, filter, clause) end)
  end

  defp goals_matching_toplevel_filters(goals, filters) do
    Enum.reduce(filters, goals, fn
      [_, "event:goal" | _] = filter, goals ->
        goals_matching_any_clause(goals, filter)

      _filter, goals ->
        goals
    end)
  end

  defp goals_matching_any_clause(goals, [_, _, clauses | _] = filter) do
    goals
    |> Enum.filter(fn goal ->
      Enum.any?(clauses, fn clause -> matches?(goal, filter, clause) end)
    end)
  end

  defp matches?(goal, [operation | _rest] = filter, clause) do
    goal_name =
      goal
      |> Plausible.Goal.display_name()
      |> mod(filter)

    clause = mod(clause, filter)

    case operation do
      :is ->
        goal_name == clause

      :contains ->
        String.contains?(goal_name, clause)
    end
  end

  defp mod(str, filter) do
    case filter do
      [_, _, _, %{case_sensitive: false}] -> String.downcase(str)
      _ -> str
    end
  end

  defp build_condition(filtered_goals, imported?) do
    Enum.reduce(filtered_goals, false, fn goal, dynamic_statement ->
      if is_nil(goal) do
        dynamic([e], ^dynamic_statement)
      else
        dynamic([e], ^goal_condition(goal, imported?) or ^dynamic_statement)
      end
    end)
  end

  def goal_condition(goal, imported? \\ false) do
    type = Plausible.Goal.type(goal)
    goal_condition(type, goal, imported?)
  end

  defp goal_condition(:event, goal, _) do
    dynamic([e], e.name == ^goal.event_name)
  end

  defp goal_condition(:scroll, goal, false = _imported?) do
    pathname_condition = page_path_condition(goal.page_path, _imported? = false)
    name_condition = dynamic([e], e.name == "engagement")

    scroll_condition =
      dynamic([e], e.scroll_depth <= 100 and e.scroll_depth >= ^goal.scroll_threshold)

    dynamic([e], ^pathname_condition and ^name_condition and ^scroll_condition)
  end

  defp goal_condition(:page, goal, true = _imported?) do
    page_path_condition(goal.page_path, _imported? = true)
  end

  defp goal_condition(:page, goal, false = _imported?) do
    name_condition = dynamic([e], e.name == "pageview")
    pathname_condition = page_path_condition(goal.page_path, _imported? = false)

    dynamic([e], ^pathname_condition and ^name_condition)
  end

  defp page_path_condition(page_path, imported?) do
    db_field = page_path_db_field(imported?)

    if String.contains?(page_path, "*") do
      dynamic([e], fragment("match(?, ?)", field(e, ^db_field), ^page_regex(page_path)))
    else
      dynamic([e], field(e, ^db_field) == ^page_path)
    end
  end

  def page_path_db_field(true = _imported?), do: :page
  def page_path_db_field(false = _imported?), do: :pathname
end
```

## File: `lib/plausible/stats/imported/base.ex`
```
defmodule Plausible.Stats.Imported.Base do
  @moduledoc """
  A module for building the base of an imported stats query
  """

  import Ecto.Query

  alias Plausible.Imported
  alias Plausible.Stats.Query

  import Plausible.Stats.Filters,
    only: [dimensions_used_in_filters: 1, dimensions_used_in_filters: 2]

  @property_to_table_mappings %{
    "visit:source" => "imported_sources",
    "visit:channel" => "imported_sources",
    "visit:referrer" => "imported_sources",
    "visit:utm_source" => "imported_sources",
    "visit:utm_medium" => "imported_sources",
    "visit:utm_campaign" => "imported_sources",
    "visit:utm_term" => "imported_sources",
    "visit:utm_content" => "imported_sources",
    "visit:entry_page" => "imported_entry_pages",
    "visit:exit_page" => "imported_exit_pages",
    "visit:country" => "imported_locations",
    "visit:region" => "imported_locations",
    "visit:city" => "imported_locations",
    "visit:country_name" => "imported_locations",
    "visit:region_name" => "imported_locations",
    "visit:city_name" => "imported_locations",
    "visit:device" => "imported_devices",
    "visit:browser" => "imported_browsers",
    "visit:browser_version" => "imported_browsers",
    "visit:os" => "imported_operating_systems",
    "visit:os_version" => "imported_operating_systems",
    "event:page" => "imported_pages",
    "event:name" => "imported_custom_events",

    # NOTE: these dimensions can be only filtered by
    "visit:screen" => "imported_devices",
    "event:hostname" => "imported_pages",

    # NOTE: These dimensions are only used in group by
    "time:month" => "imported_visitors",
    "time:week" => "imported_visitors",
    "time:day" => "imported_visitors",
    "time:hour" => "imported_visitors"
  }

  @queriable_time_dimensions ["time:month", "time:week", "time:day", "time:hour"]

  @imported_custom_props Imported.imported_custom_props()

  def property_to_table_mappings(), do: @property_to_table_mappings

  def query_imported(site, query) do
    [table] = decide_tables(query)

    query_imported(table, site, query)
  end

  def query_imported(table, site, query) do
    import_ids = Imported.complete_import_ids(site)
    # Assumption: dates in imported table are in user-local timezone.
    %{first: date_from, last: date_to} = Query.date_range(query)

    from(i in table,
      where: i.site_id == ^site.id,
      where: i.import_id in ^import_ids,
      where: i.date >= ^date_from,
      where: i.date <= ^date_to,
      where: ^Plausible.Stats.Imported.SQL.WhereBuilder.build(query),
      select: %{}
    )
  end

  def decide_tables(query) do
    behavioral_filters = dimensions_used_in_filters(query.filters, behavioral_filters: :only)

    cond do
      # Behavioral filters cannot be emulated via aggregated imported stats
      length(behavioral_filters) > 0 ->
        []

      custom_prop_query?(query) ->
        do_decide_custom_prop_table(query)

      true ->
        do_decide_tables(query)
    end
  end

  defp custom_prop_query?(query) do
    dimensions_used_in_filters(query.filters)
    |> Enum.concat(query.dimensions)
    |> Enum.any?(&(&1 in @imported_custom_props))
  end

  defp do_decide_custom_prop_table(%{dimensions: [dimension]} = query)
       when dimension in @imported_custom_props do
    do_decide_custom_prop_table(query, dimension)
  end

  @queriable_custom_prop_dimensions ["event:goal", "event:name"] ++ @queriable_time_dimensions
  defp do_decide_custom_prop_table(%{dimensions: dimensions} = query) do
    if dimensions == [] or
         (length(dimensions) == 1 and hd(dimensions) in @queriable_custom_prop_dimensions) do
      custom_prop_filters =
        dimensions_used_in_filters(query.filters)
        |> Enum.filter(&(&1 in @imported_custom_props))
        |> Enum.uniq()

      case custom_prop_filters do
        [custom_prop_filter] ->
          do_decide_custom_prop_table(query, custom_prop_filter)

        _ ->
          []
      end
    else
      []
    end
  end

  defp do_decide_custom_prop_table(query, property) do
    has_required_name_filter? =
      query.filters
      |> Enum.flat_map(fn
        [:is, "event:name", names | _rest] -> names
        [:is, "event:goal", names | _rest] -> names
        _ -> []
      end)
      |> Enum.any?(&(&1 in Plausible.Goals.SystemGoals.special_goals_for(property)))

    has_unsupported_filters? =
      query.filters
      |> dimensions_used_in_filters()
      |> Enum.any?(&(&1 not in [property, "event:name", "event:goal"]))

    if has_required_name_filter? and not has_unsupported_filters? do
      ["imported_custom_events"]
    else
      []
    end
  end

  defp do_decide_tables(%Query{filters: [], dimensions: []}), do: ["imported_visitors"]

  defp do_decide_tables(%Query{filters: [], dimensions: ["event:goal"]}) do
    ["imported_pages", "imported_custom_events"]
  end

  defp do_decide_tables(%Query{dimensions: ["event:goal"]} = query) do
    filter_dimensions = dimensions_used_in_filters(query.filters)

    filter_goals = query.preloaded_goals.matching_toplevel_filters

    any_event_goals? = Enum.any?(filter_goals, fn goal -> Plausible.Goal.type(goal) == :event end)

    any_pageview_goals? =
      Enum.any?(filter_goals, fn goal -> Plausible.Goal.type(goal) == :page end)

    any_event_name_filters? = "event:name" in filter_dimensions or any_event_goals?
    any_page_filters? = "event:page" in filter_dimensions or any_pageview_goals?

    any_other_filters? =
      Enum.any?(filter_dimensions, &(&1 not in ["event:page", "event:name", "event:goal"]))

    cond do
      any_other_filters? -> []
      any_event_name_filters? and not any_page_filters? -> ["imported_custom_events"]
      any_page_filters? and not any_event_name_filters? -> ["imported_pages"]
      true -> []
    end
  end

  defp do_decide_tables(query) do
    table_candidates =
      dimensions_used_in_filters(query.filters)
      |> Enum.concat(query.dimensions)
      |> Enum.reject(&(&1 in @queriable_time_dimensions or &1 == "event:goal"))
      |> Enum.flat_map(fn
        "visit:screen" -> ["visit:device"]
        dimension -> [dimension]
      end)
      |> Enum.map(&@property_to_table_mappings[&1])

    filter_goal_table_candidates =
      query.preloaded_goals.matching_toplevel_filters
      |> Enum.map(&Plausible.Goal.type/1)
      |> Enum.map(fn
        :event -> "imported_custom_events"
        :page -> "imported_pages"
        :scroll -> nil
      end)

    case Enum.uniq(table_candidates ++ filter_goal_table_candidates) do
      [] -> ["imported_visitors"]
      [nil] -> []
      [candidate] -> [candidate]
      _ -> []
    end
  end
end
```

## File: `lib/plausible/stats/imported/imported.ex`
```
defmodule Plausible.Stats.Imported do
  use Plausible.ClickhouseRepo
  use Plausible.Stats.SQL.Fragments

  import Ecto.Query
  import Plausible.Stats.Imported.SQL.Expression

  alias Plausible.Stats.Imported
  alias Plausible.Stats.Query
  alias Plausible.Stats.SQL.QueryBuilder

  @property_to_table_mappings Imported.Base.property_to_table_mappings()

  @doc """
  Returns a boolean indicating whether the combination of filters and
  breakdown property is possible to query from the imported tables.

  Usually, when no filters are used, the imported schema supports the
  query. There is one exception though - breakdown by a custom property.
  We are currently importing only two custom properties - `url` and `path`.
  Both these properties can only be used with their special goal filter
  (see Plausible.Goals.SystemGoals).
  """
  def schema_supports_query?(query) do
    length(Imported.Base.decide_tables(query)) > 0
  end

  def merge_imported_country_suggestions(native_q, _site, %Plausible.Stats.Query{
        include_imported: false
      }) do
    native_q
  end

  def merge_imported_country_suggestions(native_q, site, query) do
    supports_filter_set? =
      Enum.all?(query.filters, fn filter ->
        [_, filtered_prop | _] = filter
        @property_to_table_mappings[filtered_prop] == "imported_locations"
      end)

    if supports_filter_set? do
      native_q =
        native_q
        |> exclude(:order_by)
        |> exclude(:select)
        |> select([e], %{country_code: e.country_code, count: fragment("count(*)")})

      imported_q =
        from i in Imported.Base.query_imported("imported_locations", site, query),
          group_by: i.country,
          select_merge: %{country_code: i.country, count: fragment("sum(?)", i.pageviews)}

      from(s in subquery(native_q),
        full_join: i in subquery(imported_q),
        on: s.country_code == i.country_code,
        select:
          fragment("if(not empty(?), ?, ?)", s.country_code, s.country_code, i.country_code),
        order_by: [desc: fragment("? + ?", s.count, i.count)]
      )
    else
      native_q
    end
  end

  def merge_imported_region_suggestions(native_q, _site, %Plausible.Stats.Query{
        include_imported: false
      }) do
    native_q
  end

  def merge_imported_region_suggestions(native_q, site, query) do
    supports_filter_set? =
      Enum.all?(query.filters, fn filter ->
        [_, filtered_prop | _] = filter
        @property_to_table_mappings[filtered_prop] == "imported_locations"
      end)

    if supports_filter_set? do
      native_q =
        native_q
        |> exclude(:order_by)
        |> exclude(:select)
        |> select([e], %{region_code: e.subdivision1_code, count: fragment("count(*)")})

      imported_q =
        from i in Imported.Base.query_imported("imported_locations", site, query),
          where: i.region != "",
          group_by: i.region,
          select_merge: %{region_code: i.region, count: fragment("sum(?)", i.pageviews)}

      from(s in subquery(native_q),
        full_join: i in subquery(imported_q),
        on: s.region_code == i.region_code,
        select: fragment("if(not empty(?), ?, ?)", s.region_code, s.region_code, i.region_code),
        order_by: [desc: fragment("? + ?", s.count, i.count)]
      )
    else
      native_q
    end
  end

  def merge_imported_city_suggestions(native_q, _site, %Plausible.Stats.Query{
        include_imported: false
      }) do
    native_q
  end

  def merge_imported_city_suggestions(native_q, site, query) do
    supports_filter_set? =
      Enum.all?(query.filters, fn filter ->
        [_, filtered_prop | _] = filter
        @property_to_table_mappings[filtered_prop] == "imported_locations"
      end)

    if supports_filter_set? do
      native_q =
        native_q
        |> exclude(:order_by)
        |> exclude(:select)
        |> select([e], %{city_id: e.city_geoname_id, count: fragment("count(*)")})

      imported_q =
        from i in Imported.Base.query_imported("imported_locations", site, query),
          where: i.city != 0,
          group_by: i.city,
          select_merge: %{city_id: i.city, count: fragment("sum(?)", i.pageviews)}

      from(s in subquery(native_q),
        full_join: i in subquery(imported_q),
        on: s.city_id == i.city_id,
        select: fragment("if(? > 0, ?, ?)", s.city_id, s.city_id, i.city_id),
        order_by: [desc: fragment("? + ?", s.count, i.count)]
      )
    else
      native_q
    end
  end

  def merge_imported_filter_suggestions(
        native_q,
        _site,
        %Plausible.Stats.Query{include_imported: false},
        _filter_name,
        _filter_search
      ) do
    native_q
  end

  def merge_imported_filter_suggestions(
        native_q,
        site,
        query,
        filter_name,
        filter_query
      ) do
    {table, db_field} = expand_suggestions_field(filter_name)

    supports_filter_set? =
      Enum.all?(query.filters, fn filter ->
        [_, filtered_prop | _] = filter
        @property_to_table_mappings[filtered_prop] == table
      end)

    if supports_filter_set? do
      native_q =
        native_q
        |> exclude(:order_by)
        |> exclude(:select)
        |> select([e], %{name: field(e, ^filter_name), count: fragment("count(*)")})

      imported_q =
        from i in Imported.Base.query_imported(table, site, query),
          where: fragment("? ilike ?", field(i, ^db_field), ^filter_query),
          group_by: field(i, ^db_field),
          select_merge: %{name: field(i, ^db_field), count: fragment("sum(?)", i.pageviews)}

      from(s in subquery(native_q),
        full_join: i in subquery(imported_q),
        on: s.name == i.name,
        select: fragment("if(not empty(?), ?, ?)", s.name, s.name, i.name),
        order_by: [desc: fragment("? + ?", s.count, i.count)],
        limit: 25
      )
    else
      native_q
    end
  end

  @filter_suggestions_mapping %{
    referrer_source: :source,
    acquisition_channel: :channel,
    screen_size: :device,
    pathname: :page
  }

  defp expand_suggestions_field(filter_name) do
    db_field = Map.get(@filter_suggestions_mapping, filter_name, filter_name)

    property =
      case db_field do
        :operating_system -> :os
        :operating_system_version -> :os_version
        other -> other
      end

    table_by_visit = Map.get(@property_to_table_mappings, "visit:#{property}")
    table_by_event = Map.get(@property_to_table_mappings, "event:#{property}")
    table = table_by_visit || table_by_event

    {table, db_field}
  end

  def merge_imported(q, _, %Query{include_imported: false}), do: q

  def merge_imported(q, site, %Query{dimensions: []} = query) do
    q = paginate_optimization(q, query)

    imported_q =
      site
      |> Imported.Base.query_imported(query)
      |> select_imported_metrics(query)
      |> paginate_optimization(query)

    from(
      s in subquery(q),
      cross_join: i in subquery(imported_q),
      select: %{}
    )
    |> select_joined_metrics(query)
  end

  def merge_imported(q, site, %Query{dimensions: ["event:goal"]} = query) do
    goal_join_data = Plausible.Stats.Goals.goal_join_data(query)

    Imported.Base.decide_tables(query)
    |> Enum.map(fn
      "imported_custom_events" ->
        Imported.Base.query_imported("imported_custom_events", site, query)
        |> where([i], i.visitors > 0)
        |> select_merge_as([i], %{
          dim0:
            fragment(
              "indexOf(?, ?)",
              type(^goal_join_data.event_names_imports, {:array, :string}),
              i.name
            )
        })
        |> select_imported_metrics(query)
        |> group_by([], selected_as(:dim0))
        |> where([], selected_as(:dim0) != 0)

      "imported_pages" ->
        Imported.Base.query_imported("imported_pages", site, query)
        |> where([i], i.visitors > 0)
        |> where(
          [i],
          fragment(
            """
            notEmpty(
              arrayFilter(
                goal_idx -> ?[goal_idx] = 'page' AND match(?, ?[goal_idx]),
                ?
              ) as indices
            )
            """,
            type(^goal_join_data.types, {:array, :string}),
            i.page,
            type(^goal_join_data.page_regexes, {:array, :string}),
            type(^goal_join_data.indices, {:array, :integer})
          )
        )
        |> join(:inner, [_i], index in fragment("indices"), hints: "ARRAY", on: true)
        |> group_by([_i, index], index)
        |> select_merge_as([_i, index], %{
          dim0: fragment("CAST(?, 'UInt64')", index)
        })
        |> select_imported_metrics(query)
    end)
    |> Enum.reduce(q, fn imports_q, q ->
      naive_dimension_join(q, imports_q, query)
    end)
  end

  def merge_imported(q, site, query) do
    if schema_supports_query?(query) do
      q = paginate_optimization(q, query)

      imported_q =
        site
        |> Imported.Base.query_imported(query)
        |> where([i], i.visitors > 0)
        |> group_imported_by(query)
        |> select_imported_metrics(query)
        |> paginate_optimization(query)

      from(s in subquery(q),
        full_join: i in subquery(imported_q),
        on: ^QueryBuilder.build_group_by_join(query),
        select: %{}
      )
      |> select_joined_dimensions(query)
      |> select_joined_metrics(query)
    else
      q
    end
  end

  def total_imported_visitors(site, query) do
    site
    |> Imported.Base.query_imported(query)
    |> select_merge([i], %{total_visitors: fragment("sum(?)", i.visitors)})
  end

  defp naive_dimension_join(q1, q2, query) do
    from(a in subquery(q1),
      full_join: b in subquery(q2),
      on: a.dim0 == b.dim0,
      select: %{}
    )
    |> select_merge_as([a, b], %{
      dim0: fragment("if(? != 0, ?, ?)", a.dim0, a.dim0, b.dim0)
    })
    |> select_joined_metrics(query)
  end

  # Optimization for cases when grouping by a very high cardinality column.
  #
  # Instead of joining all rows from main and imported tables, we limit the number of rows
  # in both tables to LIMIT N * 100.
  #
  # This speeds up cases where a site has millions of unique pathnames, reducing the time spent
  # JOINing tables by an order of magnitude.
  #
  # Note that this optimization is lossy as the true top N values can arise from outside the top C
  # items of either subquery. In practice though, this will give plausible results.
  #
  # We only apply this optimization in cases where we can deterministically ORDER BY. This covers
  # opening Plausible dashboard but not more complicated use-cases.
  defp paginate_optimization(q, query) do
    if is_map(query.pagination) and can_order_by?(query) do
      n = (query.pagination.limit + query.pagination.offset) * 100

      q
      |> QueryBuilder.build_order_by(query)
      |> limit(^n)
    else
      q
    end
  end

  @cannot_optimize_metrics [
    :exit_rate,
    :scroll_depth,
    :percentage,
    :conversion_rate,
    :group_conversion_rate,
    :time_on_page
  ]

  defp can_order_by?(query) do
    Enum.all?(query.order_by, fn
      {metric, _direction} when metric in @cannot_optimize_metrics -> false
      {metric, _direction} when is_atom(metric) -> metric in query.metrics
      _ -> true
    end)
  end
end
```

## File: `lib/plausible/stats/imported/sql/expression.ex`
```
defmodule Plausible.Stats.Imported.SQL.Expression do
  @moduledoc """
  This module is responsible for generating SQL/Ecto expressions
  for dimensions, filters and metrics used in import table queries
  """

  use Plausible.Stats.SQL.Fragments

  import Plausible.Stats.Util, only: [shortname: 2]
  import Ecto.Query

  alias Plausible.Stats.Query

  @no_ref "Direct / None"
  @not_set "(not set)"
  @none "(none)"

  def select_imported_metrics(
        %Ecto.Query{from: %Ecto.Query.FromExpr{source: {table, _}}} = q,
        query
      ) do
    select_clause =
      query.metrics
      |> Enum.map(&select_metric(&1, table, query))
      |> Enum.reduce(%{}, &Map.merge/2)

    q
    |> select_merge(q, ^select_clause)
    |> filter_pageviews(query.metrics, table)
  end

  defp filter_pageviews(q, metrics, table) do
    should_filter = :pageviews in metrics or :views_per_visit in metrics

    case {should_filter, table} do
      {_, "imported_custom_events"} -> q
      {true, _} -> q |> where([i], i.pageviews > 0)
      {false, _} -> q
    end
  end

  defp select_metric(:visitors, _table, _query) do
    wrap_alias([i], %{visitors: sum(i.visitors)})
  end

  defp select_metric(:events, "imported_custom_events", _query) do
    wrap_alias([i], %{events: sum(i.events)})
  end

  defp select_metric(:events, _table, _query) do
    wrap_alias([i], %{events: sum(i.pageviews)})
  end

  defp select_metric(:visits, "imported_exit_pages", _query) do
    wrap_alias([i], %{visits: sum(i.exits)})
  end

  defp select_metric(:visits, "imported_entry_pages", _query) do
    wrap_alias([i], %{visits: sum(i.entrances)})
  end

  defp select_metric(:visits, _table, _query) do
    wrap_alias([i], %{visits: sum(i.visits)})
  end

  defp select_metric(:pageviews, "imported_custom_events", _query) do
    wrap_alias([i], %{pageviews: 0})
  end

  defp select_metric(:pageviews, _table, _query) do
    wrap_alias([i], %{pageviews: sum(i.pageviews)})
  end

  defp select_metric(:bounce_rate, "imported_pages", _query) do
    wrap_alias([i], %{bounces: 0, __internal_visits: 0})
  end

  defp select_metric(:bounce_rate, "imported_exit_pages", _query) do
    wrap_alias([i], %{bounces: sum(i.bounces), __internal_visits: sum(i.exits)})
  end

  defp select_metric(:bounce_rate, "imported_entry_pages", _query) do
    wrap_alias([i], %{bounces: sum(i.bounces), __internal_visits: sum(i.entrances)})
  end

  defp select_metric(:bounce_rate, _table, _query) do
    wrap_alias([i], %{bounces: sum(i.bounces), __internal_visits: sum(i.visits)})
  end

  defp select_metric(:exit_rate, "imported_exit_pages", _query) do
    wrap_alias([i], %{__internal_visits: sum(i.exits)})
  end

  defp select_metric(:visit_duration, "imported_pages", _query) do
    wrap_alias([i], %{visit_duration: 0})
  end

  defp select_metric(:visit_duration, "imported_exit_pages", _query) do
    wrap_alias([i], %{visit_duration: sum(i.visit_duration), __internal_visits: sum(i.exits)})
  end

  defp select_metric(:visit_duration, "imported_entry_pages", _query) do
    wrap_alias([i], %{visit_duration: sum(i.visit_duration), __internal_visits: sum(i.entrances)})
  end

  defp select_metric(:visit_duration, _table, _query) do
    wrap_alias([i], %{visit_duration: sum(i.visit_duration), __internal_visits: sum(i.visits)})
  end

  defp select_metric(:views_per_visit, "imported_exit_pages", _query) do
    wrap_alias([i], %{pageviews: sum(i.pageviews), __internal_visits: sum(i.exits)})
  end

  defp select_metric(:views_per_visit, "imported_entry_pages", _query) do
    wrap_alias([i], %{pageviews: sum(i.pageviews), __internal_visits: sum(i.entrances)})
  end

  defp select_metric(:views_per_visit, _table, _query) do
    wrap_alias([i], %{pageviews: sum(i.pageviews), __internal_visits: sum(i.visits)})
  end

  defp select_metric(:scroll_depth, "imported_pages", _query) do
    wrap_alias([i], %{
      total_scroll_depth: sum(i.total_scroll_depth),
      total_scroll_depth_visits: sum(i.total_scroll_depth_visits)
    })
  end

  defp select_metric(:time_on_page, "imported_pages", query) do
    case query.time_on_page_data do
      %{include_new_metric: false} ->
        wrap_alias([i], %{
          total_time_on_page: 0,
          total_time_on_page_visits: 0
        })

      %{include_new_metric: true, cutoff: nil} ->
        wrap_alias([i], %{
          total_time_on_page: sum(i.total_time_on_page),
          total_time_on_page_visits: sum(i.total_time_on_page_visits)
        })

      %{include_new_metric: true, cutoff: cutoff} ->
        cutoff_date = cutoff |> DateTime.shift_zone!(query.timezone) |> DateTime.to_date()

        wrap_alias([i], %{
          total_time_on_page:
            fragment("sumIf(?, ? >= ?)", i.total_time_on_page, i.date, ^cutoff_date),
          total_time_on_page_visits:
            fragment("sumIf(?, ? >= ?)", i.total_time_on_page_visits, i.date, ^cutoff_date)
        })
    end
  end

  defp select_metric(_metric, _table, _query), do: %{}

  def group_imported_by(q, query) do
    Enum.reduce(query.dimensions, q, fn dimension, q ->
      q
      |> select_group_fields(dimension, shortname(query, dimension), query)
      |> filter_group_values(dimension)
      |> group_by([], selected_as(^shortname(query, dimension)))
    end)
  end

  defp select_group_fields(q, dimension, key, _query)
       when dimension in ["visit:source", "visit:referrer"] do
    select_merge_as(q, [i], %{
      key =>
        fragment(
          "if(empty(?), ?, ?)",
          field(i, ^dim(dimension)),
          @no_ref,
          field(i, ^dim(dimension))
        )
    })
  end

  defp select_group_fields(q, "event:page", key, _query) do
    select_merge_as(q, [i], %{key => i.page})
  end

  defp select_group_fields(q, dimension, key, _query)
       when dimension in ["visit:device", "visit:browser", "visit:channel"] do
    select_merge_as(q, [i], %{
      key =>
        fragment(
          "if(empty(?), ?, ?)",
          field(i, ^dim(dimension)),
          @not_set,
          field(i, ^dim(dimension))
        )
    })
  end

  defp select_group_fields(q, "visit:browser_version", key, _query) do
    select_merge_as(q, [i], %{
      key => fragment("if(empty(?), ?, ?)", i.browser_version, @not_set, i.browser_version)
    })
  end

  defp select_group_fields(q, "visit:os", key, _query) do
    select_merge_as(q, [i], %{
      key => fragment("if(empty(?), ?, ?)", i.operating_system, @not_set, i.operating_system)
    })
  end

  defp select_group_fields(q, "visit:os_version", key, _query) do
    select_merge_as(q, [i], %{
      key =>
        fragment(
          "if(empty(?), ?, ?)",
          i.operating_system_version,
          @not_set,
          i.operating_system_version
        )
    })
  end

  defp select_group_fields(q, "event:props:url", key, _query) do
    select_merge_as(q, [i], %{
      key => fragment("if(not empty(?), ?, ?)", i.link_url, i.link_url, @none)
    })
  end

  defp select_group_fields(q, "event:props:path", key, _query) do
    select_merge_as(q, [i], %{
      key => fragment("if(not empty(?), ?, ?)", i.path, i.path, @none)
    })
  end

  defp select_group_fields(q, "time:month", key, _query) do
    select_merge_as(q, [i], %{key => fragment("toStartOfMonth(?)", i.date)})
  end

  defp select_group_fields(q, dimension, key, _query)
       when dimension in ["time:hour", "time:day"] do
    select_merge_as(q, [i], %{key => i.date})
  end

  defp select_group_fields(q, "time:week", key, query) do
    date_range = Query.date_range(query)

    select_merge_as(q, [i], %{
      key => weekstart_not_before(i.date, ^date_range.first)
    })
  end

  defp select_group_fields(q, dimension, key, _query) do
    select_merge_as(q, [i], %{key => field(i, ^dim(dimension))})
  end

  @utm_dimensions [
    "visit:utm_source",
    "visit:utm_medium",
    "visit:utm_campaign",
    "visit:utm_term",
    "visit:utm_content"
  ]
  defp filter_group_values(q, dimension) when dimension in @utm_dimensions do
    dim = Plausible.Stats.Filters.without_prefix(dimension)

    where(q, [i], fragment("not empty(?)", field(i, ^dim)))
  end

  defp filter_group_values(q, "visit:country"), do: where(q, [i], i.country != "ZZ")
  defp filter_group_values(q, "visit:region"), do: where(q, [i], i.region != "")
  defp filter_group_values(q, "visit:city"), do: where(q, [i], i.city != 0 and not is_nil(i.city))

  defp filter_group_values(q, "visit:country_name"), do: where(q, [i], i.country_name != "ZZ")
  defp filter_group_values(q, "visit:region_name"), do: where(q, [i], i.region_name != "")
  defp filter_group_values(q, "visit:city_name"), do: where(q, [i], i.city_name != "")

  defp filter_group_values(q, _dimension), do: q

  def select_joined_dimensions(q, query) do
    Enum.reduce(query.dimensions, q, fn dimension, q ->
      select_joined_dimension(q, dimension, shortname(query, dimension))
    end)
  end

  defp select_joined_dimension(q, "visit:city", key) do
    select_merge_as(q, [s, i], %{
      key => fragment("greatest(?,?)", field(i, ^key), field(s, ^key))
    })
  end

  defp select_joined_dimension(q, "time:" <> _, key) do
    select_merge_as(q, [s, i], %{
      key => fragment("greatest(?, ?)", field(i, ^key), field(s, ^key))
    })
  end

  defp select_joined_dimension(q, _dimension, key) do
    select_merge_as(q, [s, i], %{
      key => fragment("if(empty(?), ?, ?)", field(s, ^key), field(i, ^key), field(s, ^key))
    })
  end

  def select_joined_metrics(q, query) do
    select_metrics =
      query.metrics
      |> Enum.map(&joined_metric(&1, query))
      |> Enum.reduce(%{}, &Map.merge/2)

    select_merge(q, ^select_metrics)
  end

  # NOTE: Reverse-engineering the native data bounces and total visit
  # durations to combine with imported data is inefficient. Instead both
  # queries should fetch bounces/total_visit_duration and visits and be
  # used as subqueries to a main query that then find the bounce rate/avg
  # visit_duration.

  defp joined_metric(:visits, _query) do
    wrap_alias([s, i], %{visits: s.visits + i.visits})
  end

  defp joined_metric(:visitors, _query) do
    wrap_alias([s, i], %{visitors: s.visitors + i.visitors})
  end

  defp joined_metric(:events, _query) do
    wrap_alias([s, i], %{events: s.events + i.events})
  end

  defp joined_metric(:pageviews, _query) do
    wrap_alias([s, i], %{pageviews: s.pageviews + i.pageviews})
  end

  defp joined_metric(:views_per_visit, _query) do
    wrap_alias([s, i], %{
      views_per_visit:
        fragment(
          "if(? + ? > 0, round((? + ? * ?) / (? + ?), 2), 0)",
          s.__internal_visits,
          i.__internal_visits,
          i.pageviews,
          s.views_per_visit,
          s.__internal_visits,
          i.__internal_visits,
          s.__internal_visits
        )
    })
  end

  defp joined_metric(:bounce_rate, _query) do
    wrap_alias([s, i], %{
      bounce_rate:
        fragment(
          "if(? + ? > 0, round(100 * (? + (? * ? / 100)) / (? + ?)), 0)",
          s.__internal_visits,
          i.__internal_visits,
          i.bounces,
          s.bounce_rate,
          s.__internal_visits,
          i.__internal_visits,
          s.__internal_visits
        )
    })
  end

  defp joined_metric(:visit_duration, _query) do
    wrap_alias([s, i], %{
      visit_duration:
        fragment(
          """
          if(
            ? + ? > 0,
            round((? + ? * ?) / (? + ?), 0),
            0
          )
          """,
          s.__internal_visits,
          i.__internal_visits,
          i.visit_duration,
          s.visit_duration,
          s.__internal_visits,
          s.__internal_visits,
          i.__internal_visits
        )
    })
  end

  # The final `scroll_depth` gets selected at a later querybuilding step
  # (in `Plausible.Stats.SQL.SpecialMetrics.add/3`). But in order to avoid
  # having to join with imported data there again, we select the required
  # information from imported data here already.
  defp joined_metric(:scroll_depth, _query) do
    wrap_alias([s, i], %{
      __imported_total_scroll_depth: i.total_scroll_depth,
      __imported_total_scroll_depth_visits: i.total_scroll_depth_visits
    })
  end

  defp joined_metric(:time_on_page, query) do
    wrap_alias([s, i], %{
      __internal_total_time_on_page: s.__internal_total_time_on_page + i.total_time_on_page,
      __internal_total_time_on_page_visits:
        s.__internal_total_time_on_page_visits + i.total_time_on_page_visits
    })
    |> Map.merge(time_on_page_metric(query))
  end

  defp joined_metric(:exit_rate, _query) do
    wrap_alias([s, i], %{
      __internal_visits: s.__internal_visits + i.__internal_visits
    })
  end

  # Ignored as it's calculated separately
  defp joined_metric(metric, _query)
       when metric in [:conversion_rate, :group_conversion_rate, :percentage] do
    %{}
  end

  defp joined_metric(metric, _query) do
    wrap_alias([s, i], %{metric => field(s, ^metric)})
  end

  defp dim(dimension), do: Plausible.Stats.Filters.without_prefix(dimension)

  defp time_on_page_metric(query) do
    if query.time_on_page_data.include_legacy_metric do
      %{}
    else
      wrap_alias([], %{
        time_on_page:
          time_on_page(
            selected_as(:__internal_total_time_on_page),
            selected_as(:__internal_total_time_on_page_visits)
          )
      })
    end
  end
end
```

## File: `lib/plausible/stats/imported/sql/where_builder.ex`
```
defmodule Plausible.Stats.Imported.SQL.WhereBuilder do
  @moduledoc """
  A module for building an ecto where clause of a query out of a query for Imported tables.
  """

  import Ecto.Query

  alias Plausible.Stats.Query

  @db_field_mappings %{
    referrer_source: :source,
    screen_size: :device,
    screen: :device,
    os: :operating_system,
    os_version: :operating_system_version,
    country_code: :country,
    subdivision1_code: :region,
    city_geoname_id: :city,
    entry_page_hostname: :hostname,
    pathname: :page,
    url: :link_url
  }

  def build(%Query{filters: []}), do: true

  def build(query) do
    query.filters
    |> Enum.map(&add_filter(query, &1))
    |> Enum.reduce(fn condition, acc -> dynamic([], ^acc and ^condition) end)
  end

  defp add_filter(query, [:ignore_in_totals_query, filter]) do
    add_filter(query, filter)
  end

  defp add_filter(query, [:not, filter]) do
    dynamic([i], not (^add_filter(query, filter)))
  end

  defp add_filter(query, [:and, filters]) do
    filters
    |> Enum.map(&add_filter(query, &1))
    |> Enum.reduce(fn condition, acc -> dynamic([], ^acc and ^condition) end)
  end

  defp add_filter(query, [:or, filters]) do
    filters
    |> Enum.map(&add_filter(query, &1))
    |> Enum.reduce(fn condition, acc -> dynamic([], ^acc or ^condition) end)
  end

  defp add_filter(query, [_operation, dimension, _clauses | _rest] = filter) do
    db_field = Plausible.Stats.Filters.without_prefix(dimension)

    if db_field == :goal do
      Plausible.Stats.Goals.add_filter(query, filter, imported?: true)
    else
      mapped_db_field = Map.get(@db_field_mappings, db_field, db_field)

      Plausible.Stats.SQL.WhereBuilder.build_condition(mapped_db_field, filter)
    end
  end
end
```

## File: `lib/plausible/stats/interval.ex`
```
defmodule Plausible.Stats.Interval do
  @moduledoc """
  Collection of functions to work with intervals.

  The interval of a query defines the granularity of the data. You can think of
  it as a `GROUP BY` clause. Possible values are `minute`, `hour`, `day`,
  `week`, and `month`.
  """

  alias Plausible.Stats.DateTimeRange

  @type t() :: String.t()
  @type(opt() :: {:site, Plausible.Site.t()} | {:from, Date.t()}, {:to, Date.t()})
  @type opts :: list(opt())
  @typep period() :: String.t()

  @intervals ~w(minute hour day week month)
  @spec list() :: [t()]
  def list, do: @intervals

  @spec valid?(term()) :: boolean()
  def valid?(interval) do
    interval in @intervals
  end

  @spec default_for_period(period()) :: t()
  @doc """
  Returns the suggested interval for the given time period.
  """
  def default_for_period(period) do
    case period do
      period when period in ["realtime", "30m"] -> "minute"
      "day" -> "hour"
      period when period in ["custom", "7d", "28d", "30d", "91d", "month"] -> "day"
      period when period in ["6mo", "12mo", "year"] -> "month"
    end
  end

  @spec default_for_date_range(DateTimeRange.t()) :: t()
  @doc """
  Returns the suggested interval for the given `DateTimeRange` struct.
  """
  def default_for_date_range(%DateTimeRange{first: first, last: last}) do
    cond do
      Timex.diff(last, first, :months) > 0 ->
        "month"

      DateTime.diff(last, first, :day) > 0 ->
        "day"

      true ->
        "hour"
    end
  end

  @valid_by_period %{
    "realtime" => ["minute"],
    "day" => ["minute", "hour"],
    "7d" => ["hour", "day"],
    "28d" => ["day", "week"],
    "30d" => ["day", "week"],
    "91d" => ["day", "week", "month"],
    "month" => ["day", "week"],
    "6mo" => ["day", "week", "month"],
    "12mo" => ["day", "week", "month"],
    "year" => ["day", "week", "month"],
    "custom" => ["day", "week", "month"],
    "all" => ["day", "week", "month"]
  }

  @spec valid_by_period(opts()) :: map()
  def valid_by_period(opts \\ []) do
    site = Keyword.fetch!(opts, :site)

    table =
      with %Date{} = from <- Keyword.get(opts, :from),
           %Date{} = to <- Keyword.get(opts, :to),
           true <- abs(Timex.diff(from, to, :months)) > 12 do
        Map.replace(@valid_by_period, "custom", ["week", "month"])
      else
        _ ->
          @valid_by_period
      end

    with %Date{} = stats_start <- Plausible.Sites.stats_start_date(site),
         true <- abs(Timex.diff(Date.utc_today(), stats_start, :months)) > 12 do
      Map.replace(table, "all", ["week", "month"])
    else
      _ ->
        table
    end
  end

  @spec valid_for_period?(period(), t(), opts()) :: boolean()
  @doc """
  Returns whether the given interval is valid for a time period.

  Intervals longer than periods are not supported, e.g. current month stats with
  a month interval, or today stats with a week interval.

  There are two dynamic states:
  * `custom` period is only applicable with `month` or `week` intervals,
     if the `opts[:from]` and `opts[:to]` range difference exceeds 12 months
  * `all` period's interval options depend on particular site's `stats_start_date`
    - daily interval is excluded if the all-time range exceeds 12 months
  """
  def valid_for_period?(period, interval, opts \\ []) do
    interval in Map.get(valid_by_period(opts), period, [])
  end
end
```

## File: `lib/plausible/stats/json-schema/utils.ex`
```
defmodule Plausible.Stats.JSONSchema.Utils do
  @moduledoc """
  Module for traversing and modifying JSON schemas.
  """

  @type json :: map() | list() | String.t() | number() | boolean() | nil
  @type transform_fun :: (json() -> json() | :remove)

  @spec traverse(map(), transform_fun()) :: map() | :remove
  def traverse(json, fun) when is_map(json) do
    result =
      Enum.reduce(json, %{}, fn {k, v}, acc ->
        case traverse(v, fun) do
          :remove -> acc
          transformed_v -> Map.put(acc, k, transformed_v)
        end
      end)

    case result do
      map when map_size(map) == 0 -> fun.(%{})
      map -> fun.(map)
    end
  end

  @spec traverse(list(), transform_fun()) :: list() | :remove
  def traverse(json, fun) when is_list(json) do
    result =
      Enum.reduce(json, [], fn v, acc ->
        case traverse(v, fun) do
          :remove -> acc
          transformed_v -> [transformed_v | acc]
        end
      end)
      |> Enum.reverse()

    case result do
      [] -> fun.([])
      list -> fun.(list)
    end
  end

  @spec traverse(String.t() | number() | boolean() | nil, transform_fun()) :: json() | :remove
  def traverse(value, fun), do: fun.(value)
end
```

## File: `lib/plausible/stats/json_schema.ex`
```
defmodule Plausible.Stats.JSONSchema do
  @moduledoc """
  Module for validating query parameters against JSON schema.

  Note that `internal` queries expose some metrics, filter types and other features not
  available on the public API.
  """
  use Plausible
  alias Plausible.Stats.JSONSchema.Utils

  @external_resource "priv/json-schemas/query-api-schema.json"

  @raw_internal_schema Application.app_dir(:plausible, "priv/json-schemas/query-api-schema.json")
                       |> File.read!()
                       |> Jason.decode!()
  @raw_public_schema Utils.traverse(@raw_internal_schema, fn
                       %{"$comment" => "only :internal"} ->
                         :remove

                       %{"$comment" => "only :ee"} = value ->
                         if(ee?(), do: Map.delete(value, "$comment"), else: :remove)

                       value ->
                         value
                     end)
  @internal_query_schema ExJsonSchema.Schema.resolve(@raw_internal_schema)
  @public_query_schema ExJsonSchema.Schema.resolve(@raw_public_schema)

  def validate(schema_type, params) do
    case ExJsonSchema.Validator.validate(schema(schema_type), params) do
      :ok -> :ok
      {:error, errors} -> {:error, format_errors(errors, params)}
    end
  end

  def raw_public_schema(), do: @raw_public_schema

  defp schema(:public), do: @public_query_schema
  defp schema(:internal), do: @internal_query_schema

  defp format_errors(errors, params) do
    errors
    |> Enum.map_join("\n", fn {error, path} ->
      value = JSONPointer.get!(params, path)

      "#{path}: #{reword(path, error, value)}"
    end)
  end

  @no_matches "Expected exactly one of the schemata to match, but none of them did."

  defp reword("#/dimensions/" <> _, @no_matches, value), do: "Invalid dimension #{i(value)}"
  defp reword("#/metrics/" <> _, @no_matches, value), do: "Invalid metric #{i(value)}"
  defp reword("#/filters/" <> _, @no_matches, value), do: "Invalid filter #{i(value)}"
  defp reword("#/date_range", @no_matches, value), do: "Invalid date range #{i(value)}"

  defp reword("#/order_by/" <> _, @no_matches, value) do
    "Invalid value in order_by #{i(value)}"
  end

  defp reword(_path, error, _value), do: error

  defp i(value), do: inspect(value, charlists: :as_lists)
end
```

## File: `lib/plausible/stats/legacy/legacy_dimensions.ex`
```
defmodule Plausible.Stats.Legacy.Dimensions do
  @moduledoc """
  Deprecated module. See QueryParser for list of valid dimensions
  """
  @event_props ["event:page", "event:name", "event:goal", "event:hostname"]
  @session_props [
    "visit:source",
    "visit:channel",
    "visit:country",
    "visit:region",
    "visit:city",
    "visit:entry_page",
    "visit:exit_page",
    "visit:referrer",
    "visit:utm_medium",
    "visit:utm_source",
    "visit:utm_campaign",
    "visit:utm_content",
    "visit:utm_term",
    "visit:device",
    "visit:os",
    "visit:os_version",
    "visit:browser",
    "visit:browser_version"
  ]

  def valid?(prop) when prop in @event_props, do: true
  def valid?(prop) when prop in @session_props, do: true
  def valid?("event:props:" <> prop) when byte_size(prop) > 0, do: true
  def valid?(_), do: false
end
```

## File: `lib/plausible/stats/legacy/legacy_query_builder.ex`
```
defmodule Plausible.Stats.Legacy.QueryBuilder do
  @moduledoc """
  Module used to parse URL search params to a valid Query, used to power the API for the dashboard.
  @deprecated
  """

  use Plausible

  alias Plausible.Stats.{Filters, Interval, Query, DateTimeRange}

  def from(site, params, debug_metadata, now \\ nil) do
    now = now || DateTime.utc_now(:second)

    query =
      Query
      |> struct!(
        now: now,
        debug_metadata: debug_metadata,
        site_id: site.id,
        site_native_stats_start_at: site.native_stats_start_at
      )
      |> put_period(site, params)
      |> put_timezone(site)
      |> put_dimensions(params)
      |> put_interval(params)
      |> put_parsed_filters(params)
      |> resolve_segments(site)
      |> preload_goals_and_revenue(site)
      |> put_order_by(params)
      |> put_include(site, params)
      |> Query.put_comparison_utc_time_range()
      |> Query.put_imported_opts(site)
      |> Query.set_time_on_page_data(site)

    on_ee do
      query = Plausible.Stats.Sampling.put_threshold(query, site, params)
    end

    query
  end

  defp resolve_segments(query, site) do
    with {:ok, preloaded_segments} <-
           Plausible.Segments.Filters.preload_needed_segments(site, query.filters),
         {:ok, filters} <-
           Plausible.Segments.Filters.resolve_segments(query.filters, preloaded_segments) do
      struct!(query,
        filters: filters
      )
    end
  end

  defp preload_goals_and_revenue(query, site) do
    {preloaded_goals, revenue_warning, revenue_currencies} =
      Plausible.Stats.Filters.QueryParser.preload_goals_and_revenue(
        site,
        query.metrics,
        query.filters,
        query.dimensions
      )

    struct!(query,
      preloaded_goals: preloaded_goals,
      revenue_warning: revenue_warning,
      revenue_currencies: revenue_currencies
    )
  end

  defp put_period(%Query{now: now} = query, _site, %{"period" => period})
       when period in ["realtime", "30m"] do
    duration_minutes =
      case period do
        "realtime" -> 5
        "30m" -> 30
      end

    first_datetime = DateTime.shift(now, minute: -duration_minutes)
    last_datetime = DateTime.shift(now, second: 5)

    datetime_range =
      DateTimeRange.new!(first_datetime, last_datetime) |> DateTimeRange.to_timezone("Etc/UTC")

    struct!(query, period: period, utc_time_range: datetime_range)
  end

  defp put_period(query, site, %{"period" => "day"} = params) do
    date = parse_single_date(query, params)

    datetime_range =
      DateTimeRange.new!(date, date, site.timezone) |> DateTimeRange.to_timezone("Etc/UTC")

    struct!(query, period: "day", utc_time_range: datetime_range)
  end

  defp put_period(query, site, %{"period" => period} = params)
       when period in ["7d", "28d", "30d", "91d"] do
    {days, "d"} = Integer.parse(period)

    end_date = parse_single_date(query, params) |> Date.shift(day: -1)
    start_date = end_date |> Date.shift(day: 1 - days)

    datetime_range =
      DateTimeRange.new!(start_date, end_date, site.timezone)
      |> DateTimeRange.to_timezone("Etc/UTC")

    struct!(query, period: period, utc_time_range: datetime_range)
  end

  defp put_period(query, site, %{"period" => "month"} = params) do
    date = parse_single_date(query, params)
    start_date = Timex.beginning_of_month(date)
    end_date = Timex.end_of_month(date)

    datetime_range =
      DateTimeRange.new!(start_date, end_date, site.timezone)
      |> DateTimeRange.to_timezone("Etc/UTC")

    struct!(query, period: "month", utc_time_range: datetime_range)
  end

  defp put_period(query, site, %{"period" => "6mo"} = params) do
    end_date =
      parse_single_date(query, params)
      |> Timex.end_of_month()

    start_date =
      Date.shift(end_date, month: -5)
      |> Timex.beginning_of_month()

    datetime_range =
      DateTimeRange.new!(start_date, end_date, site.timezone)
      |> DateTimeRange.to_timezone("Etc/UTC")

    struct!(query, period: "6mo", utc_time_range: datetime_range)
  end

  defp put_period(query, site, %{"period" => "12mo"} = params) do
    end_date =
      parse_single_date(query, params)
      |> Timex.end_of_month()

    start_date =
      Date.shift(end_date, month: -11)
      |> Timex.beginning_of_month()

    datetime_range =
      DateTimeRange.new!(start_date, end_date, site.timezone)
      |> DateTimeRange.to_timezone("Etc/UTC")

    struct!(query, period: "12mo", utc_time_range: datetime_range)
  end

  defp put_period(query, site, %{"period" => "year"} = params) do
    end_date =
      parse_single_date(query, params)
      |> Timex.end_of_year()

    start_date = Timex.beginning_of_year(end_date)

    datetime_range =
      DateTimeRange.new!(start_date, end_date, site.timezone)
      |> DateTimeRange.to_timezone("Etc/UTC")

    struct!(query, period: "year", utc_time_range: datetime_range)
  end

  defp put_period(query, site, %{"period" => "all"}) do
    today = today(query)
    start_date = Plausible.Sites.stats_start_date(site) || today

    datetime_range =
      DateTimeRange.new!(start_date, today, site.timezone) |> DateTimeRange.to_timezone("Etc/UTC")

    struct!(query, period: "all", utc_time_range: datetime_range)
  end

  defp put_period(query, site, %{"period" => "custom", "from" => from, "to" => to} = params) do
    new_params =
      params
      |> Map.drop(["from", "to"])
      |> Map.put("date", Enum.join([from, to], ","))

    put_period(query, site, new_params)
  end

  defp put_period(query, site, %{"period" => "custom", "date" => date}) do
    [from, to] = String.split(date, ",")
    from_date = Date.from_iso8601!(String.trim(from))
    to_date = Date.from_iso8601!(String.trim(to))

    datetime_range =
      DateTimeRange.new!(from_date, to_date, site.timezone)
      |> DateTimeRange.to_timezone("Etc/UTC")

    struct!(query, period: "custom", utc_time_range: datetime_range)
  end

  defp put_period(query, site, params) do
    put_period(query, site, Map.merge(params, %{"period" => "30d"}))
  end

  defp put_timezone(query, site) do
    struct!(query, timezone: site.timezone)
  end

  defp put_dimensions(query, params) do
    if not is_nil(params["property"]) do
      struct!(query, dimensions: [params["property"]])
    else
      struct!(query, dimensions: Map.get(params, "dimensions", []))
    end
  end

  defp put_include(query, site, params) do
    include = parse_include(site, params["include"])

    query
    |> struct!(include: include)
    |> Query.set_include(:comparisons, parse_comparison_params(site, params))
    |> Query.set_include(:imports, params["with_imported"] == "true")
  end

  @doc """
  ### Examples:
    iex> QueryBuilder.parse_order_by(nil)
    []

    iex> QueryBuilder.parse_order_by("")
    []

    iex> QueryBuilder.parse_order_by("0")
    []

    iex> QueryBuilder.parse_order_by("[}")
    []

    iex> QueryBuilder.parse_order_by(~s({"any":"object"}))
    []

    iex> QueryBuilder.parse_order_by(~s([["visitors","invalid"]]))
    []

    iex> QueryBuilder.parse_order_by(~s([["visitors","desc"]]))
    [{:visitors, :desc}]

    iex> QueryBuilder.parse_order_by(~s([["visitors","asc"],["visit:source","desc"]]))
    [{:visitors, :asc}, {"visit:source", :desc}]
  """
  def parse_order_by(order_by) do
    json_decode(order_by)
    |> unwrap([])
    |> Filters.QueryParser.parse_order_by()
    |> unwrap([])
  end

  @doc """
  ### Examples:
    iex> QueryBuilder.parse_include(%{}, nil)
    QueryParser.default_include()

    iex> QueryBuilder.parse_include(%{}, ~s({"total_rows": true}))
    Map.merge(QueryParser.default_include(), %{total_rows: true})
  """
  def parse_include(site, include) do
    json_decode(include)
    |> unwrap(%{})
    |> Filters.QueryParser.parse_include(site)
    |> unwrap(Filters.QueryParser.default_include())
  end

  defp json_decode(string) when is_binary(string) do
    Jason.decode(string)
  end

  defp json_decode(_other), do: :error

  defp unwrap({:ok, result}, _default), do: result
  defp unwrap(_, default), do: default

  defp put_order_by(query, %{} = params) do
    struct!(query, order_by: parse_order_by(params["order_by"]))
  end

  defp put_interval(%{:period => "all"} = query, params) do
    interval = Map.get(params, "interval", Interval.default_for_date_range(query.utc_time_range))
    struct!(query, interval: interval)
  end

  defp put_interval(query, params) do
    interval = Map.get(params, "interval", Interval.default_for_period(query.period))
    struct!(query, interval: interval)
  end

  defp put_parsed_filters(query, params) do
    struct!(query, filters: Filters.parse(params["filters"]))
  end

  defp today(query) do
    query.now |> Timex.to_date()
  end

  defp parse_single_date(query, params) do
    case params["date"] do
      "today" -> query.now |> Timex.to_date()
      date when is_binary(date) -> Date.from_iso8601!(date)
      _ -> today(query)
    end
  end

  def parse_comparison_params(_site, %{"period" => period}) when period in ~w(realtime all),
    do: nil

  def parse_comparison_params(_site, %{"comparison" => mode} = params)
      when mode in ["previous_period", "year_over_year"] do
    %{
      mode: mode,
      match_day_of_week: params["match_day_of_week"] == "true"
    }
  end

  def parse_comparison_params(site, %{"comparison" => "custom"} = params) do
    {:ok, date_range} =
      Filters.QueryParser.parse_date_range_pair(site, [
        params["compare_from"],
        params["compare_to"]
      ])

    %{
      mode: "custom",
      date_range: date_range,
      match_day_of_week: params["match_day_of_week"] == "true"
    }
  end

  def parse_comparison_params(_site, %{"compare" => "previous_period"}) do
    %{mode: "previous_period"}
  end

  def parse_comparison_params(_site, _options), do: nil
end
```

## File: `lib/plausible/stats/legacy/time_on_page.ex`
```
defmodule Plausible.Stats.Legacy.TimeOnPage do
  @moduledoc """
  Calculation methods for `legacy` time_on_page metric. `Legacy` calculation methods
  are used when site does not have engagement data for the requested dates.

  Query `include.legacy_time_on_page_cutoff` is used to determine what time range
  to use for the legacy time_on_page calculations.

  Legacy metric is not exposed in the public API.
  """

  use Plausible.ClickhouseRepo
  use Plausible.Stats.SQL.Fragments

  import Ecto.Query
  import Plausible.Stats.Util

  alias Plausible.Stats.{Base, Filters, Query, SQL}

  def can_merge_legacy_time_on_page?(query) do
    :time_on_page in query.metrics and query.dimensions in [[], ["event:page"]]
  end

  def merge_legacy_time_on_page(q, query) do
    if :time_on_page in query.metrics and query.time_on_page_data.include_legacy_metric do
      q |> merge_legacy_time_on_page(query, query.dimensions)
    else
      q
    end
  end

  defp merge_legacy_time_on_page(q, query, []) do
    from(
      e in subquery(q),
      inner_join: t in subquery(aggregate_time_on_page_q(query)),
      on: true
    )
    |> select_metrics_and_dimensions(query)
  end

  defp merge_legacy_time_on_page(q, query, ["event:page"]) do
    from(
      e in subquery(q),
      left_join: t in subquery(breakdown_q(query)),
      on: e.dim0 == t.pathname
    )
    |> select_metrics_and_dimensions(query)
  end

  defp merge_legacy_time_on_page(q, _query, _dimensions) do
    q
  end

  defp select_metrics_and_dimensions(q, query) do
    q
    |> select_join_fields(query, List.delete(query.metrics, :time_on_page), e)
    |> select_join_fields(query, query.dimensions, e)
    |> select_merge_as([e, t], %{
      time_on_page:
        time_on_page(
          e.__internal_total_time_on_page + t.total_time_on_page,
          e.__internal_total_time_on_page_visits + t.transition_count
        )
    })
  end

  defp aggregate_time_on_page_q(query) do
    windowed_pages_q =
      from(e in Base.base_event_query(Query.remove_top_level_filters(query, ["event:page"])),
        where: e.name != "engagement",
        where: ^filter_by_cutoff(query),
        select: %{
          next_timestamp: over(fragment("leadInFrame(?)", e.timestamp), :event_horizon),
          next_pathname: over(fragment("leadInFrame(?)", e.pathname), :event_horizon),
          timestamp: e.timestamp,
          pathname: e.pathname,
          session_id: e.session_id
        },
        windows: [
          event_horizon: [
            partition_by: e.session_id,
            order_by: e.timestamp,
            frame: fragment("ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING")
          ]
        ]
      )

    event_page_filter = Filters.get_toplevel_filter(query, "event:page")

    timed_page_transitions_q =
      from e in Ecto.Query.subquery(windowed_pages_q),
        group_by: [e.pathname, e.next_pathname, e.session_id],
        where: ^SQL.WhereBuilder.build_condition(:pathname, event_page_filter),
        where: e.next_timestamp != 0,
        select: %{
          pathname: e.pathname,
          transition: e.next_pathname != e.pathname,
          duration: sum(e.next_timestamp - e.timestamp)
        }

    avg_time_per_page_transition_q =
      from e in Ecto.Query.subquery(timed_page_transitions_q),
        select: %{
          avg: fragment("sum(?)/countIf(?)", e.duration, e.transition),
          duration: fragment("sum(?)", e.duration),
          transition_count: fragment("countIf(?)", e.transition)
        },
        group_by: e.pathname

    from(
      e in subquery(avg_time_per_page_transition_q),
      select: %{
        total_time_on_page: fragment("sum(?)", e.duration),
        transition_count: fragment("sum(?)", e.transition_count)
      }
    )
  end

  defp breakdown_q(query) do
    windowed_pages_q =
      from(
        e in Base.base_event_query(
          Query.remove_top_level_filters(query, ["event:page", "event:props"])
        ),
        where: e.name != "engagement",
        where: ^filter_by_cutoff(query),
        select: %{
          next_timestamp: over(fragment("leadInFrame(?)", e.timestamp), :event_horizon),
          next_pathname: over(fragment("leadInFrame(?)", e.pathname), :event_horizon),
          timestamp: e.timestamp,
          pathname: e.pathname,
          session_id: e.session_id
        },
        windows: [
          event_horizon: [
            partition_by: e.session_id,
            order_by: e.timestamp,
            frame: fragment("ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING")
          ]
        ]
      )

    timed_page_transitions_q =
      from(e in subquery(windowed_pages_q),
        group_by: [e.pathname, e.next_pathname, e.session_id],
        where: e.next_timestamp != 0,
        select: %{
          pathname: e.pathname,
          transition: e.next_pathname != e.pathname,
          duration: sum(e.next_timestamp - e.timestamp)
        }
      )

    no_select_timed_pages_q =
      from e in subquery(timed_page_transitions_q),
        group_by: e.pathname

    date_range = Query.date_range(query)

    if query.include_imported do
      # Imported page views have pre-calculated values
      imported_timed_pages_q =
        from(i in "imported_pages",
          group_by: i.page,
          where: i.site_id == ^query.site_id,
          where: i.date >= ^date_range.first and i.date <= ^date_range.last,
          select: %{
            page: i.page,
            time_on_page: sum(i.total_time_on_page),
            visits: sum(i.pageviews) - sum(i.exits)
          }
        )

      timed_pages_q =
        from e in no_select_timed_pages_q,
          select: %{
            page: e.pathname,
            time_on_page: fragment("sum(?)", e.duration),
            visits: fragment("countIf(?)", e.transition)
          }

      "timed_pages"
      |> with_cte("timed_pages", as: ^timed_pages_q)
      |> with_cte("imported_timed_pages", as: ^imported_timed_pages_q)
      |> join(:full, [t], i in "imported_timed_pages", on: t.page == i.page)
      |> select(
        [t, i],
        %{
          pathname: fragment("if(empty(?),?,?)", t.page, i.page, t.page),
          total_time_on_page: t.time_on_page + i.time_on_page,
          transition_count: t.visits + i.visits
        }
      )
    else
      from(e in no_select_timed_pages_q,
        select: %{
          pathname: e.pathname,
          total_time_on_page: fragment("sum(?)", e.duration),
          transition_count: fragment("countIf(?)", e.transition)
        }
      )
    end
  end

  defp filter_by_cutoff(query) do
    case query.time_on_page_data do
      %{include_legacy_metric: true, include_new_metric: true, cutoff: cutoff} ->
        dynamic([e], e.timestamp < ^cutoff)

      _ ->
        true
    end
  end
end
```

## File: `lib/plausible/stats/metrics.ex`
```
defmodule Plausible.Stats.Metrics do
  @moduledoc """
  A module listing all available metrics in Plausible.

  Useful for an explicit string to atom conversion.
  """

  use Plausible

  @all_metrics [
                 :visitors,
                 :visits,
                 :pageviews,
                 :exit_rate,
                 :views_per_visit,
                 :bounce_rate,
                 :visit_duration,
                 :events,
                 :conversion_rate,
                 :group_conversion_rate,
                 :time_on_page,
                 :percentage,
                 :scroll_depth
               ] ++ on_ee(do: Plausible.Stats.Goal.Revenue.revenue_metrics(), else: [])

  @metric_mappings Enum.into(@all_metrics, %{}, fn metric -> {to_string(metric), metric} end)

  def metric?(value), do: Enum.member?(@all_metrics, value)

  on_ee do
    def default_value(metric, query, dimensions)
        when metric in [:average_revenue, :total_revenue],
        do: Plausible.Stats.Goal.Revenue.format_revenue_metric(nil, query, dimensions)
  end

  def default_value(:visit_duration, _query, _dimensions), do: nil
  def default_value(:exit_rate, _query, _dimensions), do: nil
  def default_value(:scroll_depth, _query, _dimensions), do: nil
  def default_value(:time_on_page, _query, _dimensions), do: nil

  @float_metrics [
    :views_per_visit,
    :bounce_rate,
    :percentage,
    :conversion_rate,
    :group_conversion_rate
  ]
  def default_value(metric, _query, _dimensions) when metric in @float_metrics, do: 0.0
  def default_value(_metric, _query, _dimensions), do: 0

  def from_string!(str) do
    Map.fetch!(@metric_mappings, str)
  end

  def from_string(str) do
    Map.fetch(@metric_mappings, str)
  end
end
```

## File: `lib/plausible/stats/query.ex`
```
defmodule Plausible.Stats.Query do
  use Plausible

  defstruct utc_time_range: nil,
            comparison_utc_time_range: nil,
            interval: nil,
            period: nil,
            dimensions: [],
            filters: [],
            sample_threshold: 20_000_000,
            imports_exist: false,
            imports_in_range: [],
            include_imported: false,
            skip_imported_reason: nil,
            now: nil,
            metrics: [],
            order_by: nil,
            timezone: nil,
            legacy_breakdown: false,
            preloaded_goals: [],
            include: Plausible.Stats.Filters.QueryParser.default_include(),
            debug_metadata: %{},
            pagination: nil,
            # Revenue metric specific metadata
            revenue_currencies: %{},
            revenue_warning: nil,
            remove_unavailable_revenue_metrics: false,
            site_id: nil,
            site_native_stats_start_at: nil,
            # Contains information to determine how to combine legacy and new time on page metrics
            time_on_page_data: %{}

  require OpenTelemetry.Tracer, as: Tracer
  alias Plausible.Stats.{DateTimeRange, Filters, Imported, Legacy, Comparisons}

  @type t :: %__MODULE__{}

  def build(site, schema_type, params, debug_metadata) do
    with {:ok, query_data} <- Filters.QueryParser.parse(site, schema_type, params) do
      query =
        %__MODULE__{
          now: DateTime.utc_now(:second),
          debug_metadata: debug_metadata,
          site_id: site.id,
          site_native_stats_start_at: site.native_stats_start_at
        }
        |> struct!(Map.to_list(query_data))
        |> set_time_on_page_data(site)
        |> put_comparison_utc_time_range()
        |> put_imported_opts(site)

      on_ee do
        query = Plausible.Stats.Sampling.put_threshold(query, site, params)
      end

      {:ok, query}
    end
  end

  @doc """
  Builds query from old-style params. New code should prefer Query.build
  """
  def from(site, params, debug_metadata \\ %{}, now \\ nil) do
    Legacy.QueryBuilder.from(site, params, debug_metadata, now)
  end

  def date_range(query, options \\ []) do
    date_range = DateTimeRange.to_date_range(query.utc_time_range, query.timezone)

    if Keyword.get(options, :trim_trailing) do
      today = query.now |> DateTime.shift_zone!(query.timezone) |> DateTime.to_date()

      Date.range(
        date_range.first,
        clamp(today, date_range)
      )
    else
      date_range
    end
  end

  defp clamp(date, date_range) do
    cond do
      date in date_range -> date
      Date.before?(date, date_range.first) -> date_range.first
      Date.after?(date, date_range.last) -> date_range.last
    end
  end

  def set(query, keywords) do
    new_query = struct!(query, keywords)

    if Keyword.has_key?(keywords, :include_imported) do
      new_query
    else
      refresh_imported_opts(new_query)
    end
  end

  def set_include(query, key, value) do
    struct!(query, include: Map.put(query.include, key, value))
  end

  def add_filter(query, filter) do
    query
    |> struct!(filters: query.filters ++ [filter])
    |> refresh_imported_opts()
  end

  @doc """
  Removes top level filters matching any of passed prefix from the query.

  Note that this doesn't handle cases with AND/OR/NOT and as such is discouraged
  from use.
  """
  def remove_top_level_filters(query, prefixes) do
    new_filters =
      Enum.reject(query.filters, fn [_, dimension_or_filter_tree | _rest] ->
        is_binary(dimension_or_filter_tree) and
          Enum.any?(prefixes, &String.starts_with?(dimension_or_filter_tree, &1))
      end)

    query
    |> struct!(filters: new_filters)
    |> refresh_imported_opts()
  end

  defp refresh_imported_opts(query) do
    put_imported_opts(query, nil)
  end

  def put_comparison_utc_time_range(%__MODULE__{include: %{comparisons: nil}} = query), do: query

  def put_comparison_utc_time_range(%__MODULE__{include: %{comparisons: comparison_opts}} = query) do
    datetime_range = Comparisons.get_comparison_utc_time_range(query, comparison_opts)
    struct!(query, comparison_utc_time_range: datetime_range)
  end

  def put_imported_opts(query, site) do
    requested? = query.include.imports

    query =
      if site do
        struct!(query,
          imports_exist: Plausible.Imported.any_completed_imports?(site),
          imports_in_range: get_imports_in_range(site, query)
        )
      else
        query
      end

    skip_imported_reason = get_skip_imported_reason(query)

    struct!(query,
      include_imported: requested? and is_nil(skip_imported_reason),
      skip_imported_reason: skip_imported_reason
    )
  end

  defp get_imports_in_range(_site, %__MODULE__{period: period})
       when period in ["realtime", "30m"] do
    []
  end

  defp get_imports_in_range(site, query) do
    in_range = Plausible.Imported.completed_imports_in_query_range(site, query)

    in_comparison_range =
      if is_map(query.include.comparisons) do
        comparison_query = Comparisons.get_comparison_query(query)
        Plausible.Imported.completed_imports_in_query_range(site, comparison_query)
      else
        []
      end

    in_comparison_range ++ in_range
  end

  def set_time_on_page_data(query, site) do
    struct!(query,
      time_on_page_data: %{
        new_metric_visible: Plausible.Stats.TimeOnPage.new_time_on_page_visible?(site),
        cutoff_date: site.legacy_time_on_page_cutoff
      }
    )
  end

  @spec get_skip_imported_reason(t()) ::
          nil | :no_imported_data | :out_of_range | :unsupported_query
  def get_skip_imported_reason(query) do
    cond do
      not query.imports_exist ->
        :no_imported_data

      query.imports_in_range == [] ->
        :out_of_range

      "time:minute" in query.dimensions or "time:hour" in query.dimensions ->
        :unsupported_interval

      not Imported.schema_supports_query?(query) ->
        :unsupported_query

      true ->
        nil
    end
  end

  @spec trace(%__MODULE__{}, [atom()]) :: %__MODULE__{}
  def trace(%__MODULE__{} = query, metrics) do
    filter_dimensions =
      query.filters
      |> Plausible.Stats.Filters.dimensions_used_in_filters()
      |> Enum.sort()
      |> Enum.uniq()
      |> Enum.join(";")

    metrics = metrics |> Enum.sort() |> Enum.join(";")

    Tracer.set_attributes([
      {"plausible.query.interval", query.interval},
      {"plausible.query.period", query.period},
      {"plausible.query.dimensions", query.dimensions |> Enum.join(";")},
      {"plausible.query.include_imported", query.include_imported},
      {"plausible.query.filter_keys", filter_dimensions},
      {"plausible.query.metrics", metrics}
    ])

    query
  end
end
```

## File: `lib/plausible/stats/query_optimizer.ex`
```
defmodule Plausible.Stats.QueryOptimizer do
  @moduledoc """
  Methods to manipulate Query for business logic reasons before building an ecto query.
  """

  use Plausible

  alias Plausible.Stats.{
    DateTimeRange,
    Filters,
    Query,
    TableDecider,
    TimeOnPage,
    Util,
    Time,
    Legacy
  }

  @doc """
    This module manipulates an existing query, updating it according to business logic.

    For example, it:
    1. Figures out what the right granularity to group by time is
    2. Adds a missing order_by clause to a query
    3. Updating "time" dimension in order_by to the right granularity
    4. Updates event:hostname filters to also apply on visit level for sane results.
    5. Removes revenue metrics from dashboard queries if not requested, present or unavailable for the site.

  """
  def optimize(query) do
    Enum.reduce(pipeline(), query, fn step, acc -> step.(acc) end)
  end

  @doc """
  Splits a query into event and sessions subcomponents as not all metrics can be
  queried from a single table.

  event:page dimension is treated in a special way, doing a breakdown of visit:entry_page
  for sessions.
  """
  def split(query) do
    {event_metrics, sessions_metrics, _other_metrics} =
      query.metrics
      |> Util.maybe_add_visitors_metric()
      |> TableDecider.partition_metrics(query)

    {
      Query.set(query,
        metrics: event_metrics,
        include_imported: query.include_imported
      ),
      split_sessions_query(query, sessions_metrics)
    }
  end

  defp pipeline() do
    [
      &update_group_by_time/1,
      &add_missing_order_by/1,
      &update_time_in_order_by/1,
      &extend_hostname_filters_to_visit/1,
      &remove_revenue_metrics_if_unavailable/1,
      &set_time_on_page_data/1
    ]
  end

  defp add_missing_order_by(%Query{order_by: nil} = query) do
    order_by =
      case time_dimension(query) do
        nil -> [{hd(query.metrics), :desc}]
        time_dimension -> [{time_dimension, :asc}, {hd(query.metrics), :desc}]
      end

    %Query{query | order_by: order_by}
  end

  defp add_missing_order_by(query), do: query

  defp update_group_by_time(
         %Query{
           utc_time_range: %DateTimeRange{first: first, last: last}
         } = query
       ) do
    dimensions =
      query.dimensions
      |> Enum.map(fn
        "time" -> resolve_time_dimension(first, last)
        entry -> entry
      end)

    %Query{query | dimensions: dimensions}
  end

  defp update_group_by_time(query), do: query

  defp resolve_time_dimension(first, last) do
    cond do
      DateTime.diff(last, first, :hour) <= 48 -> "time:hour"
      DateTime.diff(last, first, :day) <= 40 -> "time:day"
      Timex.diff(last, first, :weeks) <= 52 -> "time:week"
      true -> "time:month"
    end
  end

  defp update_time_in_order_by(query) do
    order_by =
      query.order_by
      |> Enum.map(fn
        {"time", direction} -> {time_dimension(query), direction}
        entry -> entry
      end)

    %Query{query | order_by: order_by}
  end

  @dimensions_hostname_map %{
    "visit:source" => "visit:entry_page_hostname",
    "visit:entry_page" => "visit:entry_page_hostname",
    "visit:utm_medium" => "visit:entry_page_hostname",
    "visit:utm_source" => "visit:entry_page_hostname",
    "visit:utm_campaign" => "visit:entry_page_hostname",
    "visit:utm_content" => "visit:entry_page_hostname",
    "visit:utm_term" => "visit:entry_page_hostname",
    "visit:referrer" => "visit:entry_page_hostname",
    "visit:exit_page" => "visit:exit_page_hostname"
  }

  # To avoid showing referrers across hostnames when event:hostname
  # filter is present for breakdowns, add entry/exit page hostname
  # filters
  defp extend_hostname_filters_to_visit(query) do
    # Note: Only works since event:hostname is only allowed as a top level filter
    hostname_filters =
      query.filters
      |> Enum.filter(fn [_operation, dimension | _rest] -> dimension == "event:hostname" end)

    if length(hostname_filters) > 0 do
      extra_filters =
        query.dimensions
        |> Enum.flat_map(&hostname_filters_for_dimension(&1, hostname_filters))

      %Query{query | filters: query.filters ++ extra_filters}
    else
      query
    end
  end

  defp hostname_filters_for_dimension(dimension, hostname_filters) do
    if Map.has_key?(@dimensions_hostname_map, dimension) do
      dimension = Map.get(@dimensions_hostname_map, dimension)

      hostname_filters
      |> Enum.map(fn [operation, _dimension | rest] -> [operation, dimension | rest] end)
    else
      []
    end
  end

  defp time_dimension(query) do
    Enum.find(query.dimensions, &Time.time_dimension?/1)
  end

  defp split_sessions_query(query, session_metrics) do
    dimensions =
      query.dimensions
      |> Enum.map(fn
        "event:page" -> "visit:entry_page"
        dimension -> dimension
      end)

    filters =
      if "event:page" in query.dimensions do
        Filters.rename_dimensions_used_in_filter(query.filters, %{
          "event:page" => "visit:entry_page"
        })
      else
        query.filters
      end

    Query.set(query,
      filters: filters,
      metrics: session_metrics,
      dimensions: dimensions,
      include_imported: query.include_imported
    )
  end

  on_ee do
    defp remove_revenue_metrics_if_unavailable(query) do
      if query.remove_unavailable_revenue_metrics and map_size(query.revenue_currencies) == 0 do
        Query.set(query, metrics: query.metrics -- Plausible.Stats.Goal.Revenue.revenue_metrics())
      else
        query
      end
    end
  else
    defp remove_revenue_metrics_if_unavailable(query), do: query
  end

  defp set_time_on_page_data(query) do
    case {:time_on_page in query.metrics, query.time_on_page_data} do
      {true, %{new_metric_visible: true, cutoff_date: cutoff_date}} ->
        cutoff =
          cutoff_date
          |> TimeOnPage.cutoff_datetime(query.timezone)
          |> DateTime.shift_zone!("Etc/UTC")
          |> DateTime.truncate(:second)

        Query.set(
          query,
          time_on_page_data:
            Map.merge(query.time_on_page_data, %{
              include_new_metric: DateTime.before?(cutoff, query.utc_time_range.last),
              include_legacy_metric:
                DateTime.after?(cutoff, query.utc_time_range.first) and
                  Legacy.TimeOnPage.can_merge_legacy_time_on_page?(query),
              cutoff:
                if(DateTime.after?(cutoff, query.utc_time_range.first), do: cutoff, else: nil)
            })
        )

      _ ->
        Query.set(
          query,
          time_on_page_data:
            Map.merge(query.time_on_page_data, %{
              include_new_metric: false,
              include_legacy_metric: true,
              cutoff: nil
            })
        )
    end
  end
end
```

## File: `lib/plausible/stats/query_result.ex`
```
defmodule Plausible.Stats.QueryResult do
  @moduledoc """
  This struct contains the (JSON-encodable) response for a query and
  is responsible for building it from database query results.

  For the convenience of API docs and consumers, the JSON result
  produced by Jason.encode(query_result) is ordered.
  """

  use Plausible
  alias Plausible.Stats.{DateTimeRange, Query, QueryRunner}

  defstruct results: [],
            meta: %{},
            query: nil

  @doc """
  Builds full JSON-serializable query response.

  `results` should already-built by Plausible.Stats.QueryRunner
  """
  def from(%QueryRunner{site: site, main_query: query, results: results} = runner) do
    struct!(
      __MODULE__,
      results: results,
      meta: meta(runner) |> Enum.sort_by(&elem(&1, 0)) |> Jason.OrderedObject.new(),
      query:
        Jason.OrderedObject.new(
          site_id: site.domain,
          metrics: query.metrics,
          date_range: [
            to_iso8601(query.utc_time_range.first, query.timezone),
            to_iso8601(query.utc_time_range.last, query.timezone)
          ],
          filters: query.filters,
          dimensions: query.dimensions,
          order_by: query.order_by |> Enum.map(&Tuple.to_list/1),
          include: include(query) |> Map.filter(fn {_key, val} -> val end),
          pagination: query.pagination
        )
    )
  end

  defp meta(%QueryRunner{} = runner) do
    %{}
    |> add_imports_meta(runner.main_query)
    |> add_metric_warnings_meta(runner.main_query)
    |> add_time_labels_meta(runner.main_query)
    |> add_total_rows_meta(runner.main_query, runner.total_rows)
  end

  @imports_warnings %{
    unsupported_query:
      "Imported stats are not included in the results because query parameters are not supported. " <>
        "For more information, see: https://plausible.io/docs/stats-api#filtering-imported-stats",
    unsupported_interval:
      "Imported stats are not included because the time dimension (i.e. the interval) is too short."
  }

  defp add_imports_meta(meta, %Query{include: include} = query) do
    if include.imports or include.imports_meta do
      %{
        imports_included: query.include_imported,
        imports_skip_reason: query.skip_imported_reason,
        imports_warning: @imports_warnings[query.skip_imported_reason]
      }
      |> Map.reject(fn {_key, value} -> is_nil(value) end)
      |> Map.merge(meta)
    else
      meta
    end
  end

  defp add_metric_warnings_meta(meta, query) do
    warnings = metric_warnings(query)

    if map_size(warnings) > 0 do
      Map.put(meta, :metric_warnings, warnings)
    else
      meta
    end
  end

  defp add_time_labels_meta(meta, query) do
    if query.include.time_labels do
      Map.put(meta, :time_labels, Plausible.Stats.Time.time_labels(query))
    else
      meta
    end
  end

  defp add_total_rows_meta(meta, query, total_rows) do
    if query.include.total_rows do
      Map.put(meta, :total_rows, total_rows)
    else
      meta
    end
  end

  defp include(query) do
    case get_in(query.include, [:comparisons, :date_range]) do
      %DateTimeRange{first: first, last: last} ->
        query.include
        |> put_in([:comparisons, :date_range], [
          to_iso8601(first, query.timezone),
          to_iso8601(last, query.timezone)
        ])

      nil ->
        query.include
    end
  end

  defp metric_warnings(%Query{} = query) do
    Enum.reduce(query.metrics, %{}, fn metric, acc ->
      case metric_warning(metric, query) do
        nil -> acc
        %{} = warning -> Map.put(acc, metric, warning)
      end
    end)
  end

  on_ee do
    @revenue_metrics Plausible.Stats.Goal.Revenue.revenue_metrics()

    @revenue_metrics_warnings %{
      revenue_goals_unavailable:
        "The owner of this site does not have access to the revenue metrics feature.",
      no_single_revenue_currency:
        "Revenue metrics are null as there are multiple currencies for the selected event:goals.",
      no_revenue_goals_matching:
        "Revenue metrics are null as there are no matching revenue goals."
    }

    defp metric_warning(metric, %Query{} = query)
         when metric in @revenue_metrics do
      if query.revenue_warning do
        %{
          code: query.revenue_warning,
          warning: @revenue_metrics_warnings[query.revenue_warning]
        }
      else
        nil
      end
    end
  end

  @no_imported_scroll_depth_metric_warning %{
    code: :no_imported_scroll_depth,
    warning: "No imports with scroll depth data were found"
  }

  defp metric_warning(:scroll_depth, %Query{} = query) do
    if query.include_imported and not Enum.any?(query.imports_in_range, & &1.has_scroll_depth) do
      @no_imported_scroll_depth_metric_warning
    end
  end

  defp metric_warning(:time_on_page, %Query{} = query) do
    case query.time_on_page_data do
      %{new_metric_visible: true, include_legacy_metric: true, cutoff: cutoff} ->
        cutoff_date =
          cutoff |> DateTime.shift_zone!(query.timezone) |> Calendar.strftime("%Y-%m-%d")

        %{
          code: :legacy_time_on_page_used,
          message:
            "This period includes data calculated with the legacy time on page method up to #{cutoff_date}"
        }

      _ ->
        nil
    end
  end

  defp metric_warning(_metric, _query), do: nil

  defp to_iso8601(datetime, timezone) do
    datetime
    |> DateTime.shift_zone!(timezone)
    |> DateTime.to_iso8601(:extended)
  end
end

defimpl Jason.Encoder, for: Plausible.Stats.QueryResult do
  def encode(%Plausible.Stats.QueryResult{results: results, meta: meta, query: query}, opts) do
    Jason.OrderedObject.new(results: results, meta: meta, query: query)
    |> Jason.Encoder.encode(opts)
  end
end
```

## File: `lib/plausible/stats/query_runner.ex`
```
defmodule Plausible.Stats.QueryRunner do
  @moduledoc """
  This module is responsible for executing a Plausible.Stats.Query
  and gathering results.

  Some secondary responsibilities are:
  1. Dealing with comparison queries and combining results with main
  2. Dealing with time-on-page
  3. Getting total_rows from ClickHouse results
  """

  use Plausible
  use Plausible.ClickhouseRepo

  alias Plausible.Stats.{
    Comparisons,
    Compare,
    QueryOptimizer,
    QueryResult,
    Metrics,
    SQL,
    Util,
    Time
  }

  defstruct [
    :site,
    :main_query,
    :main_results,
    :comparison_query,
    :comparison_results,
    :total_rows,
    :results
  ]

  def run(site, query) do
    optimized_query = QueryOptimizer.optimize(query)

    %__MODULE__{main_query: optimized_query, site: site}
    |> execute_main_query()
    |> add_comparison_query()
    |> execute_comparison_query()
    |> build_results_list()
    |> QueryResult.from()
  end

  defp execute_main_query(%__MODULE__{main_query: query, site: site} = runner) do
    ch_results = execute_query(query, site)

    main_results = build_from_ch(ch_results, query)

    runner = struct!(runner, main_results: main_results)

    if query.include.total_rows do
      struct!(runner, total_rows: total_rows(ch_results))
    else
      runner
    end
  end

  defp add_comparison_query(%__MODULE__{main_query: query, main_results: main_results} = runner)
       when is_map(query.include.comparisons) do
    comparison_query =
      query
      |> Comparisons.get_comparison_query()
      |> Comparisons.add_comparison_filters(main_results)
      |> QueryOptimizer.optimize()

    struct!(runner, comparison_query: comparison_query)
  end

  defp add_comparison_query(runner), do: runner

  defp execute_comparison_query(
         %__MODULE__{comparison_query: comparison_query, site: site} = runner
       ) do
    if comparison_query do
      ch_results = execute_query(comparison_query, site)
      comparison_results = build_from_ch(ch_results, comparison_query)

      struct!(runner, comparison_results: comparison_results)
    else
      runner
    end
  end

  defp get_time_lookup(query, comparison_query) do
    if Time.time_dimension(query) && comparison_query do
      Enum.zip(
        Time.time_labels(query),
        Time.time_labels(comparison_query)
      )
      |> Map.new()
    else
      %{}
    end
  end

  defp build_results_list(%__MODULE__{main_query: query, main_results: main_results} = runner) do
    results =
      case query.dimensions do
        ["time:" <> _] -> main_results |> add_empty_timeseries_rows(runner)
        _ -> main_results
      end
      |> merge_with_comparison_results(runner)

    struct!(runner, results: results)
  end

  defp execute_query(query, site) do
    query
    |> SQL.QueryBuilder.build(site)
    |> ClickhouseRepo.all(query: query)
  end

  defp build_from_ch(ch_results, query) do
    ch_results
    |> Enum.map(fn entry ->
      dimension_labels = Enum.map(query.dimensions, &dimension_label(&1, entry, query))

      %{
        dimensions: dimension_labels,
        metrics: Enum.map(query.metrics, &get_metric(entry, &1, dimension_labels, query))
      }
    end)
  end

  defp dimension_label("event:goal", entry, query) do
    get_dimension_goal(entry, query)
    |> Plausible.Goal.display_name()
  end

  defp dimension_label("time:" <> _ = time_dimension, entry, query) do
    datetime = Map.get(entry, Util.shortname(query, time_dimension))

    Time.format_datetime(datetime)
  end

  defp dimension_label(dimension, entry, query) do
    Map.get(entry, Util.shortname(query, dimension))
  end

  on_ee do
    defp get_metric(entry, metric, dimensions, query)
         when metric in [:average_revenue, :total_revenue] do
      value = Map.get(entry, metric)

      Plausible.Stats.Goal.Revenue.format_revenue_metric(value, query, dimensions)
    end
  end

  defp get_metric(entry, :events, _dimensions, query) do
    cond do
      "event:goal" in query.dimensions ->
        goal = get_dimension_goal(entry, query)

        if Plausible.Goal.type(goal) != :scroll do
          Map.get(entry, :events)
        else
          nil
        end

      # Cannot show aggregate when there are at least some scroll goal filters
      Plausible.Stats.Goals.toplevel_scroll_goal_filters?(query) ->
        nil

      true ->
        Map.get(entry, :events)
    end
  end

  defp get_metric(entry, metric, _dimensions, _query), do: Map.get(entry, metric)

  defp get_dimension_goal(entry, query) do
    goal_index = Map.get(entry, Util.shortname(query, "event:goal"))

    query.preloaded_goals.matching_toplevel_filters
    |> Enum.at(goal_index - 1)
  end

  # Special case: If comparison and single time dimension, add 0 rows - otherwise
  # comparisons would not be shown for timeseries with 0 values.
  defp add_empty_timeseries_rows(results_list, %__MODULE__{main_query: query})
       when is_map(query.include.comparisons) do
    indexed_results = index_by_dimensions(results_list)

    empty_timeseries_rows =
      Time.time_labels(query)
      |> Enum.reject(fn dimension_value -> Map.has_key?(indexed_results, [dimension_value]) end)
      |> Enum.map(fn dimension_value ->
        %{
          metrics: empty_metrics(query, [dimension_value]),
          dimensions: [dimension_value]
        }
      end)

    results_list ++ empty_timeseries_rows
  end

  defp add_empty_timeseries_rows(results_list, _), do: results_list

  defp merge_with_comparison_results(results_list, runner) do
    comparison_map = (runner.comparison_results || []) |> index_by_dimensions()
    time_lookup = get_time_lookup(runner.main_query, runner.comparison_query)

    Enum.map(
      results_list,
      &add_comparison_results(&1, runner.main_query, comparison_map, time_lookup)
    )
  end

  defp add_comparison_results(row, query, comparison_map, time_lookup)
       when is_map(query.include.comparisons) do
    dimensions = get_comparison_dimensions(row.dimensions, query, time_lookup)
    comparison_metrics = get_comparison_metrics(comparison_map, dimensions, query)

    change =
      Enum.zip([query.metrics, row.metrics, comparison_metrics])
      |> Enum.map(fn {metric, metric_value, comparison_value} ->
        Compare.calculate_change(metric, comparison_value, metric_value)
      end)

    Map.merge(row, %{
      comparison: %{
        dimensions: dimensions,
        metrics: comparison_metrics,
        change: change
      }
    })
  end

  defp add_comparison_results(row, _, _, _), do: row

  defp get_comparison_dimensions(dimensions, query, time_lookup) do
    query.dimensions
    |> Enum.zip(dimensions)
    |> Enum.map(fn
      {"time:" <> _, value} -> time_lookup[value]
      {_, value} -> value
    end)
  end

  defp index_by_dimensions(results_list) do
    results_list
    |> Map.new(fn entry -> {entry.dimensions, entry.metrics} end)
  end

  defp get_comparison_metrics(comparison_map, dimensions, query) do
    Map.get_lazy(comparison_map, dimensions, fn -> empty_metrics(query, dimensions) end)
  end

  defp empty_metrics(query, dimensions) do
    query.metrics
    |> Enum.map(fn metric -> Metrics.default_value(metric, query, dimensions) end)
  end

  defp total_rows([]), do: 0
  defp total_rows([first_row | _rest]), do: first_row.total_rows
end
```

## File: `lib/plausible/stats/sql/expression.ex`
```
defmodule Plausible.Stats.SQL.Expression do
  @moduledoc """
  This module is responsible for generating SQL/Ecto expressions
  for dimensions and metrics used in query SELECT statement.

  Each dimension and metric is tagged with with selected_as for easier
  usage down the line.
  """

  use Plausible
  use Plausible.Stats.SQL.Fragments

  import Ecto.Query

  alias Plausible.Stats.{Query, Filters, SQL}

  @no_ref "Direct / None"
  @no_channel "Direct"
  @not_set "(not set)"

  defmacrop field_or_blank_value(q, key, expr, empty_value) do
    quote do
      select_merge_as(unquote(q), [t], %{
        unquote(key) =>
          fragment("if(empty(?), ?, ?)", unquote(expr), unquote(empty_value), unquote(expr))
      })
    end
  end

  defmacrop time_slots(query, period_in_seconds) do
    quote do
      fragment(
        "timeSlots(toTimeZone(?, ?), toUInt32(timeDiff(?, ?)), toUInt32(?))",
        s.start,
        ^unquote(query).timezone,
        s.start,
        s.timestamp,
        ^unquote(period_in_seconds)
      )
    end
  end

  def select_dimension(q, key, "time:month", _table, query) do
    select_merge_as(q, [t], %{
      key => fragment("toStartOfMonth(toTimeZone(?, ?))", t.timestamp, ^query.timezone)
    })
  end

  def select_dimension(q, key, "time:week", _table, query) do
    date_range = Query.date_range(query)

    select_merge_as(q, [t], %{
      key =>
        weekstart_not_before(
          to_timezone(t.timestamp, ^query.timezone),
          ^date_range.first
        )
    })
  end

  def select_dimension(q, key, "time:day", _table, query) do
    select_merge_as(q, [t], %{
      key => fragment("toDate(toTimeZone(?, ?))", t.timestamp, ^query.timezone)
    })
  end

  def select_dimension(q, key, "time:hour", :sessions, query) do
    # :TRICKY: ClickHouse timeSlots works off of unix epoch and is not
    #   timezone-aware. This means that for e.g. Asia/Katmandu (GMT+5:45)
    #   to work, we divide time into 15-minute buckets and later combine these
    #   via toStartOfHour
    q
    |> join(:inner, [s], time_slot in time_slots(query, 15 * 60),
      as: :time_slot,
      hints: "ARRAY",
      on: true
    )
    |> select_merge_as([s, time_slot: time_slot], %{
      key => fragment("toStartOfHour(?)", time_slot)
    })
  end

  def select_dimension(q, key, "time:hour", _table, query) do
    select_merge_as(q, [t], %{
      key => fragment("toStartOfHour(toTimeZone(?, ?))", t.timestamp, ^query.timezone)
    })
  end

  # :NOTE: This is not exposed in Query APIv2
  def select_dimension(q, key, "time:minute", :sessions, query) do
    q
    |> join(:inner, [s], time_slot in time_slots(query, 60),
      as: :time_slot,
      hints: "ARRAY",
      on: true
    )
    |> select_merge_as([s, time_slot: time_slot], %{
      key => fragment("?", time_slot)
    })
  end

  # :NOTE: This is not exposed in Query APIv2
  def select_dimension(q, key, "time:minute", _table, query) do
    select_merge_as(q, [t], %{
      key => fragment("toStartOfMinute(toTimeZone(?, ?))", t.timestamp, ^query.timezone)
    })
  end

  def select_dimension(q, key, "event:name", _table, _query),
    do: select_merge_as(q, [t], %{key => t.name})

  def select_dimension(q, key, "event:page", _table, _query),
    do: select_merge_as(q, [t], %{key => t.pathname})

  def select_dimension(q, key, "event:hostname", _table, _query),
    do: select_merge_as(q, [t], %{key => t.hostname})

  def select_dimension(q, key, "event:props:" <> property_name, _table, _query) do
    select_merge_as(q, [t], %{
      key =>
        fragment(
          "if(not empty(?), ?, '(none)')",
          get_by_key(t, :meta, ^property_name),
          get_by_key(t, :meta, ^property_name)
        )
    })
  end

  def select_dimension(q, key, "visit:entry_page", _table, _query),
    do: select_merge_as(q, [t], %{key => t.entry_page})

  def select_dimension(q, key, "visit:exit_page", _table, _query),
    do: select_merge_as(q, [t], %{key => t.exit_page})

  def select_dimension(q, key, "visit:utm_medium", _table, _query),
    do: field_or_blank_value(q, key, t.utm_medium, @not_set)

  def select_dimension(q, key, "visit:utm_source", _table, _query),
    do: field_or_blank_value(q, key, t.utm_source, @not_set)

  def select_dimension(q, key, "visit:utm_campaign", _table, _query),
    do: field_or_blank_value(q, key, t.utm_campaign, @not_set)

  def select_dimension(q, key, "visit:utm_content", _table, _query),
    do: field_or_blank_value(q, key, t.utm_content, @not_set)

  def select_dimension(q, key, "visit:utm_term", _table, _query),
    do: field_or_blank_value(q, key, t.utm_term, @not_set)

  def select_dimension(q, key, "visit:source", _table, _query),
    do: field_or_blank_value(q, key, t.source, @no_ref)

  def select_dimension(q, key, "visit:channel", _table, _query),
    do: field_or_blank_value(q, key, t.acquisition_channel, @no_channel)

  def select_dimension(q, key, "visit:referrer", _table, _query),
    do: field_or_blank_value(q, key, t.referrer, @no_ref)

  def select_dimension(q, key, "visit:device", _table, _query),
    do: field_or_blank_value(q, key, t.device, @not_set)

  def select_dimension(q, key, "visit:os", _table, _query),
    do: field_or_blank_value(q, key, t.os, @not_set)

  def select_dimension(q, key, "visit:os_version", _table, _query),
    do: field_or_blank_value(q, key, t.os_version, @not_set)

  def select_dimension(q, key, "visit:browser", _table, _query),
    do: field_or_blank_value(q, key, t.browser, @not_set)

  def select_dimension(q, key, "visit:browser_version", _table, _query),
    do: field_or_blank_value(q, key, t.browser_version, @not_set)

  def select_dimension(q, key, "visit:country", _table, _query),
    do: select_merge_as(q, [t], %{key => t.country})

  def select_dimension(q, key, "visit:region", _table, _query),
    do: select_merge_as(q, [t], %{key => t.region})

  def select_dimension(q, key, "visit:city", _table, _query),
    do: select_merge_as(q, [t], %{key => t.city})

  def select_dimension(q, key, "visit:country_name", _table, _query),
    do: select_merge_as(q, [t], %{key => t.country_name})

  def select_dimension(q, key, "visit:region_name", _table, _query),
    do: select_merge_as(q, [t], %{key => t.region_name})

  def select_dimension(q, key, "visit:city_name", _table, _query),
    do: select_merge_as(q, [t], %{key => t.city_name})

  def event_metric(:pageviews, _query) do
    wrap_alias([e], %{
      pageviews: scale_sample(fragment("countIf(? = 'pageview')", e.name))
    })
  end

  def event_metric(:events, _query) do
    wrap_alias([e], %{
      events: scale_sample(fragment("countIf(? != 'engagement')", e.name))
    })
  end

  def event_metric(:visitors, _query) do
    wrap_alias([e], %{
      visitors: scale_sample(fragment("uniq(?)", e.user_id))
    })
  end

  def event_metric(:visits, _query) do
    wrap_alias([e], %{
      visits: scale_sample(fragment("uniq(?)", e.session_id))
    })
  end

  on_ee do
    def event_metric(:total_revenue, _query) do
      wrap_alias(
        [e],
        %{
          total_revenue:
            fragment("toDecimal64(sum(?) * any(_sample_factor), 3)", e.revenue_reporting_amount)
        }
      )
    end

    def event_metric(:average_revenue, _query) do
      wrap_alias(
        [e],
        %{
          average_revenue:
            fragment("toDecimal64(avg(?) * any(_sample_factor), 3)", e.revenue_reporting_amount)
        }
      )
    end
  end

  def event_metric(:sample_percent, _query) do
    wrap_alias([], %{
      sample_percent:
        fragment("if(any(_sample_factor) > 1, round(100 / any(_sample_factor)), 100)")
    })
  end

  def event_metric(:percentage, _query), do: %{}
  def event_metric(:conversion_rate, _query), do: %{}
  def event_metric(:scroll_depth, _query), do: %{}
  def event_metric(:group_conversion_rate, _query), do: %{}
  def event_metric(:total_visitors, _query), do: %{}

  def event_metric(:time_on_page, query) do
    selected =
      case query.time_on_page_data do
        %{include_new_metric: false} ->
          wrap_alias(
            [e],
            %{
              # :KLUDGE: We would like to but can't use constant 0 here as it leads to cyclic aliases if there's no other
              # metrics selected other than time_on_page.
              __internal_total_time_on_page: fragment("sumArray([0])"),
              __internal_total_time_on_page_visits: fragment("sumArray([0])")
            }
          )

        %{include_new_metric: true, cutoff: nil} ->
          wrap_alias(
            [e],
            %{
              __internal_total_time_on_page: fragment("sum(?) / 1000", e.engagement_time),
              __internal_total_time_on_page_visits:
                fragment("uniqIf(?, ? = 'engagement')", e.session_id, e.name)
            }
          )

        %{include_new_metric: true, cutoff: cutoff} ->
          wrap_alias(
            [e],
            %{
              __internal_total_time_on_page:
                fragment(
                  "sumIf(?, ? >= ?) / 1000",
                  e.engagement_time,
                  e.timestamp,
                  ^cutoff
                ),
              __internal_total_time_on_page_visits:
                fragment(
                  "uniqIf(?, ? = 'engagement' and ? >= ?)",
                  e.session_id,
                  e.name,
                  e.timestamp,
                  ^cutoff
                )
            }
          )
      end

    if query.time_on_page_data.include_legacy_metric do
      selected
    else
      Map.merge(
        selected,
        wrap_alias([e], %{
          time_on_page:
            time_on_page(
              selected_as(:__internal_total_time_on_page),
              selected_as(:__internal_total_time_on_page_visits)
            )
        })
      )
    end
  end

  def event_metric(unknown, _query), do: raise("Unknown metric: #{unknown}")

  def session_metric(:bounce_rate, query) do
    # :TRICKY: If page is passed to query, we only count bounce rate where users _entered_ at page.
    event_page_filter = Filters.get_toplevel_filter(query, "event:page")
    condition = SQL.WhereBuilder.build_condition(:entry_page, event_page_filter)

    wrap_alias([], %{
      bounce_rate:
        fragment(
          # :TRICKY: Before PR #4493, we could have sessions where `sum(is_bounce * sign)`
          # is negative, leading to an underflow and >100% bounce rate. This works around
          # that issue.
          "toUInt32(greatest(ifNotFinite(round(sumIf(is_bounce * sign, ?) / sumIf(sign, ?) * 100), 0), 0))",
          ^condition,
          ^condition
        ),
      __internal_visits: fragment("toUInt32(greatest(sum(sign), 0))")
    })
  end

  def session_metric(:exit_rate, _query) do
    wrap_alias([s], %{
      __internal_visits: fragment("toUInt32(greatest(sum(sign), 0))")
    })
  end

  def session_metric(:visits, _query) do
    wrap_alias([s], %{
      visits: scale_sample(fragment("greatest(sum(?), 0)", s.sign))
    })
  end

  def session_metric(:pageviews, _query) do
    wrap_alias([s], %{
      pageviews: scale_sample(fragment("greatest(sum(? * ?), 0)", s.sign, s.pageviews))
    })
  end

  def session_metric(:events, _query) do
    wrap_alias([s], %{
      events: scale_sample(fragment("greatest(sum(? * ?), 0)", s.sign, s.events))
    })
  end

  def session_metric(:visitors, _query) do
    wrap_alias([s], %{
      visitors: scale_sample(fragment("uniq(?)", s.user_id))
    })
  end

  def session_metric(:visit_duration, _query) do
    wrap_alias([], %{
      visit_duration:
        fragment("toUInt32(greatest(ifNotFinite(round(sum(duration * sign) / sum(sign)), 0), 0))"),
      __internal_visits: fragment("toUInt32(greatest(sum(sign), 0))")
    })
  end

  def session_metric(:views_per_visit, _query) do
    wrap_alias([s], %{
      views_per_visit:
        fragment(
          "greatest(ifNotFinite(round(sum(? * ?) / sum(?), 2), 0), 0)",
          s.sign,
          s.pageviews,
          s.sign
        ),
      __internal_visits: fragment("toUInt32(greatest(sum(sign), 0))")
    })
  end

  def session_metric(:sample_percent, _query) do
    wrap_alias([], %{
      sample_percent:
        fragment("if(any(_sample_factor) > 1, round(100 / any(_sample_factor)), 100)")
    })
  end

  def session_metric(:percentage, _query), do: %{}
  def session_metric(:conversion_rate, _query), do: %{}
  def session_metric(:group_conversion_rate, _query), do: %{}

  defmacro event_goal_join(goal_join_data) do
    quote do
      fragment(
        """
        arrayIntersect(
          multiMatchAllIndices(?, ?),
          arrayMap(
            (expected_name, threshold, index) -> if(expected_name = ? and ? between threshold and 100, index, -1),
            ?,
            ?,
            ?
          )
        )
        """,
        e.pathname,
        type(^unquote(goal_join_data).page_regexes, {:array, :string}),
        e.name,
        e.scroll_depth,
        type(^unquote(goal_join_data).event_names_by_type, {:array, :string}),
        type(^unquote(goal_join_data).scroll_thresholds, {:array, :integer}),
        type(^unquote(goal_join_data).indices, {:array, :integer})
      )
    end
  end
end
```

## File: `lib/plausible/stats/sql/fragments.ex`
```
defmodule Plausible.Stats.SQL.Fragments do
  @moduledoc """
  Various macros and common SQL fragments used in Stats code.
  """

  defmacro __using__(_) do
    quote do
      import Plausible.Stats.SQL.Fragments
      require Plausible.Stats.SQL.Fragments
    end
  end

  defmacro scale_sample(sampled_fragment) do
    quote do
      fragment("toUInt64(round(? * any(_sample_factor)))", unquote(sampled_fragment))
    end
  end

  defmacro uniq(user_id) do
    quote do
      scale_sample(fragment("uniq(?)", unquote(user_id)))
    end
  end

  defmacro total() do
    quote do
      scale_sample(fragment("count()"))
    end
  end

  defmacro sample_percent() do
    quote do
      fragment("if(any(_sample_factor) > 1, round(100 / any(_sample_factor)), 100)")
    end
  end

  defmacro bounce_rate() do
    quote do
      fragment(
        # :TRICKY: Before PR #4493, we could have sessions where `sum(is_bounce * sign)`
        # is negative, leading to an underflow and >100% bounce rate. This works around
        # that issue.
        "toUInt32(greatest(ifNotFinite(round(sum(is_bounce * sign) / sum(sign) * 100), 0), 0))"
      )
    end
  end

  defmacro visit_duration() do
    quote do
      fragment("toUInt32(ifNotFinite(round(avg(duration * sign)), 0))")
    end
  end

  defmacro coalesce_string(fieldA, fieldB) do
    quote do
      fragment("if(empty(?), ?, ?)", unquote(fieldA), unquote(fieldB), unquote(fieldA))
    end
  end

  @doc """
  Converts time or date and time to the specified timezone.

  Reference: https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions/#totimezone
  """
  defmacro to_timezone(date, timezone) do
    quote do
      fragment("toTimeZone(?, ?)", unquote(date), unquote(timezone))
    end
  end

  @doc """
  Returns the weekstart for `date`. If the weekstart is before the `not_before`
  boundary, `not_before` is returned.

  ## Examples

  In this pseudo-code example, the fragment returns the weekstart. The
  `not_before` boundary is set to the past Saturday, which is before the
  weekstart, therefore the cap does not apply.

    ```
    > this_wednesday = ~D[2022-11-09]
    > past_saturday = ~D[2022-11-05]
    > weekstart_not_before(this_wednesday, past_saturday)
    ~D[2022-11-07]
    ```

  In this other example, the fragment returns Tuesday and not the weekstart.
  The `not_before` boundary is set to Tuesday, which is past the weekstart,
  therefore the cap applies.

    ```
    > this_wednesday = ~D[2022-11-09]
    > this_tuesday = ~D[2022-11-08]
    > weekstart_not_before(this_wednesday, this_tuesday)
    ~D[2022-11-08]
    ```
  """
  defmacro weekstart_not_before(date, not_before) do
    quote do
      fragment(
        "if(toMonday(?) < toDate(?), toDate(?), toMonday(?))",
        unquote(date),
        unquote(not_before),
        unquote(not_before),
        unquote(date)
      )
    end
  end

  @doc """
  Returns whether a key (usually property) exists under `meta.key` array or similar.

  This macro is used for operating on custom properties.

  ## Examples

  `has_key(e, :meta, "some_property_name")` expands to SQL `has(meta.key, "some_property_name")`
  """
  defmacro has_key(table, meta_column, key) do
    quote do
      fragment(
        "has(?, ?)",
        field(unquote(table), ^meta_key_column(unquote(meta_column))),
        unquote(key)
      )
    end
  end

  @doc """
  Returns value of a key (usually property) under `meta.value` array or similar.

  This macro is used for operating on custom properties.
  Callsites should also check whether key exists first in SQL via `has_key` macro.

  ## Examples

  `get_by_key(e, :meta, "some_property_name")` expands to SQL `meta.value[indexOf(meta.key, "some_property")]`
  """
  defmacro get_by_key(table, meta_column, key) do
    quote do
      fragment(
        "?[indexOf(?, ?)]",
        field(unquote(table), ^meta_value_column(unquote(meta_column))),
        field(unquote(table), ^meta_key_column(unquote(meta_column))),
        unquote(key)
      )
    end
  end

  def meta_key_column(:meta), do: :"meta.key"
  def meta_key_column(:entry_meta), do: :"entry_meta.key"

  def meta_value_column(:meta), do: :"meta.value"
  def meta_value_column(:entry_meta), do: :"entry_meta.value"

  defmacro time_on_page(total_time_on_page, total_time_on_page_visits) do
    quote do
      fragment(
        "if(? > 0, toInt32(round((?) / (?))), NULL)",
        unquote(total_time_on_page_visits),
        unquote(total_time_on_page),
        unquote(total_time_on_page_visits)
      )
    end
  end

  @doc """
  Convenience Ecto macro for wrapping a map passed to select_merge_as such that each
  expression gets wrapped in dynamic and set as selected_as.

  ### Examples

    iex> wrap_alias([t], %{ foo: t.column }) |> expand_macro_once
    "%{foo: dynamic([t], selected_as(t.column, :foo))}"
  """
  defmacro wrap_alias(binding, map_literal) do
    update_literal_map_values(map_literal, fn {key, expr} ->
      key_expr =
        if Macro.quoted_literal?(key) do
          key
        else
          quote(do: ^unquote(key))
        end

      quote(do: dynamic(unquote(binding), selected_as(unquote(expr), unquote(key_expr))))
    end)
  end

  @doc """
  Convenience Ecto macro for wrapping select_merge where each value gets in turn passed to selected_as.

  ### Examples

    iex> select_merge_as(q, [t], %{ foo: t.column }) |> expand_macro_once
    "select_merge(q, [], ^wrap_alias([t], %{foo: t.column}))"
  """
  defmacro select_merge_as(q, binding, map_literal) do
    quote do
      select_merge(unquote(q), [], ^wrap_alias(unquote(binding), unquote(map_literal)))
    end
  end

  @doc """
  Macro that helps join two Ecto queries by selecting fields from either one
  """
  defmacro select_join_fields(q, query, list, table_name) do
    quote do
      Enum.reduce(unquote(list), unquote(q), fn metric_or_dimension, q ->
        key = shortname(unquote(query), metric_or_dimension)

        select_merge_as(q, [e, s], %{
          key => field(unquote(table_name), ^key)
        })
      end)
    end
  end

  defp update_literal_map_values({:%{}, ctx, keyword_list}, mapper_fn) do
    {
      :%{},
      ctx,
      Enum.map(keyword_list, fn {key, expr} ->
        {key, mapper_fn.({key, expr})}
      end)
    }
  end

  defp update_literal_map_values(ast, _), do: ast
end
```

## File: `lib/plausible/stats/sql/query_builder.ex`
```
defmodule Plausible.Stats.SQL.QueryBuilder do
  @moduledoc false

  use Plausible
  use Plausible.Stats.SQL.Fragments

  import Ecto.Query
  import Plausible.Stats.Imported
  import Plausible.Stats.Util

  alias Plausible.Stats.{Query, QueryOptimizer, TableDecider, SQL}
  alias Plausible.Stats.SQL.Expression
  alias Plausible.Stats.Legacy.TimeOnPage

  require Plausible.Stats.SQL.Expression

  def build(query, site) do
    {event_query, sessions_query} = QueryOptimizer.split(query)

    event_q = build_events_query(site, event_query)
    sessions_q = build_sessions_query(site, sessions_query)

    join_query_results(
      {event_q, event_query},
      {sessions_q, sessions_query}
    )
    |> paginate(query.pagination)
    |> select_total_rows(query.include.total_rows)
  end

  def build_order_by(q, query) do
    Enum.reduce(query.order_by || [], q, &build_order_by(&2, query, &1))
  end

  defp build_events_query(_site, %Query{metrics: []}), do: nil

  defp build_events_query(site, events_query) do
    q =
      from(
        e in "events_v2",
        where: ^SQL.WhereBuilder.build(:events, events_query),
        select: ^select_event_metrics(events_query)
      )

    on_ee do
      q = Plausible.Stats.Sampling.add_query_hint(q, events_query)
    end

    q
    |> join_sessions_if_needed(events_query)
    |> build_group_by(:events, events_query)
    |> merge_imported(site, events_query)
    |> SQL.SpecialMetrics.add(site, events_query)
    |> TimeOnPage.merge_legacy_time_on_page(events_query)
  end

  defp join_sessions_if_needed(q, query) do
    if TableDecider.events_join_sessions?(query) do
      sessions_q =
        from(
          s in "sessions_v2",
          where: ^SQL.WhereBuilder.build(:sessions, query),
          where: s.sign == 1,
          select: %{session_id: s.session_id},
          group_by: s.session_id
        )

      on_ee do
        sessions_q = Plausible.Stats.Sampling.add_query_hint(sessions_q, query)
      end

      from(
        e in q,
        join: sq in subquery(sessions_q),
        on: e.session_id == sq.session_id
      )
    else
      q
    end
  end

  defp build_sessions_query(_site, %Query{metrics: []}), do: nil

  defp build_sessions_query(site, sessions_query) do
    q =
      from(
        e in "sessions_v2",
        where: ^SQL.WhereBuilder.build(:sessions, sessions_query),
        select: ^select_session_metrics(sessions_query)
      )

    on_ee do
      q = Plausible.Stats.Sampling.add_query_hint(q, sessions_query)
    end

    q
    |> join_events_if_needed(sessions_query)
    |> build_group_by(:sessions, sessions_query)
    |> merge_imported(site, sessions_query)
    |> SQL.SpecialMetrics.add(site, sessions_query)
  end

  def join_events_if_needed(q, query) do
    if TableDecider.sessions_join_events?(query) do
      events_q =
        from(e in "events_v2",
          where: ^SQL.WhereBuilder.build(:events, query),
          select: %{
            session_id: fragment("DISTINCT ?", e.session_id),
            _sample_factor: fragment("_sample_factor")
          }
        )

      on_ee do
        events_q = Plausible.Stats.Sampling.add_query_hint(events_q, query)
      end

      from(s in q,
        join: e in subquery(events_q),
        on: s.session_id == e.session_id
      )
    else
      q
    end
  end

  defp select_event_metrics(query) do
    query.metrics
    |> Enum.map(&SQL.Expression.event_metric(&1, query))
    |> Enum.reduce(%{}, &Map.merge/2)
  end

  defp select_session_metrics(query) do
    query.metrics
    |> Enum.map(&SQL.Expression.session_metric(&1, query))
    |> Enum.reduce(%{}, &Map.merge/2)
  end

  def build_group_by(q, table, query) do
    Enum.reduce(query.dimensions, q, &dimension_group_by(&2, table, query, &1))
  end

  defp dimension_group_by(q, :events, query, "event:goal" = dimension) do
    goal_join_data = Plausible.Stats.Goals.goal_join_data(query)

    from(e in q,
      join: goal in Expression.event_goal_join(goal_join_data),
      hints: "ARRAY",
      on: true,
      select_merge: %{
        ^shortname(query, dimension) => fragment("?", goal)
      },
      group_by: goal
    )
  end

  defp dimension_group_by(q, table, query, dimension) do
    key = shortname(query, dimension)

    q
    |> Expression.select_dimension(key, dimension, table, query)
    |> group_by([], selected_as(^key))
  end

  defp build_order_by(q, query, {metric_or_dimension, order_direction}) do
    order_by(
      q,
      [t],
      {
        ^order_direction,
        selected_as(^shortname(query, metric_or_dimension))
      }
    )
  end

  defp join_query_results({nil, _}, {nil, _}), do: nil

  defp join_query_results({events_q, events_query}, {nil, _}),
    do: events_q |> build_order_by(events_query)

  defp join_query_results({nil, events_query}, {sessions_q, _}),
    do: sessions_q |> build_order_by(events_query)

  defp join_query_results({events_q, events_query}, {sessions_q, sessions_query}) do
    {join_type, events_q_fields, sessions_q_fields} =
      TableDecider.join_options(events_query, sessions_query)

    join(subquery(events_q), join_type, [e], s in subquery(sessions_q),
      on: ^build_group_by_join(events_query)
    )
    |> select_join_fields(events_query, events_q_fields, e)
    |> select_join_fields(sessions_query, sessions_q_fields, s)
    |> build_order_by(events_query)
  end

  # NOTE: Old queries do their own pagination
  defp paginate(q, nil = _pagination), do: q

  defp paginate(q, pagination) do
    q
    |> limit(^pagination.limit)
    |> offset(^pagination.offset)
  end

  defp select_total_rows(q, false = _include_total_rows), do: q

  defp select_total_rows(q, true = _include_total_rows) do
    q
    |> select_merge([], %{total_rows: fragment("count() over ()")})
  end

  def build_group_by_join(%Query{dimensions: []}), do: true

  def build_group_by_join(query) do
    query.dimensions
    |> Enum.map(fn dim ->
      dynamic([e, s], field(e, ^shortname(query, dim)) == field(s, ^shortname(query, dim)))
    end)
    |> Enum.reduce(fn condition, acc -> dynamic([], ^acc and ^condition) end)
  end
end
```

## File: `lib/plausible/stats/sql/special_metrics.ex`
```
defmodule Plausible.Stats.SQL.SpecialMetrics do
  @moduledoc """
  This module defines how special metrics like `conversion_rate` and
  `percentage` are calculated.
  """

  use Plausible.Stats.SQL.Fragments

  alias Plausible.Stats.{Base, Query, SQL, Filters}

  import Ecto.Query
  import Plausible.Stats.Util

  @special_metrics [
    :percentage,
    :conversion_rate,
    :group_conversion_rate,
    :scroll_depth,
    :exit_rate
  ]

  def add(q, site, query) do
    Enum.reduce(@special_metrics, q, fn special_metric, q ->
      if special_metric in query.metrics do
        add_special_metric(q, special_metric, site, query)
      else
        q
      end
    end)
  end

  defp add_special_metric(q, :percentage, site, query) do
    total_query =
      query
      |> remove_filters_ignored_in_totals_query()
      |> Query.set(
        dimensions: [],
        include_imported: query.include_imported,
        pagination: nil
      )

    q
    |> select_merge_as([], total_visitors_subquery(site, total_query, query.include_imported))
    |> select_merge_as([], %{
      percentage:
        fragment(
          "if(? > 0, round(? / ? * 100, 1), null)",
          selected_as(:total_visitors),
          selected_as(:visitors),
          selected_as(:total_visitors)
        )
    })
  end

  # Adds conversion_rate metric to query, calculated as
  # X / Y where Y is the same breakdown value without goal or props
  # filters.
  defp add_special_metric(q, :conversion_rate, site, query) do
    total_query =
      query
      |> Query.remove_top_level_filters(["event:goal", "event:props"])
      |> remove_filters_ignored_in_totals_query()
      |> Query.set(
        dimensions: [],
        include_imported: query.include_imported,
        preloaded_goals: Map.put(query.preloaded_goals, :matching_toplevel_filters, []),
        pagination: nil
      )

    q
    |> select_merge_as(
      [],
      total_visitors_subquery(site, total_query, query.include_imported)
    )
    |> select_merge_as([e], %{
      conversion_rate:
        fragment(
          "if(? > 0, round(? / ? * 100, 2), 0)",
          selected_as(:total_visitors),
          selected_as(:visitors),
          selected_as(:total_visitors)
        )
    })
  end

  # This function injects a group_conversion_rate metric into
  # a dimensional query. It is calculated as X / Y, where:
  #
  #   * X is the number of conversions for a set of dimensions
  #     result (conversion = number of visitors who
  #     completed the filtered goal with the filtered
  #     custom properties).
  #
  #  * Y is the number of all visitors for this set of dimensions
  #    result without the `event:goal` and `event:props:*`
  #    filters.
  defp add_special_metric(q, :group_conversion_rate, site, query) do
    group_totals_query =
      query
      |> Query.remove_top_level_filters(["event:goal", "event:props"])
      |> remove_filters_ignored_in_totals_query()
      |> Query.set(
        metrics: [:visitors],
        order_by: [],
        include_imported: query.include_imported,
        preloaded_goals: Map.put(query.preloaded_goals, :matching_toplevel_filters, []),
        pagination: nil
      )

    from(e in subquery(q),
      left_join: c in subquery(SQL.QueryBuilder.build(group_totals_query, site)),
      on: ^SQL.QueryBuilder.build_group_by_join(query)
    )
    |> select_merge_as([e, c], %{
      total_visitors: c.visitors,
      group_conversion_rate:
        fragment(
          "if(? > 0, round(? / ? * 100, 2), 0)",
          c.visitors,
          e.visitors,
          c.visitors
        )
    })
    |> select_join_fields(query, query.dimensions, e)
    |> select_join_fields(query, List.delete(query.metrics, :group_conversion_rate), e)
  end

  defp add_special_metric(q, :scroll_depth, _site, query) do
    max_per_session_q =
      Base.base_event_query(query)
      |> where([e], e.name == "engagement" and e.scroll_depth <= 100)
      |> select([e], %{
        session_id: e.session_id,
        max_scroll_depth: max(e.scroll_depth)
      })
      |> SQL.QueryBuilder.build_group_by(:events, query)
      |> group_by([e], e.session_id)

    dim_shortnames = Enum.map(query.dimensions, fn dim -> shortname(query, dim) end)

    dim_select =
      dim_shortnames
      |> Enum.map(fn dim -> {dim, dynamic([p], field(p, ^dim))} end)
      |> Map.new()

    dim_group_by =
      dim_shortnames
      |> Enum.map(fn dim -> dynamic([p], field(p, ^dim)) end)

    total_scroll_depth_q =
      subquery(max_per_session_q)
      |> select([], %{})
      |> select_merge_as([p], %{
        # Note: No need to upscale sample size here since it would end up cancelling out due to the result being an average
        total_scroll_depth: fragment("sum(?)", p.max_scroll_depth),
        total_scroll_depth_visits: fragment("uniq(?)", p.session_id)
      })
      |> select_merge(^dim_select)
      |> group_by(^dim_group_by)

    join_on_dim_condition =
      if dim_shortnames == [] do
        true
      else
        dim_shortnames
        |> Enum.map(fn dim -> dynamic([_e, ..., s], selected_as(^dim) == field(s, ^dim)) end)
        # credo:disable-for-next-line Credo.Check.Refactor.Nesting
        |> Enum.reduce(fn condition, acc -> dynamic([], ^acc and ^condition) end)
      end

    joined_q =
      join(q, :left, [e], s in subquery(total_scroll_depth_q), on: ^join_on_dim_condition)

    if query.include_imported do
      joined_q
      |> select_merge_as([..., s], %{
        scroll_depth:
          fragment(
            """
            if(? + ? > 0, toInt8(round((? + ?) / (? + ?))), NULL)
            """,
            s.total_scroll_depth_visits,
            selected_as(:__imported_total_scroll_depth_visits),
            s.total_scroll_depth,
            selected_as(:__imported_total_scroll_depth),
            s.total_scroll_depth_visits,
            selected_as(:__imported_total_scroll_depth_visits)
          )
      })
    else
      joined_q
      |> select_merge_as([..., s], %{
        scroll_depth:
          fragment(
            "if(any(?) > 0, toUInt8(round(any(?) / any(?))), NULL)",
            s.total_scroll_depth_visits,
            s.total_scroll_depth,
            s.total_scroll_depth_visits
          )
      })
    end
  end

  # Selects exit_rate into the query, calculated as X / Y, where X is the
  # total number of exits from a page (i.e. the number of sessions with a
  # specific exit page), and Y is the total pageviews on that page.
  defp add_special_metric(q, :exit_rate, site, query) do
    total_pageviews_query =
      query
      |> Query.remove_top_level_filters(["visit:exit_page"])
      |> remove_filters_ignored_in_totals_query()
      |> Query.set(
        pagination: nil,
        order_by: [],
        metrics: [:pageviews],
        include_imported: query.include_imported,
        dimensions: ["event:page"]
      )

    joined_q =
      q
      |> join(:left, [], p in subquery(SQL.QueryBuilder.build(total_pageviews_query, site)),
        on:
          selected_as(^shortname(query, "visit:exit_page")) ==
            field(p, ^shortname(total_pageviews_query, "event:page"))
      )

    if query.include_imported do
      joined_q
      |> select_merge_as([..., p], %{
        exit_rate:
          fragment(
            "if(? > 0, round(? / ? * 100, 1), NULL)",
            p.pageviews,
            selected_as(:__internal_visits),
            p.pageviews
          )
      })
    else
      joined_q
      |> select_merge_as([..., p], %{
        exit_rate:
          fragment(
            "if(? > 0, round(? / ? * 100, 1), NULL)",
            fragment("any(?)", p.pageviews),
            selected_as(:__internal_visits),
            fragment("any(?)", p.pageviews)
          )
      })
    end
  end

  # `total_visitors_subquery` returns a subquery which selects `total_visitors` -
  # the number used as the denominator in the calculation of `conversion_rate` and
  # `percentage` metrics.

  # Usually, when calculating the totals, a new query is passed into this function,
  # where certain filters (e.g. goal, props) are removed. That might make the query
  # able to include imported data. However, we always want to include imported data
  # only if it's included in the base query - otherwise the total will be based on
  # a different data set, making the metric inaccurate. This is why we're using an
  # explicit `include_imported` argument here.
  defp total_visitors_subquery(site, query, include_imported)

  defp total_visitors_subquery(site, query, true = _include_imported) do
    wrap_alias([], %{
      total_visitors:
        subquery(total_visitors(query)) +
          subquery(Plausible.Stats.Imported.total_imported_visitors(site, query))
    })
  end

  defp total_visitors_subquery(_site, query, false = _include_imported) do
    wrap_alias([], %{
      total_visitors: subquery(total_visitors(query))
    })
  end

  defp remove_filters_ignored_in_totals_query(query) do
    totals_query_filters =
      Filters.transform_filters(query.filters, fn
        [:ignore_in_totals_query, _] -> []
        filter -> [filter]
      end)

    Query.set(query, filters: totals_query_filters)
  end

  defp total_visitors(query) do
    Base.base_event_query(query)
    |> select([e],
      total_visitors: scale_sample(fragment("uniq(?)", e.user_id))
    )
  end
end
```

## File: `lib/plausible/stats/sql/where_builder.ex`
```
defmodule Plausible.Stats.SQL.WhereBuilder do
  @moduledoc """
  A module for building am ecto where clause of a query out of a query.
  """

  import Ecto.Query
  import Plausible.Stats.Time, only: [utc_boundaries: 1]
  import Plausible.Stats.Filters.Utils, only: [page_regex: 1]

  use Plausible.Stats.SQL.Fragments

  require Logger

  @sessions_only_visit_fields [
    :entry_page,
    :exit_page,
    :entry_page_hostname,
    :exit_page_hostname
  ]

  @doc "Builds WHERE clause for a given Query against sessions or events table"
  def build(table, query) do
    base_condition = filter_site_time_range(table, query)

    query.filters
    |> Enum.map(&add_filter(table, query, &1))
    |> Enum.reduce(base_condition, fn condition, acc -> dynamic([], ^acc and ^condition) end)
  end

  @doc """
  Builds WHERE clause condition based off of a filter and a custom column name
  Used for special business logic cases

  Accepts nil as the `filter` parameter, in which case the condition is a no-op (WHERE TRUE).
  """
  def build_condition(db_field, filter) do
    if filter do
      filter_field(db_field, filter)
    else
      true
    end
  end

  defp filter_site_time_range(:events, query) do
    {first_datetime, last_datetime} = utc_boundaries(query)

    dynamic(
      [e],
      e.site_id == ^query.site_id and e.timestamp >= ^first_datetime and
        e.timestamp <= ^last_datetime
    )
  end

  defp filter_site_time_range(:sessions, query) do
    {first_datetime, last_datetime} = utc_boundaries(query)

    # Counts each _active_ session in time range even if they started before
    dynamic(
      [s],
      # Currently, the sessions table in ClickHouse only has `start` column
      # in its primary key. This means that filtering by `timestamp` is not
      # considered when estimating number of returned rows from index
      # for sample factor calculation. The redundant lower bound `start` condition
      # ensures the lower bound time filter is still present as primary key
      # condition and the sample factor estimation has minimal skew.
      #
      # Without it, the sample factor would be greatly overestimated for large sites,
      # as query would be estimated to return _all_ rows matching other conditions
      # before `start == last_datetime`.
      s.site_id == ^query.site_id and
        s.start >= ^NaiveDateTime.add(first_datetime, -7, :day) and
        s.timestamp >= ^first_datetime and
        s.start <= ^last_datetime
    )
  end

  defp add_filter(table, query, [:ignore_in_totals_query, filter]) do
    add_filter(table, query, filter)
  end

  defp add_filter(table, query, [:not, filter]) do
    dynamic([e], not (^add_filter(table, query, filter)))
  end

  defp add_filter(table, query, [:and, filters]) do
    filters
    |> Enum.map(&add_filter(table, query, &1))
    |> Enum.reduce(fn condition, acc -> dynamic([], ^acc and ^condition) end)
  end

  defp add_filter(table, query, [:or, filters]) do
    filters
    |> Enum.map(&add_filter(table, query, &1))
    |> Enum.reduce(fn condition, acc -> dynamic([], ^acc or ^condition) end)
  end

  defp add_filter(_table, query, [:has_done, filter]) do
    condition =
      dynamic([], ^filter_site_time_range(:events, query) and ^add_filter(:events, query, filter))

    dynamic(
      [t],
      t.session_id in subquery(from(e in "events_v2", where: ^condition, select: e.session_id))
    )
  end

  defp add_filter(table, query, [:has_not_done, filter]) do
    dynamic([], not (^add_filter(table, query, [:has_done, filter])))
  end

  defp add_filter(:events, _query, [:is, "event:name" | _rest] = filter) do
    in_clause(col_value(:name), filter)
  end

  defp add_filter(:events, query, [_, "event:goal" | _rest] = filter) do
    Plausible.Stats.Goals.add_filter(query, filter)
  end

  defp add_filter(:events, _query, [_, "event:page" | _rest] = filter) do
    filter_field(:pathname, filter)
  end

  defp add_filter(:events, _query, [_, "event:hostname" | _rest] = filter) do
    filter_field(:hostname, filter)
  end

  defp add_filter(:events, _query, [_, "event:props:" <> prop_name | _rest] = filter) do
    filter_custom_prop(prop_name, :meta, filter)
  end

  defp add_filter(:events, _query, [_, "visit:entry_props:" <> _prop_name | _rest]) do
    true
  end

  defp add_filter(
         :events,
         _query,
         [_, "visit:" <> key | _rest] = filter
       ) do
    # Filter events query with visit dimension if possible
    field_name = db_field_name(key)

    if Enum.member?(@sessions_only_visit_fields, field_name) do
      true
    else
      filter_field(field_name, filter)
    end
  end

  defp add_filter(:sessions, _query, [_, "visit:entry_props:" <> prop_name | _rest] = filter) do
    filter_custom_prop(prop_name, :entry_meta, filter)
  end

  defp add_filter(:sessions, _query, [_, "visit:" <> key | _rest] = filter) do
    filter_field(db_field_name(key), filter)
  end

  defp add_filter(:sessions, _query, [_, "event:" <> _ | _rest]) do
    # Cannot apply sessions filters directly on session query where clause.
    true
  end

  defp add_filter(table, _query, filter) do
    Logger.notice("Unable to process garbage filter. No results are returned",
      table: table,
      filter: filter
    )

    false
  end

  defp filter_custom_prop(prop_name, column_name, [:is, _, clauses | _rest] = filter) do
    none_value_included = Enum.member?(clauses, "(none)")
    prop_value_expr = custom_prop_value(column_name, prop_name)

    dynamic(
      [t],
      (has_key(t, column_name, ^prop_name) and ^in_clause(prop_value_expr, filter)) or
        (^none_value_included and not has_key(t, column_name, ^prop_name))
    )
  end

  defp filter_custom_prop(prop_name, column_name, [:is_not, _, clauses | _rest] = filter) do
    none_value_included = Enum.member?(clauses, "(none)")
    prop_value_expr = custom_prop_value(column_name, prop_name)

    dynamic(
      [t],
      (has_key(t, column_name, ^prop_name) and
         not (^in_clause(prop_value_expr, filter))) or
        (^none_value_included and
           has_key(t, column_name, ^prop_name) and
           not (^in_clause(prop_value_expr, filter))) or
        (not (^none_value_included) and not has_key(t, column_name, ^prop_name))
    )
  end

  defp filter_custom_prop(prop_name, column_name, [:matches_wildcard, dimension, clauses | rest]) do
    regexes = Enum.map(clauses, &page_regex/1)

    filter_custom_prop(prop_name, column_name, [:matches, dimension, regexes | rest])
  end

  defp filter_custom_prop(prop_name, column_name, [
         :matches_wildcard_not,
         dimension,
         clauses | rest
       ]) do
    regexes = Enum.map(clauses, &page_regex/1)

    filter_custom_prop(prop_name, column_name, [:matches_not, dimension, regexes | rest])
  end

  defp filter_custom_prop(prop_name, column_name, [:matches, _dimension, clauses | _rest]) do
    dynamic(
      [t],
      has_key(t, column_name, ^prop_name) and
        fragment(
          "arrayExists(k -> match(?, k), ?)",
          get_by_key(t, column_name, ^prop_name),
          ^clauses
        )
    )
  end

  defp filter_custom_prop(prop_name, column_name, [:matches_not, _dimension, clauses | _rest]) do
    dynamic(
      [t],
      has_key(t, column_name, ^prop_name) and
        fragment(
          "not(arrayExists(k -> match(?, k), ?))",
          get_by_key(t, column_name, ^prop_name),
          ^clauses
        )
    )
  end

  defp filter_custom_prop(prop_name, column_name, [:contains | _rest] = filter) do
    dynamic(
      [t],
      has_key(t, column_name, ^prop_name) and
        ^contains_clause(custom_prop_value(column_name, prop_name), filter)
    )
  end

  defp filter_custom_prop(prop_name, column_name, [:contains_not | _] = filter) do
    dynamic(
      [t],
      has_key(t, column_name, ^prop_name) and
        not (^contains_clause(custom_prop_value(column_name, prop_name), filter))
    )
  end

  defp filter_field(db_field, [:matches_wildcard, _dimension, glob_exprs | _rest]) do
    page_regexes = Enum.map(glob_exprs, &page_regex/1)

    dynamic(
      [x],
      fragment("multiMatchAny(?, ?)", type(field(x, ^db_field), :string), ^page_regexes)
    )
  end

  defp filter_field(db_field, [:matches_wildcard_not | rest]) do
    dynamic([], not (^filter_field(db_field, [:matches_wildcard | rest])))
  end

  defp filter_field(db_field, [:contains | _rest] = filter) do
    contains_clause(col_value_string(db_field), filter)
  end

  defp filter_field(db_field, [:contains_not | rest]) do
    dynamic([], not (^filter_field(db_field, [:contains | rest])))
  end

  defp filter_field(db_field, [:matches, _dimension, clauses | _rest]) do
    dynamic(
      [x],
      fragment("multiMatchAny(?, ?)", type(field(x, ^db_field), :string), ^clauses)
    )
  end

  defp filter_field(db_field, [:matches_not | rest]) do
    dynamic([], not (^filter_field(db_field, [:matches | rest])))
  end

  defp filter_field(db_field, [:is, _dimension, clauses | _rest] = filter) do
    list = clauses |> Enum.map(&db_field_val(db_field, &1))
    in_clause(col_value(db_field), filter, list)
  end

  defp filter_field(db_field, [:is_not | rest]) do
    dynamic([], not (^filter_field(db_field, [:is | rest])))
  end

  @no_ref "Direct / None"
  @not_set "(not set)"

  defp db_field_name("channel"), do: :acquisition_channel
  defp db_field_name(name), do: String.to_existing_atom(name)

  defp db_field_val(:source, @no_ref), do: ""
  defp db_field_val(:referrer, @no_ref), do: ""
  defp db_field_val(:utm_medium, @no_ref), do: ""
  defp db_field_val(:utm_source, @no_ref), do: ""
  defp db_field_val(:utm_campaign, @no_ref), do: ""
  defp db_field_val(:utm_content, @no_ref), do: ""
  defp db_field_val(:utm_term, @no_ref), do: ""
  defp db_field_val(_, @not_set), do: ""
  defp db_field_val(_, val), do: val

  defp col_value(column_name) do
    dynamic([t], field(t, ^column_name))
  end

  # Needed for string functions to work properly
  defp col_value_string(column_name) do
    dynamic([t], type(field(t, ^column_name), :string))
  end

  defp custom_prop_value(column_name, prop_name) do
    dynamic([t], get_by_key(t, column_name, ^prop_name))
  end

  defp in_clause(value_expression, [_, _, clauses | _] = filter, values \\ nil) do
    values = values || clauses

    if case_sensitive?(filter) do
      dynamic([t], ^value_expression in ^values)
    else
      values = values |> Enum.map(&String.downcase/1)
      dynamic([t], fragment("lower(?)", ^value_expression) in ^values)
    end
  end

  defp contains_clause(value_expression, [_, _, clauses | _] = filter) do
    if case_sensitive?(filter) do
      dynamic(
        [x],
        fragment("multiSearchAny(?, ?)", ^value_expression, ^clauses)
      )
    else
      dynamic(
        [x],
        fragment("multiSearchAnyCaseInsensitive(?, ?)", ^value_expression, ^clauses)
      )
    end
  end

  defp case_sensitive?([_, _, _, %{case_sensitive: false}]), do: false
  defp case_sensitive?(_), do: true
end
```

## File: `lib/plausible/stats/table_decider.ex`
```
defmodule Plausible.Stats.TableDecider do
  @moduledoc """
  This module contains logic for deciding which tables need to be queried given a query
  and metrics, with the purpose of reducing the number of queries and JOINs needed to perform.
  """

  import Enum, only: [empty?: 1]
  import Plausible.Stats.Filters, only: [dimensions_used_in_filters: 1]

  alias Plausible.Stats.Query

  def events_join_sessions?(query) do
    query.filters
    |> dimensions_used_in_filters()
    |> Enum.any?(&(dimension_partitioner(query, &1) == :session))
  end

  def sessions_join_events?(query) do
    query.filters
    |> dimensions_used_in_filters()
    |> Enum.any?(&(dimension_partitioner(query, &1) == :event))
  end

  @doc """
  Validates whether metrics and dimensions are compatible with each other.

  During query building we split query into two: event and session queries. However dimensions need to be
  present in both queries and hence must be compatible.

  Used during query parsing
  """
  def validate_no_metrics_dimensions_conflict(query) do
    %{event: event_only_metrics, session: session_only_metrics} =
      partition(query.metrics, query, &metric_partitioner/2)

    %{event: event_only_dimensions, session: session_only_dimensions} =
      partition(query.dimensions, query, &dimension_partitioner/2)

    cond do
      # event:page is a special case handled in QueryOptimizer.split_sessions_query
      event_only_dimensions == ["event:page"] ->
        :ok

      not empty?(session_only_metrics) and not empty?(event_only_dimensions) ->
        {:error,
         "Session metric(s) #{i(session_only_metrics)} cannot be queried along with event dimension(s) #{i(event_only_dimensions)}"}

      not empty?(event_only_metrics) and not empty?(session_only_dimensions) ->
        {:error,
         "Event metric(s) #{i(event_only_metrics)} cannot be queried along with session dimension(s) #{i(session_only_dimensions)}"}

      true ->
        :ok
    end
  end

  @doc """
  Returns a three-element tuple with instructions on how to join two Ecto
  queries. The arguments (`events_query` and `sessions_query`) are `%Query{}`
  structs that have been split by TableDecider already.

  Normally we can always LEFT JOIN sessions to events, selecting `dimensions`
  only from the events subquery. That's because:

  1) session dimensions (e.g. entry_page) cannot be queried alongside event
     metrics/dimensions, or

  2) session dimensions (e.g. operating_system) are also available in the
     events table.

  The only exception is using the "time:minute" dimension where the sessions
  subquery might return more rows than the events one. That's because we're
  counting sessions in all time buckets they were active in.
  """
  def join_options(events_query, sessions_query) do
    events_q_select_fields = events_query.metrics ++ events_query.dimensions
    sessions_q_select_fields = sessions_query.metrics -- [:sample_percent]

    if "time:minute" in events_query.dimensions do
      {
        :full,
        events_q_select_fields -- ["time:minute"],
        sessions_q_select_fields ++ ["time:minute"]
      }
    else
      {:left, events_q_select_fields, sessions_q_select_fields}
    end
  end

  def partition_metrics(metrics, query) do
    %{
      event: event_only_metrics,
      session: session_only_metrics,
      either: either_metrics,
      other: other_metrics,
      sample_percent: sample_percent
    } =
      partition(metrics, query, &metric_partitioner/2)

    %{event: event_only_filters, session: session_only_filters} =
      query.filters
      |> dimensions_used_in_filters()
      |> partition(query, &dimension_partitioner/2)

    %{event: event_only_dimensions, session: session_only_dimensions} =
      partition(query.dimensions, query, &dimension_partitioner/2)

    cond do
      # Only one table needs to be queried
      empty?(event_only_metrics) && empty?(event_only_filters) && empty?(event_only_dimensions) ->
        {[], session_only_metrics ++ either_metrics ++ sample_percent, other_metrics}

      empty?(session_only_metrics) && empty?(session_only_filters) &&
          empty?(session_only_dimensions) ->
        {event_only_metrics ++ either_metrics ++ sample_percent, [], other_metrics}

      # Filters and/or dimensions on both events and sessions, but only one kind of metric
      empty?(event_only_metrics) && empty?(event_only_dimensions) ->
        {[], session_only_metrics ++ either_metrics ++ sample_percent, other_metrics}

      empty?(session_only_metrics) && empty?(session_only_dimensions) ->
        {event_only_metrics ++ either_metrics ++ sample_percent, [], other_metrics}

      # Default: prefer events
      true ->
        {event_only_metrics ++ either_metrics ++ sample_percent,
         session_only_metrics ++ sample_percent, other_metrics}
    end
  end

  # Note: This is inaccurate when filtering but required for old backwards compatibility
  defp metric_partitioner(%Query{legacy_breakdown: true}, :pageviews), do: :either
  defp metric_partitioner(%Query{legacy_breakdown: true}, :events), do: :either

  defp metric_partitioner(query, metric) when metric in [:visitors, :visits] do
    if "time:minute" in query.dimensions, do: :session, else: :either
  end

  defp metric_partitioner(_, :conversion_rate), do: :either
  defp metric_partitioner(_, :group_conversion_rate), do: :either
  defp metric_partitioner(_, :percentage), do: :either

  defp metric_partitioner(_, :average_revenue), do: :event
  defp metric_partitioner(_, :total_revenue), do: :event
  defp metric_partitioner(_, :scroll_depth), do: :event
  defp metric_partitioner(_, :pageviews), do: :event
  defp metric_partitioner(_, :events), do: :event
  defp metric_partitioner(_, :bounce_rate), do: :session
  defp metric_partitioner(_, :time_on_page), do: :event
  defp metric_partitioner(_, :visit_duration), do: :session
  defp metric_partitioner(_, :views_per_visit), do: :session
  defp metric_partitioner(_, :exit_rate), do: :session

  # Calculated metrics - handled on callsite separately from other metrics.
  defp metric_partitioner(_, :total_visitors), do: :other
  # Sample percentage is included in both tables if queried.
  defp metric_partitioner(_, :sample_percent), do: :sample_percent

  defp dimension_partitioner(_, "event:" <> _), do: :event
  defp dimension_partitioner(_, "visit:entry_page"), do: :session
  defp dimension_partitioner(_, "visit:entry_page_hostname"), do: :session
  defp dimension_partitioner(_, "visit:exit_page"), do: :session
  defp dimension_partitioner(_, "visit:exit_page_hostname"), do: :session

  defp dimension_partitioner(_, "visit:" <> _), do: :either

  defp dimension_partitioner(_, _), do: :either

  @default %{event: [], session: [], either: [], other: [], sample_percent: []}
  defp partition(values, query, partitioner) do
    Enum.reduce(values, @default, fn value, acc ->
      key = partitioner.(query, value)
      Map.put(acc, key, Map.fetch!(acc, key) ++ [value])
    end)
  end

  defp i(list) when is_list(list) do
    Enum.map_join(list, ", ", &"`#{&1}`")
  end
end
```

## File: `lib/plausible/stats/time.ex`
```
defmodule Plausible.Stats.Time do
  @moduledoc """
  Collection of functions to work with time in queries.
  """

  alias Plausible.Stats.{Query, DateTimeRange}

  def utc_boundaries(%Query{
        utc_time_range: time_range,
        site_native_stats_start_at: native_stats_start_at
      }) do
    first =
      time_range.first
      |> DateTime.to_naive()
      |> beginning_of_time(native_stats_start_at)

    last = DateTime.to_naive(time_range.last)

    {first, last}
  end

  defp beginning_of_time(candidate, native_stats_start_at) do
    if NaiveDateTime.after?(native_stats_start_at, candidate) do
      native_stats_start_at
    else
      candidate
    end
  end

  def format_datetime(%Date{} = date), do: Date.to_string(date)

  def format_datetime(%mod{} = datetime) when mod in [NaiveDateTime, DateTime],
    do: Calendar.strftime(datetime, "%Y-%m-%d %H:%M:%S")

  # Realtime graphs return numbers
  def format_datetime(other), do: other

  def time_dimension(query) do
    Enum.find(query.dimensions, &time_dimension?/1)
  end

  def time_dimension?("time" <> _rest), do: true
  def time_dimension?(_dimension), do: false

  @doc """
  Returns list of time bucket labels for the given query.
  """
  def time_labels(query) do
    time_labels_for_dimension(time_dimension(query), query)
  end

  defp time_labels_for_dimension("time:month", query) do
    date_range = Query.date_range(query)

    n_buckets =
      Timex.diff(
        date_range.last,
        Date.beginning_of_month(date_range.first),
        :months
      )

    Enum.map(n_buckets..0//-1, fn shift ->
      date_range.last
      |> Date.beginning_of_month()
      |> Date.shift(month: -shift)
      |> format_datetime()
    end)
  end

  defp time_labels_for_dimension("time:week", query) do
    date_range = Query.date_range(query)

    n_buckets =
      Timex.diff(
        date_range.last,
        Date.beginning_of_week(date_range.first),
        :weeks
      )

    Enum.map(0..n_buckets, fn shift ->
      date_range.first
      |> Date.shift(week: shift)
      |> date_or_weekstart(date_range)
      |> format_datetime()
    end)
  end

  defp time_labels_for_dimension("time:day", query) do
    Query.date_range(query)
    |> Enum.into([])
    |> Enum.map(&format_datetime/1)
  end

  defp time_labels_for_dimension("time:hour", query) do
    time_range = query.utc_time_range |> DateTimeRange.to_timezone(query.timezone)

    from_timestamp = time_range.first |> Map.merge(%{minute: 0, second: 0})
    n_buckets = DateTime.diff(time_range.last, from_timestamp, :hour)

    Enum.map(0..n_buckets, fn step ->
      from_timestamp
      |> DateTime.to_naive()
      |> NaiveDateTime.shift(hour: step)
      |> format_datetime()
    end)
  end

  defp time_labels_for_dimension("time:minute", query) do
    time_range = query.utc_time_range |> DateTimeRange.to_timezone(query.timezone)
    first_datetime = Map.put(time_range.first, :second, 0)

    first_datetime
    |> Stream.iterate(fn datetime -> DateTime.shift(datetime, minute: 1) end)
    |> Enum.take_while(fn datetime ->
      current_minute = Map.put(query.now, :second, 0)

      DateTime.before?(datetime, time_range.last) &&
        DateTime.before?(datetime, current_minute)
    end)
    |> Enum.map(&format_datetime/1)
  end

  def date_or_weekstart(date, date_range) do
    weekstart = Date.beginning_of_week(date)

    if Enum.member?(date_range, weekstart) do
      weekstart
    else
      date
    end
  end
end
```

## File: `lib/plausible/stats/time_on_page.ex`
```
defmodule Plausible.Stats.TimeOnPage do
  @moduledoc """
  Module to check whether the new time on page metric is available.
  """

  def new_time_on_page_visible?(site) do
    not is_nil(site.legacy_time_on_page_cutoff)
  end

  def legacy_time_on_page_cutoff(site) do
    cutoff_datetime(site.legacy_time_on_page_cutoff, site.timezone)
  end

  def cutoff_datetime(nil, _timezone), do: nil

  # Workaround for a case where casting unix epoch to DateTime fails for sites that should
  # always have the new time-on-page only. Affects CSV imports.
  def cutoff_datetime(~D[1970-01-01], _timezone), do: ~U[2000-01-01 00:00:00Z]

  def cutoff_datetime(date, timezone) do
    case DateTime.new(date, ~T[00:00:00], timezone) do
      {:ok, datetime} -> datetime
      {:gap, just_before, _just_after} -> just_before
      {:ambiguous, first_datetime, _second_datetime} -> first_datetime
    end
  end
end
```

## File: `lib/plausible/stats/timeseries.ex`
```
defmodule Plausible.Stats.Timeseries do
  @moduledoc """
  Builds timeseries results for v1 of our stats API and dashboards.

  Avoid adding new logic here - update QueryBuilder etc instead.
  """

  use Plausible
  use Plausible.ClickhouseRepo
  alias Plausible.Stats.{Comparisons, Query, QueryRunner, QueryOptimizer, Metrics, Time}

  @time_dimension %{
    "month" => "time:month",
    "week" => "time:week",
    "day" => "time:day",
    "hour" => "time:hour",
    "minute" => "time:minute"
  }

  def timeseries(site, query, metrics) do
    query =
      query
      |> Query.set(
        metrics: transform_metrics(metrics, %{conversion_rate: :group_conversion_rate}),
        dimensions: [time_dimension(query)],
        order_by: [{time_dimension(query), :asc}],
        remove_unavailable_revenue_metrics: true
      )
      |> QueryOptimizer.optimize()

    comparison_query =
      if(query.include.comparisons,
        do: Comparisons.get_comparison_query(query),
        else: nil
      )

    query_result = QueryRunner.run(site, query)

    {
      build_result(query_result, query, fn entry -> entry end),
      build_result(query_result, comparison_query, fn entry -> entry.comparison end),
      query_result.meta
    }
  end

  defp time_dimension(query), do: Map.fetch!(@time_dimension, query.interval)

  # Given a query result, build a legacy timeseries result
  # Format is %{ date => %{ date: date_string, [metric] => value } } with a bunch of special cases for the UI
  defp build_result(query_result, %Query{} = query, extract_entry) do
    query_result.results
    |> Enum.map(&extract_entry.(&1))
    |> Enum.map(fn %{dimensions: [time_dimension_value], metrics: metrics} ->
      metrics_map = Enum.zip(query.metrics, metrics) |> Map.new()

      {
        time_dimension_value,
        Map.put(metrics_map, :date, time_dimension_value)
      }
    end)
    |> Map.new()
    |> add_labels(query)
  end

  defp build_result(_, _, _), do: nil

  defp add_labels(results_map, query) do
    query
    |> Time.time_labels()
    |> Enum.map(fn key ->
      Map.get(
        results_map,
        key,
        empty_row(key, query.metrics, query)
      )
    end)
    |> transform_realtime_labels(query)
    |> transform_keys(%{group_conversion_rate: :conversion_rate})
  end

  defp empty_row(date, metrics, query) do
    metrics
    |> Map.new(fn metric -> {metric, Metrics.default_value(metric, query, [date])} end)
    |> Map.put(:date, date)
  end

  defp transform_metrics(metrics, to_replace) do
    Enum.map(metrics, &Map.get(to_replace, &1, &1))
  end

  defp transform_keys(results, keys_to_replace) do
    Enum.map(results, fn map ->
      Enum.map(map, fn {key, val} ->
        {Map.get(keys_to_replace, key, key), val}
      end)
      |> Enum.into(%{})
    end)
  end

  defp transform_realtime_labels(results, %Query{period: "30m"}) do
    Enum.with_index(results)
    |> Enum.map(fn {entry, index} -> %{entry | date: -30 + index} end)
  end

  defp transform_realtime_labels(results, _query), do: results
end
```

## File: `lib/plausible/stats/util.ex`
```
defmodule Plausible.Stats.Util do
  @moduledoc """
  Utilities for modifying stat results
  """

  @doc """
  This function adds the `visitors` metric into the list of
  given metrics if it's not already there and if it is needed
  for any of the other metrics to be calculated.
  """
  def maybe_add_visitors_metric(metrics) do
    needed? =
      Enum.any?(
        [:percentage, :conversion_rate, :group_conversion_rate, :time_on_page],
        &(&1 in metrics)
      )

    if needed? and :visitors not in metrics do
      metrics ++ [:visitors]
    else
      metrics
    end
  end

  def shortname(_query, metric) when is_atom(metric), do: metric
  def shortname(_query, "time:" <> _), do: :time

  def shortname(query, dimension) do
    index = Enum.find_index(query.dimensions, &(&1 == dimension))
    :"dim#{index}"
  end
end
```

## File: `lib/plausible/teams.ex`
```
defmodule Plausible.Teams do
  @moduledoc """
  Core context of teams.
  """

  import Ecto.Query

  alias __MODULE__
  alias Plausible.Auth
  alias Plausible.Billing
  alias Plausible.Repo
  use Plausible

  @accept_traffic_until_free ~D[2135-01-01]

  @spec default_name() :: String.t()
  def default_name(), do: "My Personal Sites"

  @spec name(nil | Teams.Team.t()) :: String.t()
  def name(nil), do: default_name()
  def name(%{setup_complete: false}), do: default_name()
  def name(team), do: team.name

  @spec setup?(nil | Teams.Team.t()) :: boolean()
  def setup?(nil), do: false
  def setup?(%{setup_complete: setup_complete}), do: setup_complete

  @spec get(pos_integer() | binary() | nil) :: Teams.Team.t() | nil
  def get(nil), do: nil

  def get(team_id) when is_integer(team_id) do
    Repo.get(Teams.Team, team_id)
  end

  def get(team_identifier) when is_binary(team_identifier) do
    case Ecto.UUID.cast(team_identifier) do
      {:ok, uuid} ->
        Repo.get_by(Teams.Team, identifier: uuid)

      :error ->
        nil
    end
  end

  @spec get!(pos_integer() | binary()) :: Teams.Team.t()
  def get!(team_id) when is_integer(team_id) do
    Repo.get!(Teams.Team, team_id)
  end

  def get!(team_identifier) when is_binary(team_identifier) do
    Repo.get_by!(Teams.Team, identifier: team_identifier)
  end

  @spec on_trial?(Teams.Team.t() | nil) :: boolean()
  on_ee do
    def on_trial?(nil), do: false
    def on_trial?(%Teams.Team{trial_expiry_date: nil}), do: false

    def on_trial?(team) do
      team = with_subscription(team)

      is_nil(team.subscription) and trial_days_left(team) >= 0
    end
  else
    def on_trial?(_), do: always(true)
  end

  @spec locked?(Teams.Team.t() | nil) :: boolean()
  def locked?(nil), do: false

  def locked?(%Teams.Team{locked: locked}), do: locked

  @spec trial_days_left(Teams.Team.t()) :: integer()
  def trial_days_left(nil) do
    nil
  end

  def trial_days_left(team) do
    Date.diff(team.trial_expiry_date, Date.utc_today())
  end

  def with_subscription(team) do
    Repo.preload(team, subscription: last_subscription_query())
  end

  @spec owned_sites(Teams.Team.t() | nil, pos_integer() | nil) :: [Plausible.Site.t()]
  def owned_sites(team, limit \\ nil)

  def owned_sites(nil, _), do: []

  def owned_sites(team, limit) do
    query = from(s in Plausible.Site, where: s.team_id == ^team.id, order_by: [asc: s.domain])

    if limit do
      query
      |> limit(^limit)
      |> Repo.all()
    else
      Repo.all(query)
    end
  end

  @spec owned_sites_ids(Teams.Team.t() | nil) :: [pos_integer()]
  def owned_sites_ids(nil) do
    []
  end

  def owned_sites_ids(team) do
    Repo.all(
      from(s in Plausible.Site,
        where: s.team_id == ^team.id,
        select: s.id,
        order_by: [desc: s.id]
      )
    )
  end

  @spec owned_sites_count(Teams.Team.t() | nil) :: non_neg_integer()
  def owned_sites_count(nil), do: 0

  def owned_sites_count(team) do
    Repo.aggregate(
      from(s in Plausible.Site,
        where: s.team_id == ^team.id
      ),
      :count
    )
  end

  def has_active_sites?(team) do
    team
    |> owned_sites()
    |> Enum.any?(&Plausible.Sites.has_stats?/1)
  end

  @doc """
  Get or create user's team.

  If the user has no non-guest membership yet, an implicit "My Personal Sites" team is
  created with them as an owner.

  If the user already has an owner membership in an existing team,
  that team is returned.
  """
  @spec get_or_create(Auth.User.t()) ::
          {:ok, Teams.Team.t()} | {:error, :multiple_teams | :permission_denied}
  def get_or_create(user) do
    with :ok <- check_user_type(user),
         {:error, :no_team} <- get_owned_team(user, only_not_setup?: true) do
      case create_my_team(user) do
        {:ok, team} ->
          {:ok, team}

        {:error, :exists_already} ->
          get_owned_team(user, only_not_setup?: true)
      end
    end
  end

  @spec force_create_my_team(Auth.User.t()) :: Teams.Team.t()
  def force_create_my_team(user) do
    # This is going to crash hard for SSO user. This shouldn't happen
    # under normal circumstances except in case of a _very_ unlucky timing.
    # Manual resolution is necessary anyway.
    case check_user_type(user) do
      :ok -> :pass
      _ -> raise "SSO user tried to force create a personal team"
    end

    {:ok, team} =
      Repo.transaction(fn ->
        clear_autocreated(user)
        {:ok, team} = create_my_team(user)
        team
      end)

    team
  end

  @spec complete_setup(Teams.Team.t()) :: Teams.Team.t()
  def complete_setup(team) do
    if not team.setup_complete do
      team =
        team
        |> Teams.Team.setup_changeset()
        |> Repo.update!()
        |> Repo.preload(:owners)

      [owner] = team.owners

      clear_autocreated(owner)

      team
    else
      team
    end
  end

  @spec delete(Teams.Team.t()) :: {:ok, :deleted} | {:error, :active_subscription}
  def delete(team) do
    team = Teams.with_subscription(team)

    if Billing.Subscription.Status.active?(team.subscription) do
      {:error, :active_subscription}
    else
      Repo.transaction(fn ->
        for site <- Teams.owned_sites(team) do
          Plausible.Site.Removal.run(site)
        end

        Repo.delete_all(from s in Billing.Subscription, where: s.team_id == ^team.id)

        Repo.delete_all(from ep in Billing.EnterprisePlan, where: ep.team_id == ^team.id)

        Repo.delete!(team)

        :deleted
      end)
    end
  end

  @spec get_by_owner(Auth.User.t(), Keyword.t()) ::
          {:ok, Teams.Team.t()} | {:error, :no_team | :multiple_teams}
  def get_by_owner(user, opts \\ []) do
    get_owned_team(user, opts)
  end

  @spec update_accept_traffic_until(Teams.Team.t()) :: Teams.Team.t()
  def update_accept_traffic_until(team) do
    team
    |> Ecto.Changeset.change(accept_traffic_until: accept_traffic_until(team))
    |> Repo.update!()
  end

  def start_trial(%Teams.Team{} = team) do
    team
    |> Teams.Team.start_trial()
    |> Repo.update!()
  end

  def start_grace_period(team) do
    team
    |> Teams.GracePeriod.start_changeset()
    |> Repo.update!()
  end

  def start_manual_lock_grace_period(team) do
    team
    |> Teams.GracePeriod.start_manual_lock_changeset()
    |> Repo.update!()
  end

  def end_grace_period(team) do
    team
    |> Teams.GracePeriod.end_changeset()
    |> Repo.update!()
  end

  def remove_grace_period(team) do
    team
    |> Teams.GracePeriod.remove_changeset()
    |> Repo.update!()
  end

  def maybe_reset_next_upgrade_override(%Teams.Team{} = team) do
    if team.allow_next_upgrade_override do
      team
      |> Ecto.Changeset.change(allow_next_upgrade_override: false)
      |> Repo.update!()
    else
      team
    end
  end

  @spec accept_traffic_until(Teams.Team.t()) :: Date.t()
  on_ee do
    def accept_traffic_until(team) do
      team = with_subscription(team)

      cond do
        on_trial?(team) ->
          Date.shift(team.trial_expiry_date,
            day: Teams.Team.trial_accept_traffic_until_offset_days()
          )

        team.subscription && team.subscription.paddle_plan_id == "free_10k" ->
          @accept_traffic_until_free

        team.subscription && team.subscription.next_bill_date ->
          Date.shift(team.subscription.next_bill_date,
            day: Teams.Team.subscription_accept_traffic_until_offset_days()
          )

        true ->
          raise "This user is neither on trial or has a valid subscription. Manual intervention required."
      end
    end
  else
    def accept_traffic_until(_user) do
      @accept_traffic_until_free
    end
  end

  @spec last_subscription_join_query() :: Ecto.Query.t()
  def last_subscription_join_query() do
    from(subscription in last_subscription_query(),
      where: subscription.team_id == parent_as(:team).id
    )
  end

  @spec last_subscription_query() :: Ecto.Query.t()
  def last_subscription_query() do
    from(subscription in Plausible.Billing.Subscription,
      order_by: [desc: subscription.inserted_at, desc: subscription.id],
      limit: 1
    )
  end

  # Exposed for use in tests
  @doc false
  def get_owned_team(user, opts \\ []) do
    only_not_setup? = Keyword.get(opts, :only_not_setup?, false)

    query =
      from(tm in Teams.Membership,
        inner_join: t in assoc(tm, :team),
        as: :team,
        where: tm.user_id == ^user.id and tm.role == :owner,
        select: t,
        order_by: t.id
      )

    query =
      if only_not_setup? do
        where(query, [team: t], t.setup_complete == false)
      else
        query
      end

    result = Repo.all(query)

    case result do
      [] ->
        {:error, :no_team}

      [team] ->
        {:ok, team}

      _teams ->
        {:error, :multiple_teams}
    end
  end

  defp check_user_type(user) do
    if Plausible.Users.type(user) == :sso do
      {:error, :permission_denied}
    else
      :ok
    end
  end

  defp clear_autocreated(user) do
    Repo.update_all(
      from(tm in Teams.Membership,
        where: tm.user_id == ^user.id,
        where: tm.is_autocreated == true
      ),
      set: [is_autocreated: false]
    )

    :ok
  end

  defp create_my_team(user) do
    team =
      %Teams.Team{}
      |> Teams.Team.changeset(%{name: default_name()})
      |> Repo.insert!()

    team_membership =
      team
      |> Teams.Membership.changeset(user, :owner)
      |> Ecto.Changeset.put_change(:is_autocreated, true)
      |> Repo.insert!(
        on_conflict: :nothing,
        conflict_target:
          {:unsafe_fragment, "(user_id) WHERE role = 'owner' and is_autocreated = true"}
      )

    if team_membership.id do
      {:ok, team}
    else
      Repo.delete!(team)
      {:error, :exists_already}
    end
  end
end
```

## File: `lib/plausible/teams/billing.ex`
```
defmodule Plausible.Teams.Billing do
  @moduledoc false

  use Plausible

  import Ecto.Query

  alias Plausible.Billing.EnterprisePlan
  alias Plausible.Billing.Subscription
  alias Plausible.Billing.Subscriptions
  alias Plausible.Repo
  alias Plausible.Teams

  alias Plausible.Billing.{EnterprisePlan, Feature, Plan, Plans, Quota}
  alias Plausible.Billing.Feature.{Goals, Props, SitesAPI, StatsAPI, SharedLinks, SSO}

  require Plausible.Billing.Subscription.Status

  @limit_sites_since ~D[2021-05-05]

  @typep last_30_days_usage() :: %{:last_30_days => Quota.usage_cycle()}
  @typep monthly_pageview_usage() :: Quota.cycles_usage() | last_30_days_usage()

  @starter_tier_launch ~D[2025-06-11]
  def starter_tier_launch(), do: @starter_tier_launch

  def show_new_upgrade_page?(nil = _team) do
    FunWithFlags.enabled?(:starter_tier)
  end

  def show_new_upgrade_page?(%Teams.Team{} = team) do
    team = Teams.with_subscription(team)
    feature_flag_enabled? = FunWithFlags.enabled?(:starter_tier, for: team)

    subscription_plan = Plans.get_subscription_plan(team.subscription)

    case {subscription_plan, team.trial_expiry_date} do
      {%Plan{generation: 5}, _} ->
        true

      {nil, nil} ->
        feature_flag_enabled?

      {nil, trial_expiry_date} ->
        diff = Date.diff(@starter_tier_launch, trial_expiry_date)
        # Active or recently (less than 10 days ago) ended trials
        # should be able to subscribe to the plans they saw when
        # they signed up.
        if diff <= 10 and diff >= -30 do
          false
        else
          feature_flag_enabled?
        end

      {_, _} ->
        feature_flag_enabled?
    end
  end

  def grandfathered_team?(nil), do: false

  def grandfathered_team?(team) do
    # timestamps were originally rewritten from owner.inserted_at
    Date.before?(team.inserted_at, @limit_sites_since)
  end

  def get_subscription(nil), do: nil

  def get_subscription(%Teams.Team{subscription: %Subscription{} = subscription}),
    do: subscription

  def get_subscription(%Teams.Team{} = team) do
    Teams.with_subscription(team).subscription
  end

  def change_plan(team, new_plan_id) do
    subscription = active_subscription_for(team)
    plan = Plausible.Billing.Plans.find(new_plan_id)

    limit_checking_opts =
      if team.allow_next_upgrade_override do
        [ignore_pageview_limit: true]
      else
        []
      end

    usage = quota_usage(team)

    with :ok <-
           Plausible.Billing.Quota.ensure_within_plan_limits(usage, plan, limit_checking_opts),
         do: do_change_plan(subscription, new_plan_id)
  end

  defp do_change_plan(subscription, new_plan_id) do
    res =
      Plausible.Billing.paddle_api().update_subscription(subscription.paddle_subscription_id, %{
        plan_id: new_plan_id
      })

    case res do
      {:ok, response} ->
        amount = :erlang.float_to_binary(response["next_payment"]["amount"] / 1, decimals: 2)

        Subscription.changeset(subscription, %{
          paddle_plan_id: Integer.to_string(response["plan_id"]),
          next_bill_amount: amount,
          next_bill_date: response["next_payment"]["date"]
        })
        |> Repo.update()

      e ->
        e
    end
  end

  def enterprise_configured?(nil), do: false

  def enterprise_configured?(%Teams.Team{} = team) do
    team
    |> Ecto.assoc(:enterprise_plan)
    |> Repo.exists?()
  end

  def latest_enterprise_plan_with_price(team, customer_ip) do
    enterprise_plan =
      Repo.one!(
        from(e in EnterprisePlan,
          where: e.team_id == ^team.id,
          order_by: [desc: e.inserted_at],
          limit: 1
        )
      )

    {enterprise_plan, Plausible.Billing.Plans.get_price_for(enterprise_plan, customer_ip)}
  end

  def has_active_subscription?(nil), do: false

  def has_active_subscription?(team) do
    team
    |> active_subscription_query()
    |> Repo.exists?()
  end

  def active_subscription_for(nil), do: nil

  def active_subscription_for(team) do
    team
    |> active_subscription_query()
    |> Repo.one()
  end

  @spec check_needs_to_upgrade(Teams.Team.t() | nil, atom()) ::
          {:needs_to_upgrade, :no_active_trial_or_subscription | :grace_period_ended}
          | :no_upgrade_needed
  def check_needs_to_upgrade(team_or_nil, usage_mod \\ Teams.Billing)

  def check_needs_to_upgrade(nil, _usage_mod),
    do: {:needs_to_upgrade, :no_active_trial_or_subscription}

  def check_needs_to_upgrade(team, usage_mod) do
    team = Teams.with_subscription(team)

    cond do
      Plausible.Teams.on_trial?(team) ->
        :no_upgrade_needed

      not Subscriptions.active?(team.subscription) ->
        {:needs_to_upgrade, :no_active_trial_or_subscription}

      Teams.GracePeriod.expired?(team) ->
        revise_pageview_usage(team, usage_mod)

      true ->
        :no_upgrade_needed
    end
  end

  defp revise_pageview_usage(team, usage_mod) do
    case Plausible.Workers.CheckUsage.check_pageview_usage_two_cycles(team, usage_mod) do
      {:over_limit, _} ->
        {:needs_to_upgrade, :grace_period_ended}

      {:below_limit, _} ->
        Plausible.Teams.remove_grace_period(team)
        :no_upgrade_needed
    end
  end

  @doc """
  Enterprise plans are always allowed to add more sites (even when
  over limit) to avoid service disruption. Their usage is checked
  in a background job instead (see `check_usage.ex`).
  """
  def ensure_can_add_new_site(nil) do
    :ok
  end

  def ensure_can_add_new_site(team) do
    team = Teams.with_subscription(team)

    case Plans.get_subscription_plan(team.subscription) do
      %EnterprisePlan{} ->
        :ok

      _ ->
        usage = site_usage(team)
        limit = site_limit(team)

        if Plausible.Billing.Quota.below_limit?(usage, limit) do
          :ok
        else
          {:error, {:over_limit, limit}}
        end
    end
  end

  on_ee do
    @site_limit_for_trials 10

    def site_limit(nil) do
      @site_limit_for_trials
    end

    def site_limit(team) do
      if grandfathered_team?(team) do
        :unlimited
      else
        get_site_limit_from_plan(team)
      end
    end

    defp get_site_limit_from_plan(team) do
      team =
        Teams.with_subscription(team)

      case Plans.get_subscription_plan(team.subscription) do
        %{site_limit: site_limit} -> site_limit
        :free_10k -> 50
        nil -> @site_limit_for_trials
      end
    end
  else
    def site_limit(_team), do: :unlimited
  end

  @doc """
  Returns the number of sites the given team owns.
  """
  @spec site_usage(Teams.Team.t()) :: non_neg_integer()
  def site_usage(nil), do: 0

  def site_usage(team) do
    Teams.owned_sites_count(team)
  end

  on_ee do
    @team_member_limit_for_trials 10

    def team_member_limit(nil) do
      @team_member_limit_for_trials
    end

    def team_member_limit(team) do
      team = Teams.with_subscription(team)

      case Plans.get_subscription_plan(team.subscription) do
        %{team_member_limit: limit} -> limit
        :free_10k -> :unlimited
        nil -> @team_member_limit_for_trials
      end
    end

    def solo?(nil), do: true

    def solo?(team) do
      team_member_limit(team) == 0
    end
  else
    def team_member_limit(_team), do: :unlimited

    def solo?(_team), do: false
  end

  @doc """
  Returns a full usage report for the team.

  ### Options

  * `pending_ownership_site_ids` - a list of site IDs from which to count
  additional usage. This allows us to look at the total usage from pending
  ownerships and owned sites at the same time, which is useful, for example,
  when deciding whether to let the team owner upgrade to a plan, or accept a
  site ownership.

  * `with_features` - when `true`, the returned map will contain features
  usage. Also counts usage from `pending_ownership_site_ids` if that option
  is given.
  """
  def quota_usage(team, opts \\ []) do
    team = Teams.with_subscription(team)
    with_features? = Keyword.get(opts, :with_features, false)
    pending_site_ids = Keyword.get(opts, :pending_ownership_site_ids, [])
    team_site_ids = Teams.owned_sites_ids(team)
    all_site_ids = pending_site_ids ++ team_site_ids

    monthly_pageviews = monthly_pageview_usage(team, all_site_ids)
    team_member_usage = team_member_usage(team, pending_ownership_site_ids: pending_site_ids)

    basic_usage = %{
      monthly_pageviews: monthly_pageviews,
      team_members: team_member_usage,
      sites: length(all_site_ids)
    }

    if with_features? do
      Map.put(basic_usage, :features, features_usage(team, all_site_ids))
    else
      basic_usage
    end
  end

  @monthly_pageview_limit_for_free_10k 10_000
  @monthly_pageview_limit_for_trials :unlimited

  def monthly_pageview_limit(nil) do
    @monthly_pageview_limit_for_trials
  end

  def monthly_pageview_limit(%Teams.Team{} = team) do
    team = Teams.with_subscription(team)
    monthly_pageview_limit(team.subscription)
  end

  def monthly_pageview_limit(subscription) do
    case Plans.get_subscription_plan(subscription) do
      %EnterprisePlan{monthly_pageview_limit: limit} ->
        limit

      %Plan{monthly_pageview_limit: limit} ->
        limit

      :free_10k ->
        @monthly_pageview_limit_for_free_10k

      _any ->
        if subscription do
          Sentry.capture_message("Unknown monthly pageview limit for plan",
            extra: %{paddle_plan_id: subscription.paddle_plan_id}
          )
        end

        @monthly_pageview_limit_for_trials
    end
  end

  @doc """
  Queries the ClickHouse database for the monthly pageview usage. If the given team's
  subscription is `active`, `past_due`, or a `deleted` (but not yet expired), a map
  with the following structure is returned:

  ```elixir
  %{
    current_cycle: usage_cycle(),
    last_cycle: usage_cycle(),
    penultimate_cycle: usage_cycle()
  }
  ```

  In all other cases of the subscription status (or a `free_10k` subscription which
    does not have a `last_bill_date` defined) - the following structure is returned:

  ```elixir
  %{last_30_days: usage_cycle()}
  ```

  Given only a team as input, the usage is queried from across all the sites that the
  team owns. Alternatively, given an optional argument of `site_ids`, the usage from
  across all those sites is queried instead.
  """
  @spec monthly_pageview_usage(Teams.Team.t(), list() | nil) :: monthly_pageview_usage()
  def monthly_pageview_usage(team, site_ids \\ nil)

  def monthly_pageview_usage(team, nil) do
    monthly_pageview_usage(team, Teams.owned_sites_ids(team))
  end

  def monthly_pageview_usage(nil, _site_ids) do
    %{last_30_days: usage_cycle(nil, :last_30_days, [])}
  end

  def monthly_pageview_usage(team, site_ids) do
    team = Teams.with_subscription(team)
    active_subscription? = Subscriptions.active?(team.subscription)

    if active_subscription? and team.subscription.last_bill_date != nil do
      [:current_cycle, :last_cycle, :penultimate_cycle]
      |> Task.async_stream(fn cycle ->
        {cycle, usage_cycle(team, cycle, site_ids)}
      end)
      |> Enum.into(%{}, fn {:ok, cycle_usage} -> cycle_usage end)
    else
      %{last_30_days: usage_cycle(team, :last_30_days, site_ids)}
    end
  end

  @spec team_member_usage(Teams.Team.t(), Keyword.t()) :: non_neg_integer()
  @doc """
  Returns the total count of team members associated with the team's sites.

  * The given team's owner is not counted as a team member.

  * Pending invitations (but not ownership transfers) are counted as team
  members even before accepted.

  * Users are counted uniquely - i.e. even if an account is associated with
  many sites owned by the given user, they still count as one team member.

  ### Options

  * `exclude_emails` - a list of emails to not count towards the usage. This
  allows us to exclude a user from being counted as a team member when
  checking whether a site invitation can be created for that same user.

  * `pending_ownership_site_ids` - a list of site IDs from which to count
  additional team member usage. Without this option, usage is queried only
  across sites owned by the given user.
  """
  def team_member_usage(team, opts \\ [])
  def team_member_usage(nil, _), do: 0

  def team_member_usage(team, opts) do
    [owner | _] = Repo.preload(team, :owners).owners
    exclude_emails = Keyword.get(opts, :exclude_emails, []) ++ [owner.email]

    pending_site_ids = Keyword.get(opts, :pending_ownership_site_ids, [])

    team
    |> query_team_member_emails(pending_site_ids, exclude_emails)
    |> Repo.aggregate(:count)
  end

  def usage_cycle(team, cycle, owned_site_ids \\ nil, today \\ Date.utc_today())

  def usage_cycle(team, cycle, nil, today) do
    owned_site_ids = Teams.owned_sites_ids(team)
    usage_cycle(team, cycle, owned_site_ids, today)
  end

  def usage_cycle(_team, :last_30_days, owned_site_ids, today) do
    date_range = Date.range(Date.shift(today, day: -30), today)

    {pageviews, custom_events} =
      Plausible.Stats.Clickhouse.usage_breakdown(owned_site_ids, date_range)

    %{
      date_range: date_range,
      pageviews: pageviews,
      custom_events: custom_events,
      total: pageviews + custom_events
    }
  end

  def usage_cycle(team, cycle, owned_site_ids, today) do
    team = Teams.with_subscription(team)
    last_bill_date = team.subscription.last_bill_date

    normalized_last_bill_date =
      Date.shift(last_bill_date, month: Timex.diff(today, last_bill_date, :months))

    date_range =
      case cycle do
        :current_cycle ->
          Date.range(
            normalized_last_bill_date,
            Date.shift(normalized_last_bill_date, month: 1, day: -1)
          )

        :last_cycle ->
          Date.range(
            Date.shift(normalized_last_bill_date, month: -1),
            Date.shift(normalized_last_bill_date, day: -1)
          )

        :penultimate_cycle ->
          Date.range(
            Date.shift(normalized_last_bill_date, month: -2),
            Date.shift(normalized_last_bill_date, day: -1, month: -1)
          )
      end

    {pageviews, custom_events} =
      Plausible.Stats.Clickhouse.usage_breakdown(owned_site_ids, date_range)

    %{
      date_range: date_range,
      pageviews: pageviews,
      custom_events: custom_events,
      total: pageviews + custom_events
    }
  end

  @spec features_usage(Teams.Team.t() | nil, list() | nil) :: [atom()]
  @doc """
  Given only a team, this function returns the features used across all the
  sites this team owns + StatsAPI if any team user has a configured Stats API key.

  Given a team, and a list of site_ids, returns the features used by those
  sites instead + StatsAPI if any user in the team has a configured Stats API key.

  The team can also be passed as `nil`, in which case we will never return
  Stats API as a used feature.
  """
  def features_usage(team, site_ids \\ nil)

  on_ee do
    def features_usage(nil, nil), do: []

    def features_usage(%Teams.Team{} = team, nil) do
      owned_site_ids = Teams.owned_sites_ids(team)
      features_usage(team, owned_site_ids)
    end

    def features_usage(%Teams.Team{} = team, owned_site_ids) when is_list(owned_site_ids) do
      site_scoped_feature_usage = features_usage(nil, owned_site_ids)

      stats_api_used? =
        Repo.exists?(
          from tm in Plausible.Teams.Membership,
            as: :team_membership,
            where: tm.team_id == ^team.id,
            where:
              exists(
                from ak in Plausible.Auth.ApiKey,
                  where: ak.user_id == parent_as(:team_membership).user_id
              )
        )

      site_scoped_feature_usage =
        if stats_api_used? do
          site_scoped_feature_usage ++ [Feature.StatsAPI]
        else
          site_scoped_feature_usage
        end

      sites_api_used? =
        Repo.exists?(
          from tm in Plausible.Teams.Membership,
            as: :team_membership,
            where: tm.team_id == ^team.id,
            where:
              exists(
                from ak in Plausible.Auth.ApiKey,
                  where: ak.user_id == parent_as(:team_membership).user_id,
                  where: "sites:provision:*" in ak.scopes
              )
        )

      site_scoped_feature_usage =
        if sites_api_used? do
          site_scoped_feature_usage ++ [SitesAPI]
        else
          site_scoped_feature_usage
        end

      sso_used? =
        case Plausible.Auth.SSO.get_integration_for(team) do
          {:ok, _} -> true
          _ -> false
        end

      if sso_used? do
        site_scoped_feature_usage ++ [SSO]
      else
        site_scoped_feature_usage
      end
    end

    def features_usage(nil, site_ids) when is_list(site_ids) do
      shared_links_usage_q =
        from l in Plausible.Site.SharedLink,
          where:
            l.site_id in ^site_ids and l.name not in ^Plausible.Sites.shared_link_special_names()

      props_usage_q =
        from s in Plausible.Site,
          where: s.id in ^site_ids and fragment("cardinality(?) > 0", s.allowed_event_props)

      funnels_usage_q = from f in "funnels", where: f.site_id in ^site_ids

      revenue_goals_usage_q =
        from g in Plausible.Goal,
          where: g.site_id in ^site_ids and not is_nil(g.currency)

      site_segments_usage_q =
        from s in Plausible.Segments.Segment, where: s.site_id in ^site_ids and s.type == :site

      [
        {Feature.SharedLinks, shared_links_usage_q},
        {Feature.Props, props_usage_q},
        {Feature.Funnels, funnels_usage_q},
        {Feature.RevenueGoals, revenue_goals_usage_q},
        {Feature.SiteSegments, site_segments_usage_q}
      ]
      |> Enum.reduce([], fn {feature, query}, acc ->
        if Repo.exists?(query), do: acc ++ [feature], else: acc
      end)
    end
  else
    def features_usage(_team, _site_ids), do: []
  end

  defp query_team_member_emails(team, pending_ownership_site_ids, exclude_emails) do
    pending_owner_memberships_q =
      from s in Plausible.Site,
        inner_join: t in assoc(s, :team),
        inner_join: tm in assoc(t, :team_memberships),
        inner_join: u in assoc(tm, :user),
        where: s.id in ^pending_ownership_site_ids,
        where: tm.role == :owner,
        where: u.email not in ^exclude_emails,
        select: %{email: u.email}

    pending_memberships_q =
      from tm in Teams.Membership,
        inner_join: u in assoc(tm, :user),
        left_join: gm in assoc(tm, :guest_memberships),
        where: gm.site_id in ^pending_ownership_site_ids,
        where: u.email not in ^exclude_emails,
        select: %{email: u.email}

    pending_invitations_q =
      from ti in Teams.Invitation,
        inner_join: gi in assoc(ti, :guest_invitations),
        where: gi.site_id in ^pending_ownership_site_ids,
        where: ti.email not in ^exclude_emails,
        select: %{email: ti.email}

    team_memberships_q =
      from tm in Teams.Membership,
        inner_join: u in assoc(tm, :user),
        where: tm.team_id == ^team.id,
        where: u.email not in ^exclude_emails,
        select: %{email: u.email}

    team_invitations_q =
      from ti in Teams.Invitation,
        where: ti.team_id == ^team.id,
        where: ti.email not in ^exclude_emails,
        select: %{email: ti.email}

    pending_memberships_q
    |> union(^pending_owner_memberships_q)
    |> union(^pending_invitations_q)
    |> union(^team_memberships_q)
    |> union(^team_invitations_q)
  end

  def allowed_features_for(nil) do
    [Goals]
  end

  def allowed_features_for(team) do
    team = Teams.with_subscription(team)

    case Plans.get_subscription_plan(team.subscription) do
      %EnterprisePlan{features: features} ->
        features

      %Plan{features: features} ->
        features

      :free_10k ->
        [Goals, Props, StatsAPI, SharedLinks]

      nil ->
        if Teams.on_trial?(team) do
          Feature.list() -- [SitesAPI, SSO]
        else
          [Goals]
        end
    end
  end

  defp active_subscription_query(team) do
    from(s in Plausible.Billing.Subscription,
      where:
        s.team_id == ^team.id and s.status == ^Plausible.Billing.Subscription.Status.active(),
      order_by: [desc: s.inserted_at],
      limit: 1
    )
  end
end
```

## File: `lib/plausible/teams/grace_period.ex`
```
defmodule Plausible.Teams.GracePeriod do
  @moduledoc """
  This embedded schema stores information about the account locking grace
  period.

  Teams are given this 7-day grace period to upgrade their account after
  outgrowing their subscriptions. The actual account locking happens in
  background with `Plausible.Workers.LockSites`.

  The grace period can also be manual, without an end date, being controlled
  manually from the CRM, and not by the background site locker job. This is
  useful for enterprise subscriptions.
  """

  use Ecto.Schema
  alias Plausible.Teams

  @type t() :: %__MODULE__{
          end_date: Date.t() | nil,
          is_over: boolean(),
          manual_lock: boolean()
        }

  embedded_schema do
    field :end_date, :date
    field :is_over, :boolean
    field :manual_lock, :boolean
  end

  @spec start_changeset(Teams.Team.t()) :: Ecto.Changeset.t()
  @doc """
  Starts a account locking grace period of 7 days by changing the Team struct.
  """
  def start_changeset(%Teams.Team{} = team) do
    grace_period = %__MODULE__{
      end_date: Date.shift(Date.utc_today(), day: 7),
      is_over: false,
      manual_lock: false
    }

    Ecto.Changeset.change(team, grace_period: grace_period)
  end

  @spec start_manual_lock_changeset(Teams.Team.t()) :: Ecto.Changeset.t()
  @doc """
  Starts a manual account locking grace period by changing the Team struct.
  Manual locking means the grace period can only be removed manually from the
  CRM.
  """
  def start_manual_lock_changeset(%Teams.Team{} = team) do
    grace_period = %__MODULE__{
      end_date: nil,
      is_over: false,
      manual_lock: true
    }

    Ecto.Changeset.change(team, grace_period: grace_period)
  end

  @spec end_changeset(Teams.Team.t()) :: Ecto.Changeset.t()
  @doc """
  Ends an existing grace period by setting `teams.grace_period.is_over` to true.
  This means the grace period has expired.
  """
  def end_changeset(%Teams.Team{} = team) do
    Ecto.Changeset.change(team, grace_period: %{is_over: true})
  end

  @spec remove_changeset(Teams.Team.t()) :: Ecto.Changeset.t()
  @doc """
  Removes the grace period from the Team completely.
  """
  def remove_changeset(%Teams.Team{} = team) do
    Ecto.Changeset.change(team, grace_period: nil)
  end

  @spec active?(Teams.Team.t() | nil) :: boolean()
  @doc """
  Returns whether the grace period is still active for a Team. Defaults to
  false if the team is nil or there is no grace period.
  """
  def active?(team)

  def active?(%{grace_period: %__MODULE__{end_date: %Date{} = end_date}}) do
    Date.diff(end_date, Date.utc_today()) >= 0
  end

  def active?(%{grace_period: %__MODULE__{manual_lock: true}}) do
    true
  end

  def active?(_team), do: false

  @spec expired?(Teams.Team.t() | nil) :: boolean()
  @doc """
  Returns whether the grace period has already expired for a Team. Defaults to
  false if the team is nil or there is no grace period.
  """
  def expired?(team) do
    if team && team.grace_period, do: !active?(team), else: false
  end
end
```

## File: `lib/plausible/teams/guest_invitation.ex`
```
defmodule Plausible.Teams.GuestInvitation do
  @moduledoc """
  Guest invitation schema
  """

  use Ecto.Schema

  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  schema "guest_invitations" do
    field :invitation_id, :string
    field :role, Ecto.Enum, values: [:viewer, :editor]

    belongs_to :site, Plausible.Site
    belongs_to :team_invitation, Plausible.Teams.Invitation

    timestamps()
  end

  def changeset(team_invitation, site, role) do
    %__MODULE__{invitation_id: Nanoid.generate()}
    |> cast(%{role: role}, [:role])
    |> validate_required(:role)
    |> put_assoc(:team_invitation, team_invitation)
    |> put_assoc(:site, site)
  end
end
```

## File: `lib/plausible/teams/guest_membership.ex`
```
defmodule Plausible.Teams.GuestMembership do
  @moduledoc """
  Guest membership schema
  """

  use Ecto.Schema

  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  schema "guest_memberships" do
    field :role, Ecto.Enum, values: [:viewer, :editor]

    belongs_to :team_membership, Plausible.Teams.Membership
    belongs_to :site, Plausible.Site

    timestamps()
  end

  def changeset(team_membership, site, role) do
    %__MODULE__{}
    |> change()
    |> put_change(:role, role)
    |> put_assoc(:team_membership, team_membership)
    |> put_assoc(:site, site)
  end
end
```

## File: `lib/plausible/teams/invitation.ex`
```
defmodule Plausible.Teams.Invitation do
  @moduledoc """
  Team invitation schema
  """

  use Ecto.Schema

  import Ecto.Changeset

  @roles Plausible.Teams.Membership.roles()

  @type t() :: %__MODULE__{}

  schema "team_invitations" do
    field :invitation_id, :string
    field :email, :string
    field :role, Ecto.Enum, values: @roles

    belongs_to :inviter, Plausible.Auth.User
    belongs_to :team, Plausible.Teams.Team

    has_many :guest_invitations, Plausible.Teams.GuestInvitation, foreign_key: :team_invitation_id

    timestamps()
  end

  def roles(), do: @roles

  def changeset(team, opts) do
    email = Keyword.fetch!(opts, :email)
    role = Keyword.fetch!(opts, :role)
    inviter = Keyword.fetch!(opts, :inviter)

    %__MODULE__{invitation_id: Nanoid.generate()}
    |> cast(%{email: email, role: role}, [:email, :role])
    |> validate_required([:email, :role])
    |> put_assoc(:team, team)
    |> put_assoc(:inviter, inviter)
  end
end
```

## File: `lib/plausible/teams/invitations.ex`
```
defmodule Plausible.Teams.Invitations do
  @moduledoc false

  use Plausible

  import Ecto.Query

  alias Plausible.Auth
  alias Plausible.Billing
  alias Plausible.Repo
  alias Plausible.Teams

  def get_team_invitation(team, invitation_id) do
    invitation = Repo.get_by(Teams.Invitation, team_id: team.id, invitation_id: invitation_id)

    if invitation do
      {:ok, invitation}
    else
      {:error, :invitation_not_found}
    end
  end

  @spec find_by_team_identifier(String.t() | nil, Plausible.Auth.User.t()) ::
          {:ok, Teams.Invitation.t()} | {:error, :invitation_not_found}
  def find_by_team_identifier(nil, _user), do: {:error, :invitation_not_found}

  def find_by_team_identifier(team_identifier, user) do
    invitation_query =
      from ti in Teams.Invitation,
        inner_join: inviter in assoc(ti, :inviter),
        inner_join: team in assoc(ti, :team),
        where: ti.email == ^user.email,
        where: team.identifier == ^team_identifier,
        where: ti.role != :guest,
        preload: [inviter: inviter, team: team]

    case Repo.one(invitation_query) do
      nil ->
        {:error, :invitation_not_found}

      invitation ->
        {:ok, invitation}
    end
  end

  def find_for_user(invitation_or_transfer_id, user) do
    with {:error, :invitation_not_found} <-
           find_team_invitation_for_user(invitation_or_transfer_id, user),
         {:error, :invitation_not_found} <-
           find_guest_invitation_for_user(invitation_or_transfer_id, user) do
      find_transfer_for_user(invitation_or_transfer_id, user)
    end
  end

  def find_for_site(invitation_or_transfer_id, site) do
    with {:error, :invitation_not_found} <-
           find_invitation_for_site(invitation_or_transfer_id, site) do
      find_transfer_for_site(invitation_or_transfer_id, site)
    end
  end

  def all(%Teams.Team{} = team) do
    Repo.all(
      from ti in Teams.Invitation,
        inner_join: inviter in assoc(ti, :inviter),
        where: ti.team_id == ^team.id,
        preload: [inviter: inviter]
    )
  end

  def all(%Plausible.Auth.User{} = user) do
    Repo.all(
      from ti in Teams.Invitation,
        inner_join: inviter in assoc(ti, :inviter),
        inner_join: team in assoc(ti, :team),
        where: ti.email == ^user.email,
        where: ti.role != :guest,
        preload: [inviter: inviter, team: team]
    )
  end

  defp find_team_invitation_for_user(team_invitation_id, user) do
    invitation_query =
      from ti in Teams.Invitation,
        inner_join: inviter in assoc(ti, :inviter),
        inner_join: team in assoc(ti, :team),
        where: ti.invitation_id == ^team_invitation_id,
        where: ti.email == ^user.email,
        where: ti.role != :guest,
        preload: [inviter: inviter, team: team]

    case Repo.one(invitation_query) do
      nil ->
        {:error, :invitation_not_found}

      invitation ->
        {:ok, invitation}
    end
  end

  defp find_guest_invitation_for_user(guest_invitation_id, user) do
    invitation_query =
      from gi in Teams.GuestInvitation,
        inner_join: s in assoc(gi, :site),
        inner_join: ti in assoc(gi, :team_invitation),
        inner_join: t in assoc(ti, :team),
        inner_join: inviter in assoc(ti, :inviter),
        where: gi.invitation_id == ^guest_invitation_id,
        where: ti.email == ^user.email,
        preload: [site: s, team_invitation: {ti, team: t, inviter: inviter}]

    case Repo.one(invitation_query) do
      nil ->
        {:error, :invitation_not_found}

      invitation ->
        {:ok, invitation}
    end
  end

  defp find_transfer_for_user(transfer_id, user) do
    transfer =
      Teams.SiteTransfer
      |> Repo.get_by(transfer_id: transfer_id, email: user.email)
      |> Repo.preload([:initiator, site: :team])

    case transfer do
      nil ->
        {:error, :invitation_not_found}

      transfer ->
        {:ok, transfer}
    end
  end

  defp find_invitation_for_site(guest_invitation_id, site) do
    invitation =
      Teams.GuestInvitation
      |> Repo.get_by(invitation_id: guest_invitation_id, site_id: site.id)
      |> Repo.preload([:site, team_invitation: :inviter])

    case invitation do
      nil ->
        {:error, :invitation_not_found}

      invitation ->
        {:ok, invitation}
    end
  end

  defp find_transfer_for_site(transfer_id, site) do
    transfer =
      Teams.SiteTransfer
      |> Repo.get_by(transfer_id: transfer_id, site_id: site.id)
      |> Repo.preload([:site, :initiator])

    case transfer do
      nil ->
        {:error, :invitation_not_found}

      transfer ->
        {:ok, transfer}
    end
  end

  def invite(%Teams.Team{} = team, invitee_email, role, inviter) do
    create_team_invitation(team, invitee_email, inviter, role: role)
  end

  def invite(%Plausible.Site{} = site, invitee_email, role, inviter) do
    site = Repo.preload(site, :team)

    if role == :owner do
      create_site_transfer(
        site,
        inviter,
        invitee_email
      )
    else
      create_invitation(
        site,
        invitee_email,
        role,
        inviter
      )
    end
  end

  def remove_team_invitation(team_invitation) do
    Repo.delete_all(
      from ti in Teams.Invitation,
        where: ti.id == ^team_invitation.id
    )

    :ok
  end

  def remove_guest_invitation(guest_invitation) do
    site = Repo.preload(guest_invitation, site: :team).site

    Repo.delete_all(
      from gi in Teams.GuestInvitation,
        where: gi.id == ^guest_invitation.id
    )

    prune_guest_invitations(site.team)
  end

  def remove_site_transfer(site_transfer) do
    Repo.delete_all(
      from st in Teams.SiteTransfer,
        where: st.id == ^site_transfer.id
    )
  end

  def accept_site_transfer(site_transfer, team) do
    {:ok, _} =
      Repo.transaction(fn ->
        :ok = transfer_site_ownership(site_transfer.site, team, NaiveDateTime.utc_now(:second))
        Repo.delete_all(from st in Teams.SiteTransfer, where: st.id == ^site_transfer.id)
      end)

    :ok
  end

  def transfer_site(site, team) do
    {:ok, _} =
      Repo.transaction(fn ->
        :ok = transfer_site_ownership(site, team, NaiveDateTime.utc_now(:second))
      end)

    :ok
  end

  def accept_guest_invitation(guest_invitation, user) do
    guest_invitation = Repo.preload(guest_invitation, :site)

    team_invitation =
      guest_invitation.team_invitation
      |> Repo.preload([
        :team,
        :inviter,
        guest_invitations: :site
      ])

    now = NaiveDateTime.utc_now(:second)

    do_accept(team_invitation, user, now, guest_invitations: [guest_invitation])
  end

  def accept_team_invitation(team_invitation, user) do
    team_invitation = Repo.preload(team_invitation, [:team, :inviter])
    now = NaiveDateTime.utc_now(:second)

    if Plausible.Users.type(user) == :sso do
      {:error, :permission_denied}
    else
      do_accept(team_invitation, user, now, guest_invitations: [])
    end
  end

  @doc false
  def ensure_transfer_valid(_team, nil, :owner), do: :ok

  def ensure_transfer_valid(team, new_team, :owner) do
    if team.id == new_team.id do
      {:error, :transfer_to_self}
    else
      :ok
    end
  end

  def ensure_transfer_valid(_team, _new_owner, _role), do: :ok

  defp create_site_transfer(site, initiator, invitee_email, now \\ NaiveDateTime.utc_now(:second)) do
    result =
      Ecto.Multi.new()
      |> Ecto.Multi.put(
        :site_transfer_changeset,
        Teams.SiteTransfer.changeset(site, initiator: initiator, email: invitee_email)
      )
      |> Ecto.Multi.run(:ensure_no_invitations, fn _repo, %{site_transfer_changeset: changeset} ->
        q =
          from ti in Teams.Invitation,
            inner_join: gi in assoc(ti, :guest_invitations),
            where: ti.email == ^invitee_email,
            where: ti.team_id == ^site.team_id,
            where: gi.site_id == ^site.id

        if Repo.exists?(q) do
          {:error, Ecto.Changeset.add_error(changeset, :invitation, "already sent")}
        else
          {:ok, :pass}
        end
      end)
      |> Ecto.Multi.insert(
        :site_transfer,
        fn %{site_transfer_changeset: changeset} -> changeset end,
        on_conflict: [set: [updated_at: now]],
        conflict_target: [:email, :site_id],
        returning: true
      )
      |> Repo.transaction()

    case result do
      {:ok, success} ->
        {:ok, success.site_transfer}

      {:error, _, changeset, _} ->
        {:error, changeset}
    end
  end

  defp do_accept(team_invitation, user, now, opts) do
    send_email? = Keyword.get(opts, :send_email?, true)
    guest_invitations = Keyword.get(opts, :guest_invitations, team_invitation.guest_invitations)

    Repo.transaction(fn ->
      with {:ok, team_membership} <-
             create_team_membership(team_invitation.team, team_invitation.role, user, now),
           {:ok, guest_memberships} <-
             create_guest_memberships(team_membership, guest_invitations, now) do
        # Clean up guest invitations after accepting
        guest_invitation_ids = Enum.map(guest_invitations, & &1.id)
        Repo.delete_all(from gi in Teams.GuestInvitation, where: gi.id in ^guest_invitation_ids)

        if team_membership.role != :guest do
          Repo.delete_all(from ti in Teams.Invitation, where: ti.id == ^team_invitation.id)
        end

        prune_guest_invitations(team_invitation.team)

        # Prune guest memberships if any exist when team membership role
        # is other than guest
        maybe_prune_guest_memberships(team_membership)

        if send_email? do
          send_invitation_accepted_email(team_invitation, guest_invitations)
        end

        %{
          team: team_invitation.team,
          team_membership: team_membership,
          guest_memberships: guest_memberships
        }
      else
        {:error, changeset} -> Repo.rollback(changeset)
      end
    end)
  end

  defp maybe_prune_guest_memberships(%Teams.Membership{role: :guest}), do: :ok

  defp maybe_prune_guest_memberships(%Teams.Membership{} = team_membership) do
    team_membership
    |> Ecto.assoc(:guest_memberships)
    |> Repo.delete_all()

    :ok
  end

  defp transfer_site_ownership(site, team, now) do
    site =
      Repo.preload(site, [
        :team,
        :owners,
        guest_memberships: [team_membership: :user],
        guest_invitations: [team_invitation: :inviter]
      ])

    prior_team = site.team

    site
    |> Ecto.Changeset.change(team_id: team.id)
    |> Repo.update!()

    {_old_team_invitations, old_guest_invitations} =
      site.guest_invitations
      |> Enum.map(fn old_guest_invitation ->
        old_team_invitation = old_guest_invitation.team_invitation

        {:ok, new_team_invitation} =
          create_team_invitation(team, old_team_invitation.email, old_team_invitation.inviter)

        {:ok, _new_guest_invitation} =
          create_guest_invitation(new_team_invitation, site, old_guest_invitation.role)

        {old_team_invitation, old_guest_invitation}
      end)
      |> Enum.unzip()

    old_guest_ids = Enum.map(old_guest_invitations, & &1.id)
    Repo.delete_all(from gi in Teams.GuestInvitation, where: gi.id in ^old_guest_ids)
    :ok = prune_guest_invitations(prior_team)

    {_old_team_memberships, old_guest_memberships} =
      site.guest_memberships
      |> Enum.map(fn old_guest_membership ->
        old_team_membership = old_guest_membership.team_membership

        {:ok, new_team_membership} =
          create_team_membership(team, :guest, old_team_membership.user, now)

        if new_team_membership.role == :guest do
          {:ok, _} =
            new_team_membership
            |> Teams.GuestMembership.changeset(site, old_guest_membership.role)
            |> Repo.insert(
              on_conflict: [set: [updated_at: now, role: old_guest_membership.role]],
              conflict_target: [:team_membership_id, :site_id],
              returning: true
            )
        end

        {old_team_membership, old_guest_membership}
      end)
      |> Enum.unzip()

    old_guest_ids = Enum.map(old_guest_memberships, & &1.id)
    Repo.delete_all(from gm in Teams.GuestMembership, where: gm.id in ^old_guest_ids)
    :ok = Teams.Memberships.prune_guests(prior_team)

    prior_owners = Repo.preload(prior_team, :owners).owners

    for prior_owner <- prior_owners do
      {:ok, prior_owner_team_membership} = create_team_membership(team, :guest, prior_owner, now)

      if prior_owner_team_membership.role == :guest do
        {:ok, _} =
          prior_owner_team_membership
          |> Teams.GuestMembership.changeset(site, :editor)
          |> Repo.insert(
            on_conflict: [set: [updated_at: now, role: :editor]],
            conflict_target: [:team_membership_id, :site_id],
            returning: true
          )
      end
    end

    on_ee do
      Billing.SiteLocker.update_for(prior_team, send_email?: false)
      :unlocked = Billing.SiteLocker.update_for(team, send_email?: false)
    end

    :ok
  end

  def prune_guest_invitations(team) do
    guest_query =
      from(
        gi in Teams.GuestInvitation,
        where: gi.team_invitation_id == parent_as(:team_invitation).id,
        select: true
      )

    Repo.delete_all(
      from(
        ti in Teams.Invitation,
        as: :team_invitation,
        where: ti.team_id == ^team.id and ti.role == :guest,
        where: not exists(guest_query)
      )
    )

    :ok
  end

  on_ee do
    def ensure_can_take_ownership(_site, nil), do: {:error, :no_plan}

    def ensure_can_take_ownership(site, team) do
      team = Teams.with_subscription(team)
      plan = Billing.Plans.get_subscription_plan(team.subscription)
      active_subscription? = Billing.Subscriptions.active?(team.subscription)

      if active_subscription? and plan != :free_10k do
        team
        |> Teams.Billing.quota_usage(pending_ownership_site_ids: [site.id])
        |> Billing.Quota.ensure_within_plan_limits(plan,
          skip_site_limit_check?: Teams.Billing.grandfathered_team?(team)
        )
      else
        {:error, :no_plan}
      end
    end
  else
    def ensure_can_take_ownership(_site, _team) do
      always(:ok)
    end
  end

  def send_transfer_accepted_email(site_transfer, team) do
    initiator_as_guest_editor? =
      Teams.Memberships.site_role(site_transfer.site, site_transfer.initiator) ==
        {:ok, {:guest_member, :editor}}

    PlausibleWeb.Email.ownership_transfer_accepted(
      site_transfer.email,
      site_transfer.initiator.email,
      team,
      site_transfer.site,
      initiator_as_guest_editor?
    )
    |> Plausible.Mailer.send()
  end

  def send_team_changed_email(site, user, team) do
    owners = Repo.preload(team, :owners).owners

    for owner <- owners do
      PlausibleWeb.Email.team_changed(owner.email, user, team, site)
      |> Plausible.Mailer.send()
    end
  end

  @spec check_can_transfer_site(Teams.Team.t(), Auth.User.t()) ::
          :ok | {:error, :permission_denied}
  def check_can_transfer_site(team, user) do
    case Teams.Memberships.team_role(team, user) do
      {:ok, role} when role in [:owner, :admin] ->
        :ok

      _ ->
        {:error, :permission_denied}
    end
  end

  @doc false
  def check_invitation_permissions(%Teams.Team{} = team, inviter, invitation_role, opts) do
    check_permissions? = Keyword.get(opts, :check_permissions, true)

    if check_permissions? do
      case Teams.Memberships.team_role(team, inviter) do
        {:ok, :owner} when invitation_role == :owner ->
          :ok

        {:ok, inviter_role}
        when inviter_role in [:owner, :admin] and invitation_role != :owner ->
          :ok

        _ ->
          {:error, :permission_denied}
      end
    else
      :ok
    end
  end

  def check_invitation_permissions(%Plausible.Site{} = site, inviter, _invitation_role, opts) do
    check_permissions? = Keyword.get(opts, :check_permissions, true)

    if check_permissions? do
      case Teams.Memberships.site_role(site, inviter) do
        {:ok, {:team_member, inviter_role}} when inviter_role in [:owner, :admin] ->
          :ok

        _ ->
          {:error, :permission_denied}
      end
    else
      :ok
    end
  end

  @doc false
  def check_team_member_limit(_team, :owner, _invitee_email), do: :ok

  def check_team_member_limit(team, _role, invitee_email) do
    limit = Teams.Billing.team_member_limit(team)
    usage = Teams.Billing.team_member_usage(team, exclude_emails: [invitee_email])

    if Billing.Quota.below_limit?(usage, limit) do
      :ok
    else
      {:error, {:over_limit, limit}}
    end
  end

  @doc false
  def ensure_new_membership(_site_or_team, nil, _role), do: :ok

  def ensure_new_membership(_site_or_team, _invitee, :owner), do: :ok

  def ensure_new_membership(%Teams.Team{} = team, invitee, _role) do
    case Teams.Memberships.team_role(team, invitee) do
      {:ok, :guest} -> :ok
      {:error, :not_a_member} -> :ok
      {:ok, _} -> {:error, :already_a_member}
    end
  end

  def ensure_new_membership(%Plausible.Site{} = site, invitee, _role) do
    if Teams.Memberships.site_role(site, invitee) == {:error, :not_a_member} do
      :ok
    else
      {:error, :already_a_member}
    end
  end

  defp create_invitation(site, invitee_email, role, inviter) do
    Repo.transaction(fn ->
      with {:ok, team_invitation} <-
             create_team_invitation(site.team, invitee_email, inviter,
               ensure_no_site_transfers_for: site.id
             ),
           {:ok, guest_invitation} <- create_guest_invitation(team_invitation, site, role) do
        guest_invitation
      else
        {:error, changeset} -> Repo.rollback(changeset)
      end
    end)
  end

  defp create_team_invitation(team, invitee_email, inviter, opts \\ []) do
    now = NaiveDateTime.utc_now(:second)
    role = Keyword.get(opts, :role, :guest)

    result =
      Ecto.Multi.new()
      |> Ecto.Multi.put(
        :changeset,
        Teams.Invitation.changeset(team, email: invitee_email, role: role, inviter: inviter)
      )
      |> Ecto.Multi.run(:ensure_no_site_transfers, fn _repo, %{changeset: changeset} ->
        ensure_no_site_transfers(changeset, opts[:ensure_no_site_transfers_for], invitee_email)
      end)
      |> Ecto.Multi.insert(
        :team_invitation,
        & &1.changeset,
        on_conflict: [set: [updated_at: now, role: role]],
        conflict_target: [:team_id, :email],
        returning: true
      )
      |> Ecto.Multi.run(:prune_guest_entries, fn _repo, %{team_invitation: team_invitation} ->
        if team_invitation.role != :guest do
          team_invitation
          |> Ecto.assoc(:guest_invitations)
          |> Repo.delete_all()
        end

        {:ok, nil}
      end)
      |> Repo.transaction()

    case result do
      {:ok, success} ->
        {:ok, success.team_invitation}

      {:error, _, changeset, _} ->
        {:error, changeset}
    end
  end

  defp create_guest_invitation(team_invitation, site, role) do
    now = NaiveDateTime.utc_now(:second)

    team_invitation
    |> Teams.GuestInvitation.changeset(site, role)
    |> Repo.insert(
      on_conflict: [set: [updated_at: now]],
      conflict_target: [:team_invitation_id, :site_id],
      returning: true
    )
  end

  @doc false
  def send_invitation_email(%Teams.SiteTransfer{} = transfer, invitee) do
    email =
      PlausibleWeb.Email.ownership_transfer_request(
        transfer.email,
        transfer.transfer_id,
        transfer.site,
        transfer.initiator,
        invitee
      )

    Plausible.Mailer.send(email)
  end

  def send_invitation_email(%Teams.Invitation{} = team_invitation, invitee) do
    email =
      if invitee do
        PlausibleWeb.Email.existing_user_team_invitation(
          team_invitation.email,
          team_invitation.team,
          team_invitation.inviter
        )
      else
        PlausibleWeb.Email.new_user_team_invitation(
          team_invitation.email,
          team_invitation.invitation_id,
          team_invitation.team,
          team_invitation.inviter
        )
      end

    Plausible.Mailer.send(email)
  end

  def send_invitation_email(%Teams.GuestInvitation{} = guest_invitation, invitee) do
    team_invitation = guest_invitation.team_invitation

    email =
      if invitee do
        PlausibleWeb.Email.existing_user_invitation(
          team_invitation.email,
          guest_invitation.site,
          team_invitation.inviter
        )
      else
        PlausibleWeb.Email.new_user_invitation(
          team_invitation.email,
          guest_invitation.invitation_id,
          guest_invitation.site,
          team_invitation.inviter
        )
      end

    Plausible.Mailer.send(email)
  end

  @team_role_type Plausible.Teams.Membership.__schema__(:type, :role)

  def create_team_membership(team, role, user, now) do
    conflict_query =
      from(tm in Teams.Membership,
        update: [
          set: [
            updated_at: ^now,
            role:
              fragment(
                "CASE WHEN ? = 'guest' THEN ? ELSE ? END",
                tm.role,
                type(^role, ^@team_role_type),
                tm.role
              )
          ]
        ]
      )

    team
    |> Teams.Membership.changeset(user, role)
    |> Repo.insert(
      on_conflict: conflict_query,
      conflict_target: [:team_id, :user_id],
      returning: true
    )
  end

  defp create_guest_memberships(_team_membership, [], _now) do
    {:ok, []}
  end

  defp create_guest_memberships(%{role: role} = _team_membership, _, _) when role != :guest do
    {:ok, []}
  end

  defp create_guest_memberships(team_membership, guest_invitations, now) do
    Enum.reduce_while(guest_invitations, {:ok, []}, fn guest_invitation,
                                                       {:ok, guest_memberships} ->
      result =
        team_membership
        |> Teams.GuestMembership.changeset(guest_invitation.site, guest_invitation.role)
        |> Repo.insert(
          on_conflict: [set: [updated_at: now]],
          conflict_target: [:team_membership_id, :site_id]
        )

      case result do
        {:ok, guest_membership} -> {:cont, {:ok, [guest_membership | guest_memberships]}}
        {:error, changeset} -> {:halt, {:error, changeset}}
      end
    end)
  end

  defp send_invitation_accepted_email(team_invitation, []) do
    team_invitation.inviter.email
    |> PlausibleWeb.Email.team_invitation_accepted(team_invitation.email, team_invitation.team)
    |> Plausible.Mailer.send()
  end

  defp send_invitation_accepted_email(team_invitation, [guest_invitation | _]) do
    team_invitation.inviter.email
    |> PlausibleWeb.Email.guest_invitation_accepted(
      team_invitation.email,
      team_invitation.team,
      guest_invitation.site
    )
    |> Plausible.Mailer.send()
  end

  defp ensure_no_site_transfers(_, nil, _) do
    {:ok, :skip}
  end

  defp ensure_no_site_transfers(changeset, site_id, invitee_email)
       when is_integer(site_id) and is_binary(invitee_email) do
    q =
      from st in Teams.SiteTransfer,
        where: st.email == ^invitee_email,
        where: st.site_id == ^site_id

    if Repo.exists?(q) do
      {:error, Ecto.Changeset.add_error(changeset, :invitation, "already sent")}
    else
      {:ok, :pass}
    end
  end
end
```

## File: `lib/plausible/teams/invitations/accept.ex`
```
defmodule Plausible.Teams.Invitations.Accept do
  use Plausible

  @moduledoc """
  Service for accepting invitations, including ownership transfers.

  Accepting invitation accounts for the fact that it's possible
  that accepting user has an existing membership for the site and
  acts permissively to not unnecessarily disrupt the flow while
  also maintaining integrity of site memberships. This also applies
  to cases where users update their email address between issuing
  the invitation and accepting it.
  """

  alias Plausible.Auth
  alias Plausible.Billing
  alias Plausible.Teams

  @type accept_error() ::
          :invitation_not_found
          | Billing.Quota.Limits.over_limits_error()
          | Ecto.Changeset.t()
          | :no_plan
          | :transfer_to_self
          | :multiple_teams
          | :permission_denied

  @spec accept(String.t(), Auth.User.t(), Teams.Team.t() | nil) ::
          {:ok, map()} | {:error, accept_error()}
  def accept(invitation_or_transfer_id, user, team \\ nil) do
    with {:ok, invitation_or_transfer} <-
           Teams.Invitations.find_for_user(invitation_or_transfer_id, user) do
      case invitation_or_transfer do
        %Teams.SiteTransfer{} = site_transfer ->
          Teams.Sites.Transfer.accept(site_transfer, user, team)

        %Teams.Invitation{} = team_invitation ->
          Teams.Invitations.accept_team_invitation(team_invitation, user)

        %Teams.GuestInvitation{} = guest_invitation ->
          Teams.Invitations.accept_guest_invitation(guest_invitation, user)
      end
    end
  end
end
```

## File: `lib/plausible/teams/invitations/invite_to_site.ex`
```
defmodule Plausible.Teams.Invitations.InviteToSite do
  @moduledoc """
  Service for inviting new or existing users to a sites, including ownershhip
  transfers.
  """

  alias Plausible.Auth.User
  alias Plausible.Repo
  alias Plausible.Site
  alias Plausible.Teams
  use Plausible

  @type invite_error() ::
          Ecto.Changeset.t()
          | :already_a_member
          | {:over_limit, non_neg_integer()}
          | :permission_denied

  @type invitation :: %Teams.GuestInvitation{} | %Teams.SiteTransfer{}

  @doc """
  Invites a new team member to the given site. Returns either
  `%Teams.GuestInvitation{}` or `%Teams.SiteTransfer{}` struct
  and sends the invitee an email to accept this invitation.

  The inviter must have enough permissions to invite the new team member,
  otherwise this function returns `{:error, :permission_denied}`.

  If the new team member role is `:owner`, this function handles the invitation
  as an ownership transfer and requires the inviter to be the owner of the site.
  """
  @spec invite(Site.t(), User.t(), String.t(), atom()) ::
          {:ok, invitation} | {:error, invite_error()}
  def invite(site, inviter, invitee_email, role) do
    Repo.transaction(fn ->
      do_invite(site, inviter, invitee_email, role)
    end)
  end

  defp do_invite(site, inviter, invitee_email, role, opts \\ []) do
    with site <- Repo.preload(site, [:owners, :team]),
         :ok <- Teams.Invitations.check_invitation_permissions(site, inviter, role, opts),
         :ok <- Teams.Invitations.check_team_member_limit(site.team, role, invitee_email),
         invitee = Plausible.Auth.find_user_by(email: invitee_email),
         :ok <- Teams.Invitations.ensure_new_membership(site, invitee, role),
         {:ok, invitation_or_transfer} <-
           Teams.Invitations.invite(site, invitee_email, role, inviter) do
      send_invitation_email(invitation_or_transfer, invitee)

      invitation_or_transfer
    else
      {:error, cause} -> Repo.rollback(cause)
    end
  end

  defp send_invitation_email(%Teams.GuestInvitation{} = guest_invitation, invitee) do
    guest_invitation
    |> Repo.preload([:site, team_invitation: :inviter])
    |> Teams.Invitations.send_invitation_email(invitee)
  end

  defp send_invitation_email(%Teams.SiteTransfer{} = site_transfer, invitee) do
    site_transfer
    |> Repo.preload([:site, :initiator])
    |> Teams.Invitations.send_invitation_email(invitee)
  end
end
```

## File: `lib/plausible/teams/invitations/invite_to_team.ex`
```
defmodule Plausible.Teams.Invitations.InviteToTeam do
  @moduledoc """
  Service for inviting new or existing users to team.
  """

  alias Plausible.Repo
  alias Plausible.Teams

  @valid_roles Plausible.Teams.Invitation.roles() -- [:guest]
  @valid_roles @valid_roles ++ Enum.map(@valid_roles, &to_string/1)

  def invite(team, inviter, invitee_email, role, opts \\ [])

  def invite(team, inviter, invitee_email, role, opts) when role in @valid_roles do
    with team <- Repo.preload(team, [:owners]),
         :ok <- Teams.Invitations.check_invitation_permissions(team, inviter, role, opts),
         :ok <- Teams.Invitations.check_team_member_limit(team, role, invitee_email),
         invitee = Plausible.Auth.find_user_by(email: invitee_email),
         :ok <- Teams.Invitations.ensure_new_membership(team, invitee, role),
         {:ok, invitation} <- Teams.Invitations.invite(team, invitee_email, role, inviter) do
      if Keyword.get(opts, :send_email?, true) do
        send_invitation_email(invitation, invitee)
      end

      {:ok, invitation}
    end
  end

  def invite(_team, _inviter, _invitee_email, role, _opts) do
    raise "Invalid role passed: #{inspect(role)}"
  end

  def send_invitation_email(invitation, invitee) do
    invitation
    |> Repo.preload([:team, :inviter])
    |> Teams.Invitations.send_invitation_email(invitee)
  end
end
```

## File: `lib/plausible/teams/invitations/reject.ex`
```
defmodule Plausible.Teams.Invitations.Reject do
  @moduledoc """
  Service for rejecting invitations.
  """

  alias Plausible.Auth
  alias Plausible.Teams

  @spec reject(String.t(), Auth.User.t()) ::
          {:ok, Teams.GuestInvitation.t() | Teams.SiteTransfer.t()}
          | {:error, :invitation_not_found}
  def reject(invitation_or_transfer_id, user) do
    with {:ok, invitation_or_transfer} <-
           Teams.Invitations.find_for_user(invitation_or_transfer_id, user) do
      do_reject(invitation_or_transfer)
      {:ok, invitation_or_transfer}
    end
  end

  defp do_reject(%Teams.Invitation{} = team_invitation) do
    Teams.Invitations.remove_team_invitation(team_invitation)

    notify_team_invitation_rejected(team_invitation)
  end

  defp do_reject(%Teams.GuestInvitation{} = guest_invitation) do
    Teams.Invitations.remove_guest_invitation(guest_invitation)

    notify_guest_invitation_rejected(guest_invitation)
  end

  defp do_reject(%Teams.SiteTransfer{} = site_transfer) do
    Teams.Invitations.remove_site_transfer(site_transfer)

    notify_site_transfer_rejected(site_transfer)
  end

  defp notify_site_transfer_rejected(site_transfer) do
    PlausibleWeb.Email.ownership_transfer_rejected(site_transfer)
    |> Plausible.Mailer.send()
  end

  defp notify_guest_invitation_rejected(guest_invitation) do
    PlausibleWeb.Email.guest_invitation_rejected(guest_invitation)
    |> Plausible.Mailer.send()
  end

  defp notify_team_invitation_rejected(team_invitation) do
    PlausibleWeb.Email.team_invitation_rejected(team_invitation)
    |> Plausible.Mailer.send()
  end
end
```

## File: `lib/plausible/teams/invitations/remove_from_site.ex`
```
defmodule Plausible.Teams.Invitations.RemoveFromSite do
  @moduledoc """
  Service for removing invitations.
  """

  alias Plausible.Teams

  @spec remove(String.t(), Plausible.Site.t()) ::
          {:ok, Teams.GuestInvitation.t() | Teams.SiteTransfer.t()}
          | {:error, :invitation_not_found}
  def remove(invitation_or_transfer_id, site) do
    with {:ok, invitation_or_transfer} <-
           Teams.Invitations.find_for_site(invitation_or_transfer_id, site) do
      do_delete(invitation_or_transfer)

      {:ok, invitation_or_transfer}
    end
  end

  defp do_delete(%Teams.GuestInvitation{} = guest_invitation) do
    Teams.Invitations.remove_guest_invitation(guest_invitation)
  end

  defp do_delete(%Teams.SiteTransfer{} = site_transfer) do
    Teams.Invitations.remove_site_transfer(site_transfer)
  end
end
```

## File: `lib/plausible/teams/invitations/remove_from_team.ex`
```
defmodule Plausible.Teams.Invitations.RemoveFromTeam do
  @moduledoc """
  Service for removing a team invitation.
  """

  alias Plausible.Repo
  alias Plausible.Teams.Invitations
  alias Plausible.Teams.Memberships

  def remove(nil, _invitation_id, _current_user) do
    {:error, :permission_denied}
  end

  def remove(team, invitation_id, current_user) do
    with {:ok, team_invitation} <- Invitations.get_team_invitation(team, invitation_id),
         {:ok, current_user_role} <- Memberships.team_role(team, current_user),
         :ok <- check_can_remove_invitation(current_user_role) do
      Repo.delete!(team_invitation)

      {:ok, team_invitation}
    end
  end

  defp check_can_remove_invitation(role) do
    if role in [:owner, :admin] do
      :ok
    else
      {:error, :permission_denied}
    end
  end
end
```

## File: `lib/plausible/teams/management/layout.ex`
```
defmodule Plausible.Teams.Management.Layout do
  @moduledoc """
  Abstraction for team membership(s) layout - provides a high level CRUD for
  setting up team memberships, including invitations. Persisting the layout,
  effectively takes care of delegating the operations to specialized services
  and sending out e-mail notifications on success, if need be.
  To be used in UIs allowing team memberships adjustments.
  """
  alias Plausible.Teams
  alias Plausible.Teams.Management.Layout.Entry
  alias Plausible.Repo
  alias Plausible.Auth.User

  @type t() :: %{String.t() => Entry.t()}

  @spec init(Teams.Team.t()) :: t()
  def init(%Teams.Team{} = team) do
    invitations_sent = Teams.Invitations.all(team)
    all_members = Teams.Memberships.all(team)
    build_by_email(invitations_sent ++ all_members)
  end

  @spec build_by_email([Teams.Invitation.t() | Teams.Membership.t()]) ::
          t()
  def build_by_email(entities) do
    Enum.reduce(entities, %{}, fn
      %Teams.Invitation{} = invitation, acc ->
        Map.put(acc, invitation.email, Entry.new(invitation))

      %Teams.Membership{} = membership, acc ->
        Map.put(
          acc,
          membership.user.email,
          Entry.new(membership)
        )
    end)
  end

  @spec active_count(t()) :: non_neg_integer()
  def active_count(layout) do
    Enum.count(layout, fn {_, entry} -> entry.queued_op != :delete end)
  end

  @spec owners_count(t()) :: non_neg_integer()
  def owners_count(layout) do
    Enum.count(layout, fn {_, entry} -> entry.queued_op != :delete and entry.role == :owner end)
  end

  @spec has_guests?(t()) :: boolean()
  def has_guests?(layout) do
    not is_nil(
      Enum.find(
        layout,
        fn
          {_, entry} -> entry.role == :guest and entry.queued_op != :delete
        end
      )
    )
  end

  @spec update_role(t(), String.t(), atom()) :: t()
  def update_role(layout, email, role) do
    entry = Map.fetch!(layout, email)
    Map.put(layout, email, Entry.patch(entry, role: role, queued_op: :update))
  end

  @spec schedule_send(t(), String.t(), atom(), Keyword.t()) :: t()
  def schedule_send(layout, email, role, entry_attrs \\ []) do
    invitation = %Teams.Invitation{email: email, role: role}
    Map.put(layout, email, Entry.new(invitation, Keyword.merge(entry_attrs, queued_op: :send)))
  end

  @spec schedule_delete(t(), String.t()) :: t()
  def schedule_delete(layout, email) do
    entry = Map.fetch!(layout, email)
    Map.put(layout, email, Entry.patch(entry, queued_op: :delete))
  end

  @spec verify_removable(t(), String.t()) :: :ok | {:error, String.t()}
  def verify_removable(layout, email) do
    ensure_at_least_one_owner(layout, email)
  end

  @spec removable?(t(), String.t()) :: boolean()
  def removable?(layout, email) do
    verify_removable(layout, email) == :ok
  end

  @spec sorted_for_display(t()) :: [{String.t(), Entry.t()}]
  def sorted_for_display(layout) do
    layout
    |> Enum.reject(fn {_, entry} -> entry.queued_op == :delete end)
    |> Enum.sort_by(fn {email, entry} ->
      primary_criterion =
        case entry do
          %{role: :guest, type: :invitation_pending} -> 10
          %{role: :guest, type: :invitation_sent} -> 11
          %{role: :guest, type: :membership} -> 12
          %{type: :invitation_pending} -> 0
          %{type: :invitation_sent} -> 1
          %{type: :membership} -> 2
        end

      secondary_criterion = entry.name
      tertiary_criterion = email
      {primary_criterion, secondary_criterion, tertiary_criterion}
    end)
  end

  @spec persist(t(), %{current_user: User.t(), current_team: Teams.Team.t()}) ::
          {:ok, integer()} | {:error, any()}
  def persist(layout, context) do
    result =
      Repo.transaction(fn ->
        Teams.complete_setup(context.current_team)

        layout
        |> sorted_for_persistence()
        |> Enum.reduce([], fn {_, entry}, acc ->
          persist_entry(entry, context, acc)
        end)
      end)

    case result do
      {:ok, persisted} ->
        persisted
        |> Enum.each(fn
          {%Entry{type: :invitation_pending}, invitation} ->
            invitee = Plausible.Auth.find_user_by(email: invitation.email)
            Teams.Invitations.InviteToTeam.send_invitation_email(invitation, invitee)

          {%Entry{type: :membership, queued_op: :delete}, team_membership} ->
            Teams.Memberships.Remove.send_team_member_removed_email(team_membership)

          _ ->
            :noop
        end)

        {:ok, length(persisted)}

      {:error, _} = error ->
        error
    end
  end

  defp sorted_for_persistence(layout) do
    # sort by deletions first, so team member limits are triggered accurately
    Enum.sort_by(layout, fn {_email, entry} ->
      case entry.queued_op do
        :delete -> 0
        _ -> 1
      end
    end)
  end

  defp ensure_at_least_one_owner(layout, email) do
    if Enum.find(layout, fn {_email, entry} ->
         entry.email != email and
           entry.role == :owner and
           entry.type == :membership and
           entry.queued_op != :delete
       end),
       do: :ok,
       else: {:error, "The team has to have at least one owner"}
  end

  def persist_entry(entry, context, acc) do
    case Entry.persist(entry, context) do
      {:ok, :ignore} -> acc
      {:ok, persist_result} -> [{entry, persist_result} | acc]
      {:error, error} -> Repo.rollback(error)
    end
  end
end
```

## File: `lib/plausible/teams/management/layout/entry.ex`
```
defmodule Plausible.Teams.Management.Layout.Entry do
  @moduledoc """
  Module representing a single Team Layout element and all its state
  transitions, including persistence options.
  """
  alias Plausible.Teams

  defstruct [:email, :name, :role, :type, :meta, :queued_op, :id]

  @type t() :: %__MODULE__{}

  @spec new(Teams.Invitation.t() | Teams.Membership.t(), Keyword.t()) :: t()
  def new(object, attrs \\ [])

  def new(
        %Teams.Invitation{id: existing} = invitation,
        attrs
      )
      when is_integer(existing) do
    %__MODULE__{
      name: "Invited User",
      id: 0,
      email: invitation.email,
      role: invitation.role,
      type: :invitation_sent,
      meta: invitation
    }
    |> Map.merge(Enum.into(attrs, %{}))
  end

  def new(%Teams.Invitation{id: nil} = pending, attrs) do
    %__MODULE__{
      name: "Invited User",
      id: 0,
      email: pending.email,
      role: pending.role,
      type: :invitation_pending,
      meta: pending
    }
    |> Map.merge(Enum.into(attrs, %{}))
  end

  def new(%Teams.Membership{} = membership, attrs) do
    %__MODULE__{
      name: membership.user.name,
      role: membership.role,
      id: membership.user.id,
      email: membership.user.email,
      type: :membership,
      meta: membership
    }
    |> Map.merge(Enum.into(attrs, %{}))
  end

  @spec patch(t(), Keyword.t()) :: t()
  def patch(%__MODULE__{} = entry, attrs) do
    struct!(entry, attrs)
  end

  @spec persist(t(), map()) ::
          {:ok, :ignore | Teams.Invitation.t() | Teams.Membership.t()} | {:error, any()}
  def persist(%__MODULE__{queued_op: nil}, _context) do
    {:ok, :ignore}
  end

  def persist(%__MODULE__{type: :invitation_pending, queued_op: :delete}, _context) do
    {:ok, :ignore}
  end

  def persist(
        %__MODULE__{email: email, role: role, type: :invitation_pending, queued_op: op},
        context
      )
      when op in [:update, :send] do
    Teams.Invitations.InviteToTeam.invite(context.current_team, context.current_user, email, role,
      send_email?: false
    )
  end

  def persist(
        %__MODULE__{type: :invitation_sent, email: email, role: role, queued_op: :update},
        context
      ) do
    Teams.Invitations.InviteToTeam.invite(context.current_team, context.current_user, email, role,
      send_email?: false
    )
  end

  def persist(
        %__MODULE__{type: :invitation_sent, queued_op: :delete, meta: meta},
        context
      ) do
    Plausible.Teams.Invitations.RemoveFromTeam.remove(
      context.current_team,
      meta.invitation_id,
      context.current_user
    )
  end

  def persist(
        %__MODULE__{type: :membership, queued_op: :delete, meta: meta},
        context
      ) do
    Plausible.Teams.Memberships.Remove.remove(
      context.current_team,
      meta.user.id,
      context.current_user,
      send_email?: false
    )
  end

  def persist(
        %__MODULE__{type: :membership, queued_op: :update, role: role, meta: meta},
        context
      ) do
    Plausible.Teams.Memberships.UpdateRole.update(
      context.current_team,
      meta.user.id,
      "#{role}",
      context.current_user
    )
  end
end
```

## File: `lib/plausible/teams/membership.ex`
```
defmodule Plausible.Teams.Membership do
  @moduledoc """
  Team membership schema
  """

  use Ecto.Schema

  import Ecto.Changeset

  @roles [:guest, :viewer, :editor, :admin, :owner, :billing]

  @type t() :: %__MODULE__{}

  @type role() :: unquote(Enum.reduce(@roles, &{:|, [], [&1, &2]}))

  schema "team_memberships" do
    field :role, Ecto.Enum, values: @roles
    field :is_autocreated, :boolean, default: false

    belongs_to :user, Plausible.Auth.User
    belongs_to :team, Plausible.Teams.Team

    has_many :guest_memberships, Plausible.Teams.GuestMembership, foreign_key: :team_membership_id

    timestamps()
  end

  def roles(), do: @roles

  def changeset(team, user, role) do
    %__MODULE__{}
    |> change()
    |> put_change(:role, role)
    |> put_assoc(:team, team)
    |> put_assoc(:user, user)
  end
end
```

## File: `lib/plausible/teams/memberships.ex`
```
defmodule Plausible.Teams.Memberships do
  @moduledoc false

  import Ecto.Query

  alias Plausible.Auth
  alias Plausible.Repo
  alias Plausible.Teams

  def all(team) do
    query =
      from tm in Teams.Membership,
        inner_join: u in assoc(tm, :user),
        where: tm.team_id == ^team.id,
        order_by: [asc: u.id],
        preload: [user: u]

    Repo.all(query)
  end

  def all_pending_site_transfers(email) do
    email
    |> pending_site_transfers_query()
    |> Repo.all()
  end

  def owners_count(team) do
    Repo.aggregate(
      from(tm in Teams.Membership, where: tm.team_id == ^team.id and tm.role == :owner),
      :count
    )
  end

  def team_role(team, user) do
    result =
      from(u in Auth.User,
        inner_join: tm in assoc(u, :team_memberships),
        where: tm.team_id == ^team.id and tm.user_id == ^user.id,
        select: tm.role
      )
      |> Repo.one()

    case result do
      nil -> {:error, :not_a_member}
      role -> {:ok, role}
    end
  end

  @spec can_add_site?(Teams.Team.t(), Auth.User.t()) :: boolean()
  def can_add_site?(team, user) do
    user_type = Plausible.Users.type(user)

    role =
      case team_role(team, user) do
        {:ok, role} -> role
        {:error, _} -> :not_a_member
      end

    case {user_type, role, team} do
      {:sso, :owner, %{setup_complete: false}} -> false
      {_, role, _} when role in [:owner, :admin, :editor] -> true
      _ -> false
    end
  end

  @spec site_role(Plausible.Site.t(), Auth.User.t() | nil) ::
          {:ok, {:team_member | :guest_member, Teams.Membership.role()}} | {:error, :not_a_member}

  def site_role(_site, nil), do: {:error, :not_a_member}

  def site_role(site, user) do
    result =
      from(u in Auth.User,
        inner_join: tm in assoc(u, :team_memberships),
        left_join: gm in assoc(tm, :guest_memberships),
        where: tm.team_id == ^site.team_id and tm.user_id == ^user.id,
        where: tm.role != :guest or gm.site_id == ^site.id,
        select: {tm.role, gm.role}
      )
      |> Repo.one()

    case result do
      {:guest, role} -> {:ok, {:guest_member, role}}
      {role, _} -> {:ok, {:team_member, role}}
      _ -> {:error, :not_a_member}
    end
  end

  def site_member?(site, user) do
    case site_role(site, user) do
      {:ok, _} -> true
      _ -> false
    end
  end

  @spec has_editor_access?(Plausible.Site.t(), Auth.User.t() | nil) :: boolean()
  def has_editor_access?(site, user) do
    case site_role(site, user) do
      {:ok, {_, role}} when role in [:editor, :admin, :owner] ->
        true

      _ ->
        false
    end
  end

  def update_role(site, user_id, new_role_str, current_user, current_user_role) do
    new_role = String.to_existing_atom(new_role_str)

    case get_guest_membership(site.id, user_id) do
      {:ok, guest_membership} ->
        can_grant_role? =
          if guest_membership.team_membership.user_id == current_user.id do
            false
          else
            can_grant_role_to_other?(current_user_role, new_role)
          end

        if can_grant_role? do
          guest_membership =
            guest_membership
            |> Ecto.Changeset.change(role: new_role)
            |> Repo.update!()
            |> Repo.preload(team_membership: :user)

          {:ok, guest_membership}
        else
          {:error, :not_allowed}
        end

      {:error, _} ->
        {:error, :no_guest}
    end
  end

  def remove(site, user) do
    case get_guest_membership(site.id, user.id) do
      {:ok, guest_membership} ->
        guest_membership =
          Repo.preload(guest_membership, [:site, team_membership: [:team, :user]])

        {:ok, _} =
          Repo.transaction(fn ->
            Repo.delete!(guest_membership)
            prune_guests(guest_membership.team_membership.team)
            Plausible.Segments.after_user_removed_from_site(site, user)
          end)

        send_site_member_removed_email(guest_membership)

      {:error, _} ->
        :pass
    end
  end

  defp can_grant_role_to_other?(:owner, :editor), do: true
  defp can_grant_role_to_other?(:owner, :viewer), do: true
  defp can_grant_role_to_other?(:admin, :editor), do: true
  defp can_grant_role_to_other?(:admin, :viewer), do: true
  defp can_grant_role_to_other?(_, _), do: false

  defp send_site_member_removed_email(guest_membership) do
    guest_membership
    |> PlausibleWeb.Email.site_member_removed()
    |> Plausible.Mailer.send()
  end

  def prune_guests(team) do
    guest_query =
      from(
        gm in Teams.GuestMembership,
        where: gm.team_membership_id == parent_as(:team_membership).id,
        select: true
      )

    Repo.delete_all(
      from(
        tm in Teams.Membership,
        as: :team_membership,
        where: tm.team_id == ^team.id and tm.role == :guest,
        where: not exists(guest_query)
      )
    )

    :ok
  end

  def get_team_membership(team, %Auth.User{} = user) do
    get_team_membership(team, user.id)
  end

  def get_team_membership(team, user_id) do
    query =
      from(
        tm in Teams.Membership,
        where: tm.team_id == ^team.id and tm.user_id == ^user_id
      )

    case Repo.one(query) do
      nil -> {:error, :membership_not_found}
      membership -> {:ok, membership}
    end
  end

  defp get_guest_membership(site_id, user_id) do
    query =
      from(
        gm in Teams.GuestMembership,
        inner_join: tm in assoc(gm, :team_membership),
        where: gm.site_id == ^site_id and tm.user_id == ^user_id,
        preload: [team_membership: tm]
      )

    case Repo.one(query) do
      nil -> {:error, :no_guest}
      membership -> {:ok, membership}
    end
  end

  defp pending_site_transfers_query(email) do
    from st in Teams.SiteTransfer, where: st.email == ^email, select: st.site_id
  end
end
```

## File: `lib/plausible/teams/memberships/leave.ex`
```
defmodule Plausible.Teams.Memberships.Leave do
  @moduledoc """
  Service for leaving a team by member.
  """

  alias Plausible.Repo
  alias Plausible.Teams
  alias Plausible.Teams.Memberships

  @spec leave(Teams.Team.t(), Plausible.Auth.User.t(), Keyword.t()) ::
          {:ok, Teams.Membership.t()} | {:error, :only_one_owner | :membership_not_found}
  def leave(team, user, opts \\ []) do
    with {:ok, team_membership} <- Memberships.get_team_membership(team, user.id),
         :ok <- check_owner_can_leave(team, team_membership.role) do
      team_membership = Repo.preload(team_membership, [:team, :user])

      {:ok, _} =
        Repo.transaction(fn ->
          delete_membership!(team_membership)

          Plausible.Segments.after_user_removed_from_team(
            team_membership.team,
            team_membership.user
          )
        end)

      if Keyword.get(opts, :send_email?, true) do
        send_team_member_left_email(team_membership)
      end

      {:ok, team_membership}
    end
  end

  defp delete_membership!(team_membership) do
    user = team_membership.user

    Repo.delete!(team_membership)

    if Plausible.Users.type(user) == :sso do
      {:ok, :deleted} = Plausible.Auth.delete_user(user)
    end

    :ok
  end

  defp check_owner_can_leave(team, :owner) do
    if Memberships.owners_count(team) > 1 do
      :ok
    else
      {:error, :only_one_owner}
    end
  end

  defp check_owner_can_leave(_team, _role), do: :ok

  def send_team_member_left_email(team_membership) do
    team_membership
    |> PlausibleWeb.Email.team_member_left()
    |> Plausible.Mailer.send()
  end
end
```

## File: `lib/plausible/teams/memberships/remove.ex`
```
defmodule Plausible.Teams.Memberships.Remove do
  @moduledoc """
  Service for removing a team member.
  """

  alias Plausible.Repo
  alias Plausible.Teams.Memberships

  def remove(nil, _, _), do: {:error, :permission_denied}

  def remove(team, user_id, current_user, opts \\ []) do
    with {:ok, team_membership} <- Memberships.get_team_membership(team, user_id),
         {:ok, current_user_role} <- Memberships.team_role(team, current_user),
         :ok <- check_can_remove_membership(current_user_role, team_membership.role),
         :ok <- check_owner_can_get_removed(team, team_membership.role) do
      team_membership = Repo.preload(team_membership, [:team, :user])

      {:ok, _} =
        Repo.transaction(fn ->
          delete_membership!(team_membership)

          Plausible.Segments.after_user_removed_from_team(
            team_membership.team,
            team_membership.user
          )
        end)

      if Keyword.get(opts, :send_email?, true) do
        send_team_member_removed_email(team_membership)
      end

      {:ok, team_membership}
    end
  end

  defp delete_membership!(team_membership) do
    user = team_membership.user

    Repo.delete!(team_membership)

    if Plausible.Users.type(user) == :sso do
      {:ok, :deleted} = Plausible.Auth.delete_user(user)
    end

    :ok
  end

  defp check_can_remove_membership(:owner, _), do: :ok
  defp check_can_remove_membership(:admin, role) when role != :owner, do: :ok
  defp check_can_remove_membership(_, _), do: {:error, :permission_denied}

  defp check_owner_can_get_removed(team, :owner) do
    if Memberships.owners_count(team) > 1 do
      :ok
    else
      {:error, :only_one_owner}
    end
  end

  defp check_owner_can_get_removed(_team, _role), do: :ok

  def send_team_member_removed_email(team_membership) do
    team_membership
    |> PlausibleWeb.Email.team_member_removed()
    |> Plausible.Mailer.send()
  end
end
```

## File: `lib/plausible/teams/memberships/update_role.ex`
```
defmodule Plausible.Teams.Memberships.UpdateRole do
  @moduledoc """
  Service for updating role of a team member.
  """

  use Plausible

  alias Plausible.Repo
  alias Plausible.Teams
  alias Plausible.Teams.Memberships

  def update(nil, _, _, _), do: {:error, :permission_denied}

  def update(team, user_id, new_role_str, current_user) do
    new_role = String.to_existing_atom(new_role_str)

    with :ok <- check_valid_role(new_role),
         {:ok, team_membership} <- Memberships.get_team_membership(team, user_id),
         {:ok, current_user_role} <- Memberships.team_role(team, current_user),
         granting_to_self? = team_membership.user_id == current_user.id,
         :ok <-
           check_can_grant_role(
             current_user_role,
             team_membership.role,
             new_role,
             granting_to_self?
           ),
         :ok <- check_owner_can_get_demoted(team, team_membership.role, new_role),
         team_membership = Repo.preload(team_membership, :user),
         :ok <- check_can_promote_to_owner(team, team_membership.user, new_role) do
      if team_membership.role == :guest and new_role != :guest do
        team_membership.user.email
        |> PlausibleWeb.Email.guest_to_team_member_promotion(
          team,
          current_user
        )
        |> Plausible.Mailer.send()
      end

      team_membership =
        team_membership
        |> Ecto.Changeset.change(role: new_role)
        |> Repo.update!()

      :ok = maybe_prune_guest_memberships(team_membership)

      {:ok, team_membership}
    end
  end

  on_ee do
    defp check_can_promote_to_owner(team, user, :owner) do
      if team.policy.force_sso == :all_but_owners and not Plausible.Auth.TOTP.enabled?(user) do
        {:error, :disabled_2fa}
      else
        :ok
      end
    end

    defp check_can_promote_to_owner(_team, _user, _new_role), do: :ok
  else
    defp check_can_promote_to_owner(_team, _user, _new_role) do
      # The `else` branch is not reachable.
      # This a workaround for Elixir 1.18+ compiler
      # being too smart.
      if :erlang.phash2(1, 1) == 0 do
        :ok
      else
        {:error, :disabled_2fa}
      end
    end
  end

  defp check_valid_role(role) do
    if role in (Teams.Membership.roles() -- [:guest]) do
      :ok
    else
      {:error, :invalid_role}
    end
  end

  defp check_owner_can_get_demoted(team, :owner, new_role) when new_role != :owner do
    if Memberships.owners_count(team) > 1 do
      :ok
    else
      {:error, :only_one_owner}
    end
  end

  defp check_owner_can_get_demoted(_team, _current_role, _new_role), do: :ok

  defp check_can_grant_role(user_role, _from_role, to_role, true) do
    if can_grant_role_to_self?(user_role, to_role) do
      :ok
    else
      {:error, :permission_denied}
    end
  end

  defp check_can_grant_role(user_role, from_role, to_role, false) do
    if can_grant_role_to_other?(user_role, from_role, to_role) do
      :ok
    else
      {:error, :permission_denied}
    end
  end

  defp can_grant_role_to_self?(:owner, :admin), do: true
  defp can_grant_role_to_self?(:owner, :editor), do: true
  defp can_grant_role_to_self?(:owner, :viewer), do: true
  defp can_grant_role_to_self?(:owner, :billing), do: true
  defp can_grant_role_to_self?(:admin, :editor), do: true
  defp can_grant_role_to_self?(:admin, :viewer), do: true
  defp can_grant_role_to_self?(:admin, :billing), do: true
  defp can_grant_role_to_self?(_, _), do: false

  defp can_grant_role_to_other?(:owner, _, _), do: true
  defp can_grant_role_to_other?(:admin, :admin, :admin), do: true
  defp can_grant_role_to_other?(:admin, :admin, :editor), do: true
  defp can_grant_role_to_other?(:admin, :admin, :viewer), do: true
  defp can_grant_role_to_other?(:admin, :admin, :billing), do: true
  defp can_grant_role_to_other?(:admin, :editor, :admin), do: true
  defp can_grant_role_to_other?(:admin, :editor, :editor), do: true
  defp can_grant_role_to_other?(:admin, :editor, :viewer), do: true
  defp can_grant_role_to_other?(:admin, :editor, :billing), do: true
  defp can_grant_role_to_other?(:admin, :viewer, :admin), do: true
  defp can_grant_role_to_other?(:admin, :viewer, :editor), do: true
  defp can_grant_role_to_other?(:admin, :viewer, :viewer), do: true
  defp can_grant_role_to_other?(:admin, :viewer, :billing), do: true
  defp can_grant_role_to_other?(:admin, :billing, :billing), do: true
  defp can_grant_role_to_other?(_, _, _), do: false

  defp maybe_prune_guest_memberships(%Teams.Membership{role: :guest}),
    do: :ok

  defp maybe_prune_guest_memberships(%Teams.Membership{} = team_membership) do
    team_membership
    |> Ecto.assoc(:guest_memberships)
    |> Repo.delete_all()

    :ok
  end
end
```

## File: `lib/plausible/teams/policy.ex`
```
defmodule Plausible.Teams.Policy do
  @moduledoc """
  Team-wide policies.
  """

  use Ecto.Schema
  use Plausible

  import Ecto.Changeset

  @sso_member_roles Plausible.Teams.Membership.roles() -- [:guest, :owner]
  @force_sso_modes [:none, :all_but_owners]

  @update_fields [:sso_default_role, :sso_session_timeout_minutes]

  @default_timeout_minutes 6 * 60
  @min_timeout_minutes 30
  @max_timeout_minutes 12 * 60

  @type t() :: %__MODULE__{}

  @type sso_member_role() :: unquote(Enum.reduce(@sso_member_roles, &{:|, [], [&1, &2]}))

  @type force_sso_mode() :: unquote(Enum.reduce(@force_sso_modes, &{:|, [], [&1, &2]}))

  on_ee do
    @derive {Plausible.Audit.Encoder,
             only: [:force_sso, :sso_default_role, :sso_session_timeout_minutes]}
  end

  embedded_schema do
    # SSO options apply to all team's integrations, should there
    # ever be more than one allowed at once.

    # SSO enforcement can have one of 2 states: enforced for none
    # or enforced for all but owners.
    # The first state is useful in the initial phase of SSO setup
    # when it's not yet confirmed to be fully operational.
    # The second state is a good default for most, leaving
    # escape hatch for cases where IdP starts failing.
    field :force_sso, Ecto.Enum, values: [:none, :all_but_owners], default: :none

    # Default role for newly provisioned SSO accounts.
    field :sso_default_role, Ecto.Enum, values: @sso_member_roles, default: :viewer

    # Default session timeout for SSO-enabled accounts. We might also
    # consider accepting session timeout from assertion, if present.
    field :sso_session_timeout_minutes, :integer, default: @default_timeout_minutes
  end

  @spec sso_member_roles() :: [sso_member_role()]
  def sso_member_roles(), do: @sso_member_roles

  @spec update_changeset(t(), map()) :: Ecto.Changeset.t()
  def update_changeset(policy, params) do
    policy
    |> cast(params, @update_fields)
    |> validate_required(@update_fields)
    |> validate_number(:sso_session_timeout_minutes,
      greater_than_or_equal_to: @min_timeout_minutes,
      less_than_or_equal_to: @max_timeout_minutes
    )
  end

  @spec force_sso_changeset(t(), force_sso_mode()) :: Ecto.Changeset.t()
  def force_sso_changeset(policy, mode) do
    policy
    |> cast(%{force_sso: mode}, [:force_sso])
    |> validate_required(:force_sso)
  end
end
```

## File: `lib/plausible/teams/site_transfer.ex`
```
defmodule Plausible.Teams.SiteTransfer do
  @moduledoc """
  Site transfer schema
  """

  use Ecto.Schema

  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  schema "team_site_transfers" do
    field :transfer_id, :string
    field :email, :string
    field :transfer_guests, :boolean, default: true

    belongs_to :site, Plausible.Site
    belongs_to :initiator, Plausible.Auth.User
    belongs_to :destination_team, Plausible.Teams.Team

    timestamps()
  end

  def changeset(site, opts) do
    initiator = Keyword.fetch!(opts, :initiator)
    transfer_guests = Keyword.get(opts, :transfer_guests, true)
    destination_team = Keyword.get(opts, :destination_team)
    email = Keyword.get(opts, :email)

    %__MODULE__{transfer_id: Nanoid.generate()}
    |> cast(%{email: email}, [:email])
    |> put_change(:transfer_guests, transfer_guests)
    |> put_assoc(:site, site)
    |> put_assoc(:destination_team, destination_team)
    |> put_assoc(:initiator, initiator)
  end
end
```

## File: `lib/plausible/teams/sites.ex`
```
defmodule Plausible.Teams.Sites do
  @moduledoc false

  import Ecto.Query

  alias Plausible.Auth
  alias Plausible.Repo
  alias Plausible.Site
  alias Plausible.Teams

  @type list_opt() :: {:filter_by_domain, String.t()} | {:team, Teams.Team.t() | nil}

  @spec list(Auth.User.t(), map(), [list_opt()]) :: Scrivener.Page.t()
  def list(user, pagination_params, opts \\ []) do
    domain_filter = Keyword.get(opts, :filter_by_domain)
    team = Keyword.get(opts, :team)

    all_query =
      if Teams.setup?(team) do
        from(tm in Teams.Membership,
          inner_join: t in assoc(tm, :team),
          inner_join: s in assoc(t, :sites),
          where: tm.user_id == ^user.id and tm.role != :guest,
          where: tm.team_id == ^team.id,
          select: %{site_id: s.id, entry_type: "site"}
        )
      else
        my_team_query =
          from(tm in Teams.Membership,
            inner_join: t in assoc(tm, :team),
            inner_join: s in assoc(t, :sites),
            where: tm.user_id == ^user.id and tm.role != :guest,
            where: tm.is_autocreated == true,
            where: t.setup_complete == false,
            select: %{site_id: s.id, entry_type: "site"}
          )

        guest_membership_query =
          from tm in Teams.Membership,
            inner_join: gm in assoc(tm, :guest_memberships),
            inner_join: s in assoc(gm, :site),
            where: tm.user_id == ^user.id and tm.role == :guest,
            select: %{site_id: s.id, entry_type: "site"}

        from s in my_team_query,
          union_all: ^guest_membership_query
      end

    from(u in subquery(all_query),
      inner_join: s in Plausible.Site,
      on: u.site_id == s.id,
      as: :site,
      left_join: up in Site.UserPreference,
      on: up.site_id == s.id and up.user_id == ^user.id,
      select: %{
        s
        | entry_type:
            selected_as(
              fragment(
                """
                CASE
                  WHEN ? IS NOT NULL THEN 'pinned_site'
                  ELSE ?
                END
                """,
                up.pinned_at,
                u.entry_type
              ),
              :entry_type
            ),
          pinned_at: selected_as(up.pinned_at, :pinned_at)
      },
      order_by: [
        asc: selected_as(:entry_type),
        desc: selected_as(:pinned_at),
        asc: s.domain
      ]
    )
    |> maybe_filter_by_domain(domain_filter)
    |> Repo.paginate(pagination_params)
  end

  @role_type Plausible.Teams.Invitation.__schema__(:type, :role)

  @spec list_with_invitations(Auth.User.t(), map(), [list_opt()]) :: Scrivener.Page.t()
  def list_with_invitations(user, pagination_params, opts \\ []) do
    domain_filter = Keyword.get(opts, :filter_by_domain)
    team = Keyword.get(opts, :team)

    union_query =
      if Teams.setup?(team) do
        list_with_invitations_setup_query(team, user)
      else
        list_with_invitations_personal_query(team, user)
      end

    from(u in subquery(union_query),
      inner_join: s in Plausible.Site,
      on: u.site_id == s.id,
      as: :site,
      left_join: up in Site.UserPreference,
      on: up.site_id == s.id and up.user_id == ^user.id,
      left_join: ti in Teams.Invitation,
      on: ti.id == u.team_invitation_id,
      left_join: gi in Teams.GuestInvitation,
      on: gi.id == u.guest_invitation_id,
      left_join: st in Teams.SiteTransfer,
      on: st.id == u.transfer_id,
      select: %{
        s
        | entry_type:
            selected_as(
              fragment(
                """
                CASE
                  WHEN ? IS NOT NULL THEN 'invitation'
                  WHEN ? IS NOT NULL THEN 'invitation'
                  WHEN ? IS NOT NULL THEN 'pinned_site'
                  ELSE ?
                END
                """,
                gi.id,
                st.id,
                up.pinned_at,
                u.entry_type
              ),
              :entry_type
            ),
          pinned_at: selected_as(up.pinned_at, :pinned_at),
          memberships: [
            %{
              role: type(u.role, ^@role_type),
              site_id: s.id,
              site: s
            }
          ],
          invitations: [
            %{
              invitation_id: coalesce(gi.invitation_id, st.transfer_id),
              email: coalesce(ti.email, st.email),
              role: type(u.role, ^@role_type),
              site_id: s.id,
              site: s
            }
          ]
      },
      order_by: [
        asc: selected_as(:entry_type),
        desc: selected_as(:pinned_at),
        asc: s.domain
      ]
    )
    |> maybe_filter_by_domain(domain_filter)
    |> Repo.paginate(pagination_params)
    |> Map.update!(:entries, fn entries ->
      Enum.map(entries, fn
        %{invitation: [%{invitation_id: nil}]} = entry ->
          %{entry | invitations: []}

        entry ->
          entry
      end)
    end)
  end

  defp list_with_invitations_setup_query(team, user) do
    team_membership_query =
      from(tm in Teams.Membership,
        inner_join: t in assoc(tm, :team),
        inner_join: u in assoc(tm, :user),
        as: :user,
        inner_join: s in assoc(t, :sites),
        as: :site,
        where: tm.user_id == ^user.id and tm.role != :guest,
        where: tm.team_id == ^team.id,
        select: %{
          site_id: s.id,
          entry_type: "site",
          guest_invitation_id: 0,
          team_invitation_id: 0,
          role: tm.role,
          transfer_id: 0
        }
      )

    site_transfer_query =
      from st in Teams.SiteTransfer,
        as: :site_transfer,
        inner_join: s in assoc(st, :site),
        as: :site,
        where: s.team_id != ^team.id,
        where: st.email == ^user.email,
        where:
          exists(
            from tm in Teams.Membership,
              inner_join: u in assoc(tm, :user),
              where: tm.team_id == ^team.id,
              where: u.email == parent_as(:site_transfer).email,
              where: tm.role in [:owner, :admin],
              select: 1
          ),
        select: %{
          site_id: s.id,
          entry_type: "invitation",
          guest_invitation_id: 0,
          team_invitation_id: 0,
          role: "owner",
          transfer_id: st.id
        }

    from s in team_membership_query,
      union_all: ^site_transfer_query
  end

  defp list_with_invitations_personal_query(team, user) do
    my_team_query =
      from(tm in Teams.Membership,
        inner_join: t in assoc(tm, :team),
        inner_join: u in assoc(tm, :user),
        as: :user,
        inner_join: s in assoc(t, :sites),
        as: :site,
        where: tm.user_id == ^user.id and tm.role == :owner,
        where: t.setup_complete == false,
        select: %{
          site_id: s.id,
          entry_type: "site",
          guest_invitation_id: 0,
          team_invitation_id: 0,
          role: tm.role,
          transfer_id: 0
        }
      )

    guest_membership_query =
      from(tm in Teams.Membership,
        inner_join: u in assoc(tm, :user),
        as: :user,
        inner_join: gm in assoc(tm, :guest_memberships),
        inner_join: s in assoc(gm, :site),
        as: :site,
        where: tm.user_id == ^user.id and tm.role == :guest,
        select: %{
          site_id: s.id,
          entry_type: "site",
          guest_invitation_id: 0,
          team_invitation_id: 0,
          role:
            fragment(
              """
              CASE
                WHEN ? = 'editor' THEN 'admin'
                ELSE ?
              END
              """,
              gm.role,
              gm.role
            ),
          transfer_id: 0
        }
      )

    guest_invitation_query =
      from ti in Teams.Invitation,
        as: :team_invitation,
        inner_join: gi in assoc(ti, :guest_invitations),
        inner_join: s in assoc(gi, :site),
        as: :site,
        where:
          not exists(
            from tm in Teams.Membership,
              inner_join: u in assoc(tm, :user),
              left_join: gm in assoc(tm, :guest_memberships),
              on: gm.site_id == parent_as(:site).id,
              where: tm.team_id == parent_as(:team_invitation).team_id,
              where: u.email == parent_as(:team_invitation).email,
              where: not is_nil(gm.id) or tm.role != :guest,
              select: 1
          ),
        where: ti.email == ^user.email and ti.role == :guest,
        select: %{
          site_id: s.id,
          entry_type: "invitation",
          guest_invitation_id: gi.id,
          team_invitation_id: ti.id,
          role:
            fragment(
              """
              CASE
                WHEN ? = 'editor' THEN 'admin'
                ELSE ?
              END
              """,
              gi.role,
              gi.role
            ),
          transfer_id: 0
        }

    site_transfer_query =
      from st in Teams.SiteTransfer,
        as: :site_transfer,
        inner_join: s in assoc(st, :site),
        as: :site,
        where: st.email == ^user.email,
        select: %{
          site_id: s.id,
          entry_type: "invitation",
          guest_invitation_id: 0,
          team_invitation_id: 0,
          role: "owner",
          transfer_id: st.id
        }

    site_transfer_query =
      if team do
        where(site_transfer_query, [site: s], s.team_id != ^team.id)
      else
        site_transfer_query
      end

    from s in my_team_query,
      union_all: ^guest_membership_query,
      union_all: ^guest_invitation_query,
      union_all: ^site_transfer_query
  end

  defp maybe_filter_by_domain(query, domain)
       when byte_size(domain) >= 1 and byte_size(domain) <= 64 do
    where(query, [site: s], ilike(s.domain, ^"%#{domain}%"))
  end

  defp maybe_filter_by_domain(query, _), do: query
end
```

## File: `lib/plausible/teams/sites/transfer.ex`
```
defmodule Plausible.Teams.Sites.Transfer do
  @moduledoc """
  Service for transferring sites.
  """

  alias Plausible.Auth
  alias Plausible.Billing
  alias Plausible.Repo
  alias Plausible.Site
  alias Plausible.Teams

  @type transfer_error() ::
          Billing.Quota.Limits.over_limits_error()
          | Ecto.Changeset.t()
          | :transfer_to_self
          | :no_plan
          | :multiple_teams
          | :permission_denied

  @spec change_team(Site.t(), Auth.User.t(), Teams.Team.t()) ::
          :ok | {:error, transfer_error()}
  def change_team(site, user, new_team) do
    with {:ok, _} <- transfer_ownership(site, user, new_team) do
      Teams.Invitations.send_team_changed_email(site, user, new_team)
      :ok
    end
  end

  @spec accept(Teams.SiteTransfer.t(), Auth.User.t(), Teams.Team.t() | nil) ::
          {:ok, %{team: Teams.Team.t(), team_memberships: [Teams.Membership.t()], site: Site.t()}}
          | {:error, transfer_error()}
  def accept(site_transfer, new_owner, team) do
    site = Repo.preload(site_transfer.site, :team)

    with {:ok, new_team} <- maybe_get_team(new_owner, team),
         :ok <- Teams.Invitations.ensure_transfer_valid(site.team, new_team, :owner),
         :ok <- Teams.Invitations.check_can_transfer_site(new_team, new_owner),
         :ok <- Teams.Invitations.ensure_can_take_ownership(site, new_team),
         :ok <- Teams.Invitations.accept_site_transfer(site_transfer, new_team) do
      Teams.Invitations.send_transfer_accepted_email(site_transfer, new_team)

      site = site |> Repo.reload!() |> Repo.preload(ownerships: :user)

      {:ok, %{team: new_team, team_memberships: site.ownerships, site: site}}
    end
  end

  defp transfer_ownership(site, new_owner, team) do
    site = Repo.preload(site, :team)

    with {:ok, new_team} <- maybe_get_team(new_owner, team),
         :ok <- Teams.Invitations.ensure_transfer_valid(site.team, new_team, :owner),
         :ok <- Teams.Invitations.check_can_transfer_site(new_team, new_owner),
         :ok <- Teams.Invitations.ensure_can_take_ownership(site, new_team),
         :ok <- Teams.Invitations.transfer_site(site, new_team) do
      site = site |> Repo.reload!() |> Repo.preload(ownerships: :user)

      {:ok, site.ownerships}
    end
  end

  defp maybe_get_team(_user, %Teams.Team{} = team) do
    {:ok, team}
  end

  defp maybe_get_team(user, nil) do
    Teams.get_or_create(user)
  end
end
```

## File: `lib/plausible/teams/team.ex`
```
defmodule Plausible.Teams.Team do
  @moduledoc """
  Team schema
  """

  defimpl FunWithFlags.Actor, for: __MODULE__ do
    def id(%{id: id}) do
      "team:#{id}"
    end
  end

  use Ecto.Schema
  use Plausible

  alias Plausible.Auth

  import Ecto.Changeset

  @type t() :: %__MODULE__{}

  @trial_accept_traffic_until_offset_days 14
  @subscription_accept_traffic_until_offset_days 30

  on_ee do
    @derive {Plausible.Audit.Encoder,
             only: [
               :id,
               :identifier,
               :name,
               :trial_expiry_date,
               :accept_traffic_until,
               :allow_next_upgrade_override,
               :locked,
               :setup_complete,
               :setup_at,
               :hourly_api_request_limit,
               :policy
             ]}
  end

  schema "teams" do
    field :identifier, Ecto.UUID
    field :name, :string
    field :trial_expiry_date, :date
    field :accept_traffic_until, :date
    field :allow_next_upgrade_override, :boolean, default: false
    field :locked, :boolean, default: false

    field :setup_complete, :boolean, default: false
    field :setup_at, :naive_datetime

    # Field kept in sync with current subscription plan, if any
    field :hourly_api_request_limit, :integer, default: Auth.ApiKey.hourly_request_limit()

    # Field for purely informational purposes in CRM context
    field :notes, :string

    on_ee do
      # Embed for storing team-wide policies
      embeds_one :policy, Plausible.Teams.Policy, on_replace: :update, defaults_to_struct: true
    end

    embeds_one :grace_period, Plausible.Teams.GracePeriod, on_replace: :update

    has_many :sites, Plausible.Site
    has_many :team_memberships, Plausible.Teams.Membership
    has_many :team_invitations, Plausible.Teams.Invitation
    has_one :subscription, Plausible.Billing.Subscription
    has_one :enterprise_plan, Plausible.Billing.EnterprisePlan

    on_ee do
      has_one :sso_integration, Plausible.Auth.SSO.Integration
    end

    has_many :ownerships, Plausible.Teams.Membership,
      where: [role: :owner],
      preload_order: [asc: :id]

    has_many :billing_memberships, Plausible.Teams.Membership,
      where: [role: :billing],
      preload_order: [asc: :id]

    has_many :owners, through: [:ownerships, :user]
    has_many :billing_members, through: [:billing_memberships, :user]

    timestamps()
  end

  def crm_changeset(team, params) do
    team
    |> cast(params, [
      :name,
      :notes,
      :trial_expiry_date,
      :allow_next_upgrade_override,
      :accept_traffic_until
    ])
  end

  def changeset(team \\ %__MODULE__{}, attrs \\ %{}, today \\ Date.utc_today()) do
    team
    |> cast(attrs, [:name])
    |> validate_required(:name)
    |> start_trial(today)
    |> maybe_bump_accept_traffic_until()
    |> maybe_set_identifier()
  end

  def name_changeset(team, attrs \\ %{}) do
    team
    |> cast(attrs, [:name])
    |> validate_required(:name)
    |> validate_exclusion(:name, [Plausible.Teams.default_name()])
  end

  def setup_changeset(team, now \\ NaiveDateTime.utc_now(:second)) do
    team
    |> change(
      setup_complete: true,
      setup_at: now
    )
  end

  def start_trial(team, today \\ Date.utc_today()) do
    trial_expiry = trial_expiry(today)

    change(team,
      trial_expiry_date: trial_expiry,
      accept_traffic_until: Date.add(trial_expiry, @trial_accept_traffic_until_offset_days)
    )
  end

  def end_trial(team) do
    change(team, trial_expiry_date: Date.utc_today() |> Date.shift(day: -1))
  end

  defp maybe_set_identifier(changeset) do
    if get_field(changeset, :identifier) do
      changeset
    else
      put_change(changeset, :identifier, Ecto.UUID.generate())
    end
  end

  defp maybe_bump_accept_traffic_until(changeset) do
    expiry_change = get_change(changeset, :trial_expiry_date)

    if expiry_change do
      put_change(
        changeset,
        :accept_traffic_until,
        Date.add(expiry_change, @trial_accept_traffic_until_offset_days)
      )
    else
      changeset
    end
  end

  def trial_accept_traffic_until_offset_days(), do: @trial_accept_traffic_until_offset_days

  def subscription_accept_traffic_until_offset_days(),
    do: @subscription_accept_traffic_until_offset_days

  @doc false
  def trial_expiry(today \\ Date.utc_today()) do
    on_ee do
      Date.shift(today, day: 30)
    else
      Date.shift(today, year: 100)
    end
  end
end
```

## File: `lib/plausible/teams/users.ex`
```
defmodule Plausible.Teams.Users do
  @moduledoc """
  Users API accounting for teams.
  """

  import Ecto.Query

  alias Plausible.Repo
  alias Plausible.Teams

  def owned_teams(user) do
    Repo.all(teams_query(user, roles: :owner))
  end

  def teams(user, opts \\ []) do
    user
    |> teams_query(Keyword.merge([order_by: :name], opts))
    |> Repo.all()
    |> Repo.preload(:owners)
  end

  def teams_query(user, opts \\ []) do
    order_by = Keyword.get(opts, :order_by, :name)
    roles = Keyword.get(opts, :roles)
    identifier = Keyword.get(opts, :identifier)

    query =
      from(
        tm in Teams.Membership,
        as: :team_membership,
        inner_join: t in assoc(tm, :team),
        as: :team,
        where: tm.user_id == ^user.id,
        where: tm.role != :guest,
        select: t
      )

    query =
      if roles do
        where(query, [team_membership: tm], tm.role in ^List.wrap(roles))
      else
        query
      end

    query =
      if identifier do
        where(query, [team: team], team.identifier == ^identifier)
      else
        query
      end

    case order_by do
      :name ->
        order_by(query, [team: t], [t.name, t.id])

      :id_desc ->
        order_by(query, [team: t], desc: t.id)

      _ ->
        query
    end
  end

  def team_member?(user, opts \\ []) do
    excluded_team_ids = Keyword.get(opts, :except, [])
    only_setup? = Keyword.get(opts, :only_setup?, false)

    query =
      from(
        tm in Teams.Membership,
        where: tm.user_id == ^user.id,
        where: tm.role != :guest,
        where: tm.team_id not in ^excluded_team_ids
      )

    query =
      if only_setup? do
        query
        |> join(:inner, [tm], t in assoc(tm, :team), as: :team)
        |> where([team: t], t.setup_complete == true)
      else
        query
      end

    Repo.exists?(query)
  end

  def has_sites?(user, opts \\ []) do
    include_pending? = Keyword.get(opts, :include_pending?, false)

    sites_query =
      from(
        s in Plausible.Site,
        where: s.team_id == parent_as(:site_parent).team_id,
        select: 1
      )

    # NOTE: Provided guest team memberships are consistently pruned,
    # mere presence of guest team membership means there are sites
    # associated with it, so querying for team membership alone
    # should be enough.
    team_member_query =
      from(
        tm in Teams.Membership,
        as: :site_parent,
        where: exists(sites_query),
        where: tm.user_id == ^user.id,
        select: 1
      )

    query =
      if include_pending? do
        site_transfer_query =
          from(
            st in Teams.SiteTransfer,
            where: st.email == ^user.email,
            select: 1
          )

        # NOTE: The same principle applies to guest team invitations,
        # as it's pruned as well when there are no more guest invitations
        # associated with it.
        member_invitation_query =
          from(
            ti in Teams.Invitation,
            as: :site_parent,
            where: exists(sites_query),
            where: ti.email == ^user.email,
            select: 1
          )

        team_member_query
        |> union_all(^site_transfer_query)
        |> union_all(^member_invitation_query)
      else
        team_member_query
      end

    Repo.exists?(query)
  end

  def owns_sites?(user, opts \\ []) do
    include_pending? = Keyword.get(opts, :include_pending?, false)
    only_team = Keyword.get(opts, :only_team)

    sites_query =
      from(
        s in Plausible.Site,
        where: s.team_id == parent_as(:site_parent).team_id,
        select: 1
      )

    owner_query =
      from(
        tm in Teams.Membership,
        as: :site_parent,
        where: exists(sites_query),
        where: tm.user_id == ^user.id,
        where: tm.role == :owner,
        select: 1
      )

    owner_query =
      if only_team do
        where(owner_query, [tm], tm.team_id == ^only_team.id)
      else
        owner_query
      end

    query =
      if include_pending? do
        site_transfer_query =
          from(
            st in Teams.SiteTransfer,
            where: st.email == ^user.email,
            select: 1
          )

        owner_invitation_query =
          from(
            ti in Teams.Invitation,
            as: :site_parent,
            where: exists(sites_query),
            where: ti.email == ^user.email,
            where: ti.role == :owner,
            select: 1
          )

        owner_query
        |> union_all(^site_transfer_query)
        |> union_all(^owner_invitation_query)
      else
        owner_query
      end

    Repo.exists?(query)
  end
end
```

## File: `lib/plausible/telemetry/plausible_metrics.ex`
```
defmodule Plausible.PromEx.Plugins.PlausibleMetrics do
  @moduledoc """
  Custom PromEx plugin for instrumenting code within Plausible app.
  """
  use PromEx.Plugin
  alias Plausible.Site
  alias Plausible.Ingestion

  @impl true
  def polling_metrics(opts) do
    poll_rate = Keyword.get(opts, :poll_rate, 5_000)

    otp_app = Keyword.fetch!(opts, :otp_app)

    metric_prefix =
      Keyword.get(opts, :metric_prefix, PromEx.metric_prefix(otp_app, :plausible_metrics))

    [
      write_buffer_metrics(metric_prefix, poll_rate),
      cache_metrics(metric_prefix, poll_rate)
    ]
  end

  @impl true
  def event_metrics(opts) do
    otp_app = Keyword.fetch!(opts, :otp_app)
    metric_prefix = Keyword.get(opts, :metric_prefix, PromEx.metric_prefix(otp_app, :plausible))

    Event.build(
      :plausible_internal_telemetry,
      [
        distribution(
          metric_prefix ++ [:cache_warmer, :sites, :refresh, :all],
          event_name: Site.Cache.telemetry_event_refresh(:all),
          reporter_options: [
            buckets: [500, 1000, 2000, 5000, 10_000]
          ],
          unit: {:native, :millisecond},
          measurement: :duration
        ),
        distribution(
          metric_prefix ++ [:cache_warmer, :sites, :refresh, :updated_recently],
          event_name: Site.Cache.telemetry_event_refresh(:updated_recently),
          reporter_options: [
            buckets: [500, 1000, 2000, 5000, 10_000]
          ],
          unit: {:native, :millisecond},
          measurement: :duration
        ),
        distribution(
          metric_prefix ++ [:ingest, :events, :pipeline, :steps],
          event_name: Ingestion.Event.telemetry_pipeline_step_duration(),
          reporter_options: [
            buckets: [10, 50, 100, 250, 350, 500, 1000, 5000, 10_000, 100_000, 500_000]
          ],
          unit: {:native, :microsecond},
          measurement: :duration,
          tags: [:step]
        ),
        distribution(
          metric_prefix ++ [:sessions, :cache, :register, :lock],
          event_name: Plausible.Session.CacheStore.lock_telemetry_event(),
          reporter_options: [
            buckets: [10, 50, 100, 250, 350, 500, 1000, 5000, 10_000, 100_000, 500_000]
          ],
          unit: {:native, :microsecond},
          measurement: :duration
        ),
        counter(
          metric_prefix ++ [:ingest, :events, :buffered, :total],
          event_name: Ingestion.Event.telemetry_event_buffered()
        ),
        counter(
          metric_prefix ++ [:ingest, :events, :dropped, :total],
          event_name: Ingestion.Event.telemetry_event_dropped(),
          tags: [:reason]
        ),
        counter(
          metric_prefix ++ [:ingest, :user_agent_parse, :timeout, :total],
          event_name: Ingestion.Event.telemetry_ua_parse_timeout()
        ),
        counter(
          metric_prefix ++ [:plausible_cache, :hit],
          event_name: ConCache.Operations.telemetry_hit(),
          tags: [:name],
          tag_values: &%{name: &1.cache.name}
        ),
        counter(
          metric_prefix ++ [:plausible_cache, :miss],
          event_name: ConCache.Operations.telemetry_miss(),
          tags: [:name],
          tag_values: &%{name: &1.cache.name}
        ),
        distribution(
          metric_prefix ++ [:sessions, :transfer, :duration],
          event_name: Plausible.Session.Transfer.telemetry_event(),
          reporter_options: [
            buckets: [
              100_000,
              250_000,
              500_000,
              750_000,
              1_000_000,
              2_500_000,
              5_000_000,
              7_500_000,
              10_000_000
            ]
          ],
          unit: {:native, :microsecond},
          measurement: :duration
        ),
        counter(
          metric_prefix ++ [:tracker_script, :request, :v2],
          event_name: PlausibleWeb.TrackerPlug.telemetry_event(:v2),
          tags: [:status],
          tag_values: &%{status: &1.status}
        ),
        counter(
          metric_prefix ++ [:tracker_script, :request, :legacy],
          event_name: PlausibleWeb.TrackerPlug.telemetry_event(:legacy),
          tags: [:status],
          tag_values: &%{status: &1.status}
        ),
        counter(
          metric_prefix ++ [:verification, :js_elixir_diff],
          event_name:
            Plausible.InstallationSupport.Checks.Installation.telemetry_event(_diff = true)
        ),
        counter(
          metric_prefix ++ [:verification, :js_elixir_match],
          event_name:
            Plausible.InstallationSupport.Checks.Installation.telemetry_event(_diff = false)
        )
      ]
    )
  end

  @doc """
  Add telemetry events for Session and Event write buffers
  """
  def execute_write_buffer_metrics do
    event_write_buffer_pid = GenServer.whereis(Plausible.Event.WriteBuffer)

    {:message_queue_len, events_message_queue_len} =
      if is_pid(event_write_buffer_pid),
        do: Process.info(event_write_buffer_pid, :message_queue_len),
        else: {:message_queue_len, 0}

    session_write_buffer_pid = GenServer.whereis(Plausible.Event.WriteBuffer)

    {:message_queue_len, sessions_message_queue_len} =
      if is_pid(session_write_buffer_pid),
        do: Process.info(session_write_buffer_pid, :message_queue_len),
        else: {:message_queue_len, 0}

    :telemetry.execute([:prom_ex, :plugin, :write_buffer_metrics, :events_message_queue_len], %{
      count: events_message_queue_len
    })

    :telemetry.execute([:prom_ex, :plugin, :write_buffer_metrics, :sessions_message_queue_len], %{
      count: sessions_message_queue_len
    })
  end

  @doc """
  Fire telemetry events for various caches
  """
  def execute_cache_metrics do
    :telemetry.execute([:prom_ex, :plugin, :cache, :user_agents], %{
      count: Plausible.Cache.Adapter.size(:user_agents)
    })

    :telemetry.execute([:prom_ex, :plugin, :cache, :sessions], %{
      count: Plausible.Cache.Adapter.size(:sessions)
    })

    :telemetry.execute([:prom_ex, :plugin, :cache, :sites], %{
      count: Site.Cache.size()
    })
  end

  def measure_duration(event, fun, meta \\ %{}) when is_function(fun, 0) do
    {duration, result} = time_it(fun)
    :telemetry.execute(event, %{duration: duration}, meta)
    result
  end

  defp time_it(fun) do
    start = System.monotonic_time()
    result = fun.()
    stop = System.monotonic_time()
    {stop - start, result}
  end

  defp write_buffer_metrics(metric_prefix, poll_rate) do
    Polling.build(
      :write_buffer_metrics,
      poll_rate,
      {__MODULE__, :execute_write_buffer_metrics, []},
      [
        last_value(
          metric_prefix ++ [:events, :message_queue_len, :count],
          event_name: [:prom_ex, :plugin, :write_buffer_metrics, :events_message_queue_len],
          measurement: :count
        ),
        last_value(
          metric_prefix ++ [:sessions, :message_queue_len, :count],
          event_name: [:prom_ex, :plugin, :write_buffer_metrics, :sessions_message_queue_len],
          measurement: :count
        )
      ]
    )
  end

  defp cache_metrics(metric_prefix, poll_rate) do
    Polling.build(
      :cache_metrics,
      poll_rate,
      {__MODULE__, :execute_cache_metrics, []},
      [
        last_value(
          metric_prefix ++ [:cache, :sessions, :size],
          event_name: [:prom_ex, :plugin, :cache, :sessions],
          measurement: :count
        ),
        last_value(
          metric_prefix ++ [:cache, :user_agents, :size],
          event_name: [:prom_ex, :plugin, :cache, :user_agents],
          measurement: :count
        ),
        last_value(
          metric_prefix ++ [:cache, :sites, :size],
          event_name: [:prom_ex, :plugin, :cache, :sites],
          measurement: :count
        )
      ]
    )
  end
end
```

## File: `lib/plausible/themes.ex`
```
defmodule Plausible.Themes do
  @options [
    [key: "Follow System Theme", value: "system"],
    [key: "Light", value: "light"],
    [key: "Dark", value: "dark"]
  ]

  def options() do
    @options
  end
end
```

## File: `lib/plausible/timezones.ex`
```
defmodule Plausible.Timezones do
  @spec options(DateTime.t()) :: [{:key, String.t()}, {:value, String.t()}, {:offset, integer()}]
  def options(now \\ DateTime.utc_now()) do
    Tzdata.zone_list()
    |> Enum.reduce([], fn timezone_code, acc -> build_option(timezone_code, acc, now) end)
    |> Enum.sort_by(& &1[:offset], :desc)
  end

  @spec to_date_in_timezone(Date.t() | NaiveDateTime.t() | DateTime.t(), String.t()) :: Date.t()
  def to_date_in_timezone(dt, timezone) do
    to_datetime_in_timezone(dt, timezone) |> DateTime.to_date()
  end

  @spec to_datetime_in_timezone(Date.t() | NaiveDateTime.t() | DateTime.t(), String.t()) ::
          DateTime.t()
  def to_datetime_in_timezone(dt, timezone) do
    dt |> to_datetime() |> DateTime.shift_zone!(timezone)
  end

  defp to_datetime(%NaiveDateTime{} = naive), do: DateTime.from_naive!(naive, "Etc/UTC")
  defp to_datetime(%Date{} = date), do: DateTime.new!(date, ~T[00:00:00], "Etc/UTC")
  defp to_datetime(%DateTime{} = already_dt), do: already_dt

  defp build_option(timezone_code, acc, now) do
    case Timex.Timezone.get(timezone_code, now) do
      %Timex.TimezoneInfo{} = timezone_info ->
        offset_in_minutes = timezone_info |> Timex.Timezone.total_offset() |> div(-60)

        hhmm_formatted_offset =
          timezone_info
          |> Timex.TimezoneInfo.format_offset()
          |> String.slice(0..-4//1)

        option = [
          key: "(GMT#{hhmm_formatted_offset}) #{timezone_code}",
          value: timezone_code,
          offset: offset_in_minutes
        ]

        [option | acc]

      error ->
        Sentry.capture_message("Failed to fetch timezone",
          extra: %{code: timezone_code, error: inspect(error)}
        )

        acc
    end
  end
end
```

## File: `lib/plausible/users.ex`
```
defmodule Plausible.Users do
  @moduledoc """
  User context
  """
  use Plausible

  import Ecto.Query

  alias Plausible.Auth
  alias Plausible.Repo

  on_ee do
    @spec type(Auth.User.t()) :: :standard | :sso
    def type(user) do
      user.type
    end
  else
    @spec type(Auth.User.t()) :: :standard
    def type(_user) do
      # The `else` branch is not reachable.
      # This a workaround for Elixir 1.18+ compiler
      # being too smart.
      if :erlang.phash2(1, 1) == 0 do
        :standard
      else
        :sso
      end
    end
  end

  @spec bump_last_seen(Auth.User.t() | pos_integer(), NaiveDateTime.t()) :: :ok
  def bump_last_seen(%Auth.User{id: user_id}, now) do
    bump_last_seen(user_id, now)
  end

  def bump_last_seen(user_id, now) do
    q = from(u in Auth.User, where: u.id == ^user_id)

    Repo.update_all(q, set: [last_seen: now])

    :ok
  end

  @spec remember_last_team(Auth.User.t(), String.t() | nil) :: :ok
  def remember_last_team(%Auth.User{id: user_id}, team_identifier) do
    q = from(u in Auth.User, where: u.id == ^user_id)
    Repo.update_all(q, set: [last_team_identifier: team_identifier])
    :ok
  end

  @spec has_email_code?(Auth.User.t()) :: boolean()
  def has_email_code?(user) do
    Auth.EmailVerification.any?(user)
  end
end
```

## File: `lib/plausible_release.ex`
```
defmodule Plausible.Release do
  use Plausible
  use Plausible.Repo
  require Logger

  @app :plausible
  @start_apps [
    :ssl,
    :postgrex,
    :ch,
    :ecto
  ]

  def should_be_first_launch? do
    on_ee do
      always(false)
    else
      not (_has_users? = Repo.exists?(Plausible.Auth.User))
    end
  end

  @doc """
  `interweave_migrate/0` is a migration function that:

  - Lists all pending migrations across multiple repositories.
  - Sorts these migrations into a single list.
  - Groups consecutive migrations by repository into "streaks".
  - Executes the migrations in the correct order by processing each streak sequentially.

  ### Why Use This Approach?

  This function resolves dependencies between migrations that span across different repositories.
  The default `migrate/0` function migrates each repository independently, which may result in
  migrations running in the wrong order when there are cross-repository dependencies.

  Consider the following example (adapted from reality, not 100% accurate):

  - **Migration 1**: The PostgreSQL (PG) repository creates a table named `site_imports`.
  - **Migration 2**: The ClickHouse (CH) repository creates `import_id` columns in `imported_*` tables.
  - **Migration 3**: The PG repository runs a data migration that utilizes both PG and CH databases,
    reading from the `import_id` column in `imported_*` tables.

  The default `migrate/0` would execute these migrations by repository, resulting in the following order:

  1. Migration 1 (PG)
  2. Migration 3 (PG)
  3. Migration 2 (CH)

  This sequence would fail at Migration 3, as the `import_id` columns in the CH repository have not been created yet.

  `interweave_migrate/0` addresses this issue by consolidating all pending migrations into a single, ordered queue:

  1. Migration 1 (PG)
  2. Migration 2 (CH)
  3. Migration 3 (PG)

  This ensures all dependencies are resolved in the correct order.
  """
  def interweave_migrate(repos \\ repos()) do
    prepare()

    pending = all_pending_migrations(repos)
    streaks = migration_streaks(pending)

    Enum.each(streaks, fn {repo, up_to_version} ->
      {:ok, _, _} =
        Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :up, to: up_to_version),
          log: :notice
        )
    end)
  end

  defp migration_streaks(pending_migrations) do
    sorted_migrations =
      pending_migrations
      |> Enum.map(fn {repo, version, _name} -> {repo, version} end)
      |> Enum.sort_by(fn {_repo, version} -> version end, :asc)

    streaks_reversed =
      Enum.reduce(sorted_migrations, [], fn {repo, _version} = latest_migration, streaks_acc ->
        case streaks_acc do
          # start the streak for repo
          [] -> [latest_migration]
          # extend the streak
          [{^repo, _prev_version} | rest] -> [latest_migration | rest]
          # end the streak for prev_repo, start the streak for repo
          [{_prev_repo, _prev_version} | _rest] -> [latest_migration | streaks_acc]
        end
      end)

    :lists.reverse(streaks_reversed)
  end

  @spec all_pending_migrations([Ecto.Repo.t()]) :: [{Ecto.Repo.t(), integer, String.t()}]
  defp all_pending_migrations(repos) do
    Enum.flat_map(repos, fn repo ->
      # credo:disable-for-lines:6 Credo.Check.Refactor.Nesting
      {:ok, pending, _started} =
        Ecto.Migrator.with_repo(repo, fn repo ->
          Ecto.Migrator.migrations(repo)
          |> Enum.filter(fn {status, _version, _name} -> status == :down end)
          |> Enum.map(fn {_status, version, name} -> {repo, version, name} end)
        end)

      pending
    end)
  end

  def pending_streaks(repos \\ repos()) do
    prepare()
    IO.puts("Collecting pending migrations..")

    pending = all_pending_migrations(repos)

    if pending == [] do
      IO.puts("No pending migrations!")
    else
      streaks = migration_streaks(pending)
      print_migration_streaks(streaks, pending)
    end
  end

  defp print_migration_streaks([{repo, up_to_version} | streaks], pending) do
    {streak, pending} =
      Enum.split_with(pending, fn {pending_repo, version, _name} ->
        pending_repo == repo and version <= up_to_version
      end)

    IO.puts(
      "\n#{inspect(repo)} [#{Path.relative_to_cwd(Ecto.Migrator.migrations_path(repo))}] streak up to version #{up_to_version}:"
    )

    Enum.each(streak, fn {_repo, version, name} -> IO.puts("  * #{version}_#{name}") end)
    print_migration_streaks(streaks, pending)
  end

  defp print_migration_streaks([], []), do: :ok

  def seed do
    prepare()
    # Run seed script
    Enum.each(repos(), &run_seeds_for/1)
    # Signal shutdown
    IO.puts("Success!")
  end

  def createdb(repos \\ repos()) do
    prepare()

    for repo <- repos do
      :ok = ensure_repo_created(repo)
    end

    IO.puts("Creation of Db successful!")
  end

  def rollback do
    prepare()

    get_step =
      IO.gets("Enter the number of steps: ")
      |> String.trim()
      |> Integer.parse()

    case get_step do
      {int, _trailing} ->
        Enum.each(repos(), fn repo -> run_rollbacks_for(repo, int) end)
        IO.puts("Rollback successful!")

      :error ->
        IO.puts("Invalid integer")
    end
  end

  def configure_ref_inspector() do
    priv_dir = Application.app_dir(:plausible, "priv/ref_inspector")
    Application.put_env(:ref_inspector, :database_path, priv_dir)
  end

  def configure_ua_inspector() do
    priv_dir = Application.app_dir(:plausible, "priv/ua_inspector")
    Application.put_env(:ua_inspector, :database_path, priv_dir)
  end

  def dump_plans() do
    prepare()

    Repo.delete_all("plans")

    plans =
      Plausible.Billing.Plans.all()
      |> Plausible.Billing.Plans.with_prices()
      |> Enum.map(fn plan ->
        plan = Map.from_struct(plan)

        monthly_cost = plan.monthly_cost && Money.to_decimal(plan.monthly_cost)
        yearly_cost = plan.yearly_cost && Money.to_decimal(plan.yearly_cost)

        features =
          Enum.map(plan.features, fn f ->
            {:ok, feat} = Plausible.Billing.Ecto.Feature.dump(f)
            feat
          end)

        {:ok, team_member_limit} = Plausible.Billing.Ecto.Limit.dump(plan.team_member_limit)

        plan
        |> Map.drop([:id])
        |> Map.put(:kind, Atom.to_string(plan.kind))
        |> Map.put(:monthly_cost, monthly_cost)
        |> Map.put(:yearly_cost, yearly_cost)
        |> Map.put(:features, features)
        |> Map.put(:team_member_limit, team_member_limit)
      end)

    {count, _} = Repo.insert_all("plans", plans)
    IO.puts("Inserted #{count} plans")
  end

  ##############################

  defp repos do
    Application.fetch_env!(@app, :ecto_repos)
  end

  defp run_seeds_for(repo) do
    # Run the seed script if it exists
    seed_script = seeds_path(repo)

    if File.exists?(seed_script) do
      IO.puts("Running seed script..")
      Code.eval_file(seed_script)
    end
  end

  defp ensure_repo_created(repo) do
    config = repo.config()
    adapter = repo.__adapter__()

    case adapter.storage_status(config) do
      :up ->
        IO.puts("#{inspect(repo)} database already exists")
        :ok

      :down ->
        IO.puts("Creating #{inspect(repo)} database..")

        case adapter.storage_up(config) do
          :ok -> :ok
          {:error, :already_up} -> :ok
          {:error, _reason} = error -> error
        end

      {:error, _reason} = error ->
        error
    end
  end

  defp run_rollbacks_for(repo, step) do
    app = Keyword.get(repo.config, :otp_app)
    IO.puts("Running rollbacks for #{app} (STEP=#{step})")

    {:ok, _, _} =
      Ecto.Migrator.with_repo(repo, &Ecto.Migrator.run(&1, :down, all: false, step: step))
  end

  defp prepare do
    IO.puts("Loading #{@app}..")
    # Load the code for myapp, but don't start it
    :ok = Application.ensure_loaded(@app)

    IO.puts("Starting dependencies..")
    # Start apps necessary for executing migrations
    Enum.each(@start_apps, &Application.ensure_all_started/1)

    # Start the Repo(s) for myapp
    IO.puts("Starting repos..")
    Enum.each(repos(), & &1.start_link(pool_size: 2))
  end

  defp seeds_path(repo), do: priv_path_for(repo, "seeds.exs")

  defp priv_path_for(repo, filename) do
    app = Keyword.get(repo.config, :otp_app)
    IO.puts("App: #{app}")
    repo_underscore = repo |> Module.split() |> List.last() |> Macro.underscore()
    Path.join([priv_dir(app), repo_underscore, filename])
  end

  defp priv_dir(app), do: "#{:code.priv_dir(app)}"
end
```

## File: `lib/plausible_web.ex`
```
defmodule PlausibleWeb do
  use Plausible

  def live_view(opts \\ []) do
    quote do
      use Plausible
      use Phoenix.LiveView, global_prefixes: ~w(x-)
      use PlausibleWeb.Live.Flash

      use PlausibleWeb.Live.AuthContext

      unless :no_sentry_context in unquote(opts) do
        use PlausibleWeb.Live.SentryContext
      end

      on_ee do
        use Plausible.Audit.LiveContext
      end

      alias PlausibleWeb.Router.Helpers, as: Routes
      alias Phoenix.LiveView.JS

      import PlausibleWeb.Components.Generic
      import PlausibleWeb.Live.Components.Form
    end
  end

  def live_component do
    quote do
      use Phoenix.LiveComponent, global_prefixes: ~w(x-)
      import PlausibleWeb.Components.Generic
      import PlausibleWeb.Live.Components.Form
      alias Phoenix.LiveView.JS
      alias PlausibleWeb.Router.Helpers, as: Routes
    end
  end

  def component do
    quote do
      use Phoenix.Component, global_prefixes: ~w(x-)
      import PlausibleWeb.Components.Generic
      import PlausibleWeb.Live.Components.Form
      alias Phoenix.LiveView.JS
      alias PlausibleWeb.Router.Helpers, as: Routes
    end
  end

  def controller do
    quote do
      use Phoenix.Controller, namespace: PlausibleWeb

      import Plug.Conn
      import PlausibleWeb.ControllerHelpers
      alias PlausibleWeb.Router.Helpers, as: Routes
    end
  end

  def view do
    quote do
      use Phoenix.View,
        root: "lib/plausible_web/templates",
        namespace: PlausibleWeb

      # Import convenience functions from controllers
      import Phoenix.Controller, only: [view_module: 1]

      use Phoenix.Component

      import PlausibleWeb.Components.Generic
      import PlausibleWeb.Live.Components.Form
      alias PlausibleWeb.Router.Helpers, as: Routes
    end
  end

  on_ee do
    def extra_view do
      quote do
        use Phoenix.View,
          root: "extra/lib/plausible_web/templates",
          namespace: PlausibleWeb

        # Import convenience functions from controllers
        import Phoenix.Controller, only: [view_module: 1]

        use Phoenix.Component

        import PlausibleWeb.Components.Generic
        import PlausibleWeb.Live.Components.Form
        alias PlausibleWeb.Router.Helpers, as: Routes
      end
    end
  end

  def router do
    quote do
      use Phoenix.Router
      import Plug.Conn
      import Phoenix.Controller
    end
  end

  def channel do
    quote do
      use Phoenix.Channel
    end
  end

  def plugins_api_controller do
    quote do
      use Phoenix.Controller, namespace: PlausibleWeb.Plugins.API
      import Plug.Conn
      import PlausibleWeb.Router.Helpers

      alias PlausibleWeb.Plugins.API.Schemas
      alias PlausibleWeb.Plugins.API.Views
      alias PlausibleWeb.Plugins.API.Errors
      alias Plausible.Plugins.API

      plug(OpenApiSpex.Plug.CastAndValidate, json_render_error_v2: true, replace_params: false)

      use OpenApiSpex.ControllerSpecs
    end
  end

  def plugins_api_view do
    quote do
      use Phoenix.View,
        namespace: PlausibleWeb.Plugins.API,
        root: ""

      alias PlausibleWeb.Router.Helpers
      import PlausibleWeb.Plugins.API.Views.Pagination, only: [render_metadata_links: 4]
    end
  end

  def open_api_schema do
    quote do
      require OpenApiSpex
      alias OpenApiSpex.Schema
      alias PlausibleWeb.Plugins.API.Schemas
    end
  end

  @doc """
  When used, dispatch to the appropriate controller/view/etc.
  """
  defmacro __using__(which) when is_atom(which) do
    apply(__MODULE__, which, [])
  end

  defmacro __using__([{which, opts}]) when is_atom(which) do
    apply(__MODULE__, which, [List.wrap(opts)])
  end
end
```

## File: `lib/plausible_web/captcha.ex`
```
defmodule PlausibleWeb.Captcha do
  alias Plausible.HTTPClient

  @verify_endpoint "https://hcaptcha.com/siteverify"

  def enabled? do
    is_binary(sitekey())
  end

  def sitekey() do
    Application.get_env(:plausible, :hcaptcha, [])[:sitekey]
  end

  def verify(token) do
    if enabled?() do
      res =
        HTTPClient.impl().post(
          @verify_endpoint,
          [{"content-type", "application/x-www-form-urlencoded"}],
          %{
            response: token,
            secret: secret()
          }
        )

      case res do
        {:ok, %Finch.Response{status: 200, body: %{"success" => success}}} ->
          success

        _ ->
          false
      end
    else
      true
    end
  end

  defp secret() do
    Application.get_env(:plausible, :hcaptcha, [])[:secret]
  end
end
```

## File: `lib/plausible_web/components/billing/billing.ex`
```
defmodule PlausibleWeb.Components.Billing do
  @moduledoc false

  use PlausibleWeb, :component
  use Plausible

  require Plausible.Billing.Subscription.Status
  alias Plausible.Billing.{Subscription, Subscriptions, Plan, Plans, EnterprisePlan}

  attr :current_role, :atom, required: true
  attr :current_team, :any, required: true
  attr :locked?, :boolean, required: true
  slot :inner_block, required: true

  def feature_gate(assigns) do
    ~H"""
    <div id="feature-gate-inner-block-container" class={if(@locked?, do: "pointer-events-none")}>
      {render_slot(@inner_block)}
    </div>
    <div
      :if={@locked?}
      id="feature-gate-overlay"
      class="absolute backdrop-blur-[6px] bg-white/50 dark:bg-gray-800/50 inset-0 flex justify-center items-center rounded-md"
    >
      <div class="px-6 flex flex-col items-center text-gray-500 dark:text-gray-400">
        <Heroicons.lock_closed solid class="size-8 mb-2" />

        <span id="lock-notice" class="text-center max-w-sm sm:max-w-md">
          To gain access to this feature,
          <.upgrade_call_to_action current_role={@current_role} current_team={@current_team} />.
        </span>
      </div>
    </div>
    """
  end

  def render_monthly_pageview_usage(%{usage: usage} = assigns)
      when is_map_key(usage, :last_30_days) do
    ~H"""
    <.monthly_pageview_usage_table usage={@usage.last_30_days} limit={@limit} period={:last_30_days} />
    """
  end

  def render_monthly_pageview_usage(assigns) do
    ~H"""
    <article id="monthly_pageview_usage_container" x-data="{ tab: 'last_cycle' }" class="mt-8">
      <.title>Monthly pageviews usage</.title>
      <div class="mt-4 mb-4">
        <ol class="divide-y divide-gray-300 dark:divide-gray-600 rounded-md border dark:border-gray-600 md:flex md:flex-row-reverse md:divide-y-0 md:overflow-hidden">
          <.billing_cycle_tab
            name="Upcoming cycle"
            tab={:current_cycle}
            date_range={@usage.current_cycle.date_range}
            with_separator={true}
          />
          <.billing_cycle_tab
            name="Last cycle"
            tab={:last_cycle}
            date_range={@usage.last_cycle.date_range}
            with_separator={true}
          />
          <.billing_cycle_tab
            name="Penultimate cycle"
            tab={:penultimate_cycle}
            date_range={@usage.penultimate_cycle.date_range}
            disabled={@usage.penultimate_cycle.total == 0}
          />
        </ol>
      </div>
      <div x-show="tab === 'current_cycle'">
        <.monthly_pageview_usage_table
          usage={@usage.current_cycle}
          limit={@limit}
          period={:current_cycle}
        />
      </div>
      <div x-show="tab === 'last_cycle'">
        <.monthly_pageview_usage_table usage={@usage.last_cycle} limit={@limit} period={:last_cycle} />
      </div>
      <div x-show="tab === 'penultimate_cycle'">
        <.monthly_pageview_usage_table
          usage={@usage.penultimate_cycle}
          limit={@limit}
          period={:penultimate_cycle}
        />
      </div>
    </article>
    """
  end

  attr(:usage, :map, required: true)
  attr(:limit, :any, required: true)
  attr(:period, :atom, required: true)

  defp monthly_pageview_usage_table(assigns) do
    ~H"""
    <.usage_and_limits_table>
      <.usage_and_limits_row
        id={"total_pageviews_#{@period}"}
        title={"Total billable pageviews#{if @period == :last_30_days, do: " (last 30 days)"}"}
        usage={@usage.total}
        limit={@limit}
      />
      <.usage_and_limits_row
        id={"pageviews_#{@period}"}
        pad
        title="Pageviews"
        usage={@usage.pageviews}
      />
      <.usage_and_limits_row
        id={"custom_events_#{@period}"}
        pad
        title="Custom events"
        usage={@usage.custom_events}
      />
    </.usage_and_limits_table>
    """
  end

  attr(:name, :string, required: true)
  attr(:date_range, :any, required: true)
  attr(:tab, :atom, required: true)
  attr(:disabled, :boolean, default: false)
  attr(:with_separator, :boolean, default: false)

  defp billing_cycle_tab(assigns) do
    ~H"""
    <li id={"billing_cycle_tab_#{@tab}"} class="relative md:w-1/3">
      <button
        class={["w-full group", @disabled && "pointer-events-none opacity-50 dark:opacity-25"]}
        x-on:click={"tab = '#{@tab}'"}
      >
        <span
          class="absolute left-0 top-0 h-full w-1 md:bottom-0 md:top-auto md:h-1 md:w-full"
          x-bind:class={"tab === '#{@tab}' ? 'bg-indigo-500' : 'bg-transparent group-hover:bg-gray-200 dark:group-hover:bg-gray-700 '"}
          aria-hidden="true"
        >
        </span>
        <div class={"flex items-center justify-between md:flex-col md:items-start py-2 pr-2 #{if @with_separator, do: "pl-2 md:pl-4", else: "pl-2"}"}>
          <span
            class="text-sm dark:text-gray-100"
            x-bind:class={"tab === '#{@tab}' ? 'text-indigo-600 dark:text-indigo-500 font-semibold' : 'font-medium'"}
          >
            {@name}
          </span>
          <span class="flex text-xs text-gray-500 dark:text-gray-400">
            {if @disabled,
              do: "Not available",
              else: PlausibleWeb.TextHelpers.format_date_range(@date_range)}
          </span>
        </div>
      </button>
      <div
        :if={@with_separator}
        class="absolute inset-0 left-0 top-0 w-3 hidden md:block"
        aria-hidden="true"
      >
        <svg
          class="h-full w-full text-gray-300 dark:text-gray-600"
          viewBox="0 0 12 82"
          fill="none"
          preserveAspectRatio="none"
        >
          <path
            d="M0.5 0V31L10.5 41L0.5 51V82"
            stroke="currentcolor"
            vector-effect="non-scaling-stroke"
          />
        </svg>
      </div>
    </li>
    """
  end

  slot(:inner_block, required: true)
  attr(:rest, :global)

  def usage_and_limits_table(assigns) do
    ~H"""
    <table class="min-w-full text-gray-900 dark:text-gray-100" {@rest}>
      <tbody class="divide-y divide-gray-200 dark:divide-gray-600">
        {render_slot(@inner_block)}
      </tbody>
    </table>
    """
  end

  attr(:title, :string, required: true)
  attr(:usage, :integer, required: true)
  attr(:limit, :integer, default: nil)
  attr(:pad, :boolean, default: false)
  attr(:rest, :global)

  def usage_and_limits_row(assigns) do
    ~H"""
    <tr {@rest}>
      <td class={["text-sm py-4 pr-1 sm:whitespace-nowrap text-left", @pad && "pl-6"]}>
        {@title}
      </td>
      <td class="text-sm py-4 sm:whitespace-nowrap text-right">
        {Cldr.Number.to_string!(@usage)}
        {if is_number(@limit), do: "/ #{Cldr.Number.to_string!(@limit)}"}
      </td>
    </tr>
    """
  end

  def monthly_quota_box(assigns) do
    ~H"""
    <div
      id="monthly-quota-box"
      class="w-full flex-1 h-32 px-2 py-4 text-center bg-gray-100 rounded dark:bg-gray-900 w-max-md"
    >
      <h4 class="font-black dark:text-gray-100">Monthly quota</h4>
      <div class="py-2 text-xl font-medium dark:text-gray-100">
        {PlausibleWeb.AuthView.subscription_quota(@subscription, format: :long)}
      </div>
      <.styled_link
        :if={
          not (Plausible.Teams.Billing.enterprise_configured?(@team) &&
                 Subscriptions.halted?(@subscription))
        }
        id="#upgrade-or-change-plan-link"
        href={Routes.billing_path(PlausibleWeb.Endpoint, :choose_plan)}
      >
        {change_plan_or_upgrade_text(@subscription)}
      </.styled_link>
    </div>
    """
  end

  def present_enterprise_plan(assigns) do
    ~H"""
    <ul class="w-full py-4">
      <li>
        Up to <b>{present_limit(@plan, :monthly_pageview_limit)}</b> monthly pageviews
      </li>
      <li>
        Up to <b>{present_limit(@plan, :site_limit)}</b> sites
      </li>
      <li>
        Up to <b>{present_limit(@plan, :hourly_api_request_limit)}</b> hourly api requests
      </li>
    </ul>
    """
  end

  defp present_limit(enterprise_plan, key) do
    enterprise_plan
    |> Map.fetch!(key)
    |> PlausibleWeb.StatsView.large_number_format()
  end

  attr :id, :string, required: true
  attr :paddle_product_id, :string, required: true
  attr :checkout_disabled, :boolean, default: false
  attr :user, :map, required: true
  attr :team, :map, default: nil
  attr :confirm_message, :any, default: nil
  slot :inner_block, required: true

  def paddle_button(assigns) do
    js_action_expr =
      start_paddle_checkout_expr(assigns.paddle_product_id, assigns.team, assigns.user)

    confirmed =
      if assigns.confirm_message, do: "confirm(\"#{assigns.confirm_message}\")", else: "true"

    assigns =
      assigns
      |> assign(:confirmed, confirmed)
      |> assign(:js_action_expr, js_action_expr)

    ~H"""
    <button
      id={@id}
      onclick={"if (#{@confirmed}) {#{@js_action_expr}}"}
      class={[
        "text-sm w-full mt-6 block rounded-md py-2 px-3 text-center font-semibold leading-6 text-white",
        !@checkout_disabled && "bg-indigo-600 hover:bg-indigo-500",
        @checkout_disabled && "pointer-events-none bg-gray-400 dark:bg-gray-600"
      ]}
    >
      {render_slot(@inner_block)}
    </button>
    """
  end

  if Mix.env() == :dev do
    def start_paddle_checkout_expr(paddle_product_id, _team, _user) do
      "window.location = '#{Routes.dev_subscription_path(PlausibleWeb.Endpoint, :create_form, paddle_product_id)}'"
    end

    def paddle_script(assigns), do: ~H""
  else
    def start_paddle_checkout_expr(paddle_product_id, team, user) do
      passthrough =
        if team do
          "ee:#{ee?()};user:#{user.id};team:#{team.id}"
        else
          "ee:#{ee?()};user:#{user.id}"
        end

      paddle_checkout_params =
        Jason.encode!(%{
          product: paddle_product_id,
          email: user.email,
          disableLogout: true,
          passthrough: passthrough,
          success: Routes.billing_path(PlausibleWeb.Endpoint, :upgrade_success),
          theme: "none"
        })

      "Paddle.Checkout.open(#{paddle_checkout_params})"
    end

    def paddle_script(assigns) do
      ~H"""
      <script type="text/javascript" src="https://cdn.paddle.com/paddle/paddle.js">
      </script>
      <script :if={Application.get_env(:plausible, :environment) == "staging"}>
        Paddle.Environment.set('sandbox')
      </script>
      <script>
        Paddle.Setup({vendor: <%= Application.get_env(:plausible, :paddle) |> Keyword.fetch!(:vendor_id) %> })
      </script>
      """
    end
  end

  def upgrade_link(assigns) do
    ~H"""
    <.button_link id="upgrade-link-2" href={Routes.billing_path(PlausibleWeb.Endpoint, :choose_plan)}>
      Upgrade
    </.button_link>
    """
  end

  defp change_plan_or_upgrade_text(nil), do: "Upgrade"

  defp change_plan_or_upgrade_text(%Subscription{status: Subscription.Status.deleted()}),
    do: "Upgrade"

  defp change_plan_or_upgrade_text(_subscription), do: "Change plan"

  def upgrade_call_to_action(assigns) do
    team = Plausible.Teams.with_subscription(assigns.current_team)

    upgrade_assistance_required? =
      case Plans.get_subscription_plan(team && team.subscription) do
        %Plan{kind: :business} -> true
        %EnterprisePlan{} -> true
        _ -> false
      end

    cond do
      not is_nil(assigns.current_role) and assigns.current_role not in [:owner, :billing] ->
        ~H"please reach out to the team owner to upgrade their subscription"

      upgrade_assistance_required? ->
        ~H"""
        please contact <a href="mailto:hello@plausible.io" class="underline">hello@plausible.io</a>
        to upgrade your subscription
        """

      true ->
        ~H"""
        please
        <.link
          class="underline inline-block"
          href={Routes.billing_path(PlausibleWeb.Endpoint, :choose_plan)}
        >
          upgrade your subscription
        </.link>
        """
    end
  end
end
```

## File: `lib/plausible_web/components/billing/legacy_plan_benefits.ex`
```
defmodule PlausibleWeb.Components.Billing.LegacyPlanBenefits do
  @moduledoc """
  [DEPRECATED] This file is essentially a copy of
  `PlausibleWeb.Components.Billing.PlanBenefits` with the
  intent of keeping the old behaviour in place for the users without
  the `starter_tier` feature flag enabled.
  """

  use Phoenix.Component
  alias Plausible.Billing.Plan

  attr :benefits, :list, required: true
  attr :class, :string, default: nil

  @doc """
  This function takes a list of benefits returned by either one of:

  * `for_growth/1`
  * `for_business/2`
  * `for_enterprise/1`.

  and renders them as HTML.

  The benefits in the given list can be either strings or functions
  returning a Phoenix component. This allows, for example, to render
  links within the plan benefit text.
  """
  def render(assigns) do
    ~H"""
    <ul role="list" class={["mt-8 space-y-3 text-sm leading-6 xl:mt-10", @class]}>
      <li :for={benefit <- @benefits} class="flex gap-x-3">
        <Heroicons.check class="h-6 w-5 text-indigo-600 dark:text-green-600" />
        {if is_binary(benefit), do: benefit, else: benefit.(assigns)}
      </li>
    </ul>
    """
  end

  @doc """
  This function takes a growth plan and returns a list representing
  the different benefits a user gets when subscribing to this plan.
  """
  def for_growth(plan) do
    [
      team_member_limit_benefit(plan),
      site_limit_benefit(plan),
      data_retention_benefit(plan),
      "Intuitive, fast and privacy-friendly dashboard",
      "Email/Slack reports",
      "Google Analytics import"
    ]
    |> Kernel.++(feature_benefits(plan))
    |> Kernel.++(["Saved Segments"])
    |> Enum.filter(& &1)
  end

  @doc """
  Returns Business benefits for the given Business plan.

  A second argument is also required - list of Growth benefits. This
  is because we don't want to list the same benefits in both Growth
  and Business. Everything in Growth is also included in Business.
  """
  def for_business(plan, growth_benefits) do
    [
      "Everything in Growth",
      team_member_limit_benefit(plan),
      site_limit_benefit(plan),
      data_retention_benefit(plan)
    ]
    |> Kernel.++(feature_benefits(plan))
    |> Kernel.--(growth_benefits)
    |> Kernel.++(["Priority support"])
    |> Enum.filter(& &1)
  end

  @doc """
  This function only takes a list of business benefits. Since all
  limits and features of enterprise plans are configurable, we can
  say on the upgrade page that enterprise plans include everything
  in Business.
  """
  def for_enterprise(business_benefits) do
    team_members =
      if "Up to 10 team members" in business_benefits, do: "10+ team members"

    data_retention =
      if "5 years of data retention" in business_benefits, do: "5+ years of data retention"

    [
      "Everything in Business",
      team_members,
      "50+ sites",
      "600+ Stats API requests per hour",
      &sites_api_benefit/1,
      "Single Sign-On (SSO)",
      data_retention
    ]
    |> Enum.filter(& &1)
  end

  defp data_retention_benefit(%Plan{} = plan) do
    if plan.data_retention_in_years, do: "#{plan.data_retention_in_years} years of data retention"
  end

  defp team_member_limit_benefit(%Plan{} = plan) do
    case plan.team_member_limit do
      :unlimited -> "Unlimited team members"
      number -> "Up to #{number} team members"
    end
  end

  defp site_limit_benefit(%Plan{} = plan), do: "Up to #{plan.site_limit} sites"

  defp feature_benefits(%Plan{} = plan) do
    Enum.flat_map(plan.features, fn feature_mod ->
      case feature_mod.name() do
        :goals -> ["Goals and custom events"]
        :teams -> []
        :shared_links -> []
        :stats_api -> ["Stats API (600 requests per hour)", "Looker Studio Connector"]
        :revenue_goals -> ["Ecommerce revenue attribution"]
        _ -> [feature_mod.display_name()]
      end
    end)
  end

  defp sites_api_benefit(assigns) do
    ~H"""
    <p>
      Sites API access for
      <.link
        class="text-indigo-500 hover:text-indigo-400"
        href="https://plausible.io/white-label-web-analytics"
      >
        reselling
      </.link>
    </p>
    """
  end
end
```

## File: `lib/plausible_web/components/billing/legacy_plan_box.ex`
```
defmodule PlausibleWeb.Components.Billing.LegacyPlanBox do
  @moduledoc """
  [DEPRECATED] This file is essentially a copy of
  `PlausibleWeb.Components.Billing.PlanBox` with the
  intent of keeping the old behaviour in place for the users without
  the `starter_tier` feature flag enabled.
  """

  use PlausibleWeb, :component

  require Plausible.Billing.Subscription.Status
  alias PlausibleWeb.Components.Billing.{LegacyPlanBenefits, Notice}
  alias Plausible.Billing.{Plan, Quota, Subscription}

  def standard(assigns) do
    highlight =
      cond do
        assigns.owned && assigns.recommended -> "Current"
        assigns.recommended -> "Recommended"
        true -> nil
      end

    assigns = assign(assigns, :highlight, highlight)

    ~H"""
    <div
      id={"#{@kind}-plan-box"}
      class={[
        "shadow-lg bg-white rounded-3xl px-6 sm:px-8 py-4 sm:py-6 dark:bg-gray-800",
        !@highlight && "dark:ring-gray-600",
        @highlight && "ring-2 ring-indigo-600 dark:ring-indigo-300"
      ]}
    >
      <div class="flex items-center justify-between gap-x-4">
        <h3 class={[
          "text-lg font-semibold leading-8",
          !@highlight && "text-gray-900 dark:text-gray-100",
          @highlight && "text-indigo-600 dark:text-indigo-300"
        ]}>
          {String.capitalize(to_string(@kind))}
        </h3>
        <.pill :if={@highlight} text={@highlight} />
      </div>
      <div>
        <.render_price_info available={@available} {assigns} />
        <%= if @available do %>
          <.checkout id={"#{@kind}-checkout"} {assigns} />
        <% else %>
          <.contact_button class="bg-indigo-600 hover:bg-indigo-500 text-white" />
        <% end %>
      </div>
      <%= if @owned && @kind == :growth && @plan_to_render.generation < 4 do %>
        <Notice.growth_grandfathered />
      <% else %>
        <LegacyPlanBenefits.render benefits={@benefits} class="text-gray-600 dark:text-gray-100" />
      <% end %>
    </div>
    """
  end

  def enterprise(assigns) do
    ~H"""
    <div
      id="enterprise-plan-box"
      class={[
        "rounded-3xl px-6 sm:px-8 py-4 sm:py-6 bg-gray-900 shadow-xl dark:bg-gray-800",
        !@recommended && "dark:ring-gray-600",
        @recommended && "ring-4 ring-indigo-500 dark:ring-2 dark:ring-indigo-300"
      ]}
    >
      <div class="flex items-center justify-between gap-x-4">
        <h3 class={[
          "text-lg font-semibold leading-8",
          !@recommended && "text-white dark:text-gray-100",
          @recommended && "text-indigo-400 dark:text-indigo-300"
        ]}>
          Enterprise
        </h3>
        <span
          :if={@recommended}
          id="enterprise-highlight-pill"
          class="rounded-full ring-1 ring-indigo-500 px-2.5 py-1 text-xs font-semibold leading-5 text-indigo-400 dark:text-indigo-300 dark:ring-1 dark:ring-indigo-300/50"
        >
          Recommended
        </span>
      </div>
      <p class="mt-6 flex items-baseline gap-x-1">
        <span class="text-4xl font-bold tracking-tight text-white dark:text-gray-100">
          Custom
        </span>
      </p>
      <p class="h-4 mt-1"></p>
      <.contact_button class="" />
      <LegacyPlanBenefits.render benefits={@benefits} class="text-gray-300 dark:text-gray-100" />
    </div>
    """
  end

  defp pill(assigns) do
    ~H"""
    <div class="flex items-center justify-between gap-x-4">
      <p
        id="highlight-pill"
        class="rounded-full bg-indigo-600/10 px-2.5 py-1 text-xs font-semibold leading-5 text-indigo-600 dark:text-indigo-300 dark:ring-1 dark:ring-indigo-300/50"
      >
        {@text}
      </p>
    </div>
    """
  end

  defp render_price_info(%{available: false} = assigns) do
    ~H"""
    <p id={"#{@kind}-custom-price"} class="mt-6 flex items-baseline gap-x-1">
      <span class="text-4xl font-bold tracking-tight text-gray-900 dark:text-white">
        Custom
      </span>
    </p>
    <p class="h-4 mt-1"></p>
    """
  end

  defp render_price_info(assigns) do
    ~H"""
    <p class="mt-6 flex items-baseline gap-x-1">
      <.price_tag
        kind={@kind}
        selected_interval={@selected_interval}
        plan_to_render={@plan_to_render}
      />
    </p>
    <p class="mt-1 text-xs">+ VAT if applicable</p>
    """
  end

  defp price_tag(%{plan_to_render: %Plan{monthly_cost: nil}} = assigns) do
    ~H"""
    <span class="text-4xl font-bold tracking-tight text-gray-900 dark:text-gray-100">
      N/A
    </span>
    """
  end

  defp price_tag(%{selected_interval: :monthly} = assigns) do
    ~H"""
    <span
      id={"#{@kind}-price-tag-amount"}
      class="text-4xl font-bold tracking-tight text-gray-900 dark:text-gray-100"
    >
      {@plan_to_render.monthly_cost |> Plausible.Billing.format_price()}
    </span>
    <span
      id={"#{@kind}-price-tag-interval"}
      class="text-sm font-semibold leading-6 text-gray-600 dark:text-gray-500"
    >
      /month
    </span>
    """
  end

  defp price_tag(%{selected_interval: :yearly} = assigns) do
    ~H"""
    <span class="text-2xl font-bold w-max tracking-tight line-through text-gray-500 dark:text-gray-600 mr-1">
      {@plan_to_render.monthly_cost |> Money.mult!(12) |> Plausible.Billing.format_price()}
    </span>
    <span
      id={"#{@kind}-price-tag-amount"}
      class="text-4xl font-bold tracking-tight text-gray-900 dark:text-gray-100"
    >
      {@plan_to_render.yearly_cost |> Plausible.Billing.format_price()}
    </span>
    <span id={"#{@kind}-price-tag-interval"} class="text-sm font-semibold leading-6 text-gray-600">
      /year
    </span>
    """
  end

  defp checkout(assigns) do
    paddle_product_id = get_paddle_product_id(assigns.plan_to_render, assigns.selected_interval)
    change_plan_link_text = change_plan_link_text(assigns)

    subscription =
      Plausible.Teams.Billing.get_subscription(assigns.current_team)

    billing_details_expired =
      Subscription.Status.in?(subscription, [
        Subscription.Status.paused(),
        Subscription.Status.past_due()
      ])

    subscription_deleted = Subscription.Status.deleted?(subscription)
    usage_check = check_usage_within_plan_limits(assigns)

    {checkout_disabled, disabled_message} =
      cond do
        not Quota.eligible_for_upgrade?(assigns.usage) ->
          {true, nil}

        change_plan_link_text == "Currently on this plan" && not subscription_deleted ->
          {true, nil}

        usage_check != :ok ->
          {true, "Your usage exceeds this plan"}

        billing_details_expired ->
          {true, "Please update your billing details first"}

        true ->
          {false, nil}
      end

    exceeded_plan_limits =
      case usage_check do
        {:error, {:over_plan_limits, limits}} ->
          limits

        _ ->
          []
      end

    feature_usage_check = Quota.ensure_feature_access(assigns.usage, assigns.plan_to_render)

    assigns =
      assigns
      |> assign(:paddle_product_id, paddle_product_id)
      |> assign(:change_plan_link_text, change_plan_link_text)
      |> assign(:checkout_disabled, checkout_disabled)
      |> assign(:disabled_message, disabled_message)
      |> assign(:exceeded_plan_limits, exceeded_plan_limits)
      |> assign(:confirm_message, losing_features_message(feature_usage_check))

    ~H"""
    <%= if @owned_plan && Plausible.Billing.Subscriptions.resumable?(@current_team.subscription) do %>
      <.change_plan_link {assigns} />
    <% else %>
      <PlausibleWeb.Components.Billing.paddle_button
        user={@current_user}
        team={@current_team}
        {assigns}
      >
        Upgrade
      </PlausibleWeb.Components.Billing.paddle_button>
    <% end %>
    <.tooltip :if={@exceeded_plan_limits != [] && @disabled_message}>
      <div class="pt-2 text-sm w-full flex items-center text-red-700 dark:text-red-500 justify-center">
        {@disabled_message}
        <Heroicons.information_circle class="hidden sm:block w-5 h-5 sm:ml-2" />
      </div>
      <:tooltip_content>
        Your usage exceeds the following limit(s):<br /><br />
        <p :for={limit <- @exceeded_plan_limits}>
          {Phoenix.Naming.humanize(limit)}<br />
        </p>
      </:tooltip_content>
    </.tooltip>
    <div
      :if={@disabled_message && @exceeded_plan_limits == []}
      class="pt-2 text-sm w-full text-red-700 dark:text-red-500 text-center"
    >
      {@disabled_message}
    </div>
    """
  end

  defp check_usage_within_plan_limits(%{available: false}) do
    {:error, :plan_unavailable}
  end

  defp check_usage_within_plan_limits(%{
         available: true,
         usage: usage,
         current_team: current_team,
         plan_to_render: plan
       }) do
    # At this point, the user is *not guaranteed* to have a team,
    # with ongoing trial.
    trial_active_or_ended_recently? =
      not is_nil(current_team) and not is_nil(current_team.trial_expiry_date) and
        Plausible.Teams.trial_days_left(current_team) >= -10

    limit_checking_opts =
      cond do
        current_team && current_team.allow_next_upgrade_override ->
          [ignore_pageview_limit: true]

        trial_active_or_ended_recently? && plan.volume == "10k" ->
          [pageview_allowance_margin: 0.3]

        trial_active_or_ended_recently? ->
          [pageview_allowance_margin: 0.15]

        true ->
          []
      end

    Quota.ensure_within_plan_limits(usage, plan, limit_checking_opts)
  end

  defp get_paddle_product_id(%Plan{monthly_product_id: plan_id}, :monthly), do: plan_id
  defp get_paddle_product_id(%Plan{yearly_product_id: plan_id}, :yearly), do: plan_id

  defp change_plan_link_text(
         %{
           owned_plan: %Plan{kind: from_kind, monthly_pageview_limit: from_volume},
           plan_to_render: %Plan{kind: to_kind, monthly_pageview_limit: to_volume},
           current_interval: from_interval,
           selected_interval: to_interval
         } = _assigns
       ) do
    cond do
      from_kind == :business && to_kind == :growth ->
        "Downgrade to Growth"

      from_kind == :growth && to_kind == :business ->
        "Upgrade to Business"

      from_volume == to_volume && from_interval == to_interval ->
        "Currently on this plan"

      from_volume == to_volume ->
        "Change billing interval"

      from_volume > to_volume ->
        "Downgrade"

      true ->
        "Upgrade"
    end
  end

  defp change_plan_link_text(_), do: nil

  defp change_plan_link(assigns) do
    confirmed =
      if assigns.confirm_message, do: "confirm(\"#{assigns.confirm_message}\")", else: "true"

    assigns = assign(assigns, :confirmed, confirmed)

    ~H"""
    <button
      id={"#{@kind}-checkout"}
      onclick={"if (#{@confirmed}) {window.location = '#{Routes.billing_path(PlausibleWeb.Endpoint, :change_plan_preview, @paddle_product_id)}'}"}
      class={[
        "w-full mt-6 block rounded-md py-2 px-3 text-center text-sm font-semibold leading-6 text-white",
        !@checkout_disabled && "bg-indigo-600 hover:bg-indigo-500",
        @checkout_disabled && "pointer-events-none bg-gray-400 dark:bg-gray-600"
      ]}
    >
      {@change_plan_link_text}
    </button>
    """
  end

  defp losing_features_message(:ok), do: nil

  defp losing_features_message({:error, {:unavailable_features, features}}) do
    features_list_str =
      features
      |> Enum.map(fn feature_mod -> feature_mod.display_name() end)
      |> PlausibleWeb.TextHelpers.pretty_join()

    "This plan does not support #{features_list_str}, which you have been using. By subscribing to this plan, you will not have access to #{if length(features) == 1, do: "this feature", else: "these features"}."
  end

  defp contact_button(assigns) do
    ~H"""
    <.link
      href="https://plausible.io/contact"
      class={[
        "mt-6 block rounded-md py-2 px-3 text-center text-sm font-semibold leading-6 bg-gray-800 hover:bg-gray-700 text-white dark:bg-indigo-600 dark:hover:bg-indigo-500",
        @class
      ]}
    >
      Contact us
    </.link>
    """
  end
end
```

## File: `lib/plausible_web/components/billing/notice.ex`
```
defmodule PlausibleWeb.Components.Billing.Notice do
  @moduledoc false

  use PlausibleWeb, :component

  require Plausible.Billing.Subscription.Status
  alias Plausible.Billing.{Subscription, Plans, Subscriptions}

  def active_grace_period(assigns) do
    if assigns.enterprise? do
      ~H"""
      <aside class="container">
        <.notice
          title={Plausible.Billing.active_grace_period_notice_title()}
          class="shadow-md dark:shadow-none"
        >
          To keep your stats running smoothly, it’s time to upgrade your subscription to match your growing usage.
          <.link
            href={Routes.billing_path(PlausibleWeb.Endpoint, :choose_plan)}
            class="whitespace-nowrap font-semibold"
          >
            Upgrade now <span aria-hidden="true"> &rarr;</span>
          </.link>
        </.notice>
      </aside>
      """
    else
      ~H"""
      <aside class="container">
        <.notice
          title={Plausible.Billing.active_grace_period_notice_title()}
          class="shadow-md dark:shadow-none"
        >
          To keep your stats running smoothly, it’s time to upgrade your subscription to match your growing usage.
          <.link
            href={Routes.billing_path(PlausibleWeb.Endpoint, :choose_plan)}
            class="whitespace-nowrap font-semibold"
          >
            Upgrade now <span aria-hidden="true"> &rarr;</span>
          </.link>
        </.notice>
      </aside>
      """
    end
  end

  def dashboard_locked(assigns) do
    ~H"""
    <aside class="container">
      <.notice
        title={Plausible.Billing.dashboard_locked_notice_title()}
        class="shadow-md dark:shadow-none"
      >
        Since you’ve outgrown your current subscription tier, it’s time to upgrade to match your growing usage.
        <.link
          href={Routes.billing_path(PlausibleWeb.Endpoint, :choose_plan)}
          class="whitespace-nowrap font-semibold"
        >
          Upgrade now <span aria-hidden="true"> &rarr;</span>
        </.link>
      </.notice>
    </aside>
    """
  end

  attr(:current_team, :any, required: true)
  attr(:current_role, :atom, required: true)
  attr(:limit, :integer, required: true)
  attr(:resource, :string, required: true)
  attr(:rest, :global)

  def limit_exceeded(assigns) do
    ~H"""
    <.notice {@rest} title="Notice" data-test="limit-exceeded-notice">
      {account_label(@current_team)} is limited to {pretty_print_resource_limit(@limit, @resource)}. To increase this limit,
      <PlausibleWeb.Components.Billing.upgrade_call_to_action
        current_team={@current_team}
        current_role={@current_role}
      />.
    </.notice>
    """
  end

  defp pretty_print_resource_limit(1 = _limit, resource_plural) do
    "a single #{String.trim_trailing(resource_plural, "s")}"
  end

  defp pretty_print_resource_limit(limit, resource_plural) do
    "#{limit} #{resource_plural}"
  end

  attr(:subscription, :map, required: true)
  attr(:dismissable, :boolean, default: true)

  @doc """
  Given a user with a cancelled subscription, this component renders a cancelled
  subscription notice. If the given user does not have a subscription or it has a
  different status, this function returns an empty template.

  It also takes a dismissable argument which renders the notice dismissable (with
  the help of JavaScript and localStorage). We show a dismissable notice about a
  cancelled subscription across the app, but when the user dismisses it, we will
  start displaying it in the account settings > subscription section instead.

  So it's either shown across the app, or only on the /settings page. Depending
  on whether the localStorage flag to dismiss it has been set or not.
  """
  def subscription_cancelled(assigns)

  def subscription_cancelled(
        %{
          dismissable: true,
          subscription: %Subscription{status: Subscription.Status.deleted()}
        } = assigns
      ) do
    ~H"""
    <aside
      :if={not Subscriptions.expired?(@subscription)}
      id="global-subscription-cancelled-notice"
      class="container"
    >
      <.notice
        dismissable_id={Plausible.Billing.cancelled_subscription_notice_dismiss_id(@subscription.id)}
        title={Plausible.Billing.subscription_cancelled_notice_title()}
        theme={:red}
        class="shadow-md dark:shadow-none"
      >
        <.subscription_cancelled_notice_body subscription={@subscription} />
      </.notice>
    </aside>
    """
  end

  def subscription_cancelled(
        %{
          dismissable: false,
          subscription: %Subscription{status: Subscription.Status.deleted()}
        } = assigns
      ) do
    assigns = assign(assigns, :container_id, "local-subscription-cancelled-notice")

    ~H"""
    <aside :if={not Subscriptions.expired?(@subscription)} id={@container_id} class="hidden">
      <.notice
        title={Plausible.Billing.subscription_cancelled_notice_title()}
        theme={:red}
        class="shadow-md dark:shadow-none"
      >
        <.subscription_cancelled_notice_body subscription={@subscription} />
      </.notice>
    </aside>
    <script
      data-localstorage-key={"notice_dismissed__#{Plausible.Billing.cancelled_subscription_notice_dismiss_id(@subscription.id)}"}
      data-container-id={@container_id}
    >
      const dataset = document.currentScript.dataset

      if (localStorage[dataset.localstorageKey]) {
        document.getElementById(dataset.containerId).classList.remove('hidden')
      }
    </script>
    """
  end

  def subscription_cancelled(assigns), do: ~H""

  attr(:class, :string, default: "")
  attr(:subscription, :any, default: nil)

  def subscription_past_due(
        %{subscription: %Subscription{status: Subscription.Status.past_due()}} = assigns
      ) do
    ~H"""
    <aside class={@class}>
      <.notice
        title={Plausible.Billing.subscription_past_due_notice_title()}
        class="shadow-md dark:shadow-none"
      >
        There was a problem with your latest payment. Please update your payment information to keep using Plausible.<.link
          href={@subscription.update_url}
          class="whitespace-nowrap font-semibold"
        > Update billing info <span aria-hidden="true"> &rarr;</span></.link>
      </.notice>
    </aside>
    """
  end

  def subscription_past_due(assigns), do: ~H""

  attr(:class, :string, default: "")
  attr(:subscription, :any, default: nil)

  def subscription_paused(
        %{subscription: %Subscription{status: Subscription.Status.paused()}} = assigns
      ) do
    ~H"""
    <aside class={@class}>
      <.notice
        title={Plausible.Billing.subscription_paused_notice_title()}
        theme={:red}
        class="shadow-md dark:shadow-none"
      >
        Your subscription is paused due to failed payments. Please provide valid payment details to keep using Plausible.<.link
          href={@subscription.update_url}
          class="whitespace-nowrap font-semibold"
        > Update billing info <span aria-hidden="true"> &rarr;</span></.link>
      </.notice>
    </aside>
    """
  end

  def subscription_paused(assigns), do: ~H""

  def upgrade_ineligible(assigns) do
    ~H"""
    <aside id="upgrade-eligible-notice" class="pb-6">
      <.notice
        title={Plausible.Billing.upgrade_ineligible_notice_title()}
        theme={:yellow}
        class="shadow-md dark:shadow-none"
      >
        You cannot start a subscription as your account doesn't own any sites. The account that owns the sites is responsible for the billing. Please either
        <.styled_link href="https://plausible.io/docs/transfer-ownership">
          transfer the sites
        </.styled_link>
        to your account or start a subscription from the account that owns your sites.
      </.notice>
    </aside>
    """
  end

  def pending_site_ownerships_notice(%{pending_ownership_count: count} = assigns) do
    if count > 0 do
      message =
        "Your account has been invited to become the owner of " <>
          if(count == 1, do: "a site, which is", else: "#{count} sites, which are") <>
          " being counted towards the usage of your account."

      assigns = assign(assigns, message: message)

      ~H"""
      <aside class={@class}>
        <.notice
          title={Plausible.Billing.pending_site_ownerships_notice_title()}
          class="shadow-md dark:shadow-none mt-4"
        >
          {@message} To exclude pending sites from your usage, please go to
          <.link href="https://plausible.io/sites" class="whitespace-nowrap font-semibold">
            plausible.io/sites
          </.link>
          and reject the invitations.
        </.notice>
      </aside>
      """
    else
      ~H""
    end
  end

  def growth_grandfathered(assigns) do
    ~H"""
    <div class="mt-8 space-y-3 text-sm leading-6 text-gray-600 text-justify dark:text-gray-100">
      Your subscription has been grandfathered in at the same rate and terms as when you first joined. If you don't need the "Business" features, you're welcome to stay on this plan. You can adjust the pageview limit or change the billing frequency of this grandfathered plan. If you're interested in business features, you can upgrade to a "Business" plan.
    </div>
    """
  end

  defp subscription_cancelled_notice_body(assigns) do
    ~H"""
    <p>
      You have access to your stats until <span class="font-semibold inline"><%= Calendar.strftime(@subscription.next_bill_date, "%b %-d, %Y") %></span>.
      <.link
        class="underline inline-block"
        href={Routes.billing_path(PlausibleWeb.Endpoint, :choose_plan)}
      >
        Upgrade your subscription
      </.link>
      to make sure you don't lose access.
    </p>
    <.lose_grandfathering_warning subscription={@subscription} />
    """
  end

  defp lose_grandfathering_warning(%{subscription: subscription} = assigns) do
    plan = Plans.get_regular_plan(subscription, only_non_expired: true)
    latest_generation = if FunWithFlags.enabled?(:starter_tier), do: 5, else: 4
    loses_grandfathering? = plan && plan.generation < latest_generation

    assigns = assign(assigns, :loses_grandfathering?, loses_grandfathering?)

    ~H"""
    <p :if={@loses_grandfathering?} class="mt-2">
      Please also note that by letting your subscription expire, you lose access to our grandfathered terms. If you want to subscribe again after that, your account will be offered the <.link
        href="https://plausible.io/#pricing"
        target="_blank"
        rel="noopener noreferrer"
        class="underline"
      >latest pricing</.link>.
    </p>
    """
  end

  defp account_label(%Plausible.Teams.Team{setup_complete: true}), do: "This team"
  defp account_label(_team), do: "This account"
end
```

## File: `lib/plausible_web/components/billing/pageview_slider.ex`
```
defmodule PlausibleWeb.Components.Billing.PageviewSlider do
  @moduledoc false

  use PlausibleWeb, :component

  def render(assigns) do
    ~H"""
    <.slider_output volume={@selected_volume} available_volumes={@available_volumes} />
    <.slider_input selected_volume={@selected_volume} available_volumes={@available_volumes} />
    <.slider_styles />
    """
  end

  attr :volume, :any
  attr :available_volumes, :list

  defp slider_output(assigns) do
    ~H"""
    <output class="lg:w-1/4 lg:order-1 font-medium text-md text-gray-600 dark:text-gray-200">
      <span :if={@volume != :enterprise}>Up to</span>
      <strong id="slider-value" class="text-gray-900 dark:text-gray-100">
        {format_volume(@volume, @available_volumes)}
      </strong>
      monthly pageviews
    </output>
    """
  end

  defp slider_input(assigns) do
    slider_labels =
      Enum.map(
        assigns.available_volumes ++ [:enterprise],
        &format_volume(&1, assigns.available_volumes)
      )

    assigns = assign(assigns, :slider_labels, slider_labels)

    ~H"""
    <form class="max-w-md lg:max-w-none w-full lg:w-1/2 lg:order-2">
      <div class="flex items-baseline space-x-2">
        <span class="text-xs font-medium text-gray-600 dark:text-gray-200">
          {List.first(@slider_labels)}
        </span>
        <div class="flex-1 relative">
          <input
            phx-change="slide"
            id="slider"
            name="slider"
            class="shadow dark:bg-gray-600 dark:border-none"
            type="range"
            min="0"
            max={length(@available_volumes)}
            step="1"
            value={
              Enum.find_index(@available_volumes, &(&1 == @selected_volume)) ||
                length(@available_volumes)
            }
            oninput="repositionBubble()"
          />
          <output
            id="slider-bubble"
            class="absolute bottom-[35px] py-[4px] px-[12px] -translate-x-1/2 rounded-md text-white bg-indigo-600 position text-xs font-medium"
            phx-update="ignore"
          />
        </div>
        <span class="text-xs font-medium text-gray-600 dark:text-gray-200">
          {List.last(@slider_labels)}
        </span>
      </div>
    </form>

    <script>
      const SLIDER_LABELS = <%= Phoenix.HTML.raw Jason.encode!(@slider_labels) %>

      function repositionBubble() {
        const input = document.getElementById("slider")
        const percentage = Number((input.value / input.max) * 100)
        const bubble = document.getElementById("slider-bubble")

        bubble.innerHTML = SLIDER_LABELS[input.value]
        bubble.style.left = `calc(${percentage}% + (${13.87 - percentage * 0.26}px))`
      }

      repositionBubble()
    </script>
    """
  end

  defp format_volume(volume, available_volumes) do
    if volume == :enterprise do
      available_volumes
      |> List.last()
      |> PlausibleWeb.StatsView.large_number_format()
      |> Kernel.<>("+")
    else
      PlausibleWeb.StatsView.large_number_format(volume)
    end
  end

  defp slider_styles(assigns) do
    ~H"""
    <style>
      input[type="range"] {
        vertical-align: middle;
        -moz-appearance: none;
        -webkit-appearance: none;
        background: white;
        border-radius: 3px;
        height: 6px;
        width: 100%;
        margin-top: 15px;
        margin-bottom: 15px;
        outline: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        appearance: none;
        -webkit-appearance: none;
        background-color: #5f48ff;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20width%3D%2212%22%20height%3D%228%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M8%20.5v7L12%204zM0%204l4%203.5v-7z%22%20fill%3D%22%23FFFFFF%22%20fill-rule%3D%22nonzero%22%2F%3E%3C%2Fsvg%3E");
        background-position: center;
        background-repeat: no-repeat;
        border: 0;
        border-radius: 50%;
        cursor: pointer;
        height: 26px;
        width: 26px;
      }

      input[type="range"]::-moz-range-thumb {
        background-color: #5f48ff;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20width%3D%2212%22%20height%3D%228%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M8%20.5v7L12%204zM0%204l4%203.5v-7z%22%20fill%3D%22%23FFFFFF%22%20fill-rule%3D%22nonzero%22%2F%3E%3C%2Fsvg%3E");
        background-position: center;
        background-repeat: no-repeat;
        border: 0;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        height: 26px;
        width: 26px;
      }

      input[type="range"]::-ms-thumb {
        background-color: #5f48ff;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20width%3D%2212%22%20height%3D%228%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M8%20.5v7L12%204zM0%204l4%203.5v-7z%22%20fill%3D%22%23FFFFFF%22%20fill-rule%3D%22nonzero%22%2F%3E%3C%2Fsvg%3E");
        background-position: center;
        background-repeat: no-repeat;
        border: 0;
        border-radius: 50%;
        cursor: pointer;
        height: 26px;
        width: 26px;
      }

      input[type="range"]::-moz-focus-outer {
        border: 0;
      }
    </style>
    """
  end
end
```

## File: `lib/plausible_web/components/billing/plan_benefits.ex`
```
defmodule PlausibleWeb.Components.Billing.PlanBenefits do
  @moduledoc """
  This module exposes functions for rendering and returning plan
  benefits for Growth, Business, and Enterprise plans.
  """

  use Phoenix.Component

  attr :benefits, :list, required: true
  attr :class, :string, default: nil

  @doc """
  This function takes a list of benefits returned by either one of:

  * `Plausible.Billing.PlanBenefits.for_starter/1`
  * `Plausible.Billing.PlanBenefits.for_growth/2`
  * `Plausible.Billing.PlanBenefits.for_business/3`
  * `Plausible.Billing.PlanBenefits.for_enterprise/1`.

  and renders them as HTML.

  The benefits in the given list can be either strings or functions
  returning a Phoenix component. This allows, for example, to render
  links within the plan benefit text.
  """
  def render(assigns) do
    ~H"""
    <ul role="list" class={["mt-8 space-y-1 text-sm leading-6", @class]}>
      <li :for={benefit <- @benefits} class="flex gap-x-1">
        <Heroicons.check class="shrink-0 h-5 w-5 text-indigo-600 dark:text-green-600" />
        <%= if benefit == "Sites API" do %>
          <.sites_api_benefit />
        <% else %>
          {benefit}
        <% end %>
      </li>
    </ul>
    """
  end

  defp sites_api_benefit(assigns) do
    ~H"""
    <p>
      Sites API access for
      <.link
        class="text-indigo-500 hover:underline"
        href="https://plausible.io/white-label-web-analytics"
      >
        reselling
      </.link>
    </p>
    """
  end
end
```

## File: `lib/plausible_web/components/billing/plan_box.ex`
```
defmodule PlausibleWeb.Components.Billing.PlanBox do
  @moduledoc false

  use PlausibleWeb, :component

  require Plausible.Billing.Subscription.Status
  alias PlausibleWeb.Components.Billing.{PlanBenefits}
  alias Plausible.Billing.{Plan, Quota, Subscription}

  @plan_box_price_container_class "relative h-20 pt-4 max-h-20 whitespace-nowrap overflow-hidden"

  def standard(assigns) do
    highlight =
      cond do
        assigns.owned && assigns.recommended -> "Current"
        assigns.recommended -> "Recommended"
        true -> nil
      end

    assigns =
      assigns
      |> assign(:highlight, highlight)
      |> assign(:price_container_class, @plan_box_price_container_class)

    ~H"""
    <div
      id={"#{@kind}-plan-box"}
      class={[
        "shadow-lg border border-gray-200 dark:border-none bg-white rounded-xl px-6 sm:px-4 py-4 sm:py-3 dark:bg-gray-800",
        !@highlight && "dark:ring-gray-600",
        @highlight && "ring-2 ring-indigo-600 dark:ring-indigo-300"
      ]}
    >
      <div class="flex items-center justify-between gap-x-4">
        <h3 class={[
          "text-lg font-semibold leading-8",
          !@highlight && "text-gray-900 dark:text-gray-100",
          @highlight && "text-indigo-600 dark:text-indigo-300"
        ]}>
          {String.capitalize(to_string(@kind))}
        </h3>
        <.pill :if={@highlight} text={@highlight} />
      </div>
      <div>
        <div class={@price_container_class}>
          <.render_price_info available={@available} {assigns} />
        </div>
        <%= if @available do %>
          <.checkout id={"#{@kind}-checkout"} {assigns} />
        <% else %>
          <.contact_button class="bg-indigo-600 hover:bg-indigo-500 text-white" />
        <% end %>
      </div>
      <PlanBenefits.render benefits={@benefits} class="text-gray-600 dark:text-gray-100" />
    </div>
    """
  end

  def enterprise(assigns) do
    assigns = assign(assigns, :price_container_class, @plan_box_price_container_class)

    ~H"""
    <div
      id="enterprise-plan-box"
      class={[
        "rounded-xl px-6 sm:px-4 py-4 sm:py-3 bg-gray-900 shadow-xl dark:bg-gray-800",
        !@recommended && "dark:ring-gray-600",
        @recommended && "ring-4 ring-indigo-500 dark:ring-2 dark:ring-indigo-300"
      ]}
    >
      <div class="flex items-center justify-between gap-x-4">
        <h3 class={[
          "text-lg font-semibold leading-8",
          !@recommended && "text-white dark:text-gray-100",
          @recommended && "text-indigo-400 dark:text-indigo-300"
        ]}>
          Enterprise
        </h3>
        <span
          :if={@recommended}
          id="enterprise-highlight-pill"
          class="rounded-full ring-1 ring-indigo-500 px-2.5 py-1 text-xs font-semibold leading-5 text-indigo-400 dark:text-indigo-300 dark:ring-1 dark:ring-indigo-300/50"
        >
          Recommended
        </span>
      </div>
      <div class={@price_container_class}>
        <span class="text-3xl lg:text-2xl xl:text-3xl font-bold tracking-tight text-white dark:text-gray-100">
          Custom
        </span>
      </div>
      <.contact_button class="" />
      <PlanBenefits.render benefits={@benefits} class="text-gray-300 dark:text-gray-100" />
    </div>
    """
  end

  defp pill(assigns) do
    ~H"""
    <div class="flex items-center justify-between gap-x-4">
      <p
        id="highlight-pill"
        class="rounded-full bg-indigo-600/10 px-2.5 py-1 text-xs font-semibold leading-5 text-indigo-600 dark:text-indigo-300 dark:ring-1 dark:ring-indigo-300/50"
      >
        {@text}
      </p>
    </div>
    """
  end

  defp render_price_info(%{available: false} = assigns) do
    ~H"""
    <p id={"#{@kind}-custom-price"} class="flex items-baseline gap-x-1">
      <span class="text-3xl font-bold tracking-tight text-gray-900 dark:text-white">
        Custom
      </span>
    </p>
    <p class="h-4 mt-1"></p>
    """
  end

  defp render_price_info(assigns) do
    ~H"""
    <.price_tag kind={@kind} selected_interval={@selected_interval} plan_to_render={@plan_to_render} />
    <div
      id={"#{@kind}-vat-notice"}
      class="absolute top-[32px] sm:top-[29px] md:top-[32px] lg:top-[29px] xl:top-[32px] right-0 text-xs text-gray-500"
    >
      + VAT
      <span class="hidden sm:inline lg:hidden xl:inline">
        if applicable
      </span>
    </div>
    """
  end

  defp price_tag(%{selected_interval: :monthly} = assigns) do
    monthly_cost =
      case assigns.plan_to_render do
        %{monthly_cost: nil} -> "N/A"
        %{monthly_cost: monthly_cost} -> Plausible.Billing.format_price(monthly_cost)
      end

    assigns = assign(assigns, :monthly_cost, monthly_cost)

    ~H"""
    <p class="flex items-baseline gap-x-1">
      <span
        id={"#{@kind}-price-tag-amount"}
        class="text-3xl lg:text-2xl xl:text-3xl font-bold tracking-tight text-gray-900 dark:text-gray-100"
      >
        {@monthly_cost}
      </span>
      <span
        id={"#{@kind}-price-tag-interval"}
        class="text-sm font-semibold leading-6 text-gray-600 dark:text-gray-500"
      >
        /month
      </span>
    </p>
    """
  end

  defp price_tag(%{selected_interval: :yearly} = assigns) do
    monthly_cost =
      case assigns.plan_to_render do
        %{monthly_cost: nil} -> "N/A"
        %{monthly_cost: monthly_cost} -> Plausible.Billing.format_price(monthly_cost)
      end

    {yearly_cost, monthly_cost_with_discount} =
      case assigns.plan_to_render do
        %{yearly_cost: nil} ->
          {"N/A", "N/A"}

        %{yearly_cost: yearly_cost} ->
          {
            Plausible.Billing.format_price(yearly_cost),
            Plausible.Billing.format_price(Money.div!(yearly_cost, 12))
          }
      end

    assigns =
      assigns
      |> assign(:monthly_cost, monthly_cost)
      |> assign(:yearly_cost, yearly_cost)
      |> assign(:monthly_cost_with_discount, monthly_cost_with_discount)

    ~H"""
    <div class="grid grid-cols-[max-content_1fr]">
      <span
        id={"#{@kind}-price-tag-amount"}
        class="text-3xl lg:text-2xl xl:text-3xl font-bold tracking-tight text-gray-900 dark:text-gray-100"
      >
        {@yearly_cost}
      </span>

      <span
        id={"#{@kind}-price-tag-interval"}
        class="text-sm font-semibold leading-6 text-gray-600 pl-1 self-end"
      >
        /year
      </span>

      <div class="font-bold tracking-tight text-sm self-center">
        <span
          id={"#{@kind}-discount-price-tag-strikethrough-amount"}
          class="line-through tracking-tight text-gray-500 dark:text-gray-600"
        >
          {@monthly_cost}
        </span>
        <span id={"#{@kind}-discount-price-tag-amount"} class="ml-1 text-gray-900 dark:text-gray-100">
          {@monthly_cost_with_discount}
        </span>
      </div>

      <span class="text-sm font-semibold text-gray-600 pl-1 self-center">
        /month
      </span>
    </div>
    """
  end

  defp checkout(assigns) do
    paddle_product_id = get_paddle_product_id(assigns.plan_to_render, assigns.selected_interval)
    change_plan_link_text = change_plan_link_text(assigns)

    subscription =
      Plausible.Teams.Billing.get_subscription(assigns.current_team)

    billing_details_expired =
      Subscription.Status.in?(subscription, [
        Subscription.Status.paused(),
        Subscription.Status.past_due()
      ])

    subscription_deleted = Subscription.Status.deleted?(subscription)
    usage_check = check_usage_within_plan_limits(assigns)

    {checkout_disabled, disabled_message} =
      cond do
        not Quota.eligible_for_upgrade?(assigns.usage) ->
          {true, nil}

        change_plan_link_text == "Currently on this plan" && not subscription_deleted ->
          {true, nil}

        usage_check != :ok ->
          {true, "Your usage exceeds this plan"}

        billing_details_expired ->
          {true, "Please update your billing details first"}

        true ->
          {false, nil}
      end

    exceeded_plan_limits =
      case usage_check do
        {:error, {:over_plan_limits, limits}} ->
          limits

        _ ->
          []
      end

    feature_usage_check = Quota.ensure_feature_access(assigns.usage, assigns.plan_to_render)

    assigns =
      assigns
      |> assign(:paddle_product_id, paddle_product_id)
      |> assign(:change_plan_link_text, change_plan_link_text)
      |> assign(:checkout_disabled, checkout_disabled)
      |> assign(:disabled_message, disabled_message)
      |> assign(:exceeded_plan_limits, exceeded_plan_limits)
      |> assign(:confirm_message, losing_features_message(feature_usage_check))

    ~H"""
    <%= if @owned_plan && Plausible.Billing.Subscriptions.resumable?(@current_team.subscription) do %>
      <.change_plan_link {assigns} />
    <% else %>
      <PlausibleWeb.Components.Billing.paddle_button
        user={@current_user}
        team={@current_team}
        {assigns}
      >
        Upgrade
      </PlausibleWeb.Components.Billing.paddle_button>
    <% end %>
    <div :if={@exceeded_plan_limits != [] && @disabled_message} class="flex flex-col items-center">
      <.tooltip>
        <div class="h-0 text-sm">
          <div class="flex items-center text-red-700 dark:text-red-500 justify-center">
            {@disabled_message}
            <Heroicons.information_circle class="hidden sm:block w-5 h-5 sm:ml-2" />
          </div>
        </div>
        <:tooltip_content>
          Your usage exceeds the following limit(s):<br /><br />
          <p :for={limit <- @exceeded_plan_limits}>
            {Phoenix.Naming.humanize(limit)}<br />
          </p>
        </:tooltip_content>
      </.tooltip>
    </div>
    <div
      :if={@disabled_message && @exceeded_plan_limits == []}
      class="pt-2 text-sm w-full text-red-700 dark:text-red-500 text-center"
    >
      {@disabled_message}
    </div>
    """
  end

  defp check_usage_within_plan_limits(%{available: false}) do
    {:error, :plan_unavailable}
  end

  defp check_usage_within_plan_limits(%{
         available: true,
         usage: usage,
         current_team: current_team,
         plan_to_render: plan
       }) do
    # At this point, the user is *not guaranteed* to have a team,
    # with ongoing trial.
    trial_active_or_ended_recently? =
      not is_nil(current_team) and not is_nil(current_team.trial_expiry_date) and
        Plausible.Teams.trial_days_left(current_team) >= -10

    limit_checking_opts =
      cond do
        current_team && current_team.allow_next_upgrade_override ->
          [ignore_pageview_limit: true]

        trial_active_or_ended_recently? && plan.volume == "10k" ->
          [pageview_allowance_margin: 0.3]

        trial_active_or_ended_recently? ->
          [pageview_allowance_margin: 0.15]

        true ->
          []
      end

    Quota.ensure_within_plan_limits(usage, plan, limit_checking_opts)
  end

  defp get_paddle_product_id(%Plan{monthly_product_id: plan_id}, :monthly), do: plan_id
  defp get_paddle_product_id(%Plan{yearly_product_id: plan_id}, :yearly), do: plan_id

  defp change_plan_link_text(
         %{
           owned_plan: %Plan{kind: from_kind, monthly_pageview_limit: from_volume},
           plan_to_render: %Plan{kind: to_kind, monthly_pageview_limit: to_volume},
           current_interval: from_interval,
           selected_interval: to_interval
         } = _assigns
       ) do
    cond do
      from_kind in [:growth, :business] && to_kind == :starter ->
        "Downgrade to Starter"

      from_kind == :business && to_kind == :growth ->
        "Downgrade to Growth"

      from_kind == :starter && to_kind == :growth ->
        "Upgrade to Growth"

      from_kind in [:starter, :growth] && to_kind == :business ->
        "Upgrade to Business"

      from_volume == to_volume && from_interval == to_interval ->
        "Currently on this plan"

      from_volume == to_volume ->
        "Change billing interval"

      from_volume > to_volume ->
        "Downgrade"

      true ->
        "Upgrade"
    end
  end

  defp change_plan_link_text(_), do: nil

  defp change_plan_link(assigns) do
    confirmed =
      if assigns.confirm_message, do: "confirm(\"#{assigns.confirm_message}\")", else: "true"

    assigns = assign(assigns, :confirmed, confirmed)

    ~H"""
    <button
      id={"#{@kind}-checkout"}
      onclick={"if (#{@confirmed}) {window.location = '#{Routes.billing_path(PlausibleWeb.Endpoint, :change_plan_preview, @paddle_product_id)}'}"}
      class={[
        "w-full mt-6 block rounded-md py-2 px-3 text-center text-sm font-semibold leading-6 text-white",
        !@checkout_disabled && "bg-indigo-600 hover:bg-indigo-500",
        @checkout_disabled && "pointer-events-none bg-gray-400 dark:bg-gray-600"
      ]}
    >
      {@change_plan_link_text}
    </button>
    """
  end

  defp losing_features_message(:ok), do: nil

  defp losing_features_message({:error, {:unavailable_features, features}}) do
    features_list_str =
      features
      |> Enum.map(fn feature_mod -> feature_mod.display_name() end)
      |> PlausibleWeb.TextHelpers.pretty_join()

    "This plan does not support #{features_list_str}, which you have been using. By subscribing to this plan, you will not have access to #{if length(features) == 1, do: "this feature", else: "these features"}."
  end

  defp contact_button(assigns) do
    ~H"""
    <.link
      href="https://plausible.io/contact"
      class={[
        "mt-6 block rounded-md py-2 px-3 text-center text-sm font-semibold leading-6 bg-gray-800 hover:bg-gray-700 text-white dark:bg-indigo-600 dark:hover:bg-indigo-500",
        @class
      ]}
    >
      Contact us
    </.link>
    """
  end
end
```

## File: `lib/plausible_web/components/first_dashboard_launch_banner.ex`
```
defmodule PlausibleWeb.Components.FirstDashboardLaunchBanner do
  @moduledoc """
  A banner that appears on the first dashboard launch
  """

  use PlausibleWeb, :component

  attr(:site, Plausible.Site, required: true)

  def set(assigns) do
    ~H"""
    <script>
      sessionStorage.setItem('<%= storage_key(@site) %>', false);
    </script>
    """
  end

  attr(:site, Plausible.Site, required: true)

  def render(assigns) do
    ~H"""
    <div
      x-cloak
      x-data={x_data(@site)}
      class="w-full px-4 text-sm font-bold text-center text-blue-900 bg-blue-200 rounded transition"
      style="top: 91px"
      role="alert"
      x-bind:class="! show ? 'hidden' : ''"
      x-init={x_init(@site)}
    >
      <.styled_link href={"/#{URI.encode_www_form(@site.domain)}/settings/email-reports"}>
        Invite guests, enable email reports, import from GA and more →
      </.styled_link>
    </div>
    """
  end

  defp x_data(site) do
    "{show: !!sessionStorage.getItem('#{storage_key(site)}')}"
  end

  defp x_init(site) do
    "setTimeout(() => sessionStorage.removeItem('#{storage_key(site)}'), 3000)"
  end

  defp storage_key(site) do
    "dashboard_seen_#{site.domain}"
  end
end
```

## File: `lib/plausible_web/components/flow_progress.ex`
```
defmodule PlausibleWeb.Components.FlowProgress do
  @moduledoc """
  Component for provisioning/registration flows displaying
  progress status. See `PlausibleWeb.Flows` for the list of
  flow definitions.
  """
  use Phoenix.Component

  attr :flow, :string, required: true, values: PlausibleWeb.Flows.valid_keys()
  attr :current_step, :string, required: true, values: PlausibleWeb.Flows.valid_values()

  def render(assigns) do
    steps = PlausibleWeb.Flows.steps(assigns.flow)
    current_step_idx = Enum.find_index(steps, &(&1 == assigns.current_step))

    assigns =
      assign(assigns,
        steps: steps,
        current_step_idx: current_step_idx
      )

    ~H"""
    <div :if={not Enum.empty?(@steps)} class="mt-6 hidden md:block" id="flow-progress">
      <div class="flex items-center justify-between max-w-4xl mx-auto my-8">
        <%= for {step, idx} <- Enum.with_index(@steps) do %>
          <div class="flex items-center text-base">
            <div
              :if={idx < @current_step_idx}
              class="w-5 h-5 bg-green-500 dark:bg-green-600 text-white rounded-full flex items-center justify-center"
            >
              <Heroicons.check class="w-4 h-4" />
            </div>
            <div
              :if={idx == @current_step_idx}
              class="w-5 h-5 bg-indigo-600 text-white rounded-full flex items-center justify-center font-semibold"
            >
              {idx + 1}
            </div>
            <div
              :if={idx > @current_step_idx}
              class="w-5 h-5 bg-gray-300 text-white dark:bg-gray-800 rounded-full flex items-center justify-center"
            >
              {idx + 1}
            </div>
            <span :if={idx < @current_step_idx} class="ml-2 text-gray-500">
              {step}
            </span>
            <span
              :if={idx == @current_step_idx}
              class="ml-2 font-semibold text-black dark:text-gray-300"
            >
              {step}
            </span>
            <span :if={idx > @current_step_idx} class="ml-2 text-gray-500">
              {step}
            </span>
          </div>
          <div :if={idx + 1 != length(@steps)} class="flex-1 h-px bg-gray-300 mx-4 dark:bg-gray-800 ">
          </div>
        <% end %>
      </div>
    </div>
    """
  end
end
```

## File: `lib/plausible_web/components/generic.ex`
```
defmodule PlausibleWeb.Components.Generic do
  @moduledoc """
  Generic reusable components
  """
  use Phoenix.Component, global_prefixes: ~w(x-)

  @notice_themes %{
    gray: %{
      bg: "bg-white dark:bg-gray-800",
      icon: "text-gray-400",
      title_text: "text-gray-800 dark:text-gray-400",
      body_text: "text-gray-700 dark:text-gray-500 leading-5"
    },
    yellow: %{
      bg: "bg-yellow-50 dark:bg-yellow-100",
      icon: "text-yellow-400",
      title_text: "text-sm text-yellow-800 dark:text-yellow-900",
      body_text: "text-sm text-yellow-700 dark:text-yellow-800 leading-5"
    },
    red: %{
      bg: "bg-red-100",
      icon: "text-red-700",
      title_text: "text-sm text-red-800 dark:text-red-900",
      body_text: "text-sm text-red-700 dark:text-red-800"
    }
  }

  @button_themes %{
    "primary" => "bg-indigo-600 text-white hover:bg-indigo-700 focus-visible:outline-indigo-600",
    "bright" =>
      "border border-gray-200 bg-gray-100 dark:bg-gray-300 text-gray-800 hover:bg-gray-200 focus-visible:outline-gray-100",
    "danger" =>
      "border border-gray-300 dark:border-gray-500 text-red-700 bg-white dark:bg-gray-900 hover:text-red-500 dark:hover:text-red-400 focus:border-blue-300 dark:text-red-500 active:text-red-800"
  }

  @button_base_class "whitespace-nowrap truncate inline-flex items-center justify-center gap-x-2 font-medium rounded-md px-3.5 py-2.5 text-sm shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 disabled:bg-gray-400 dark:disabled:text-white dark:disabled:text-gray-400 dark:disabled:bg-gray-700"

  attr(:type, :string, default: "button")
  attr(:theme, :string, default: "primary")
  attr(:class, :string, default: "")
  attr(:disabled, :boolean, default: false)
  attr(:mt?, :boolean, default: true)
  attr(:rest, :global, include: ~w(name))

  slot(:inner_block)

  def button(assigns) do
    assigns =
      assign(assigns,
        button_base_class: @button_base_class,
        theme_class: @button_themes[assigns.theme]
      )

    ~H"""
    <button
      type={@type}
      disabled={@disabled}
      class={[
        @mt? && "mt-6",
        @button_base_class,
        @theme_class,
        @class
      ]}
      {@rest}
    >
      {render_slot(@inner_block)}
    </button>
    """
  end

  attr(:href, :string, required: true)
  attr(:class, :string, default: "")
  attr(:theme, :string, default: "primary")
  attr(:disabled, :boolean, default: false)
  attr(:method, :string, default: "get")
  attr(:mt?, :boolean, default: true)
  attr(:rest, :global)

  slot(:inner_block)

  def button_link(assigns) do
    extra =
      if assigns.method == "get" do
        []
      else
        [
          "data-csrf": Phoenix.Controller.get_csrf_token(),
          "data-method": assigns.method,
          "data-to": assigns.href
        ]
      end

    assigns = assign(assigns, extra: extra)

    theme_class =
      if assigns.disabled do
        "bg-gray-400 text-white dark:text-white dark:text-gray-400 dark:bg-gray-700 cursor-not-allowed"
      else
        @button_themes[assigns.theme]
      end

    onclick =
      if assigns.disabled do
        "return false;"
      else
        assigns[:onclick]
      end

    assigns =
      assign(assigns,
        onclick: onclick,
        button_base_class: @button_base_class,
        theme_class: theme_class
      )

    ~H"""
    <.link
      href={@href}
      onclick={@onclick}
      class={[
        @mt? && "mt-6",
        @button_base_class,
        @theme_class,
        @class
      ]}
      {@extra}
      {@rest}
    >
      {render_slot(@inner_block)}
    </.link>
    """
  end

  attr(:slug, :string, required: true)
  attr(:class, :string, default: nil)

  def docs_info(assigns) do
    ~H"""
    <a href={"https://plausible.io/docs/#{@slug}"} rel="noopener noreferrer" target="_blank">
      <Heroicons.information_circle class={[
        "text-gray-500 dark:text-indigo-500 w-6 h-6 stroke-2 hover:text-indigo-500 dark:hover:text-indigo-300",
        @class
      ]} />
    </a>
    """
  end

  attr(:title, :any, default: nil)
  attr(:theme, :atom, default: :yellow)
  attr(:dismissable_id, :any, default: nil)
  attr(:class, :string, default: "")
  attr(:rest, :global)
  slot(:inner_block)

  def notice(assigns) do
    assigns = assign(assigns, :theme, Map.fetch!(@notice_themes, assigns.theme))

    ~H"""
    <div id={@dismissable_id} class={[@dismissable_id && "hidden"]}>
      <div class={["rounded-md p-4 relative", @theme.bg, @class]} {@rest}>
        <button
          :if={@dismissable_id}
          class={"absolute right-0 top-0 m-2 #{@theme.title_text}"}
          onclick={"localStorage['notice_dismissed__#{@dismissable_id}'] = 'true'; document.getElementById('#{@dismissable_id}').classList.add('hidden')"}
        >
          <Heroicons.x_mark class="h-4 w-4 hover:stroke-2" />
        </button>
        <div class="flex">
          <div :if={@title} class="flex-shrink-0">
            <svg
              class={"h-5 w-5 #{@theme.icon}"}
              viewBox="0 0 20 20"
              fill="currentColor"
              aria-hidden="true"
            >
              <path
                fill-rule="evenodd"
                d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495zM10 5a.75.75 0 01.75.75v3.5a.75.75 0 01-1.5 0v-3.5A.75.75 0 0110 5zm0 9a1 1 0 100-2 1 1 0 000 2z"
                clip-rule="evenodd"
              />
            </svg>
          </div>
          <div class={["w-full", @title && "ml-3"]}>
            <h3 :if={@title} class={"font-medium #{@theme.title_text} mb-2"}>
              {@title}
            </h3>
            <div class={"#{@theme.body_text}"}>
              <p>
                {render_slot(@inner_block)}
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script :if={@dismissable_id} data-key={@dismissable_id}>
      const dismissId = document.currentScript.dataset.key
      const localStorageKey = `notice_dismissed__${dismissId}`

      if (localStorage[localStorageKey] !== 'true') {
        document.getElementById(dismissId).classList.remove('hidden')
      }
    </script>
    """
  end

  attr(:href, :string, default: "#")
  attr(:new_tab, :boolean, default: false)
  attr(:class, :string, default: "")
  attr(:rest, :global, include: ~w(patch))
  attr(:method, :string, default: "get")
  slot(:inner_block)

  def styled_link(assigns) do
    ~H"""
    <.unstyled_link
      new_tab={@new_tab}
      href={@href}
      method={@method}
      class={"text-indigo-600 hover:text-indigo-700 dark:text-indigo-500 dark:hover:text-indigo-600 " <> @class}
      {@rest}
    >
      {render_slot(@inner_block)}
    </.unstyled_link>
    """
  end

  attr :class, :string, default: ""
  attr :id, :string, default: nil

  slot :button, required: true do
    attr(:class, :string)
  end

  slot :menu, required: true do
    attr(:class, :string)
  end

  def dropdown(assigns) do
    assigns = assign(assigns, :menu_class, assigns.menu |> List.first() |> Map.get(:class, ""))

    ~H"""
    <div
      id={@id}
      x-data="dropdown"
      x-on:keydown.escape.prevent.stop="close($refs.button)"
      class="relative inline-block text-left"
    >
      <button
        x-ref="button"
        x-on:click="toggle()"
        type="button"
        class={["py-2.5", List.first(@button).class]}
      >
        {render_slot(List.first(@button))}
      </button>
      <div
        x-show="open"
        x-cloak
        x-transition:enter="transition ease-out duration-100"
        x-transition:enter-start="opacity-0 scale-95"
        x-transition:enter-end="opacity-100 scale-100"
        x-transition:leave="transition ease-in duration-75"
        x-transition:leave-start="opacity-100 scale-100"
        x-transition:leave-end="opacity-0 scale-95"
        x-on:click.outside="close($refs.button)"
        style="display: none;"
        class={[
          "origin-top-right absolute z-50 right-0 mt-2 p-1.5 w-max rounded-md shadow-lg overflow-hidden bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none",
          @menu_class
        ]}
      >
        {render_slot(List.first(@menu))}
      </div>
    </div>
    """
  end

  attr(:href, :string)
  attr(:class, :string, default: "")
  attr(:id, :string, default: nil)
  attr(:new_tab, :boolean, default: false)
  attr(:disabled, :boolean, default: false)
  attr(:rest, :global, include: ~w(method))
  slot(:inner_block, required: true)

  @base_class "block rounded-lg text-sm/6 text-gray-900 ui-disabled:text-gray-500 dark:text-gray-100 dark:ui-disabled:text-gray-400 px-3.5 py-1.5"
  @clickable_class "hover:bg-gray-100 dark:hover:bg-gray-700"
  def dropdown_item(assigns) do
    assigns =
      if assigns[:disabled] do
        assign(assigns, :state, "disabled")
      else
        assign(assigns, :state, "")
      end

    if assigns[:href] && !assigns[:disabled] do
      assigns = assign(assigns, :class, [assigns[:class], @base_class, @clickable_class])

      ~H"""
      <.unstyled_link
        id={@id}
        class={@class}
        new_tab={@new_tab}
        href={@href}
        x-on:click="close()"
        data-ui-state={@state}
        {@rest}
      >
        {render_slot(@inner_block)}
      </.unstyled_link>
      """
    else
      assigns = assign(assigns, :class, [assigns[:class], @base_class])

      ~H"""
      <div data-ui-state={@state} class={@class}>
        {render_slot(@inner_block)}
      </div>
      """
    end
  end

  def dropdown_divider(assigns) do
    ~H"""
    <div class="mx-3.5 my-1 h-px border-0 bg-gray-950/5 sm:mx-3 dark:bg-white/10" role="separator">
    </div>
    """
  end

  attr(:href, :string, required: true)
  attr(:new_tab, :boolean, default: false)
  attr(:class, :string, default: nil)
  attr(:rest, :global)
  attr(:method, :string, default: "get")
  slot(:inner_block)

  def unstyled_link(assigns) do
    extra =
      if assigns.method == "get" do
        []
      else
        [
          "data-csrf": Phoenix.Controller.get_csrf_token(),
          "data-method": assigns.method,
          "data-to": assigns.href
        ]
      end

    assigns = assign(assigns, extra: extra)

    if assigns[:new_tab] do
      assigns = assign(assigns, :icon_class, icon_class(assigns))

      ~H"""
      <.link
        class={[
          "inline-flex items-center gap-x-0.5",
          @class
        ]}
        href={@href}
        target="_blank"
        rel="noopener noreferrer"
        {@extra}
        {@rest}
      >
        {render_slot(@inner_block)}
        <Heroicons.arrow_top_right_on_square class={["opacity-60", @icon_class]} />
      </.link>
      """
    else
      ~H"""
      <.link class={@class} href={@href} {@extra} {@rest}>{render_slot(@inner_block)}</.link>
      """
    end
  end

  attr(:class, :any, default: "")
  attr(:rest, :global)

  def spinner(assigns) do
    ~H"""
    <svg
      class={["animate-spin h-4 w-4 text-indigo-500", @class]}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      {@rest}
    >
      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4">
      </circle>
      <path
        className="opacity-75"
        fill="currentColor"
        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
      >
      </path>
    </svg>
    """
  end

  attr :id, :string, required: true
  attr :js_active_var, :string, required: true
  attr :id_suffix, :string, default: ""
  attr :disabled, :boolean, default: false

  attr(:rest, :global)

  def toggle_switch(assigns) do
    ~H"""
    <button
      id={"#{@id}-#{@id_suffix}"}
      class={["h-6", if(@disabled, do: "cursor-not-allowed", else: "cursor-pointer")]}
      aria-labelledby={@id}
      role="switch"
      type="button"
      x-on:click={"#{@js_active_var} = !#{@js_active_var}"}
      x-bind:aria-checked={@js_active_var}
      disabled={@disabled}
      {@rest}
    >
      <span
        class="relative inline-flex h-6 w-11 flex-shrink-0 rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2"
        x-bind:class={"#{@js_active_var} ? 'bg-indigo-600' : 'dark:bg-gray-700 bg-gray-200'"}
      >
        <span
          aria-hidden="true"
          class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out"
          x-bind:class={"#{@js_active_var} ? 'dark:bg-gray-800 translate-x-5' : 'dark:bg-gray-800 translate-x-0'"}
        />
      </span>
    </button>
    """
  end

  def settings_tiles(assigns) do
    ~H"""
    <div class="text-gray-900 leading-5 dark:text-gray-100">
      {render_slot(@inner_block)}
    </div>
    """
  end

  attr :docs, :string, default: nil
  slot :inner_block, required: true
  slot :title, required: true
  slot :subtitle, required: true
  attr :feature_mod, :atom, default: nil
  attr :feature_toggle?, :boolean, default: false
  attr :current_role, :atom, default: nil
  attr :current_team, :any, default: nil
  attr :site, :any
  attr :conn, :any

  def tile(assigns) do
    ~H"""
    <div class="shadow bg-white dark:bg-gray-800 rounded-md mb-6">
      <header class="relative py-4 px-6">
        <.title>
          {render_slot(@title)}

          <.docs_info :if={@docs} slug={@docs} class="absolute top-4 right-4" />
        </.title>
        <div class="text-sm mt-px text-gray-500 dark:text-gray-400 leading-5">
          {render_slot(@subtitle)}
        </div>
        <PlausibleWeb.Components.Site.Feature.toggle
          :if={@feature_toggle?}
          feature_mod={@feature_mod}
          site={@site}
          conn={@conn}
        />
      </header>
      <div class="border-b dark:border-gray-700 mx-6"></div>
      <div class="relative">
        <%= if @feature_mod do %>
          <PlausibleWeb.Components.Billing.feature_gate
            locked?={@feature_mod.check_availability(@current_team) != :ok}
            current_role={@current_role}
            current_team={@current_team}
          >
            <div class="py-4 px-6">
              {render_slot(@inner_block)}
            </div>
          </PlausibleWeb.Components.Billing.feature_gate>
        <% else %>
          <div class="py-4 px-6">
            {render_slot(@inner_block)}
          </div>
        <% end %>
      </div>
    </div>
    """
  end

  attr(:sticky?, :boolean, default: true)
  attr(:enabled?, :boolean, default: true)
  slot(:inner_block, required: true)
  slot(:tooltip_content, required: true)

  def tooltip(assigns) do
    wrapper_data =
      if assigns[:sticky?], do: "{sticky: false, hovered: false}", else: "{hovered: false}"

    show_inner = if assigns[:sticky?], do: "hovered || sticky", else: "hovered"

    assigns = assign(assigns, wrapper_data: wrapper_data, show_inner: show_inner)

    if assigns.enabled? do
      ~H"""
      <div
        x-data={@wrapper_data}
        x-on:mouseenter="hovered = true"
        x-on:mouseleave="hovered = false"
        class={["w-max relative z-[1000]"]}
      >
        <div
          x-cloak
          x-show={@show_inner}
          class={["tooltip-content absolute pb-2 top-0 -translate-y-full z-[1000] sm:w-72"]}
          x-transition:enter="transition ease-out duration-200"
          x-transition:enter-start="opacity-0"
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-150"
          x-transition:leave-start="opacity-100"
          x-transition:leave-end="opacity-0"
        >
          <div class="bg-gray-900 text-white rounded p-4 text-sm font-medium">
            {render_slot(@tooltip_content)}
          </div>
        </div>
        <div x-on:click="sticky = true; hovered = true" x-on:click.outside="sticky = false">
          {render_slot(@inner_block)}
        </div>
      </div>
      """
    else
      ~H"{render_slot(@inner_block)}"
    end
  end

  slot :inner_block, required: true

  def accordion_menu(assigns) do
    ~H"""
    <dl class="divide-y divide-gray-200 dark:divide-gray-700">
      {render_slot(@inner_block)}
    </dl>
    """
  end

  attr :id, :string, required: true
  attr :title, :string, required: true
  attr :open_by_default, :boolean, default: false
  attr :title_class, :string, default: ""
  slot :inner_block, required: true

  def accordion_item(assigns) do
    ~H"""
    <div x-data={"{ open: #{@open_by_default}}"} class="py-4">
      <dt>
        <button
          type="button"
          class={"flex w-full items-start justify-between text-left #{@title_class}"}
          @click="open = !open"
        >
          <span class="text-base font-semibold">{@title}</span>
          <span class="ml-6 flex h-6 items-center">
            <svg
              x-show="!open"
              class="size-5"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
            >
              <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6" />
            </svg>
            <svg
              x-show="open"
              class="size-5"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
            >
              <path stroke-linecap="round" stroke-linejoin="round" d="M18 12H6" />
            </svg>
          </span>
        </button>
      </dt>
      <dd x-show="open" id={@id} class="mt-2 pr-12 text-sm">
        {render_slot(@inner_block)}
      </dd>
    </div>
    """
  end

  attr(:rest, :global, include: ~w(fill stroke stroke-width))
  attr(:name, :atom, required: true)
  attr(:outline, :boolean, default: true)
  attr(:solid, :boolean, default: false)
  attr(:mini, :boolean, default: false)

  def dynamic_icon(assigns) do
    apply(Heroicons, assigns.name, [assigns])
  end

  attr(:width, :integer, default: 100)
  attr(:height, :integer, default: 100)
  attr(:id, :string, default: "shuttle")

  defp icon_class(link_assigns) do
    classes = List.wrap(link_assigns[:class]) |> Enum.join(" ")

    if String.contains?(classes, "text-sm") or
         String.contains?(classes, "text-xs") do
      ["w-3 h-3"]
    else
      ["w-4 h-4"]
    end
  end

  slot(:item, required: true)

  def focus_list(assigns) do
    ~H"""
    <ol class="list-disc space-y-1 ml-4 text-sm">
      <li :for={item <- @item} class="marker:text-indigo-700 dark:marker:text-indigo-700">
        {render_slot(item)}
      </li>
    </ol>
    """
  end

  slot :title
  slot :subtitle
  slot :inner_block, required: true
  slot :footer
  attr :padding?, :boolean, default: true
  attr :rest, :global

  def focus_box(assigns) do
    ~H"""
    <div
      class="bg-white w-full max-w-lg mx-auto dark:bg-gray-800 text-gray-900 dark:text-gray-100 shadow-md rounded-md mt-12"
      {@rest}
    >
      <div class={if(@padding?, do: "p-8")}>
        <.title :if={@title != []}>
          {render_slot(@title)}
        </.title>
        <div></div>

        <div :if={@subtitle != []} class="text-sm mt-4 leading-6">
          {render_slot(@subtitle)}
        </div>

        <div :if={@title != []} class="mt-8">
          {render_slot(@inner_block)}
        </div>

        <div :if={@title == []}>
          {render_slot(@inner_block)}
        </div>
      </div>
      <div
        :if={@footer != []}
        class="flex flex-col dark:text-gray-200 border-t border-gray-300 dark:border-gray-700"
      >
        <div class="p-8">
          {render_slot(@footer)}
        </div>
      </div>
    </div>
    """
  end

  attr :rest, :global
  attr :width, :string, default: "min-w-full"
  attr :rows, :list, default: []
  attr :row_attrs, :any, default: nil
  slot :thead, required: false
  slot :tbody, required: true
  slot :inner_block, required: false

  def table(assigns) do
    ~H"""
    <table :if={not Enum.empty?(@rows)} class={@width} {@rest}>
      <thead :if={@thead != []}>
        <tr class="border-b border-gray-200 dark:border-gray-700">
          {render_slot(@thead)}
        </tr>
      </thead>
      <tbody class="divide-y divide-gray-200 dark:divide-gray-700">
        <tr :for={item <- @rows} {if @row_attrs, do: @row_attrs.(item), else: %{}}>
          {render_slot(@tbody, item)}
        </tr>
        {render_slot(@inner_block)}
      </tbody>
    </table>
    """
  end

  slot :inner_block, required: true
  attr :truncate, :boolean, default: false
  attr :max_width, :string, default: ""
  attr :height, :string, default: ""
  attr :class, :string, default: ""
  attr :actions, :boolean, default: nil
  attr :hide_on_mobile, :boolean, default: nil
  attr :rest, :global

  def td(assigns) do
    max_width =
      cond do
        assigns.max_width != "" -> assigns.max_width
        assigns.truncate -> "max-w-sm"
        true -> ""
      end

    assigns = assign(assigns, max_width: max_width)

    ~H"""
    <td
      class={[
        @height,
        "text-sm px-6 py-3 first:pl-0 last:pr-0 whitespace-nowrap",
        @truncate && "truncate",
        @max_width,
        @actions && "flex text-right justify-end",
        @hide_on_mobile && "hidden md:table-cell",
        @class
      ]}
      {@rest}
    >
      <div :if={@actions} class="flex gap-2">
        {render_slot(@inner_block)}
      </div>
      <div :if={!@actions}>
        {render_slot(@inner_block)}
      </div>
    </td>
    """
  end

  slot :inner_block, required: true
  attr :invisible, :boolean, default: false
  attr :hide_on_mobile, :boolean, default: nil

  def th(assigns) do
    class =
      if assigns[:invisible] do
        "invisible"
      else
        "px-6 first:pl-0 last:pr-0 py-3 text-left text-sm font-medium"
      end

    assigns = assign(assigns, class: class)

    ~H"""
    <th scope="col" class={[@hide_on_mobile && "hidden md:table-cell", @class]}>
      {render_slot(@inner_block)}
    </th>
    """
  end

  attr :set_to, :boolean, default: false
  attr :disabled?, :boolean, default: false
  slot :inner_block, required: true

  def toggle_submit(assigns) do
    ~H"""
    <div class="mt-4 mb-2 flex items-center">
      <button
        type="submit"
        class={[
          "relative inline-flex flex-shrink-0 h-6 w-11 border-2 border-transparent rounded-full transition-colors ease-in-out duration-200 focus:outline-none focus:ring",
          if(@set_to, do: "bg-indigo-600", else: "bg-gray-200 dark:bg-gray-700"),
          if(@disabled?, do: "cursor-not-allowed")
        ]}
        disabled={@disabled?}
      >
        <span
          aria-hidden="true"
          class={[
            "inline-block h-5 w-5 rounded-full bg-white dark:bg-gray-800 shadow transform transition ease-in-out duration-200",
            if(@set_to, do: "translate-x-5", else: "translate-x-0")
          ]}
        />
      </button>

      <span class={[
        "ml-2 font-medium leading-5 text-sm",
        if(@disabled?,
          do: "text-gray-500 dark:text-gray-400",
          else: "text-gray-900 dark:text-gray-100"
        )
      ]}>
        {render_slot(@inner_block)}
      </span>
    </div>
    """
  end

  attr :href, :string, default: nil
  attr :icon, :atom, default: :pencil_square
  attr :rest, :global, include: ~w(method disabled)

  def edit_button(assigns) do
    if assigns[:href] do
      ~H"""
      <.unstyled_link href={@href} {@rest}>
        <.dynamic_icon
          name={@icon}
          class="w-5 h-5 text-indigo-800 hover:text-indigo-500 dark:text-indigo-500 dark:hover:text-indigo-300"
        />
      </.unstyled_link>
      """
    else
      ~H"""
      <button {@rest}>
        <.dynamic_icon
          name={@icon}
          class="w-5 h-5 text-indigo-800 hover:text-indigo-500 dark:text-indigo-500 dark:hover:text-indigo-300"
        />
      </button>
      """
    end
  end

  attr :href, :string, default: nil
  attr :icon, :atom, default: :trash
  attr :rest, :global, include: ~w(method disabled)

  def delete_button(assigns) do
    if assigns[:href] do
      ~H"""
      <.unstyled_link href={@href} {@rest}>
        <.dynamic_icon
          name={@icon}
          class="w-5 h-5 text-red-800 hover:text-red-500 dark:text-red-500 dark:hover:text-red-400"
        />
      </.unstyled_link>
      """
    else
      ~H"""
      <button {@rest}>
        <.dynamic_icon
          name={@icon}
          class="w-5 h-5 text-red-800 hover:text-red-500 dark:text-red-500 dark:hover:text-red-400"
        />
      </button>
      """
    end
  end

  attr :filter_text, :string, default: ""
  attr :placeholder, :string, default: ""
  attr :filtering_enabled?, :boolean, default: true
  slot :inner_block, required: false

  def filter_bar(assigns) do
    ~H"""
    <div class="mb-6 flex items-center justify-between" x-data>
      <div :if={@filtering_enabled?} class="relative rounded-md shadow-sm flex">
        <form id="filter-form" phx-change="filter" phx-submit="filter" class="flex items-center">
          <div class="text-gray-800 inline-flex items-center">
            <div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
              <Heroicons.magnifying_glass class="feather mr-1 dark:text-gray-300" />
            </div>
            <input
              type="text"
              name="filter-text"
              id="filter-text"
              class="w-36 sm:w-full pl-8 text-sm shadow-sm dark:bg-gray-900 dark:text-gray-300 focus:ring-indigo-500 focus:border-indigo-500 block border-gray-300 dark:border-gray-500 rounded-md dark:bg-gray-800"
              placeholder="Press / to search"
              x-ref="filter_text"
              phx-debounce={200}
              autocomoplete="off"
              x-on:keydown.slash.window="if (['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName) || document.activeElement.isContentEditable) return; $refs.filter_text.focus(); $refs.filter_text.select();"
              x-on:keydown.escape="$refs.filter_text.blur(); $refs.reset_filter?.dispatchEvent(new Event('click', {bubbles: true, cancelable: true}));"
              value={@filter_text}
              x-on:focus={"$refs.filter_text.placeholder = '#{@placeholder}';"}
              x-on:blur="$refs.filter_text.placeholder = 'Press / to search';"
            />

            <Heroicons.backspace
              :if={String.trim(@filter_text) != ""}
              class="feather ml-2 cursor-pointer hover:text-red-500 dark:text-gray-300 dark:hover:text-red-500"
              phx-click="reset-filter-text"
              id="reset-filter"
              x-ref="reset_filter"
            />
          </div>
        </form>
      </div>
      {render_slot(@inner_block)}
    </div>
    """
  end

  slot :inner_block, required: true
  attr :class, :any, default: nil

  def h2(assigns) do
    ~H"""
    <h2 class={[@class || "font-semibold leading-6 text-gray-900 dark:text-gray-100"]}>
      {render_slot(@inner_block)}
    </h2>
    """
  end

  slot :inner_block, required: true
  attr :class, :any, default: nil

  def title(assigns) do
    ~H"""
    <.h2 class={["text-lg font-medium text-gray-900 dark:text-gray-100 leading-7", @class]}>
      {render_slot(@inner_block)}
    </.h2>
    """
  end

  alias Phoenix.LiveView.JS

  slot :inner_block, required: true

  def disclosure(assigns) do
    ~H"""
    <div>
      {render_slot(@inner_block)}
    </div>
    """
  end

  slot :inner_block, required: true
  attr :class, :any, default: nil

  def disclosure_button(assigns) do
    ~H"""
    <button
      type="button"
      id="disclosure-button"
      data-open="false"
      phx-click={
        JS.toggle(to: "#disclosure-panel")
        |> JS.toggle_attribute({"data-open", "true", "false"}, to: "#disclosure-button")
      }
      class={@class}
    >
      {render_slot(@inner_block)}
    </button>
    """
  end

  slot :inner_block, required: true

  def disclosure_panel(assigns) do
    ~H"""
    <div id="disclosure-panel" style="display: none;">
      {render_slot(@inner_block)}
    </div>
    """
  end
end
```

## File: `lib/plausible_web/components/google.ex`
```
defmodule PlausibleWeb.Components.Google do
  @moduledoc """
  Google-related components
  """
  use PlausibleWeb, :component

  attr(:to, :string, required: true)
  attr(:id, :string, required: true)

  def button(assigns) do
    ~H"""
    <.unstyled_link
      id={@id}
      href={@to}
      class="inline-flex pr-4 items-center border border-gray-100 shadow rounded-md focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-gray-200 mt-8 hover:bg-gray-50 dark:hover:bg-gray-700"
    >
      <.logo />
      <span
        style="font-family: Roboto, system-ui"
        class="text-sm font-medium text-gray-600 dark:text-gray-50"
      >
        Continue with Google
      </span>
    </.unstyled_link>
    """
  end

  def logo(assigns \\ %{}) do
    ~H"""
    <svg
      width="46px"
      height="46px"
      viewBox="0 0 46 46"
      version="1.1"
      xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink"
    >
      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-1.000000, -1.000000)">
          <g transform="translate(15.000000, 15.000000)">
            <path
              d="M17.64,9.20454545 C17.64,8.56636364 17.5827273,7.95272727 17.4763636,7.36363636 L9,7.36363636 L9,10.845 L13.8436364,10.845 C13.635,11.97 13.0009091,12.9231818 12.0477273,13.5613636 L12.0477273,15.8195455 L14.9563636,15.8195455 C16.6581818,14.2527273 17.64,11.9454545 17.64,9.20454545 L17.64,9.20454545 Z"
              fill="#4285F4"
            >
            </path>
            <path
              d="M9,18 C11.43,18 13.4672727,17.1940909 14.9563636,15.8195455 L12.0477273,13.5613636 C11.2418182,14.1013636 10.2109091,14.4204545 9,14.4204545 C6.65590909,14.4204545 4.67181818,12.8372727 3.96409091,10.71 L0.957272727,10.71 L0.957272727,13.0418182 C2.43818182,15.9831818 5.48181818,18 9,18 L9,18 Z"
              fill="#34A853"
            >
            </path>
            <path
              d="M3.96409091,10.71 C3.78409091,10.17 3.68181818,9.59318182 3.68181818,9 C3.68181818,8.40681818 3.78409091,7.83 3.96409091,7.29 L3.96409091,4.95818182 L0.957272727,4.95818182 C0.347727273,6.17318182 0,7.54772727 0,9 C0,10.4522727 0.347727273,11.8268182 0.957272727,13.0418182 L3.96409091,10.71 L3.96409091,10.71 Z"
              fill="#FBBC05"
            >
            </path>
            <path
              d="M9,3.57954545 C10.3213636,3.57954545 11.5077273,4.03363636 12.4404545,4.92545455 L15.0218182,2.34409091 C13.4631818,0.891818182 11.4259091,0 9,0 C5.48181818,0 2.43818182,2.01681818 0.957272727,4.95818182 L3.96409091,7.29 C4.67181818,5.16272727 6.65590909,3.57954545 9,3.57954545 L9,3.57954545 Z"
              fill="#EA4335"
            >
            </path>
            <path d="M0,0 L18,0 L18,18 L0,18 L0,0 Z"></path>
          </g>
        </g>
      </g>
    </svg>
    """
  end
end
```

## File: `lib/plausible_web/components/layout.ex`
```
defmodule PlausibleWeb.Components.Layout do
  @moduledoc false

  use Phoenix.Component

  def favicon(assigns) do
    ~H"""
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href={PlausibleWeb.Router.Helpers.static_path(@conn, logo_path("apple-touch-icon.png"))}
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href={PlausibleWeb.Router.Helpers.static_path(@conn, logo_path("favicon-32x32.png"))}
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href={PlausibleWeb.Router.Helpers.static_path(@conn, logo_path("favicon-16x16.png"))}
    />
    """
  end

  def theme_script(assigns) do
    ~H"""
    <script blocking="rendering">
      (function(){
        var themePref = '<%= theme_preference(assigns) %>';
        function reapplyTheme() {
          var darkMediaPref = window.matchMedia('(prefers-color-scheme: dark)').matches;
          var htmlRef = document.querySelector('html');
          var hcaptchaRefs = Array.from(document.getElementsByClassName('h-captcha'));

          var isDark = themePref === 'dark' || (themePref === 'system' && darkMediaPref);

          if (isDark) {
              htmlRef.classList.add('dark')
              hcaptchaRefs.forEach(function(ref) { ref.dataset.theme = "dark"; });
          } else {
              htmlRef.classList.remove('dark');
              hcaptchaRefs.forEach(function(ref) { ref.dataset.theme = "light"; });
          }
        }

        reapplyTheme();
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', reapplyTheme);
      })()
    </script>
    """
  end

  attr(:selected_fn, :any, required: true)
  attr(:prefix, :string, default: "")
  attr(:options, :list, required: true)

  def settings_sidebar(assigns) do
    ~H"""
    <.settings_top_tab
      :for={%{key: key, value: value, icon: icon} = opts <- @options}
      selected_fn={@selected_fn}
      prefix={@prefix}
      icon={icon}
      text={key}
      badge={opts[:badge]}
      value={value}
    />
    """
  end

  attr(:selected_fn, :any)
  attr(:prefix, :string, default: "")
  attr(:icon, :any, default: nil)
  attr(:text, :string, required: true)
  attr(:badge, :any, default: nil)
  attr(:value, :any, default: nil)

  defp settings_top_tab(assigns) do
    ~H"""
    <%= if is_binary(@value) do %>
      <.settings_tab
        selected_fn={@selected_fn}
        prefix={@prefix}
        icon={@icon}
        text={@text}
        badge={@badge}
        value={@value}
      />
    <% else %>
      <.settings_tab icon={@icon} text={@text} />

      <div class="ml-6">
        <.settings_tab
          :for={%{key: key, value: value} = opts <- @value}
          selected_fn={@selected_fn}
          prefix={@prefix}
          icon={nil}
          text={key}
          badge={opts[:badge]}
          value={value}
          submenu?={true}
        />
      </div>
    <% end %>
    """
  end

  attr(:selected_fn, :any, default: nil)
  attr(:prefix, :string, default: "")
  attr(:value, :any, default: nil)
  attr(:icon, :any, default: nil)
  attr(:submenu?, :boolean, default: false)
  attr(:text, :string, required: true)
  attr(:badge, :any, default: nil)

  defp settings_tab(assigns) do
    current_tab? = assigns[:selected_fn] != nil and assigns.selected_fn.(assigns[:value])
    assigns = assign(assigns, :current_tab?, current_tab?)

    ~H"""
    <a
      href={@value && @prefix <> "/settings/" <> @value}
      class={[
        "text-sm flex items-center px-2 py-2 leading-5 font-medium rounded-md outline-none focus:outline-none transition ease-in-out duration-150",
        @current_tab? &&
          "text-gray-900 dark:text-gray-100 bg-gray-100 font-semibold dark:bg-gray-900 hover:text-gray-900 focus:bg-gray-200 dark:focus:bg-gray-800",
        @value && not @current_tab? &&
          "text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100 hover:bg-gray-100 dark:hover:bg-gray-800 focus:text-gray-900 focus:bg-gray-50 dark:focus:text-gray-100 dark:focus:bg-gray-800",
        !@value && "text-gray-600 dark:text-gray-400"
      ]}
    >
      <PlausibleWeb.Components.Generic.dynamic_icon
        :if={not @submenu? && @icon}
        name={@icon}
        class={["h-4 w-4 mr-2", @current_tab? && "stroke-2"]}
      />
      {@text}
      <.settings_badge type={@badge} />
      <Heroicons.chevron_down
        :if={is_nil(@value)}
        class="h-3 w-3 ml-2 text-gray-400 dark:text-gray-500"
      />
    </a>
    """
  end

  defp settings_badge(%{type: :new} = assigns) do
    ~H"""
    <span class="inline-block ml-2 bg-indigo-700 text-gray-100 text-xs p-1 rounded">
      NEW
    </span>
    """
  end

  defp settings_badge(assigns), do: ~H""

  defp theme_preference(%{theme: theme}) when not is_nil(theme), do: theme

  defp theme_preference(%{current_user: %Plausible.Auth.User{theme: theme}})
       when not is_nil(theme) do
    theme
  end

  defp theme_preference(_assigns), do: "system"

  defdelegate logo_path(path), to: PlausibleWeb.LayoutView
end
```

## File: `lib/plausible_web/components/site/feature.ex`
```
defmodule PlausibleWeb.Components.Site.Feature do
  @moduledoc """
  Phoenix Component for rendering a user-facing feature toggle
  capable of flipping booleans in `Plausible.Site` via the `toggle_feature` controller action.
  """
  use PlausibleWeb, :view

  attr(:site, Plausible.Site, required: true)
  attr(:feature_mod, :atom, required: true, values: Plausible.Billing.Feature.list())
  attr(:conn, Plug.Conn, required: true)
  attr(:class, :any, default: nil)
  slot(:inner_block)

  def toggle(assigns) do
    assigns =
      assigns
      |> assign(:current_setting, assigns.feature_mod.enabled?(assigns.site))
      |> assign(:disabled?, assigns.feature_mod.check_availability(assigns.site.team) !== :ok)

    ~H"""
    <div>
      <.form
        action={target(@site, @feature_mod.toggle_field(), @conn, !@current_setting)}
        method="put"
        for={nil}
        class={@class}
      >
        <.toggle_submit set_to={@current_setting} disabled?={@disabled?}>
          Show {@feature_mod.display_name()} in the Dashboard
        </.toggle_submit>
      </.form>

      <div :if={@current_setting}>
        {render_slot(@inner_block)}
      </div>
    </div>
    """
  end

  def target(site, setting, conn, set_to) when is_boolean(set_to) do
    r = conn.request_path
    Routes.site_path(conn, :update_feature_visibility, site.domain, setting, r: r, set: set_to)
  end
end
```

## File: `lib/plausible_web/components/team/notice.ex`
```
defmodule PlausibleWeb.Team.Notice do
  @moduledoc """
  Components with teams related notices.
  """
  use PlausibleWeb, :component

  def owner_cta_banner(assigns) do
    ~H"""
    <aside class="mt-4 mb-4">
      <.notice
        title="A Better Way of Inviting People to Your Team"
        class="shadow-md dark:shadow-none mt-4"
      >
        <p>
          You can also create a team and assign different roles to team members, such as admin,
          editor, viewer or billing. Team members will gain access to all your sites.
          <.styled_link href={Routes.team_setup_path(PlausibleWeb.Endpoint, :setup)}>
            Create your team here
          </.styled_link>.
        </p>
      </.notice>
    </aside>
    """
  end

  def guest_cta_banner(assigns) do
    ~H"""
    <aside class="mt-4 mb-4">
      <.notice
        title="A Better Way of Inviting People to a Team"
        class="shadow-md dark:shadow-none mt-4"
      >
        <p>
          It is also possible to create a team and assign different roles to team members, such as
          admin, editor, viewer or billing. Team members can gain access to all the sites. Please
          contact the site owner to create your team.
        </p>
      </.notice>
    </aside>
    """
  end

  def team_members_notice(assigns) do
    ~H"""
    <aside class="mt-4 mb-4">
      <.notice theme={:gray} class="rounded border border-gray-300 text-sm mt-4">
        <p>
          Team members automatically have access to this site.
          <.styled_link href={Routes.settings_path(PlausibleWeb.Endpoint, :team_general)}>
            View team members
          </.styled_link>
        </p>
      </.notice>
    </aside>
    """
  end

  def team_invitations(assigns) do
    ~H"""
    <aside :if={not Enum.empty?(@team_invitations)} class="mt-4 mb-4">
      <.notice
        :for={i <- @team_invitations}
        id={"invitation-#{i.invitation_id}"}
        title="You have received team invitation"
        class="shadow-md dark:shadow-none mt-4"
      >
        {i.inviter.name} has invited you to join the "{i.team.name}" as {i.role} member.
        <.link
          method="post"
          href={Routes.invitation_path(PlausibleWeb.Endpoint, :accept_invitation, i.invitation_id)}
          class="whitespace-nowrap font-semibold"
        >
          Accept
        </.link>
        or
        <.link
          method="post"
          href={Routes.invitation_path(PlausibleWeb.Endpoint, :reject_invitation, i.invitation_id)}
          phx-value-invitation-id={i.invitation_id}
          class="whitespace-nowrap font-semibold"
        >
          Reject
        </.link>
      </.notice>
    </aside>
    """
  end
end
```

## File: `lib/plausible_web/components/two_factor.ex`
```
defmodule PlausibleWeb.Components.TwoFactor do
  @moduledoc """
  Reusable components specific to 2FA
  """
  use PlausibleWeb, :component

  attr :text, :string, required: true
  attr :scale, :integer, default: 4

  def qr_code(assigns) do
    qr_code =
      assigns.text
      |> EQRCode.encode()
      |> EQRCode.svg(%{width: 160})

    assigns = assign(assigns, :code, qr_code)

    ~H"""
    {Phoenix.HTML.raw(@code)}
    """
  end

  attr :id, :string, default: "verify-button"
  attr :form, :any, required: true
  attr :field, :any, required: true
  attr :class, :string, default: ""
  attr :show_button?, :boolean, default: true

  def verify_2fa_input(assigns) do
    input_class =
      "font-mono tracking-[0.5em] w-36 pl-5 font-medium shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block border-gray-300 dark:border-gray-500 dark:text-gray-200 dark:bg-gray-900 rounded-l-md"

    input_class =
      if assigns.show_button? do
        input_class
      else
        [input_class, "rounded-r-md"]
      end

    assigns = assign(assigns, :input_class, input_class)
    assigns = assign(assigns, :field, assigns[:form][assigns[:field]])

    ~H"""
    <div class={[@class, "flex items-center"]}>
      <input
        type="text"
        name={@field.name}
        value={@field.value}
        autocomplete="off"
        class={@input_class}
        oninput={
          if @show_button? do
            "this.value=this.value.replace(/[^0-9]/g, ''); if (this.value.length >= 6) document.getElementById('#{@id}').focus()"
          else
            "this.value=this.value.replace(/[^0-9]/g, '');"
          end
        }
        onclick="this.select();"
        oninvalid={@show_button? && "document.getElementById('#{@id}').disabled = false"}
        maxlength="6"
        placeholder="••••••"
        required="required"
      />
      <.button
        :if={@show_button?}
        type="submit"
        id={@id}
        mt?={false}
        class="rounded-l-none [&>span.label-enabled]:block [&>span.label-disabled]:hidden [&[disabled]>span.label-enabled]:hidden [&[disabled]>span.label-disabled]:block"
      >
        <span class="label-enabled pointer-events-none">
          Verify &rarr;
        </span>

        <span class="label-disabled">
          <.spinner class="inline-block h-5 w-5 mr-2 text-white dark:text-gray-400" /> Verifying...
        </span>
      </.button>
    </div>
    """
  end

  attr :id, :string, required: true
  attr :state_param, :string, required: true
  attr :form_data, :any, required: true
  attr :form_target, :string, required: true
  attr :onsubmit, :string, default: nil
  attr :title, :string, required: true

  slot :icon, required: true
  slot :inner_block, required: true
  slot :buttons, required: true

  def modal(assigns) do
    ~H"""
    <div
      id={@id}
      x-cloak
      x-show={@state_param}
      x-on:keyup.escape.window={"#{@state_param} = false"}
      class="fixed z-10 inset-0 overflow-y-auto"
      aria-labelledby="modal-title"
      role="dialog"
      aria-modal="true"
    >
      <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
        <div
          x-show={@state_param}
          x-transition:enter="transition ease-out duration-300"
          x-transition:enter-start="opacity-0"
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200"
          x-transition:leave-start="opacity-100"
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-gray-500 dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 transition-opacity"
          aria-hidden="true"
          x-on:click={"#{@state_param} = false"}
        >
        </div>
        <!-- This element is to trick the browser into centering the modal contents. -->
        <span class="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">
          &#8203;
        </span>

        <div
          x-show={@state_param}
          x-transition:enter="transition ease-out duration-300"
          x-transition:enter-start="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
          x-transition:enter-end="opacity-100 translate-y-0 sm:scale-100"
          x-transition:leave="transition ease-in duration-200"
          x-transition:leave-start="opacity-100 translate-y-0 sm:scale-100"
          x-transition:leave-end="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
          class="inline-block align-bottom bg-white dark:bg-gray-900 rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full"
        >
          <.form :let={f} for={@form_data} action={@form_target} onsubmit={@onsubmit}>
            <div class="bg-white dark:bg-gray-800 px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
              <div class="hidden sm:block absolute top-0 right-0 pt-4 pr-4">
                <a
                  href="#"
                  x-on:click.prevent={"#{@state_param} = false"}
                  class="bg-white dark:bg-gray-800 rounded-md text-gray-400 dark:text-gray-500 hover:text-gray-500 dark:hover:text-gray-400 focus:outline-none"
                >
                  <span class="sr-only">Close</span>
                  <Heroicons.x_mark class="h-6 w-6" />
                </a>
              </div>
              <div class="sm:flex sm:items-start">
                <div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-green-100 sm:mx-0 sm:h-10 sm:w-10">
                  {render_slot(@icon)}
                </div>
                <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left text-gray-900 dark:text-gray-100">
                  <h3 class="text-lg leading-6 font-medium" id="modal-title">
                    {@title}
                  </h3>

                  {render_slot(@inner_block, f)}
                </div>
              </div>
            </div>
            <div class="bg-gray-50 dark:bg-gray-850 px-4 py-3 sm:px-9 sm:flex sm:flex-row-reverse">
              {render_slot(@buttons)}
              <.button
                type="button"
                x-on:click={"#{@state_param} = false"}
                class="w-full sm:w-auto mr-2"
                theme="bright"
              >
                Cancel
              </.button>
            </div>
          </.form>
        </div>
      </div>
    </div>
    """
  end
end
```

## File: `lib/plausible_web/controllers/api/external_controller.ex`
```
defimpl FunWithFlags.Actor, for: BitString do
  def id(str) do
    str
  end
end

defmodule PlausibleWeb.Api.ExternalController do
  use PlausibleWeb, :controller
  require Logger

  alias Plausible.Ingestion

  def event(conn, _params) do
    with {:ok, request} <- Ingestion.Request.build(conn),
         _ <- Sentry.Context.set_extra_context(%{request: request}) do
      case Ingestion.Event.build_and_buffer(request) do
        {:ok, %{dropped: [], buffered: _buffered}} ->
          conn
          |> put_status(202)
          |> text("ok")

        {:ok, %{dropped: dropped, buffered: _}} ->
          first_invalid_changeset = find_first_invalid_changeset(dropped)

          if first_invalid_changeset do
            conn
            |> put_resp_header("x-plausible-dropped", "#{Enum.count(dropped)}")
            |> put_status(400)
            |> json(%{
              errors: Plausible.ChangesetHelpers.traverse_errors(first_invalid_changeset)
            })
          else
            conn
            |> put_resp_header("x-plausible-dropped", "#{Enum.count(dropped)}")
            |> put_status(202)
            |> text("ok")
          end
      end
    else
      {:error, %Ecto.Changeset{} = changeset} ->
        conn
        |> put_status(400)
        |> json(%{errors: Plausible.ChangesetHelpers.traverse_errors(changeset)})
    end
  end

  def error(conn, _params) do
    Sentry.capture_message("JS snippet error")
    send_resp(conn, 200, "")
  end

  defp find_first_invalid_changeset(dropped) do
    Enum.find_value(dropped, nil, fn dropped_event ->
      case dropped_event.drop_reason do
        {:error, %Ecto.Changeset{} = changeset} -> changeset
        _ -> false
      end
    end)
  end
end
```

## File: `lib/plausible_web/controllers/api/external_query_api_controller.ex`
```
defmodule PlausibleWeb.Api.ExternalQueryApiController do
  @moduledoc false

  use PlausibleWeb, :controller
  use Plausible.Repo
  use PlausibleWeb.Plugs.ErrorHandler
  alias Plausible.Stats.Query

  def query(conn, params) do
    site = Repo.preload(conn.assigns.site, :owners)

    case Query.build(site, conn.assigns.schema_type, params, debug_metadata(conn)) do
      {:ok, query} ->
        results = Plausible.Stats.query(site, query)
        json(conn, results)

      {:error, message} ->
        conn
        |> put_status(400)
        |> json(%{error: message})
    end
  end

  def schema(conn, _params) do
    json(conn, Plausible.Stats.JSONSchema.raw_public_schema())
  end
end
```

## File: `lib/plausible_web/controllers/api/external_stats_controller.ex`
```
defmodule PlausibleWeb.Api.ExternalStatsController do
  use PlausibleWeb, :controller
  use Plausible.Repo
  use PlausibleWeb.Plugs.ErrorHandler
  alias Plausible.Stats.{Query, Metrics, Filters}

  def realtime_visitors(conn, _params) do
    site = conn.assigns.site
    json(conn, Plausible.Stats.current_visitors(site))
  end

  def aggregate(conn, params) do
    site = Repo.preload(conn.assigns.site, :owners)

    params = Map.put(params, "property", nil)

    with :ok <- validate_period(params),
         :ok <- validate_date(params),
         query <- Query.from(site, params, debug_metadata(conn)),
         :ok <- validate_filters(site, query.filters),
         {:ok, metrics} <- parse_and_validate_metrics(params, query),
         :ok <- ensure_custom_props_access(site, query) do
      %{results: results, meta: meta} = Plausible.Stats.aggregate(site, query, metrics)

      payload = maybe_add_warning(%{results: results}, meta)

      json(conn, payload)
    else
      err_tuple -> send_json_error_response(conn, err_tuple)
    end
  end

  def breakdown(conn, params) do
    site = Repo.preload(conn.assigns.site, :owners)

    with :ok <- validate_period(params),
         :ok <- validate_date(params),
         :ok <- validate_property(params),
         query <- Query.from(site, params, debug_metadata(conn)),
         :ok <- validate_filters(site, query.filters),
         {:ok, metrics} <- parse_and_validate_metrics(params, query),
         {:ok, limit} <- validate_or_default_limit(params),
         :ok <- ensure_custom_props_access(site, query) do
      page = String.to_integer(Map.get(params, "page", "1"))

      %{results: results, meta: meta} =
        Plausible.Stats.breakdown(site, query, metrics, {limit, page})

      payload = maybe_add_warning(%{results: results}, meta)

      json(conn, payload)
    else
      err_tuple -> send_json_error_response(conn, err_tuple)
    end
  end

  defp validate_property(%{"property" => property}) do
    cond do
      property == "event:hostname" ->
        {:error,
         "Property 'event:hostname' is currently not supported for breakdowns.  Please provide a valid property for the breakdown endpoint: https://plausible.io/docs/stats-api#properties"}

      Plausible.Stats.Legacy.Dimensions.valid?(property) ->
        :ok

      true ->
        {:error,
         "Invalid property '#{property}'. Please provide a valid property for the breakdown endpoint: https://plausible.io/docs/stats-api#properties"}
    end
  end

  defp validate_property(_) do
    {:error,
     "The `property` parameter is required. Please provide at least one property to show a breakdown by."}
  end

  @max_breakdown_limit 1000
  defp validate_or_default_limit(%{"limit" => limit}) do
    with {limit, ""} when limit > 0 and limit <= @max_breakdown_limit <- Integer.parse(limit) do
      {:ok, limit}
    else
      _ ->
        {:error, "Please provide limit as a number between 1 and #{@max_breakdown_limit}."}
    end
  end

  @default_breakdown_limit 100
  defp validate_or_default_limit(_), do: {:ok, @default_breakdown_limit}

  defp parse_and_validate_metrics(params, query) do
    metrics =
      Map.get(params, "metrics", "visitors")
      |> String.split(",")

    case validate_metrics(metrics, query) do
      {:error, reason} ->
        {:error, reason}

      metrics ->
        {:ok, Enum.map(metrics, &Metrics.from_string!/1)}
    end
  end

  @spec ensure_custom_props_access(Plausible.Site.t(), Query.t()) ::
          :ok | {:error, {402, String.t()}}
  defp ensure_custom_props_access(site, query) do
    allowed_props = Plausible.Props.allowed_for(site, bypass_setup?: true)
    prop_filter = Filters.get_toplevel_filter(query, "event:props:")

    query_allowed? =
      case {prop_filter, query.dimensions, allowed_props} do
        {_, _, :all} ->
          true

        {[_, "event:props:" <> prop | _], _property, allowed_props} ->
          prop in allowed_props

        {_filter, ["event:props:" <> prop], allowed_props} ->
          prop in allowed_props

        _ ->
          true
      end

    if query_allowed? do
      :ok
    else
      msg = "The owner of this site does not have access to the custom properties feature"
      {:error, {402, msg}}
    end
  end

  defp validate_metrics(metrics, query) do
    if length(metrics) == length(Enum.uniq(metrics)) do
      validate_each_metric(metrics, query)
    else
      {:error, "Metrics cannot be queried multiple times."}
    end
  end

  defp validate_each_metric(metrics, query) do
    Enum.reduce_while(metrics, [], fn metric, acc ->
      case validate_metric(metric, query) do
        {:ok, metric} -> {:cont, acc ++ [metric]}
        {:error, reason} -> {:halt, {:error, reason}}
      end
    end)
  end

  defp validate_metric("time_on_page" = metric, query) do
    cond do
      Filters.filtering_on_dimension?(query, "event:goal") ->
        {:error, "Metric `#{metric}` cannot be queried when filtering by `event:goal`"}

      Filters.filtering_on_dimension?(query, "event:name") ->
        {:error, "Metric `#{metric}` cannot be queried when filtering by `event:name`"}

      query.dimensions == ["event:page"] ->
        {:ok, metric}

      not Enum.empty?(query.dimensions) ->
        {:error,
         "Metric `#{metric}` is not supported in breakdown queries (except `event:page` breakdown)"}

      Filters.filtering_on_dimension?(query, "event:page") ->
        {:ok, metric}

      true ->
        {:error,
         "Metric `#{metric}` can only be queried in a page breakdown or with a page filter."}
    end
  end

  defp validate_metric("conversion_rate" = metric, query) do
    cond do
      query.dimensions == ["event:goal"] ->
        {:ok, metric}

      Filters.filtering_on_dimension?(query, "event:goal") ->
        {:ok, metric}

      true ->
        {:error,
         "Metric `#{metric}` can only be queried in a goal breakdown or with a goal filter"}
    end
  end

  defp validate_metric(metric, _) when metric in ["visitors", "pageviews", "events"] do
    {:ok, metric}
  end

  defp validate_metric("views_per_visit" = metric, query) do
    cond do
      Filters.filtering_on_dimension?(query, "event:page") ->
        {:error, "Metric `#{metric}` cannot be queried with a filter on `event:page`."}

      not Enum.empty?(query.dimensions) ->
        {:error, "Metric `#{metric}` is not supported in breakdown queries."}

      true ->
        validate_session_metric(metric, query)
    end
  end

  defp validate_metric(metric, query)
       when metric in ["visits", "bounce_rate", "visit_duration"] do
    validate_session_metric(metric, query)
  end

  defp validate_metric(metric, _) do
    {:error,
     "The metric `#{metric}` is not recognized. Find valid metrics from the documentation: https://plausible.io/docs/stats-api#metrics"}
  end

  defp validate_session_metric(metric, query) do
    cond do
      length(query.dimensions) == 1 and event_only_property?(hd(query.dimensions)) ->
        {:error,
         "Session metric `#{metric}` cannot be queried for breakdown by `#{query.dimensions}`."}

      event_only_filter = find_event_only_filter(query) ->
        {:error,
         "Session metric `#{metric}` cannot be queried when using a filter on `#{event_only_filter}`."}

      true ->
        {:ok, metric}
    end
  end

  defp find_event_only_filter(query) do
    query.filters
    |> Enum.map(fn [_op, prop | _] -> prop end)
    |> Enum.find(&event_only_property?/1)
  end

  defp event_only_property?("event:name"), do: true
  defp event_only_property?("event:goal"), do: true
  defp event_only_property?("event:props:" <> _), do: true
  defp event_only_property?(_), do: false

  def timeseries(conn, params) do
    site = Repo.preload(conn.assigns.site, :owners)

    params = Map.put(params, "property", nil)

    params =
      if Map.get(params, "interval") == "date" do
        %{params | "interval" => "day"}
      else
        params
      end

    with :ok <- validate_period(params),
         :ok <- validate_date(params),
         :ok <- validate_interval(params),
         query <- Query.from(site, params, debug_metadata(conn)),
         :ok <- validate_filters(site, query.filters),
         {:ok, metrics} <- parse_and_validate_metrics(params, query),
         :ok <- ensure_custom_props_access(site, query) do
      {results, _, meta} = Plausible.Stats.timeseries(site, query, metrics)

      payload =
        case meta[:imports_warning] do
          nil -> %{results: results}
          warning -> %{results: results, warning: warning}
        end

      json(conn, payload)
    else
      err_tuple -> send_json_error_response(conn, err_tuple)
    end
  end

  defp validate_date(%{"period" => "custom"} = params) do
    with {:ok, date} <- Map.fetch(params, "date"),
         [from, to] <- String.split(date, ","),
         {:ok, _from} <- Date.from_iso8601(String.trim(from)),
         {:ok, _to} <- Date.from_iso8601(String.trim(to)) do
      :ok
    else
      :error ->
        {:error,
         "The `date` parameter is required when using a custom period. See https://plausible.io/docs/stats-api#time-periods"}

      _ ->
        {:error,
         "Invalid format for `date` parameter. When using a custom period, please include two ISO-8601 formatted dates joined by a comma. See https://plausible.io/docs/stats-api#time-periods"}
    end
  end

  defp validate_date(%{"date" => date}) do
    case Date.from_iso8601(date) do
      {:ok, _date} ->
        :ok

      {:error, msg} ->
        {:error,
         "Error parsing `date` parameter: #{msg}. Please specify a valid date in ISO-8601 format."}
    end
  end

  defp validate_date(_), do: :ok

  defp validate_period(%{"period" => period}) do
    if period in ["day", "7d", "30d", "month", "6mo", "12mo", "custom"] do
      :ok
    else
      {:error,
       "Error parsing `period` parameter: invalid period `#{period}`. Please find accepted values in our docs: https://plausible.io/docs/stats-api#time-periods"}
    end
  end

  defp validate_period(_), do: :ok

  @valid_intervals ["day", "month"]
  @valid_intervals_str Enum.map(@valid_intervals, &("`" <> &1 <> "`")) |> Enum.join(", ")

  defp validate_interval(%{"interval" => interval}) do
    if interval in @valid_intervals do
      :ok
    else
      {:error,
       "Error parsing `interval` parameter: invalid interval `#{interval}`. Valid intervals are #{@valid_intervals_str}"}
    end
  end

  defp validate_interval(_), do: :ok

  defp validate_filters(site, filters) do
    Enum.reduce_while(filters, :ok, fn filter, _ ->
      case validate_filter(site, filter) do
        :ok -> {:cont, :ok}
        {:error, reason} -> {:halt, {:error, reason}}
      end
    end)
  end

  defp validate_filter(site, [_type, "event:goal", goal_filter | _rest]) do
    configured_goals =
      site
      |> Plausible.Goals.for_site()
      |> Enum.map(& &1.display_name)

    goals_in_filter = List.wrap(goal_filter)

    if found = Enum.find(goals_in_filter, &(&1 not in configured_goals)) do
      msg =
        goal_not_configured_message(found) <>
          "Find out how to configure goals here: https://plausible.io/docs/stats-api#filtering-by-goals"

      {:error, msg}
    else
      :ok
    end
  end

  defp validate_filter(_site, [_, property | _]) do
    if Plausible.Stats.Legacy.Dimensions.valid?(property) do
      :ok
    else
      {:error,
       "Invalid filter property '#{property}'. Please provide a valid filter property: https://plausible.io/docs/stats-api#properties"}
    end
  end

  defp goal_not_configured_message("Visit " <> page_path) do
    "The pageview goal for the pathname `#{page_path}` is not configured for this site. "
  end

  defp goal_not_configured_message(goal) do
    "The goal `#{goal}` is not configured for this site. "
  end

  @imported_query_unsupported_warning "Imported stats are not included in the results because query parameters are not supported. For more information, see: https://plausible.io/docs/stats-api#filtering-imported-stats"

  defp maybe_add_warning(payload, %Jason.OrderedObject{} = meta) do
    case meta[:imports_skip_reason] do
      :unsupported_query -> Map.put(payload, :warning, @imported_query_unsupported_warning)
      _ -> payload
    end
  end

  defp send_json_error_response(conn, {:error, {status, msg}}) do
    conn
    |> put_status(status)
    |> json(%{error: msg})
  end

  defp send_json_error_response(conn, {:error, msg}) do
    conn
    |> put_status(400)
    |> json(%{error: msg})
  end
end
```

## File: `lib/plausible_web/controllers/api/helpers.ex`
```
defmodule PlausibleWeb.Api.Helpers do
  import Plug.Conn

  def unauthorized(conn, msg) do
    conn
    |> put_status(401)
    |> Phoenix.Controller.json(%{error: msg})
    |> halt()
  end

  def not_enough_permissions(conn, msg) do
    conn
    |> put_status(403)
    |> Phoenix.Controller.json(%{error: msg})
    |> halt()
  end

  def bad_request(conn, msg) do
    conn
    |> put_status(400)
    |> Phoenix.Controller.json(%{error: msg})
    |> halt()
  end

  def not_found(conn, msg) do
    conn
    |> put_status(404)
    |> Phoenix.Controller.json(%{error: msg})
    |> halt()
  end

  def too_many_requests(conn, msg) do
    conn
    |> put_status(429)
    |> Phoenix.Controller.json(%{error: msg})
    |> halt()
  end

  def payment_required(conn, msg) do
    conn
    |> put_status(402)
    |> Phoenix.Controller.json(%{error: msg})
    |> halt()
  end
end
```

## File: `lib/plausible_web/controllers/api/internal/segments_controller.ex`
```
defmodule PlausibleWeb.Api.Internal.SegmentsController do
  @moduledoc """
  Internal API controller for segments.
  """
  use Plausible
  use PlausibleWeb, :controller
  use PlausibleWeb.Plugs.ErrorHandler
  alias PlausibleWeb.Api.Helpers, as: H
  alias Plausible.Segments

  def create(
        %Plug.Conn{
          assigns: %{
            site: site,
            current_user: %{id: user_id},
            site_role: site_role
          }
        } = conn,
        %{} = params
      ) do
    case Segments.insert_one(user_id, site, site_role, params) do
      {:error, :not_enough_permissions} ->
        H.not_enough_permissions(conn, "Not enough permissions to create segment")

      {:error, :segment_limit_reached} ->
        H.not_enough_permissions(conn, "Segment limit reached")

      {:error, {:invalid_segment, errors}} when is_list(errors) ->
        conn
        |> put_status(400)
        |> json(%{
          error: Segments.serialize_first_error(errors)
        })

      {:ok, segment} ->
        json(conn, segment)
    end
  end

  def create(%Plug.Conn{} = conn, _params), do: invalid_request(conn)

  def update(
        %Plug.Conn{
          assigns: %{
            site: site,
            current_user: %{id: user_id},
            site_role: site_role
          }
        } =
          conn,
        %{} = params
      ) do
    segment_id = normalize_segment_id_param(params["segment_id"])

    case Segments.update_one(user_id, site, site_role, segment_id, params) do
      {:error, :not_enough_permissions} ->
        H.not_enough_permissions(conn, "Not enough permissions to edit segment")

      {:error, :segment_not_found} ->
        segment_not_found(conn, params["segment_id"])

      {:error, {:invalid_segment, errors}} when is_list(errors) ->
        conn
        |> put_status(400)
        |> json(%{
          error: Segments.serialize_first_error(errors)
        })

      {:ok, segment} ->
        json(conn, segment)
    end
  end

  def update(%Plug.Conn{} = conn, _params), do: invalid_request(conn)

  def delete(
        %Plug.Conn{
          assigns: %{
            site: site,
            current_user: %{id: user_id},
            site_role: site_role
          }
        } =
          conn,
        %{} = params
      ) do
    segment_id = normalize_segment_id_param(params["segment_id"])

    case Segments.delete_one(user_id, site, site_role, segment_id) do
      {:error, :not_enough_permissions} ->
        H.not_enough_permissions(conn, "Not enough permissions to delete segment")

      {:error, :segment_not_found} ->
        segment_not_found(conn, params["segment_id"])

      {:ok, segment} ->
        json(conn, segment)
    end
  end

  def delete(%Plug.Conn{} = conn, _params), do: invalid_request(conn)

  @spec normalize_segment_id_param(any()) :: nil | pos_integer()
  defp normalize_segment_id_param(input) do
    case Integer.parse(input) do
      {int_value, ""} when int_value > 0 -> int_value
      _ -> nil
    end
  end

  defp segment_not_found(%Plug.Conn{} = conn, segment_id_param) do
    H.not_found(conn, "Segment not found with ID #{inspect(segment_id_param)}")
  end

  defp invalid_request(%Plug.Conn{} = conn) do
    H.bad_request(conn, "Invalid request")
  end
end
```

## File: `lib/plausible_web/controllers/api/internal_controller.ex`
```
defmodule PlausibleWeb.Api.InternalController do
  use PlausibleWeb, :controller
  use Plausible.Repo
  alias Plausible.{Sites, Auth}
  alias Plausible.Auth.User

  def sites(conn, _params) do
    current_user = conn.assigns[:current_user]
    current_team = conn.assigns[:current_team]

    if current_user do
      sites = sites_for(current_user, current_team)

      json(conn, %{data: sites})
    else
      PlausibleWeb.Api.Helpers.unauthorized(
        conn,
        "You need to be logged in to request a list of sites"
      )
    end
  end

  @features %{
    "funnels" => Plausible.Billing.Feature.Funnels,
    "props" => Plausible.Billing.Feature.Props,
    "conversions" => Plausible.Billing.Feature.Goals
  }
  def disable_feature(conn, %{"domain" => domain, "feature" => feature}) do
    with %User{id: user_id} = user <- conn.assigns[:current_user],
         site <- Sites.get_by_domain(domain),
         true <-
           Plausible.Teams.Memberships.has_editor_access?(site, user) ||
             Auth.is_super_admin?(user_id),
         {:ok, mod} <- Map.fetch(@features, feature),
         {:ok, _site} <- mod.toggle(site, user, override: false) do
      json(conn, "ok")
    else
      {:error, :upgrade_required} ->
        PlausibleWeb.Api.Helpers.payment_required(
          conn,
          "This feature is part of the Plausible Business plan. To get access to this feature, please upgrade your account"
        )

      :error ->
        PlausibleWeb.Api.Helpers.bad_request(
          conn,
          "The feature you tried to disable is not valid. Valid features are: #{@features |> Map.keys() |> Enum.join(", ")}"
        )

      _ ->
        PlausibleWeb.Api.Helpers.unauthorized(
          conn,
          "You need to be logged in as the owner or admin account of this site"
        )
    end
  end

  defp sites_for(user, team) do
    pagination = Sites.list(user, %{page_size: 9}, team: team)
    Enum.map(pagination.entries, &%{domain: &1.domain})
  end
end
```

## File: `lib/plausible_web/controllers/api/paddle_controller.ex`
```
defmodule PlausibleWeb.Api.PaddleController do
  use PlausibleWeb, :controller
  use Plausible.Repo
  require Logger

  plug :verify_signature when action in [:webhook]

  def webhook(conn, %{"alert_name" => "subscription_created"} = params) do
    Plausible.Billing.subscription_created(params)
    |> webhook_response(conn, params)
  end

  def webhook(conn, %{"alert_name" => "subscription_updated"} = params) do
    Plausible.Billing.subscription_updated(params)
    |> webhook_response(conn, params)
  end

  def webhook(conn, %{"alert_name" => "subscription_cancelled"} = params) do
    Plausible.Billing.subscription_cancelled(params)
    |> webhook_response(conn, params)
  end

  def webhook(conn, %{"alert_name" => "subscription_payment_succeeded"} = params) do
    Plausible.Billing.subscription_payment_succeeded(params)
    |> webhook_response(conn, params)
  end

  def webhook(conn, _params) do
    send_resp(conn, 404, "") |> halt
  end

  @default_currency_fallback :EUR

  def currency(conn, _params) do
    plan_id = get_currency_reference_plan_id()
    customer_ip = PlausibleWeb.RemoteIP.get(conn)

    result =
      Plausible.Cache.Adapter.fetch(:customer_currency, {plan_id, customer_ip}, fn ->
        case Plausible.Billing.PaddleApi.fetch_prices([plan_id], customer_ip) do
          {:ok, %{^plan_id => money}} ->
            {:ok, money.currency}

          error ->
            Sentry.capture_message("Failed to fetch currency reference plan",
              extra: %{error: inspect(error)}
            )

            {:error, :fetch_prices_failed}
        end
      end)

    case result do
      {:ok, currency} ->
        conn
        |> put_status(200)
        |> json(%{currency: Cldr.Currency.currency_for_code!(currency).narrow_symbol})

      {:error, :fetch_prices_failed} ->
        conn
        |> put_status(200)
        |> json(%{
          currency: Cldr.Currency.currency_for_code!(@default_currency_fallback).narrow_symbol
        })
    end
  end

  def verify_signature(conn, _opts) do
    signature = Base.decode64!(conn.params["p_signature"])

    msg =
      Map.delete(conn.params, "p_signature")
      |> Enum.map(fn {key, val} -> {key, "#{val}"} end)
      |> List.keysort(0)
      |> PhpSerializer.serialize()

    [key_entry] = :public_key.pem_decode(get_paddle_key())

    public_key = :public_key.pem_entry_decode(key_entry)

    if :public_key.verify(msg, :sha, signature, public_key) do
      conn
    else
      send_resp(conn, 400, "") |> halt
    end
  end

  @paddle_currency_reference_plan_id "857097"
  @paddle_sandbox_currency_reference_plan_id "63842"
  defp get_currency_reference_plan_id() do
    if Application.get_env(:plausible, :environment) == "staging" do
      @paddle_sandbox_currency_reference_plan_id
    else
      @paddle_currency_reference_plan_id
    end
  end

  @paddle_prod_key File.read!("priv/paddle.pem")
  @paddle_sandbox_key File.read!("priv/paddle_sandbox.pem")

  defp get_paddle_key() do
    if Application.get_env(:plausible, :environment) == "staging" do
      @paddle_sandbox_key
    else
      @paddle_prod_key
    end
  end

  defp webhook_response({:ok, _}, conn, _params) do
    json(conn, "")
  end

  defp webhook_response({:error, details}, conn, _params) do
    Logger.error("Error processing Paddle webhook: #{inspect(details)}")

    conn |> send_resp(400, "") |> halt
  end
end
```

## File: `lib/plausible_web/controllers/api/stats_controller.ex`
```
defmodule PlausibleWeb.Api.StatsController do
  use Plausible
  use PlausibleWeb, :controller
  use Plausible.Repo
  use PlausibleWeb.Plugs.ErrorHandler

  alias Plausible.Stats
  alias Plausible.Stats.{Query, Comparisons, Filters, Time, TableDecider, TimeOnPage}
  alias PlausibleWeb.Api.Helpers, as: H

  require Logger

  @revenue_metrics on_ee(do: Plausible.Stats.Goal.Revenue.revenue_metrics(), else: [])
  @not_set "(not set)"

  plug(:date_validation_plug)

  @doc """
  Returns a time-series based on given parameters.

  ## Parameters

  This API accepts the following parameters:

    * `period` - x-axis of the graph, e.g. `12mo`, `day`, `custom`.

    * `metric` - y-axis of the graph, e.g. `visits`, `visitors`, `pageviews`.
      See the Stats API ["Metrics"](https://plausible.io/docs/stats-api#metrics)
      section for more details. Defaults to `visitors`.

    * `interval` - granularity of the time-series data. You can think of it as
      a `GROUP BY` clause. Possible values are `minute`, `hour`, `date`, `week`,
      and `month`. The default depends on the `period` parameter. Check
      `Plausible.Query.from/2` for each default.

    * `filters` - optional filters to drill down data. See the Stats API
      ["Filtering"](https://plausible.io/docs/stats-api#filtering) section for
      more details.

    * `with_imported` - boolean indicating whether to include Google Analytics
      imported data or not. Defaults to `false`.

  Full example:
  ```elixir
  %{
    "from" => "2021-09-06",
    "interval" => "month",
    "metric" => "visitors",
    "period" => "custom",
    "to" => "2021-12-13"
  }
  ```

  ## Response

  Returns a map with the following keys:

    * `plot` - list of values for the requested metric representing the y-axis
      of the graph.

    * `labels` - list of date times representing the x-axis of the graph.

    * `present_index` - index of the element representing the current date in
      `labels` and `plot` lists.

    * `interval` - the interval used for querying.

    * `includes_imported` - boolean indicating whether imported data
      was queried or not.

    * `full_intervals` - map of dates indicating whether the interval has been
      cut off by the requested date range or not. For example, if looking at a
      month week-by-week, some weeks may be cut off by the month boundaries.
      It's useful to adjust the graph display slightly in case the interval is
      not 'full' so that the user understands why the numbers might be lower for
      those partial periods.

  Full example:
  ```elixir
  %{
    "full_intervals" => %{
      "2021-09-01" => false,
      "2021-10-01" => true,
      "2021-11-01" => true,
      "2021-12-01" => false
    },
    "interval" => "month",
    "labels" => ["2021-09-01", "2021-10-01", "2021-11-01", "2021-12-01"],
    "plot" => [0, 0, 0, 0],
    "present_index" => nil,
    "includes_imported" => false
  }
  ```

  """
  def main_graph(conn, params) do
    site = conn.assigns[:site]

    with {:ok, dates} <- parse_date_params(params),
         :ok <- validate_interval(params),
         :ok <- validate_interval_granularity(site, params, dates),
         params <- realtime_period_to_30m(params),
         query = Query.from(site, params, debug_metadata(conn)),
         {:ok, metric} <- parse_and_validate_graph_metric(params, query) do
      {timeseries_result, comparison_result, _meta} = Stats.timeseries(site, query, [metric])

      labels = label_timeseries(timeseries_result, comparison_result)
      present_index = present_index_for(site, query, labels)
      full_intervals = build_full_intervals(query, labels)

      json(conn, %{
        metric: metric,
        plot: plot_timeseries(timeseries_result, metric),
        labels: labels,
        comparison_plot: comparison_result && plot_timeseries(comparison_result, metric),
        comparison_labels: comparison_result && label_timeseries(comparison_result, nil),
        present_index: present_index,
        full_intervals: full_intervals
      })
    else
      {:error, message} when is_binary(message) -> bad_request(conn, message)
    end
  end

  defp plot_timeseries(timeseries, metric) do
    Enum.map(timeseries, & &1[metric])
  end

  defp label_timeseries(main_result, nil) do
    Enum.map(main_result, & &1.date)
  end

  @blank_value "__blank__"
  defp label_timeseries(main_result, comparison_result) do
    blanks_to_fill = Enum.count(comparison_result) - Enum.count(main_result)

    if blanks_to_fill > 0 do
      blanks = List.duplicate(@blank_value, blanks_to_fill)
      Enum.map(main_result, & &1.date) ++ blanks
    else
      Enum.map(main_result, & &1.date)
    end
  end

  defp build_full_intervals(
         %Query{interval: "week"} = query,
         labels
       ) do
    date_range = Query.date_range(query)
    build_intervals(labels, date_range, &Timex.beginning_of_week/1, &Timex.end_of_week/1)
  end

  defp build_full_intervals(
         %Query{interval: "month"} = query,
         labels
       ) do
    date_range = Query.date_range(query)
    build_intervals(labels, date_range, &Timex.beginning_of_month/1, &Timex.end_of_month/1)
  end

  defp build_full_intervals(_query, _labels) do
    nil
  end

  def build_intervals(labels, date_range, start_fn, end_fn) do
    for label <- labels, into: %{} do
      case Date.from_iso8601(label) do
        {:ok, date} ->
          interval_start = start_fn.(date)
          interval_end = end_fn.(date)

          within_interval? =
            Enum.member?(date_range, interval_start) && Enum.member?(date_range, interval_end)

          {label, within_interval?}

        _ ->
          {label, false}
      end
    end
  end

  def top_stats(conn, params) do
    site = conn.assigns[:site]

    params = realtime_period_to_30m(params)

    query =
      site
      |> Query.from(params, debug_metadata(conn))
      |> Query.set_include(:imports_meta, true)

    %{
      top_stats: top_stats,
      meta: meta,
      sample_percent: sample_percent,
      graphable_metrics: graphable_metrics
    } = fetch_top_stats(site, query)

    comparison_query = comparison_query(query)

    json(conn, %{
      top_stats: top_stats,
      meta: meta,
      graphable_metrics: graphable_metrics,
      interval: query.interval,
      sample_percent: sample_percent,
      with_imported_switch: with_imported_switch_info(meta),
      includes_imported: meta[:imports_included] == true,
      comparing_from: query.include.comparisons && Query.date_range(comparison_query).first,
      comparing_to: query.include.comparisons && Query.date_range(comparison_query).last,
      from: Query.date_range(query).first,
      to: Query.date_range(query).last
    })
  end

  defp with_imported_switch_info(%Jason.OrderedObject{} = meta) do
    case {meta[:imports_included], meta[:imports_skip_reason]} do
      {true, nil} ->
        %{visible: true, togglable: true, tooltip_msg: "Click to exclude imported data"}

      {false, nil} ->
        %{visible: true, togglable: true, tooltip_msg: "Click to include imported data"}

      {false, :unsupported_query} ->
        %{visible: true, togglable: false, tooltip_msg: "Imported data cannot be included"}

      {false, reason} when reason in [:no_imported_data, :out_of_range] ->
        %{visible: false, togglable: false, tooltip_msg: nil}
    end
  end

  defp present_index_for(site, query, dates) do
    case query.interval do
      "hour" ->
        current_date =
          DateTime.now!(site.timezone)
          |> Calendar.strftime("%Y-%m-%d %H:00:00")

        Enum.find_index(dates, &(&1 == current_date))

      "day" ->
        current_date =
          DateTime.now!(site.timezone)
          |> Timex.to_date()
          |> Date.to_string()

        Enum.find_index(dates, &(&1 == current_date))

      "week" ->
        date_range = Query.date_range(query)

        current_date =
          DateTime.now!(site.timezone)
          |> Timex.to_date()
          |> Time.date_or_weekstart(date_range)
          |> Date.to_string()

        Enum.find_index(dates, &(&1 == current_date))

      "month" ->
        current_date =
          DateTime.now!(site.timezone)
          |> Timex.to_date()
          |> Timex.beginning_of_month()
          |> Date.to_string()

        Enum.find_index(dates, &(&1 == current_date))

      "minute" ->
        current_date =
          DateTime.now!(site.timezone)
          |> Calendar.strftime("%Y-%m-%d %H:%M:00")

        Enum.find_index(dates, &(&1 == current_date))
    end
  end

  defp fetch_top_stats(site, query) do
    goal_filter? =
      toplevel_goal_filter?(query)

    cond do
      query.period == "30m" && goal_filter? ->
        fetch_goal_realtime_top_stats(site, query)

      query.period == "30m" ->
        fetch_realtime_top_stats(site, query)

      goal_filter? ->
        fetch_goal_top_stats(site, query)

      true ->
        fetch_other_top_stats(site, query)
    end
  end

  defp fetch_goal_realtime_top_stats(site, query) do
    query = Query.set_include(query, :comparisons, nil)

    %{
      results: %{
        visitors: %{value: unique_conversions},
        events: %{value: total_conversions}
      },
      meta: meta
    } = Stats.aggregate(site, query, [:visitors, :events])

    top_stats = [
      %{
        name: "Current visitors",
        graph_metric: :current_visitors,
        value: Stats.current_visitors(site)
      },
      %{
        name: "Unique conversions (last 30 min)",
        graph_metric: :visitors,
        value: unique_conversions
      },
      %{
        name: "Total conversions (last 30 min)",
        graph_metric: :events,
        value: total_conversions
      }
    ]

    %{
      top_stats: top_stats,
      meta: meta,
      graphable_metrics: [:visitors, :events],
      sample_percent: 100
    }
  end

  defp fetch_realtime_top_stats(site, query) do
    query = Query.set_include(query, :comparisons, nil)

    %{
      results: %{
        visitors: %{value: visitors},
        pageviews: %{value: pageviews}
      },
      meta: meta
    } = Stats.aggregate(site, query, [:visitors, :pageviews])

    top_stats = [
      %{
        name: "Current visitors",
        graph_metric: :current_visitors,
        value: Stats.current_visitors(site)
      },
      %{
        name: "Unique visitors (last 30 min)",
        graph_metric: :visitors,
        value: visitors
      },
      %{
        name: "Pageviews (last 30 min)",
        graph_metric: :pageviews,
        value: pageviews
      }
    ]

    %{
      top_stats: top_stats,
      meta: meta,
      sample_percent: 100,
      graphable_metrics: [:visitors, :pageviews]
    }
  end

  defp fetch_goal_top_stats(site, query) do
    metrics =
      [:visitors, :events, :conversion_rate] ++ @revenue_metrics

    %{results: results, meta: meta} = Stats.aggregate(site, query, metrics)

    top_stats =
      [
        top_stats_entry(results, "Unique conversions", :visitors),
        top_stats_entry(results, "Total conversions", :events),
        on_ee do
          top_stats_entry(results, "Average revenue", :average_revenue)
        end,
        on_ee do
          top_stats_entry(results, "Total revenue", :total_revenue)
        end,
        top_stats_entry(results, "Conversion rate", :conversion_rate)
      ]
      |> Enum.reject(&is_nil/1)

    %{top_stats: top_stats, meta: meta, graphable_metrics: metrics, sample_percent: 100}
  end

  defp fetch_other_top_stats(site, query) do
    page_filter? =
      Filters.filtering_on_dimension?(query, "event:page", behavioral_filters: :ignore)

    metrics = [:visitors, :visits, :pageviews, :sample_percent]

    metrics =
      cond do
        page_filter? && query.include_imported ->
          metrics ++ [:scroll_depth]

        page_filter? ->
          metrics ++ [:bounce_rate, :scroll_depth, :time_on_page]

        true ->
          metrics ++ [:views_per_visit, :bounce_rate, :visit_duration]
      end

    %{results: results, meta: meta} = Stats.aggregate(site, query, metrics)

    top_stats =
      [
        top_stats_entry(results, "Unique visitors", :visitors),
        top_stats_entry(results, "Total visits", :visits),
        top_stats_entry(results, "Total pageviews", :pageviews),
        top_stats_entry(results, "Views per visit", :views_per_visit),
        top_stats_entry(results, "Bounce rate", :bounce_rate),
        top_stats_entry(results, "Visit duration", :visit_duration),
        top_stats_entry(results, "Time on page", :time_on_page,
          formatter: fn
            nil -> 0
            value -> value
          end
        ),
        top_stats_entry(results, "Scroll depth", :scroll_depth)
      ]
      |> Enum.filter(& &1)

    sample_percent = results[:sample_percent][:value]

    %{
      top_stats: top_stats,
      meta: meta,
      graphable_metrics:
        if(TimeOnPage.new_time_on_page_visible?(site),
          do: metrics,
          else: metrics -- [:time_on_page]
        ),
      sample_percent: sample_percent
    }
  end

  defp top_stats_entry(current_results, name, key, opts \\ []) do
    if current_results[key] do
      formatter = Keyword.get(opts, :formatter, & &1)
      value = get_in(current_results, [key, :value])

      %{name: name, value: formatter.(value), graph_metric: key}
      |> maybe_put_comparison(current_results, key, formatter)
    end
  end

  defp maybe_put_comparison(entry, results, key, formatter) do
    prev_value = get_in(results, [key, :comparison_value])
    change = get_in(results, [key, :change])

    if prev_value do
      entry
      |> Map.put(:comparison_value, formatter.(prev_value))
      |> Map.put(:change, change)
    else
      entry
    end
  end

  def sources(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:source")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)

    extra_metrics =
      if params["detailed"], do: [:bounce_rate, :visit_duration], else: []

    metrics = breakdown_metrics(query, extra_metrics)

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    res =
      results
      |> transform_keys(%{source: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        res
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        res |> to_csv([:name, :visitors, :bounce_rate, :visit_duration])
      end
    else
      json(conn, %{
        results: res,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def channels(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:channel")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)

    extra_metrics =
      if params["detailed"], do: [:bounce_rate, :visit_duration], else: []

    metrics = breakdown_metrics(query, extra_metrics)

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    res =
      results
      |> transform_keys(%{channel: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        res
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        res |> to_csv([:name, :visitors, :bounce_rate, :visit_duration])
      end
    else
      json(conn, %{
        results: res,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  on_ee do
    def funnel(conn, %{"id" => funnel_id} = params) do
      site = Plausible.Repo.preload(conn.assigns.site, :team)

      with :ok <- Plausible.Billing.Feature.Funnels.check_availability(site.team),
           query <- Query.from(site, params, debug_metadata(conn)),
           :ok <- validate_funnel_query(query),
           {funnel_id, ""} <- Integer.parse(funnel_id),
           {:ok, funnel} <- Stats.funnel(site, query, funnel_id) do
        json(conn, funnel)
      else
        {:error, {:invalid_funnel_query, due_to}} ->
          bad_request(
            conn,
            "We are unable to show funnels when the dashboard is filtered by #{due_to}",
            %{
              level: :normal
            }
          )

        {:error, :funnel_not_found} ->
          conn
          |> put_status(404)
          |> json(%{error: "Funnel not found"})
          |> halt()

        {:error, :upgrade_required} ->
          H.payment_required(
            conn,
            "#{Plausible.Billing.Feature.Funnels.display_name()} is part of the Plausible Business plan. To get access to this feature, please upgrade your account."
          )

        _ ->
          bad_request(conn, "There was an error with your request")
      end
    end

    defp validate_funnel_query(query) do
      cond do
        toplevel_goal_filter?(query) ->
          {:error, {:invalid_funnel_query, "goals"}}

        Filters.filtering_on_dimension?(query, "event:page") ->
          {:error, {:invalid_funnel_query, "pages"}}

        query.period == "realtime" ->
          {:error, {:invalid_funnel_query, "realtime period"}}

        true ->
          :ok
      end
    end
  end

  def utm_mediums(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:utm_medium")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query, [:bounce_rate, :visit_duration])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    res =
      results
      |> transform_keys(%{utm_medium: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        res
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        res |> to_csv([:name, :visitors, :bounce_rate, :visit_duration])
      end
    else
      json(conn, %{
        results: res,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def utm_campaigns(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:utm_campaign")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query, [:bounce_rate, :visit_duration])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    res =
      results
      |> transform_keys(%{utm_campaign: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        res
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        res |> to_csv([:name, :visitors, :bounce_rate, :visit_duration])
      end
    else
      json(conn, %{
        results: res,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def utm_contents(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:utm_content")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query, [:bounce_rate, :visit_duration])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    res =
      results
      |> transform_keys(%{utm_content: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        res
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        res |> to_csv([:name, :visitors, :bounce_rate, :visit_duration])
      end
    else
      json(conn, %{
        results: res,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def utm_terms(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:utm_term")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query, [:bounce_rate, :visit_duration])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    res =
      results
      |> transform_keys(%{utm_term: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        res
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        res |> to_csv([:name, :visitors, :bounce_rate, :visit_duration])
      end
    else
      json(conn, %{
        results: res,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def utm_sources(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:utm_source")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query, [:bounce_rate, :visit_duration])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    res =
      results
      |> transform_keys(%{utm_source: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        res
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        res |> to_csv([:name, :visitors, :bounce_rate, :visit_duration])
      end
    else
      json(conn, %{
        results: res,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def referrers(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:referrer")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query, [:bounce_rate, :visit_duration])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    res =
      results
      |> transform_keys(%{referrer: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        res
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        res |> to_csv([:name, :visitors, :bounce_rate, :visit_duration])
      end
    else
      json(conn, %{
        results: res,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def referrer_drilldown(conn, %{"referrer" => "Google"} = params) do
    site = conn.assigns[:site]

    query = Query.from(site, params, debug_metadata(conn))

    is_admin =
      if current_user = conn.assigns[:current_user] do
        Plausible.Teams.Memberships.has_editor_access?(site, current_user)
      else
        false
      end

    pagination = {
      to_int(params["limit"], 9),
      to_int(params["page"], 0)
    }

    search = params["search"] || ""

    not_configured_error_payload = %{error_code: :not_configured, is_admin: is_admin}

    search_terms = google_api().fetch_stats(site, query, pagination, search)
    period_too_recent? = DateTime.diff(query.now, query.utc_time_range.first, :hour) < 72

    case {search_terms, period_too_recent?} do
      {{:error, :google_property_not_configured}, _} ->
        conn
        |> put_status(422)
        |> json(not_configured_error_payload)

      {{:error, :unsupported_filters}, _} ->
        conn
        |> put_status(422)
        |> json(%{error_code: :unsupported_filters})

      {{:ok, []}, _period_too_recent? = true} ->
        # We consider this an error case because Google Search Console
        # data is usually delayed 1-3 days.
        conn
        |> put_status(422)
        |> json(%{error_code: :period_too_recent})

      {{:ok, terms}, _} ->
        json(conn, %{results: terms})

      {{:error, error}, _} ->
        Logger.error("Plausible.Google.API.fetch_stats failed with error: `#{inspect(error)}`")

        conn
        |> put_status(502)
        |> json(not_configured_error_payload)
    end
  end

  def referrer_drilldown(conn, %{"referrer" => referrer} = params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:referrer")

    query =
      Query.from(site, params, debug_metadata(conn))
      |> Query.add_filter([:is, "visit:source", [referrer]])

    pagination = parse_pagination(params)

    extra_metrics =
      if params["detailed"], do: [:bounce_rate, :visit_duration], else: []

    metrics = breakdown_metrics(query, extra_metrics)

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    referrers =
      results
      |> transform_keys(%{referrer: :name})

    json(conn, %{
      results: referrers,
      meta: Stats.Breakdown.formatted_date_ranges(query),
      skip_imported_reason: meta[:imports_skip_reason]
    })
  end

  def pages(conn, params) do
    site = conn.assigns[:site]

    params = Map.put(params, "property", "event:page")
    query = Query.from(site, params, debug_metadata(conn))

    extra_metrics =
      if params["detailed"] do
        [:pageviews, :bounce_rate, :time_on_page, :scroll_depth]
      else
        []
      end

    metrics = breakdown_metrics(query, extra_metrics)
    pagination = parse_pagination(params)

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    pages =
      results
      |> transform_keys(%{page: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        pages
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        cols = [:name, :visitors, :pageviews, :bounce_rate, :time_on_page, :scroll_depth]
        pages |> to_csv(cols)
      end
    else
      json(conn, %{
        results: pages,
        meta: Map.merge(meta, Stats.Breakdown.formatted_date_ranges(query)),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def entry_pages(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:entry_page")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query, [:visits, :visit_duration])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    entry_pages =
      results
      |> transform_keys(%{entry_page: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        to_csv(entry_pages, [:name, :visitors, :conversion_rate], [
          :name,
          :conversions,
          :conversion_rate
        ])
      else
        to_csv(entry_pages, [:name, :visitors, :visits, :visit_duration], [
          :name,
          :unique_entrances,
          :total_entrances,
          :visit_duration
        ])
      end
    else
      json(conn, %{
        results: entry_pages,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def exit_pages(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:exit_page")
    query = Query.from(site, params, debug_metadata(conn))
    {limit, page} = parse_pagination(params)

    extra_metrics =
      if TableDecider.sessions_join_events?(query) do
        [:visits]
      else
        [:visits, :exit_rate]
      end

    metrics = breakdown_metrics(query, extra_metrics)

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, {limit, page})

    exit_pages =
      results
      |> transform_keys(%{exit_page: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        to_csv(exit_pages, [:name, :visitors, :conversion_rate], [
          :name,
          :conversions,
          :conversion_rate
        ])
      else
        to_csv(exit_pages, [:name, :visitors, :visits, :exit_rate], [
          :name,
          :unique_exits,
          :total_exits,
          :exit_rate
        ])
      end
    else
      json(conn, %{
        results: exit_pages,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def countries(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:country")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query, [:percentage])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    countries =
      results
      |> transform_keys(%{country: :code})

    if params["csv"] do
      countries =
        countries
        |> Enum.map(fn country ->
          country_info = get_country(country[:code])
          Map.put(country, :name, country_info.name)
        end)

      if toplevel_goal_filter?(query) do
        countries
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        countries |> to_csv([:name, :visitors])
      end
    else
      countries =
        Enum.map(countries, fn row ->
          country = get_country(row[:code])

          if country do
            Map.merge(row, %{
              name: country.name,
              flag: country.flag,
              alpha_3: country.alpha_3,
              code: country.alpha_2
            })
          else
            Map.merge(row, %{
              name: row[:code],
              flag: "",
              alpha_3: "",
              code: ""
            })
          end
        end)

      json(conn, %{
        results: countries,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def regions(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:region")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query)

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    regions =
      results
      |> transform_keys(%{region: :code})
      |> Enum.map(fn region ->
        region_entry = Location.get_subdivision(region[:code])

        if region_entry do
          country_entry = get_country(region_entry.country_code)
          Map.merge(region, %{name: region_entry.name, country_flag: country_entry.flag})
        else
          Logger.warning("Could not find region info - code: #{inspect(region[:code])}")
          Map.merge(region, %{name: region[:code]})
        end
      end)

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        regions
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        regions |> to_csv([:name, :visitors])
      end
    else
      json(conn, %{
        results: regions,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def cities(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:city")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)
    metrics = breakdown_metrics(query)

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    cities =
      results
      |> transform_keys(%{city: :code})
      |> Enum.map(fn city ->
        city_info = Location.get_city(city[:code])

        if city_info do
          country_info = get_country(city_info.country_code)

          Map.merge(city, %{
            name: city_info.name,
            country_flag: country_info.flag
          })
        else
          Logger.warning("Could not find city info - code: #{inspect(city[:code])}")

          Map.merge(city, %{name: "N/A"})
        end
      end)

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        cities
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        cities |> to_csv([:name, :visitors])
      end
    else
      json(conn, %{
        results: cities,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def browsers(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:browser")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)

    extra_metrics =
      if params["detailed"], do: [:bounce_rate, :visit_duration], else: []

    metrics = breakdown_metrics(query, extra_metrics ++ [:percentage])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    browsers =
      results
      |> transform_keys(%{browser: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        browsers
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        browsers |> to_csv([:name, :visitors])
      end
    else
      json(conn, %{
        results: browsers,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def browser_versions(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:browser_version")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)

    extra_metrics =
      if params["detailed"], do: [:bounce_rate, :visit_duration], else: []

    metrics = breakdown_metrics(query, extra_metrics ++ [:percentage])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    results =
      results
      |> transform_keys(%{browser_version: :version})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        results
        |> transform_keys(%{browser: :name, visitors: :conversions})
        |> to_csv([:name, :version, :conversions, :conversion_rate])
      else
        results
        |> transform_keys(%{browser: :name})
        |> to_csv([:name, :version, :visitors])
      end
    else
      results =
        if params["detailed"] do
          transform_keys(results, %{version: :name})
        else
          Enum.map(results, &put_combined_name_with_version(&1, :browser))
        end

      json(conn, %{
        results: results,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def operating_systems(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:os")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)

    extra_metrics =
      if params["detailed"], do: [:bounce_rate, :visit_duration], else: []

    metrics = breakdown_metrics(query, extra_metrics ++ [:percentage])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    systems =
      results
      |> transform_keys(%{os: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        systems
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        systems |> to_csv([:name, :visitors])
      end
    else
      json(conn, %{
        results: systems,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def operating_system_versions(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:os_version")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)

    extra_metrics =
      if params["detailed"], do: [:bounce_rate, :visit_duration], else: []

    metrics = breakdown_metrics(query, extra_metrics ++ [:percentage])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    results =
      results
      |> transform_keys(%{os_version: :version})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        results
        |> transform_keys(%{os: :name, visitors: :conversions})
        |> to_csv([:name, :version, :conversions, :conversion_rate])
      else
        results
        |> transform_keys(%{os: :name})
        |> to_csv([:name, :version, :visitors])
      end
    else
      results =
        if params["detailed"] do
          transform_keys(results, %{version: :name})
        else
          Enum.map(results, &put_combined_name_with_version(&1, :os))
        end

      json(conn, %{
        results: results,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def screen_sizes(conn, params) do
    site = conn.assigns[:site]
    params = Map.put(params, "property", "visit:device")
    query = Query.from(site, params, debug_metadata(conn))
    pagination = parse_pagination(params)

    extra_metrics =
      if params["detailed"], do: [:bounce_rate, :visit_duration], else: []

    metrics = breakdown_metrics(query, extra_metrics ++ [:percentage])

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    sizes =
      results
      |> transform_keys(%{device: :name})

    if params["csv"] do
      if toplevel_goal_filter?(query) do
        sizes
        |> transform_keys(%{visitors: :conversions})
        |> to_csv([:name, :conversions, :conversion_rate])
      else
        sizes |> to_csv([:name, :visitors])
      end
    else
      json(conn, %{
        results: sizes,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def conversions(conn, params) do
    pagination = parse_pagination(params)
    site = Plausible.Repo.preload(conn.assigns.site, :goals)

    params =
      params
      |> realtime_period_to_30m()
      |> Map.put("property", "event:goal")

    query = Query.from(site, params, debug_metadata(conn))

    metrics = [:visitors, :events, :conversion_rate] ++ @revenue_metrics

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    conversions =
      results
      |> transform_keys(%{goal: :name})

    if params["csv"] do
      to_csv(conversions, [:name, :visitors, :events], [
        :name,
        :unique_conversions,
        :total_conversions
      ])
    else
      json(conn, %{
        results: conversions,
        meta: Stats.Breakdown.formatted_date_ranges(query),
        skip_imported_reason: meta[:imports_skip_reason]
      })
    end
  end

  def custom_prop_values(conn, params) do
    site = Plausible.Repo.preload(conn.assigns.site, :team)
    prop_key = Map.fetch!(params, "prop_key")

    case Plausible.Props.ensure_prop_key_accessible(prop_key, site.team) do
      :ok ->
        json(conn, breakdown_custom_prop_values(conn, site, params))

      {:error, :upgrade_required} ->
        H.payment_required(
          conn,
          "#{Plausible.Billing.Feature.Props.display_name()} is part of the Plausible Business plan. To get access to this feature, please upgrade your account."
        )
    end
  end

  def all_custom_prop_values(conn, params) do
    site = conn.assigns.site
    query = Query.from(site, params, debug_metadata(conn))

    prop_names = Plausible.Stats.CustomProps.fetch_prop_names(site, query)

    prop_names =
      if Plausible.Billing.Feature.Props.enabled?(site) do
        prop_names
      else
        prop_names |> Enum.filter(&(&1 in Plausible.Props.internal_keys()))
      end

    if not Enum.empty?(prop_names) do
      values =
        prop_names
        |> Enum.map(fn prop_key ->
          breakdown_custom_prop_values(conn, site, Map.put(params, "prop_key", prop_key))
          |> Map.get(:results)
          |> Enum.map(&Map.put(&1, :property, prop_key))
          |> transform_keys(%{:name => :value})
        end)
        |> Enum.concat()

      percent_or_cr =
        if toplevel_goal_filter?(query),
          do: :conversion_rate,
          else: :percentage

      to_csv(values, [:property, :value, :visitors, :events, percent_or_cr])
    end
  end

  defp breakdown_custom_prop_values(conn, site, %{"prop_key" => prop_key} = params) do
    pagination = parse_pagination(params)
    prefixed_prop = "event:props:" <> prop_key

    params = Map.put(params, "property", prefixed_prop)

    query = Query.from(site, params, debug_metadata(conn))

    metrics =
      if toplevel_goal_filter?(query) do
        [:visitors, :events, :conversion_rate] ++ @revenue_metrics
      else
        [:visitors, :events, :percentage] ++ @revenue_metrics
      end

    %{results: results, meta: meta} = Stats.breakdown(site, query, metrics, pagination)

    props =
      results
      |> transform_keys(%{prop_key => :name})

    %{
      results: props,
      meta: Stats.Breakdown.formatted_date_ranges(query),
      skip_imported_reason: meta[:imports_skip_reason]
    }
  end

  def current_visitors(conn, _) do
    site = conn.assigns[:site]
    json(conn, Stats.current_visitors(site))
  end

  defp google_api(), do: Application.fetch_env!(:plausible, :google_api)

  def filter_suggestions(conn, params) do
    site = conn.assigns[:site]

    query = Query.from(site, params, debug_metadata(conn))

    json(
      conn,
      Stats.filter_suggestions(site, query, params["filter_name"], params["q"])
    )
  end

  def custom_prop_value_filter_suggestions(conn, %{"prop_key" => prop_key} = params) do
    site = conn.assigns[:site]

    query = Query.from(site, params, debug_metadata(conn))

    json(
      conn,
      Stats.custom_prop_value_filter_suggestions(site, query, prop_key, params["q"])
    )
  end

  defp transform_keys(result, keys_to_replace) when is_map(result) do
    for {key, val} <- result, do: {Map.get(keys_to_replace, key, key), val}, into: %{}
  end

  defp transform_keys(results, keys_to_replace) when is_list(results) do
    Enum.map(results, &transform_keys(&1, keys_to_replace))
  end

  defp parse_pagination(params) do
    limit = to_int(params["limit"], 9)
    page = to_int(params["page"], 1)
    {limit, page}
  end

  defp to_int(string, default) when is_binary(string) do
    case Integer.parse(string) do
      {i, ""} when is_integer(i) ->
        i

      _ ->
        default
    end
  end

  defp to_int(_, default), do: default

  defp to_csv(list, columns), do: to_csv(list, columns, columns)

  defp to_csv(list, columns, column_names) do
    list
    |> Enum.map(fn row -> Enum.map(columns, &row[&1]) end)
    |> (fn res -> [column_names | res] end).()
    |> NimbleCSV.RFC4180.dump_to_iodata()
  end

  defp get_country(code) do
    case Location.get_country(code) do
      nil ->
        Logger.warning("Could not find country info - code: #{inspect(code)}")

        %Location.Country{
          alpha_2: code,
          alpha_3: "N/A",
          name: code,
          flag: nil
        }

      country ->
        country
    end
  end

  defp date_validation_plug(conn, _opts) do
    case parse_date_params(conn.params) do
      {:ok, _dates} -> conn
      {:error, message} when is_binary(message) -> bad_request(conn, message)
    end
  end

  defp parse_date_params(params) do
    params
    |> Map.take(["from", "to", "date"])
    |> Enum.reduce_while({:ok, %{}}, fn {key, value}, {:ok, acc} ->
      case Date.from_iso8601(value) do
        {:ok, date} ->
          {:cont, {:ok, Map.put(acc, key, date)}}

        _ ->
          {:halt,
           {:error,
            "Failed to parse '#{key}' argument. Only ISO 8601 dates are allowed, e.g. `2019-09-07`, `2020-01-01`"}}
      end
    end)
  end

  defp validate_interval(params) do
    with %{"interval" => interval} <- params,
         true <- Plausible.Stats.Interval.valid?(interval) do
      :ok
    else
      %{} ->
        :ok

      false ->
        values = Enum.join(Plausible.Stats.Interval.list(), ", ")
        {:error, "Invalid value for interval. Accepted values are: #{values}"}
    end
  end

  defp validate_interval_granularity(site, params, dates) do
    case params do
      %{"interval" => interval, "period" => "custom", "from" => _, "to" => _} ->
        if Plausible.Stats.Interval.valid_for_period?("custom", interval,
             site: site,
             from: dates["from"],
             to: dates["to"]
           ) do
          :ok
        else
          {:error,
           "Invalid combination of interval and period. Custom ranges over 12 months must come with greater granularity, e.g. `period=custom,interval=week`"}
        end

      %{"interval" => interval, "period" => period} ->
        if Plausible.Stats.Interval.valid_for_period?(period, interval, site: site) do
          :ok
        else
          {:error,
           "Invalid combination of interval and period. Interval must be smaller than the selected period, e.g. `period=day,interval=minute`"}
        end

      _ ->
        :ok
    end
  end

  defp parse_and_validate_graph_metric(params, query) do
    metric =
      case params["metric"] do
        nil -> :visitors
        "conversions" -> :visitors
        m -> Plausible.Stats.Metrics.from_string!(m)
      end

    requires_goal_filter? = metric in [:conversion_rate, :events]
    has_goal_filter? = toplevel_goal_filter?(query)

    requires_page_filter? = metric == :scroll_depth

    has_page_filter? =
      Filters.filtering_on_dimension?(query, "event:page", behavioral_filters: :ignore)

    cond do
      requires_goal_filter? and not has_goal_filter? ->
        {:error, "Metric `#{metric}` can only be queried with a goal filter"}

      requires_page_filter? and not has_page_filter? ->
        {:error, "Metric `#{metric}` can only be queried with a page filter"}

      true ->
        {:ok, metric}
    end
  end

  defp bad_request(conn, message, extra \\ %{}) do
    payload = Map.merge(extra, %{error: message})

    conn
    |> put_status(400)
    |> json(payload)
    |> halt()
  end

  def comparison_query(query) do
    if query.include.comparisons do
      Comparisons.get_comparison_query(query)
    end
  end

  defp breakdown_metrics(query, extra_metrics \\ []) do
    if toplevel_goal_filter?(query) do
      [:visitors, :conversion_rate, :total_visitors]
    else
      [:visitors] ++ extra_metrics
    end
  end

  def put_combined_name_with_version(row, name_key) do
    name =
      case {row[name_key], row.version} do
        {@not_set, @not_set} -> @not_set
        {browser_or_os, version} -> "#{browser_or_os} #{version}"
      end

    Map.put(row, :name, name)
  end

  defp realtime_period_to_30m(%{"period" => _} = params) do
    Map.update!(params, "period", fn period ->
      if period == "realtime", do: "30m", else: period
    end)
  end

  defp realtime_period_to_30m(params), do: params

  defp toplevel_goal_filter?(query) do
    Filters.filtering_on_dimension?(query, "event:goal",
      max_depth: 0,
      behavioral_filters: :ignore
    )
  end
end
```

## File: `lib/plausible_web/controllers/api/system_controller.ex`
```
defmodule PlausibleWeb.Api.SystemController do
  use PlausibleWeb, :controller
  require Logger

  def info(conn, _params) do
    build =
      :plausible
      |> Application.get_env(:runtime_metadata)
      |> Keyword.take([:version, :commit, :created, :tags])
      |> Map.new()

    geo_database = Plausible.Geo.database_type() || "(not configured)"

    json(conn, %{
      geo_database: geo_database,
      build: build
    })
  end

  def liveness(conn, _params) do
    json(conn, %{ok: true})
  end

  @task_timeout 15_000
  def readiness(conn, _params) do
    postgres_health_task =
      Task.async(fn ->
        Ecto.Adapters.SQL.query(Plausible.Repo, "SELECT 1", [])
      end)

    clickhouse_health_task =
      Task.async(fn ->
        Ecto.Adapters.SQL.query(Plausible.ClickhouseRepo, "SELECT 1", [])
      end)

    postgres_health =
      case Task.await(postgres_health_task, @task_timeout) do
        {:ok, _} ->
          "ok"

        e ->
          Logger.error("Postgres health check failure: #{inspect(e)}")
          "error"
      end

    clickhouse_health =
      case Task.await(clickhouse_health_task, @task_timeout) do
        {:ok, _} ->
          "ok"

        e ->
          Logger.error("Clickhouse health check failure: #{inspect(e)}")
          "error"
      end

    cache_health =
      if postgres_health == "ok" and Plausible.Site.Cache.ready?() and
           Plausible.Shield.IPRuleCache.ready?() do
        "ok"
      end

    sessions_health =
      if Plausible.Session.Transfer.attempted?() do
        "ok"
      else
        "waiting"
      end

    status =
      case {postgres_health, clickhouse_health, cache_health, sessions_health} do
        {"ok", "ok", "ok", "ok"} -> 200
        _ -> 500
      end

    put_status(conn, status)
    |> json(%{
      postgres: postgres_health,
      clickhouse: clickhouse_health,
      sites_cache: cache_health,
      sessions: sessions_health
    })
  end
end
```

## File: `lib/plausible_web/controllers/auth_controller.ex`
```
defmodule PlausibleWeb.AuthController do
  use PlausibleWeb, :controller
  use Plausible.Repo
  use Plausible

  alias Plausible.Auth
  alias Plausible.Teams
  alias PlausibleWeb.TwoFactor
  alias PlausibleWeb.UserAuth
  alias PlausibleWeb.LoginPreference

  require Logger

  plug(
    PlausibleWeb.RequireLoggedOutPlug
    when action in [
           :register,
           :register_from_invitation,
           :login_form,
           :login,
           :verify_2fa_form,
           :verify_2fa,
           :verify_2fa_recovery_code_form,
           :verify_2fa_recovery_code
         ]
  )

  plug(
    PlausibleWeb.RequireAccountPlug
    when action in [
           :delete_me,
           :activate_form,
           :activate,
           :request_activation_code,
           :initiate_2fa_setup,
           :verify_2fa_setup_form,
           :verify_2fa_setup,
           :disable_2fa,
           :generate_2fa_recovery_codes,
           :select_team,
           :switch_team
         ]
  )

  plug Plausible.Plugs.RestrictUserType,
       [deny: :sso] when action in [:delete_me, :disable_2fa]

  plug(
    :clear_2fa_user
    when action not in [
           :verify_2fa_form,
           :verify_2fa,
           :verify_2fa_recovery_code_form,
           :verify_2fa_recovery_code
         ]
  )

  # Plug purging 2FA user session cookie outsite 2FA flow
  defp clear_2fa_user(conn, _opts) do
    TwoFactor.Session.clear_2fa_user(conn)
  end

  def select_team(conn, _params) do
    current_user = conn.assigns.current_user
    current_team = conn.assigns[:current_team]

    owner_name_fn = fn owner ->
      if owner.id == current_user.id do
        "You"
      else
        owner.name
      end
    end

    teams =
      current_user
      |> Teams.Users.teams()
      |> Enum.filter(& &1.setup_complete)
      |> Enum.map(fn team ->
        current_team? = current_team && team.id == current_team.id

        owners =
          Enum.map_join(team.owners, ", ", &owner_name_fn.(&1))

        many_owners? = length(team.owners) > 1

        %{
          identifier: team.identifier,
          name: team.name,
          current?: current_team?,
          many_owners?: many_owners?,
          owners: owners
        }
      end)

    case teams do
      [] ->
        redirect(conn, to: Routes.site_path(conn, :index))

      [%{identifier: sole_team_identifier}] ->
        redirect(conn, to: Routes.site_path(conn, :index, __team: sole_team_identifier))

      [_ | _] ->
        render(conn, "select_team.html", teams_selection: teams)
    end
  end

  def activate_form(conn, params) do
    user = conn.assigns.current_user
    flow = params["flow"] || PlausibleWeb.Flows.register()
    team_identifier = params["team_identifier"]

    render(conn, "activate.html",
      error: nil,
      has_email_code?: Plausible.Users.has_email_code?(user),
      has_any_memberships?: Plausible.Teams.Users.has_sites?(user),
      form_submit_url: "/activate?flow=#{flow}",
      team_identifier: team_identifier
    )
  end

  def activate(conn, %{"code" => code}) do
    user = conn.assigns[:current_user]

    has_any_invitations? = Plausible.Teams.Users.has_sites?(user, include_pending?: true)
    has_any_memberships? = Plausible.Teams.Users.has_sites?(user, include_pending?: false)

    flow = conn.params["flow"]
    team_identifier = conn.params["team_identifier"]

    case Auth.EmailVerification.verify_code(user, code) do
      :ok ->
        cond do
          team_identifier not in ["", nil] ->
            redirect_path = accept_team_invitation(conn, team_identifier, user, flow: flow)
            redirect(conn, to: redirect_path)

          has_any_memberships? ->
            handle_email_updated(conn)

          has_any_invitations? ->
            redirect_path = accept_team_invitation(conn, team_identifier, user, flow: flow)
            redirect(conn, to: redirect_path)

          true ->
            redirect(conn, to: Routes.site_path(conn, :new, flow: flow))
        end

      {:error, :incorrect} ->
        render(conn, "activate.html",
          error: "Incorrect activation code",
          has_email_code?: true,
          has_any_memberships?: has_any_memberships?,
          form_submit_url: "/activate?flow=#{flow}"
        )

      {:error, :expired} ->
        render(conn, "activate.html",
          error: "Code is expired, please request another one",
          has_email_code?: false,
          has_any_memberships?: has_any_memberships?,
          form_submit_url: "/activate?flow=#{flow}"
        )
    end
  end

  def request_activation_code(conn, _params) do
    user = conn.assigns.current_user
    Auth.EmailVerification.issue_code(user)

    conn
    |> put_flash(:success, "Activation code was sent to #{user.email}")
    |> redirect(to: Routes.auth_path(conn, :activate_form))
  end

  def password_reset_request_form(conn, _) do
    render(conn, "password_reset_request_form.html")
  end

  def password_reset_request(conn, %{"email" => ""}) do
    render(conn, "password_reset_request_form.html", error: "Please enter an email address")
  end

  def password_reset_request(conn, %{"email" => email} = params) do
    if PlausibleWeb.Captcha.verify(params["h-captcha-response"]) do
      case Auth.lookup(email) do
        {:ok, _user} ->
          token = Auth.Token.sign_password_reset(email)
          url = PlausibleWeb.Endpoint.url() <> "/password/reset?token=#{token}"
          email_template = PlausibleWeb.Email.password_reset_email(email, url)
          Plausible.Mailer.deliver_later(email_template)

          Logger.debug(
            "Password reset e-mail sent. In dev environment GET /sent-emails for details."
          )

          render(conn, "password_reset_request_success.html", email: email)

        {:error, _} ->
          render(conn, "password_reset_request_success.html", email: email)
      end
    else
      render(conn, "password_reset_request_form.html",
        error: "Please complete the captcha to reset your password"
      )
    end
  end

  def password_reset_form(conn, params) do
    case Auth.Token.verify_password_reset(params["token"]) do
      {:ok, %{email: email}} ->
        render(conn, "password_reset_form.html",
          connect_live_socket: true,
          email: email
        )

      {:error, :expired} ->
        render_error(
          conn,
          401,
          "Your token has expired. Please request another password reset link."
        )

      {:error, _} ->
        render_error(
          conn,
          401,
          "Your token is invalid. Please request another password reset link."
        )
    end
  end

  def password_reset(conn, _params) do
    conn
    |> UserAuth.log_out_user()
    |> put_flash(:login_title, "Password updated successfully")
    |> put_flash(:login_instructions, "Please log in with your new credentials")
    |> redirect(to: Routes.auth_path(conn, :login_form))
  end

  on_ee do
    def login_form(conn, params) do
      login_preference = LoginPreference.get(conn)
      error = Phoenix.Flash.get(conn.assigns.flash, :login_error)

      case {login_preference, params["prefer"], error} do
        {"sso", nil, nil} ->
          if Plausible.sso_enabled?() do
            redirect(conn, to: Routes.sso_path(conn, :login_form, return_to: params["return_to"]))
          else
            render(conn, "login_form.html")
          end

        _ ->
          render(conn, "login_form.html")
      end
    end
  else
    def login_form(conn, _params) do
      render(conn, "login_form.html")
    end
  end

  def login(conn, %{"user" => params}) do
    login(conn, params)
  end

  def login(conn, %{"email" => email, "password" => password} = params) do
    with :ok <- Auth.rate_limit(:login_ip, conn),
         {:ok, user} <- Auth.lookup(email),
         :ok <- Auth.rate_limit(:login_user, user),
         :ok <- Auth.check_password(user, password),
         :ok <- check_2fa_verified(conn, user) do
      redirect_path =
        cond do
          not is_nil(params["register_action"]) and not user.email_verified ->
            Auth.EmailVerification.issue_code(user)

            flow =
              if params["register_action"] == "register_form" do
                PlausibleWeb.Flows.register()
              else
                PlausibleWeb.Flows.invitation()
              end

            Routes.auth_path(conn, :activate_form,
              flow: flow,
              team_identifier: params["team_identifier"]
            )

          params["register_action"] == "register_from_invitation_form" ->
            accept_team_invitation(conn, params["team_identifier"], user)

          params["register_action"] == "register_form" ->
            Routes.site_path(conn, :new)

          true ->
            params["return_to"]
        end

      conn
      |> LoginPreference.clear()
      |> UserAuth.log_in_user(user, redirect_path)
    else
      {:error, :wrong_password} ->
        Auth.log_failed_login_attempt("wrong password for #{email}")

        conn
        |> put_flash(:login_error, "Wrong email or password. Please try again.")
        |> render("login_form.html")

      {:error, :user_not_found} ->
        Auth.log_failed_login_attempt("user not found for #{email}")
        Plausible.Auth.Password.dummy_calculation()

        conn
        |> put_flash(:login_error, "Wrong email or password. Please try again.")
        |> render("login_form.html")

      {:error, {:rate_limit, _}} ->
        Auth.log_failed_login_attempt("too many login attempts for #{email}")

        render_error(
          conn,
          429,
          "Too many login attempts. Wait a minute before trying again."
        )

      {:error, {:unverified_2fa, user}} ->
        query_params =
          if params["return_to"] not in [nil, ""], do: [return_to: params["return_to"]], else: []

        conn
        |> TwoFactor.Session.set_2fa_user(user)
        |> redirect(to: Routes.auth_path(conn, :verify_2fa, query_params))
    end
  end

  defp accept_team_invitation(conn, team_identifier, user, params \\ [])

  defp accept_team_invitation(conn, no_identifier, _user, params)
       when no_identifier in ["", nil] do
    Routes.site_path(conn, :index, params)
  end

  defp accept_team_invitation(conn, team_identifier, user, extra_params) do
    params = Keyword.merge([__team: team_identifier], extra_params)

    # We try switching to the team no matter the invitation presence or acceptance outcome.
    case Teams.Invitations.find_by_team_identifier(team_identifier, user) do
      {:ok, invitation} ->
        {_, _} = Teams.Invitations.accept_team_invitation(invitation, user)
        Routes.site_path(conn, :index, params)

      {:error, :invitation_not_found} ->
        Routes.site_path(conn, :index, params)
    end
  end

  defp check_2fa_verified(conn, user) do
    if Auth.TOTP.enabled?(user) and not TwoFactor.Session.remember_2fa?(conn, user) do
      {:error, {:unverified_2fa, user}}
    else
      :ok
    end
  end

  def initiate_2fa_setup(conn, _params) do
    case Auth.TOTP.initiate(conn.assigns.current_user) do
      {:ok, user, %{totp_uri: totp_uri, secret: secret}} ->
        render(conn, "initiate_2fa_setup.html", user: user, totp_uri: totp_uri, secret: secret)

      {:error, :already_setup} ->
        conn
        |> put_flash(:error, "Two-Factor Authentication is already setup for this account.")
        |> redirect(to: Routes.settings_path(conn, :security) <> "#update-2fa")
    end
  end

  def verify_2fa_setup_form(conn, _params) do
    if Auth.TOTP.initiated?(conn.assigns.current_user) do
      render(conn, "verify_2fa_setup.html")
    else
      redirect(conn, to: Routes.settings_path(conn, :security) <> "#update-2fa")
    end
  end

  def verify_2fa_setup(conn, %{"code" => code}) do
    case Auth.TOTP.enable(conn.assigns.current_user, code) do
      {:ok, _, %{recovery_codes: codes}} ->
        conn
        |> put_flash(:success, "Two-Factor Authentication is fully enabled")
        |> render("generate_2fa_recovery_codes.html", recovery_codes: codes, from_setup: true)

      {:error, :invalid_code} ->
        conn
        |> put_flash(:error, "The provided code is invalid. Please try again")
        |> render("verify_2fa_setup.html")

      {:error, :not_initiated} ->
        conn
        |> put_flash(:error, "Please enable Two-Factor Authentication for this account first.")
        |> redirect(to: Routes.settings_path(conn, :security) <> "#update-2fa")
    end
  end

  def disable_2fa(conn, %{"password" => password}) do
    case Auth.TOTP.disable(conn.assigns.current_user, password) do
      {:ok, _} ->
        conn
        |> TwoFactor.Session.clear_remember_2fa()
        |> put_flash(:success, "Two-Factor Authentication is disabled")
        |> redirect(to: Routes.settings_path(conn, :security) <> "#update-2fa")

      {:error, :invalid_password} ->
        conn
        |> put_flash(:error, "Incorrect password provided")
        |> redirect(to: Routes.settings_path(conn, :security) <> "#update-2fa")
    end
  end

  def generate_2fa_recovery_codes(conn, %{"password" => password}) do
    case Auth.TOTP.generate_recovery_codes(conn.assigns.current_user, password) do
      {:ok, codes} ->
        conn
        |> put_flash(:success, "New Recovery Codes generated")
        |> render("generate_2fa_recovery_codes.html", recovery_codes: codes, from_setup: false)

      {:error, :invalid_password} ->
        conn
        |> put_flash(:error, "Incorrect password provided")
        |> redirect(to: Routes.settings_path(conn, :security) <> "#update-2fa")

      {:error, :not_enabled} ->
        conn
        |> put_flash(:error, "Please enable Two-Factor Authentication for this account first.")
        |> redirect(to: Routes.settings_path(conn, :security) <> "#update-2fa")
    end
  end

  def verify_2fa_form(conn, _params) do
    case TwoFactor.Session.get_2fa_user(conn) do
      {:ok, user} ->
        if Auth.TOTP.enabled?(user) do
          render(conn, "verify_2fa.html",
            remember_2fa_days: TwoFactor.Session.remember_2fa_days()
          )
        else
          redirect_to_login(conn)
        end

      {:error, :not_found} ->
        redirect_to_login(conn)
    end
  end

  def verify_2fa(conn, %{"code" => code} = params) do
    with {:ok, user} <- get_2fa_user_limited(conn) do
      case Auth.TOTP.validate_code(user, code) do
        {:ok, user} ->
          conn
          |> TwoFactor.Session.maybe_set_remember_2fa(user, params["remember_2fa"])
          |> UserAuth.log_in_user(user, params["return_to"])

        {:error, :invalid_code} ->
          Auth.log_failed_login_attempt("wrong 2FA verification code provided for #{user.email}")

          conn
          |> put_flash(:error, "The provided code is invalid. Please try again")
          |> render("verify_2fa.html",
            remember_2fa_days: TwoFactor.Session.remember_2fa_days()
          )

        {:error, :not_enabled} ->
          UserAuth.log_in_user(conn, user, params["return_to"])
      end
    end
  end

  def verify_2fa_recovery_code_form(conn, _params) do
    case TwoFactor.Session.get_2fa_user(conn) do
      {:ok, user} ->
        if Auth.TOTP.enabled?(user) do
          render(conn, "verify_2fa_recovery_code.html")
        else
          redirect_to_login(conn)
        end

      {:error, :not_found} ->
        redirect_to_login(conn)
    end
  end

  def verify_2fa_recovery_code(conn, %{"recovery_code" => recovery_code}) do
    with {:ok, user} <- get_2fa_user_limited(conn) do
      case Auth.TOTP.use_recovery_code(user, recovery_code) do
        :ok ->
          UserAuth.log_in_user(conn, user)

        {:error, :invalid_code} ->
          Auth.log_failed_login_attempt("wrong 2FA recovery code provided for #{user.email}")

          conn
          |> put_flash(:error, "The provided recovery code is invalid. Please try another one")
          |> render("verify_2fa_recovery_code.html")

        {:error, :not_enabled} ->
          UserAuth.log_in_user(conn, user)
      end
    end
  end

  defp get_2fa_user_limited(conn) do
    case TwoFactor.Session.get_2fa_user(conn) do
      {:ok, user} ->
        with :ok <- Auth.rate_limit(:login_ip, conn),
             :ok <- Auth.rate_limit(:login_user, user) do
          {:ok, user}
        else
          {:error, {:rate_limit, _}} ->
            Auth.log_failed_login_attempt("too many login attempts for #{user.email}")

            conn
            |> TwoFactor.Session.clear_2fa_user()
            |> render_error(
              429,
              "Too many login attempts. Wait a minute before trying again."
            )
        end

      {:error, :not_found} ->
        conn
        |> redirect(to: Routes.auth_path(conn, :login_form))
    end
  end

  defp handle_email_updated(conn) do
    conn
    |> put_flash(:success, "Email updated successfully")
    |> redirect(to: Routes.settings_path(conn, :security) <> "#update-email")
  end

  def delete_me(conn, params) do
    case Plausible.Auth.delete_user(conn.assigns[:current_user]) do
      {:ok, :deleted} ->
        logout(conn, params)

      {:error, :active_subscription} ->
        conn
        |> put_flash(
          :error,
          "You have an active subscription which must be canceled first."
        )
        |> redirect(to: Routes.settings_path(conn, :danger_zone))

      {:error, :is_only_team_owner} ->
        conn
        |> put_flash(
          :error,
          "You can't delete your account when you are the only owner on a team."
        )
        |> redirect(to: Routes.settings_path(conn, :danger_zone))
    end
  end

  def logout(conn, params) do
    redirect_to = Map.get(params, "redirect", "/")

    conn
    |> UserAuth.log_out_user()
    |> redirect(to: redirect_to)
  end

  def google_auth_callback(conn, %{"error" => error, "state" => state} = params) do
    [site_id, redirected_to | _] = Jason.decode!(state)

    site = Repo.get(Plausible.Site, site_id)

    redirect_route =
      if redirected_to == "import" do
        Routes.site_path(conn, :settings_imports_exports, site.domain)
      else
        Routes.site_path(conn, :settings_integrations, site.domain)
      end

    case error do
      "access_denied" ->
        conn
        |> put_flash(
          :error,
          "We were unable to authenticate your Google Analytics account. Please check that you have granted us permission to 'See and download your Google Analytics data' and try again."
        )
        |> redirect(to: redirect_route)

      message when message in ["server_error", "temporarily_unavailable"] ->
        conn
        |> put_flash(
          :error,
          "We are unable to authenticate your Google Analytics account because Google's authentication service is temporarily unavailable. Please try again in a few moments."
        )
        |> redirect(to: redirect_route)

      _any ->
        Sentry.capture_message("Google OAuth callback failed. Reason: #{inspect(params)}")

        conn
        |> put_flash(
          :error,
          "We were unable to authenticate your Google Analytics account. If the problem persists, please contact support for assistance."
        )
        |> redirect(to: redirect_route)
    end
  end

  def google_auth_callback(conn, %{"code" => code, "state" => state}) do
    res = Plausible.Google.API.fetch_access_token!(code)

    [site_id, redirect_to | _] = Jason.decode!(state)

    site = Repo.get(Plausible.Site, site_id)
    expires_at = NaiveDateTime.add(NaiveDateTime.utc_now(), res["expires_in"])

    case redirect_to do
      "import" ->
        redirect(conn,
          to:
            Routes.google_analytics_path(conn, :property_form, site.domain,
              access_token: res["access_token"],
              refresh_token: res["refresh_token"],
              expires_at: NaiveDateTime.to_iso8601(expires_at)
            )
        )

      _ ->
        id_token = res["id_token"]
        [_, body, _] = String.split(id_token, ".")
        id = body |> Base.decode64!(padding: false) |> Jason.decode!()

        Plausible.Site.GoogleAuth.changeset(%Plausible.Site.GoogleAuth{}, %{
          email: id["email"],
          refresh_token: res["refresh_token"],
          access_token: res["access_token"],
          expires: expires_at,
          user_id: conn.assigns[:current_user].id,
          site_id: site_id
        })
        |> Repo.insert!()

        site = Repo.get(Plausible.Site, site_id)

        redirect(conn, to: Routes.site_path(conn, :settings_integrations, site.domain))
    end
  end

  defp redirect_to_login(conn) do
    redirect(conn, to: Routes.auth_path(conn, :login_form))
  end
end
```

## File: `lib/plausible_web/controllers/avatar_controller.ex`
```
defmodule PlausibleWeb.AvatarController do
  @moduledoc """
  This module proxies requests to BASE_URL/avatar/:hash to www.gravatar.com/avatar/:hash.

  The purpose is to make use of Gravatar's convenient avatar service without exposing information
  that could be used for tracking the Plausible user. Compared to requesting the Gravatar directly
  from the browser, this proxy module protects the Plausible user from disclosing to Gravatar:
  1. The client IP address
  2. User-Agent
  3. Referer header which can be used to track which site the user is visiting (i.e. plausible.io or self-hosted URL)

  The downside is the added latency from the request having to go through the Plausible server, rather than contacting the
  local CDN server operated by Gravatar's service.
  """
  use PlausibleWeb, :controller
  alias Plausible.HTTPClient

  @gravatar_base_url "https://www.gravatar.com"
  def avatar(conn, params) do
    url = Path.join(@gravatar_base_url, ["avatar/", params["hash"]]) <> "?s=150&d=identicon"

    case HTTPClient.impl().get(url) do
      {:ok, %Finch.Response{status: 200, body: body, headers: headers}} ->
        conn
        |> forward_headers(headers)
        |> send_resp(200, body)

      {:error, _} ->
        send_resp(conn, 400, "")
    end
  end

  @forwarded_headers ["content-type", "cache-control", "expires"]
  defp forward_headers(conn, headers) do
    headers_to_forward = Enum.filter(headers, fn {k, _} -> k in @forwarded_headers end)
    %Plug.Conn{conn | resp_headers: headers_to_forward}
  end
end
```

## File: `lib/plausible_web/controllers/billing_controller.ex`
```
defmodule PlausibleWeb.BillingController do
  use PlausibleWeb, :controller
  use Plausible.Repo
  require Logger
  require Plausible.Billing.Subscription.Status
  alias Plausible.Billing
  alias Plausible.Billing.Subscription

  plug PlausibleWeb.RequireAccountPlug

  plug Plausible.Plugs.AuthorizeTeamAccess, [:owner, :billing]

  def ping_subscription(%Plug.Conn{} = conn, _params) do
    subscribed? = Plausible.Teams.Billing.has_active_subscription?(conn.assigns.current_team)

    json(conn, %{is_subscribed: subscribed?})
  end

  def choose_plan(conn, _params) do
    team = conn.assigns.current_team

    {live_module, hide_header?} =
      if Plausible.Teams.Billing.show_new_upgrade_page?(team) do
        {PlausibleWeb.Live.ChoosePlan, true}
      else
        {PlausibleWeb.Live.LegacyChoosePlan, false}
      end

    if Plausible.Teams.Billing.enterprise_configured?(team) do
      redirect(conn, to: Routes.billing_path(conn, :upgrade_to_enterprise_plan))
    else
      render(conn, "choose_plan.html",
        live_module: live_module,
        hide_header?: hide_header?,
        disable_global_notices?: true,
        skip_plausible_tracking: true,
        connect_live_socket: true
      )
    end
  end

  def upgrade_to_enterprise_plan(conn, _params) do
    team = conn.assigns.current_team
    subscription = Plausible.Teams.Billing.get_subscription(team)

    {latest_enterprise_plan, price} =
      Plausible.Teams.Billing.latest_enterprise_plan_with_price(
        team,
        PlausibleWeb.RemoteIP.get(conn)
      )

    subscription_resumable? =
      Plausible.Billing.Subscriptions.resumable?(subscription)

    subscribed_to_latest? =
      subscription_resumable? &&
        subscription.paddle_plan_id == latest_enterprise_plan.paddle_plan_id

    cond do
      Subscription.Status.in?(subscription, [
        Subscription.Status.past_due(),
        Subscription.Status.paused()
      ]) ->
        redirect(conn, to: Routes.settings_path(conn, :subscription))

      subscribed_to_latest? ->
        render(conn, "change_enterprise_plan_contact_us.html", skip_plausible_tracking: true)

      true ->
        render(conn, "upgrade_to_enterprise_plan.html",
          latest_enterprise_plan: latest_enterprise_plan,
          price: price,
          subscription_resumable: subscription_resumable?,
          contact_link: "https://plausible.io/contact",
          skip_plausible_tracking: true
        )
    end
  end

  def upgrade_success(conn, _params) do
    render(conn, "upgrade_success.html", disable_global_notices?: true)
  end

  def change_plan_preview(conn, %{"plan_id" => new_plan_id}) do
    team = conn.assigns.current_team
    current_user = conn.assigns.current_user
    subscription = Plausible.Teams.Billing.active_subscription_for(team)

    case preview_subscription(subscription, new_plan_id) do
      {:ok, {subscription, preview_info}} ->
        render(conn, "change_plan_preview.html",
          back_link: Routes.billing_path(conn, :choose_plan),
          skip_plausible_tracking: true,
          subscription: subscription,
          preview_info: preview_info
        )

      _ ->
        msg =
          "Something went wrong with loading your plan change information. Please try again, or contact us at support@plausible.io if the issue persists."

        Sentry.capture_message("Error loading change plan preview",
          extra: %{
            message: msg,
            new_plan_id: new_plan_id,
            team_id: team.id,
            user_id: current_user.id
          }
        )

        conn
        |> put_flash(:error, msg)
        |> redirect(to: Routes.billing_path(conn, :choose_plan))
    end
  end

  def change_plan(conn, %{"new_plan_id" => new_plan_id}) do
    team = conn.assigns.current_team

    case Plausible.Teams.Billing.change_plan(team, new_plan_id) do
      {:ok, _subscription} ->
        conn
        |> put_flash(:success, "Plan changed successfully")
        |> redirect(to: Routes.settings_path(conn, :subscription))

      {:error, e} ->
        msg =
          case e do
            {:over_plan_limits, exceeded_limits} ->
              "Unable to subscribe to this plan because the following limits are exceeded: #{PlausibleWeb.TextHelpers.pretty_list(exceeded_limits)}"

            %{"code" => 147} ->
              # https://developer.paddle.com/api-reference/intro/api-error-codes
              "We were unable to charge your card. Click 'update billing info' to update your payment details and try again."

            %{"message" => msg} when not is_nil(msg) ->
              msg

            _ ->
              "Something went wrong. Please try again or contact support at support@plausible.io"
          end

        Sentry.capture_message("Error changing plans",
          extra: %{
            errors: inspect(e),
            message: msg,
            new_plan_id: new_plan_id,
            team_id: team.id,
            user_id: conn.assigns.current_user.id
          }
        )

        conn
        |> put_flash(:error, msg)
        |> redirect(to: Routes.settings_path(conn, :subscription))
    end
  end

  defp preview_subscription(nil, _new_plan_id), do: {:error, :no_subscription}

  defp preview_subscription(subscription, new_plan_id) do
    with {:ok, preview_info} <- Billing.change_plan_preview(subscription, new_plan_id) do
      {:ok, {subscription, preview_info}}
    end
  end
end
```

## File: `lib/plausible_web/controllers/debug_controller.ex`
```
defmodule PlausibleWeb.DebugController do
  use PlausibleWeb, :controller
  use Plausible.IngestRepo
  use Plausible

  import Ecto.Query

  plug(PlausibleWeb.RequireAccountPlug)
  plug(PlausibleWeb.SuperAdminOnlyPlug)

  def clickhouse(conn, params) do
    cluster? = Plausible.IngestRepo.clustered_table?("events_v2")
    on_cluster = if(cluster?, do: "ON CLUSTER '{cluster}'", else: "")

    # Ensure last logs are flushed
    IngestRepo.query("SYSTEM FLUSH LOGS #{on_cluster}")

    queries =
      from(
        l in from_query_log(cluster?),
        select: %{
          query: fragment("formatQuery(?)", l.query),
          log_comment: l.log_comment,
          type: l.type,
          event_time: l.event_time,
          query_duration_ms: l.query_duration_ms,
          query_id: l.query_id,
          memory_usage: fragment("formatReadableSize(?)", l.memory_usage),
          read_bytes: fragment("formatReadableSize(?)", l.read_bytes),
          result_bytes: fragment("formatReadableSize(?)", l.result_bytes),
          result_rows: l.result_rows
        },
        where: l.type > 1 and fragment("event_time > now() - toIntervalMinute(15)"),
        order_by: [desc: l.event_time]
      )
      |> filter_by_params(conn, params)
      |> IngestRepo.all()
      |> Enum.map(fn data ->
        Jason.decode!(data.log_comment)
        |> Map.merge(data)
        |> Map.delete(:log_comment)
      end)

    conn
    |> render("clickhouse.html",
      queries: queries
    )
  end

  defp from_query_log(cluster?) do
    case cluster? do
      true -> from(l in fragment("clusterAllReplicas('{cluster}', system.query_log)"))
      false -> from(l in fragment("system.query_log"))
    end
  end

  defp filter_by_params(q, _conn, %{"user_id" => user_id}),
    do: where(q, [l], fragment("JSONExtractInt(?, \'user_id\') = ?", l.log_comment, ^user_id))

  defp filter_by_params(q, _conn, %{"site_id" => site_id}),
    do: where(q, [l], fragment("JSONExtractInt(?, \'site_id\') = ?", l.log_comment, ^site_id))

  defp filter_by_params(q, _conn, %{"site_domain" => site_domain}),
    do:
      where(
        q,
        [l],
        fragment("JSONExtractString(?, \'site_domain\') = ?", l.log_comment, ^site_domain)
      )

  defp filter_by_params(q, conn, _),
    do: filter_by_params(q, conn, %{"user_id" => conn.assigns.current_user.id})
end
```

## File: `lib/plausible_web/controllers/error_report_controller.ex`
```
defmodule PlausibleWeb.ErrorReportController do
  use PlausibleWeb, :controller

  plug PlausibleWeb.RequireAccountPlug

  def submit_error_report(conn, %{
        "error" => %{"trace_id" => trace_id, "user_feedback" => feedback}
      }) do
    if String.length(String.trim(feedback)) > 5 do
      reported_by = "#{conn.assigns.current_user.name} <#{conn.assigns.current_user.email}>"
      email_template = PlausibleWeb.Email.error_report(reported_by, trace_id, feedback)

      Plausible.Mailer.deliver_later(email_template)
    end

    thanks(conn)
  end

  def submit_error_report(conn, _params) do
    thanks(conn)
  end

  defp thanks(conn) do
    conn
    |> put_view(PlausibleWeb.ErrorView)
    |> render("server_error_report_thanks.html",
      layout: {PlausibleWeb.LayoutView, "base_error.html"}
    )
  end
end
```

## File: `lib/plausible_web/controllers/google_analytics_controller.ex`
```
defmodule PlausibleWeb.GoogleAnalyticsController do
  use PlausibleWeb, :controller

  alias Plausible.Google
  alias Plausible.Imported
  use Plausible

  require Plausible.Imported.SiteImport

  plug(PlausibleWeb.RequireAccountPlug)

  plug(PlausibleWeb.Plugs.AuthorizeSiteAccess, [:owner, :editor, :admin, :super_admin])

  def property_form(
        conn,
        %{
          "access_token" => access_token,
          "refresh_token" => refresh_token,
          "expires_at" => expires_at
        } = params
      ) do
    site = conn.assigns.site

    redirect_route = Routes.site_path(conn, :settings_imports_exports, site.domain)

    result = Google.API.list_properties(access_token)

    error =
      case params["error"] do
        "no_data" ->
          "No data found. Nothing to import."

        "no_time_window" ->
          "Imported data time range is completely overlapping with existing data. Nothing to import."

        _ ->
          nil
      end

    case result do
      {:ok, properties} ->
        conn
        |> assign(:skip_plausible_tracking, true)
        |> render("property_form.html",
          access_token: access_token,
          refresh_token: refresh_token,
          expires_at: expires_at,
          site: conn.assigns.site,
          properties: properties,
          selected_property_error: error
        )

      {:error, :rate_limit_exceeded} ->
        conn
        |> put_flash(
          :error,
          "Google Analytics rate limit has been exceeded. Please try again later."
        )
        |> redirect(to: redirect_route)

      {:error, {:authentication_failed, message}} ->
        default_message =
          "We were unable to authenticate your Google Analytics account. Please check that you have granted us permission to 'See and download your Google Analytics data' and try again."

        message =
          if ce?() do
            message || default_message
          else
            default_message
          end

        conn
        |> put_flash(:ttl, :timer.seconds(5))
        |> put_flash(:error, message)
        |> redirect(to: redirect_route)

      {:error, :timeout} ->
        conn
        |> put_flash(
          :error,
          "Google Analytics API has timed out. Please try again."
        )
        |> redirect(to: redirect_route)

      {:error, _any} ->
        conn
        |> put_flash(
          :error,
          "We were unable to list your Google Analytics properties. If the problem persists, please contact support for assistance."
        )
        |> redirect(to: redirect_route)
    end
  end

  def property(
        conn,
        %{
          "property" => property,
          "access_token" => access_token,
          "refresh_token" => refresh_token,
          "expires_at" => expires_at
        } = params
      ) do
    site = conn.assigns.site

    redirect_route = Routes.site_path(conn, :settings_imports_exports, site.domain)

    with {:ok, api_start_date} <- Google.API.get_analytics_start_date(access_token, property),
         {:ok, api_end_date} <- Google.API.get_analytics_end_date(access_token, property),
         :ok <- ensure_dates(api_start_date, api_end_date),
         {:ok, start_date, end_date} <- Imported.clamp_dates(site, api_start_date, api_end_date) do
      redirect(conn,
        to:
          Routes.google_analytics_path(conn, :confirm, site.domain,
            property: property,
            access_token: access_token,
            refresh_token: refresh_token,
            expires_at: expires_at,
            start_date: Date.to_iso8601(start_date),
            end_date: Date.to_iso8601(end_date)
          )
      )
    else
      {:error, error} when error in [:no_data, :no_time_window] ->
        params =
          params
          |> Map.take(["access_token", "refresh_token", "expires_at"])
          |> Map.put("error", Atom.to_string(error))

        property_form(conn, params)

      {:error, :rate_limit_exceeded} ->
        conn
        |> put_flash(
          :error,
          "Google Analytics rate limit has been exceeded. Please try again later."
        )
        |> redirect(to: redirect_route)

      {:error, {:authentication_failed, message}} ->
        default_message =
          "Google Analytics authentication seems to have expired. Please try again."

        message =
          if ce?() do
            message || default_message
          else
            default_message
          end

        conn
        |> put_flash(:ttl, :timer.seconds(5))
        |> put_flash(:error, message)
        |> redirect(to: redirect_route)

      {:error, :timeout} ->
        conn
        |> put_flash(
          :error,
          "Google Analytics API has timed out. Please try again."
        )
        |> redirect(to: redirect_route)

      {:error, _any} ->
        conn
        |> put_flash(
          :error,
          "We were unable to retrieve information from Google Analytics. If the problem persists, please contact support for assistance."
        )
        |> redirect(to: redirect_route)
    end
  end

  def confirm(conn, %{
        "property" => property,
        "access_token" => access_token,
        "refresh_token" => refresh_token,
        "expires_at" => expires_at,
        "start_date" => start_date,
        "end_date" => end_date
      }) do
    site = conn.assigns.site

    start_date = Date.from_iso8601!(start_date)
    end_date = Date.from_iso8601!(end_date)

    redirect_route = Routes.site_path(conn, :settings_imports_exports, site.domain)

    case Google.API.get_property(access_token, property) do
      {:ok, %{name: property_name, id: property}} ->
        conn
        |> assign(:skip_plausible_tracking, true)
        |> render("confirm.html",
          access_token: access_token,
          refresh_token: refresh_token,
          expires_at: expires_at,
          site: site,
          selected_property: property,
          selected_property_name: property_name,
          start_date: start_date,
          end_date: end_date
        )

      {:error, :rate_limit_exceeded} ->
        conn
        |> put_flash(
          :error,
          "Google Analytics rate limit has been exceeded. Please try again later."
        )
        |> redirect(to: redirect_route)

      {:error, {:authentication_failed, message}} ->
        default_message =
          "Google Analytics authentication seems to have expired. Please try again."

        message =
          if ce?() do
            message || default_message
          else
            default_message
          end

        conn
        |> put_flash(:ttl, :timer.seconds(5))
        |> put_flash(:error, message)
        |> redirect(to: redirect_route)

      {:error, :timeout} ->
        conn
        |> put_flash(
          :error,
          "Google Analytics API has timed out. Please try again."
        )
        |> redirect(to: redirect_route)

      {:error, :not_found} ->
        conn
        |> put_flash(
          :error,
          "Google Analytics property not found. Please try again."
        )
        |> redirect(to: redirect_route)

      {:error, _any} ->
        conn
        |> put_flash(
          :error,
          "We were unable to retrieve information from Google Analytics. If the problem persists, please contact support for assistance."
        )
        |> redirect(to: redirect_route)
    end
  end

  def import(conn, %{
        "property" => property,
        "start_date" => start_date,
        "end_date" => end_date,
        "access_token" => access_token,
        "refresh_token" => refresh_token,
        "expires_at" => expires_at
      }) do
    site = conn.assigns.site
    current_user = conn.assigns.current_user

    start_date = Date.from_iso8601!(start_date)
    end_date = Date.from_iso8601!(end_date)

    redirect_route = Routes.site_path(conn, :settings_imports_exports, site.domain)

    import_opts = [
      label: property,
      property: property,
      start_date: start_date,
      end_date: end_date,
      access_token: access_token,
      refresh_token: refresh_token,
      token_expires_at: expires_at
    ]

    with {:ok, start_date, end_date} <- Imported.clamp_dates(site, start_date, end_date),
         import_opts = [{:start_date, start_date}, {:end_date, end_date} | import_opts],
         {:ok, _} <- Imported.GoogleAnalytics4.new_import(site, current_user, import_opts) do
      conn
      |> put_flash(:success, "Import scheduled. An email will be sent when it completes.")
      |> redirect(to: redirect_route)
    else
      {:error, :no_time_window} ->
        conn
        |> put_flash(
          :error,
          "Import failed. No data could be imported because date range overlaps with existing data."
        )
        |> redirect(to: redirect_route)

      {:error, :import_in_progress} ->
        conn
        |> put_flash(
          :error,
          "There's another import still in progress. Please wait until it's completed or cancel it before starting a new one."
        )
        |> redirect(to: redirect_route)
    end
  end

  defp ensure_dates(%Date{}, %Date{}), do: :ok
  defp ensure_dates(_, _), do: {:error, :no_data}
end
```

## File: `lib/plausible_web/controllers/helpers.ex`
```
defmodule PlausibleWeb.ControllerHelpers do
  import Plug.Conn
  import Phoenix.Controller

  def render_error(conn, status, message) do
    conn
    |> put_status(status)
    |> put_view(PlausibleWeb.ErrorView)
    |> render("#{status}.html", message: message, layout: error_layout())
  end

  def render_error(conn, status) do
    conn
    |> put_status(status)
    |> put_view(PlausibleWeb.ErrorView)
    |> render("#{status}.html", layout: error_layout())
  end

  defp error_layout,
    do: Application.get_env(:plausible, PlausibleWeb.Endpoint)[:render_errors][:layout]

  def debug_metadata(conn) do
    %{
      request_method: conn.method,
      request_path: conn.request_path,
      params: conn.params,
      phoenix_controller: conn.private.phoenix_controller |> to_string(),
      phoenix_action: conn.private.phoenix_action |> to_string(),
      site_id: conn.assigns.site.id,
      site_domain: conn.assigns.site.domain,
      user_id: get_user_id(conn, conn.assigns)
    }
  end

  defp get_user_id(_conn, %{current_user: user}), do: user.id

  defp get_user_id(conn, _assigns) do
    case PlausibleWeb.UserAuth.get_user_session(conn) do
      {:ok, user_session} -> user_session.user_id
      _ -> nil
    end
  end
end
```

## File: `lib/plausible_web/controllers/invitation_controller.ex`
```
defmodule PlausibleWeb.InvitationController do
  use PlausibleWeb, :controller

  alias Plausible.Teams

  plug PlausibleWeb.RequireAccountPlug

  plug PlausibleWeb.Plugs.AuthorizeSiteAccess,
       [:owner, :admin] when action in [:remove_invitation]

  def accept_invitation(conn, %{"invitation_id" => invitation_id}) do
    current_user = conn.assigns.current_user
    team = conn.assigns.current_team

    case Teams.Invitations.Accept.accept(invitation_id, current_user, team) do
      {:ok, result} ->
        team = result.team

        site =
          case result do
            %{guest_memberships: [guest_membership]} ->
              Plausible.Repo.preload(guest_membership, :site).site

            %{guest_memberships: []} ->
              nil

            %{site: site} ->
              site
          end

        if site do
          conn
          |> put_flash(:success, "You now have access to #{site.domain}")
          |> redirect(to: Routes.stats_path(conn, :stats, site.domain, []))
        else
          conn
          |> put_flash(:success, "You now have access to \"#{team.name}\" team")
          |> redirect(to: Routes.site_path(conn, :index, __team: team.identifier))
        end

      {:error, :invitation_not_found} ->
        conn
        |> put_flash(:error, "Invitation missing or already accepted")
        |> redirect(to: "/sites")

      {:error, :transfer_to_self} ->
        conn
        |> put_flash(:error, "The site is already in the current team")
        |> redirect(to: "/sites")

      {:error, :permission_denied} ->
        conn
        |> put_flash(:error, "You can't add sites in the current team")
        |> redirect(to: "/sites")

      {:error, :no_plan} ->
        conn
        |> put_flash(:error, "No existing subscription")
        |> redirect(to: "/sites")

      {:error, {:over_plan_limits, limits}} ->
        conn
        |> put_flash(
          :error,
          "Plan limits exceeded: #{PlausibleWeb.TextHelpers.pretty_list(limits)}."
        )
        |> redirect(to: "/sites")

      {:error, _} ->
        conn
        |> put_flash(:error, "Something went wrong, please try again")
        |> redirect(to: "/sites")
    end
  end

  def reject_invitation(conn, %{"invitation_id" => invitation_id}) do
    case Teams.Invitations.Reject.reject(invitation_id, conn.assigns.current_user) do
      {:ok, _invitation} ->
        conn
        |> put_flash(:success, "You have rejected the invitation")
        |> redirect(to: "/sites")

      {:error, :invitation_not_found} ->
        conn
        |> put_flash(:error, "Invitation missing or already accepted")
        |> redirect(to: "/sites")
    end
  end

  def remove_invitation(conn, %{"invitation_id" => invitation_id}) do
    case Teams.Invitations.RemoveFromSite.remove(invitation_id, conn.assigns.site) do
      {:ok, invitation_or_transfer} ->
        {site, email} =
          case invitation_or_transfer do
            %Plausible.Teams.GuestInvitation{} = guest_invitation ->
              {guest_invitation.site, guest_invitation.team_invitation.email}

            %Plausible.Teams.SiteTransfer{} = site_transfer ->
              {site_transfer.site, site_transfer.email}
          end

        conn
        |> put_flash(:success, "You have removed the invitation for #{email}")
        |> redirect(to: Routes.site_path(conn, :settings_people, site.domain))

      {:error, :invitation_not_found} ->
        conn
        |> put_flash(:error, "Invitation missing or already removed")
        |> redirect(to: Routes.site_path(conn, :settings_people, conn.assigns.site.domain))
    end
  end

  def remove_team_invitation(conn, %{"invitation_id" => invitation_id}) do
    %{current_team: team, current_user: current_user} = conn.assigns

    case Teams.Invitations.RemoveFromTeam.remove(team, invitation_id, current_user) do
      {:ok, invitation} ->
        conn
        |> put_flash(:success, "You have removed the invitation for #{invitation.email}")
        |> redirect(to: Routes.settings_path(conn, :team_general))

      {:error, :invitation_not_found} ->
        conn
        |> put_flash(:error, "Invitation missing or already removed")
        |> redirect(to: Routes.settings_path(conn, :team_general))

      {:error, :permission_denied} ->
        conn
        |> put_flash(:error, "You are not allowed to remove invitations")
        |> redirect(to: Routes.settings_path(conn, :team_general))
    end
  end
end
```

## File: `lib/plausible_web/controllers/page_controller.ex`
```
defmodule PlausibleWeb.PageController do
  use PlausibleWeb, :controller
  use Plausible.Repo

  plug PlausibleWeb.RequireLoggedOutPlug

  @doc """
  The root path is never accessible in Plausible.Cloud because it is handled by the upstream reverse proxy.

  This controller action is only ever triggered in self-hosted Plausible.
  """
  def index(conn, _params) do
    render(conn, "index.html")
  end
end
```

## File: `lib/plausible_web/controllers/settings_controller.ex`
```
defmodule PlausibleWeb.SettingsController do
  use PlausibleWeb, :controller
  use Plausible
  use Plausible.Repo

  alias Plausible.Auth
  alias Plausible.Teams

  require Logger

  plug Plausible.Plugs.AuthorizeTeamAccess,
       [:owner, :admin] when action in [:update_team_name]

  plug Plausible.Plugs.AuthorizeTeamAccess,
       [:owner, :billing] when action in [:subscription, :invoices]

  plug Plausible.Plugs.AuthorizeTeamAccess,
       [:owner] when action in [:team_danger_zone, :delete_team]

  plug Plausible.Plugs.RestrictUserType,
       [deny: :sso] when action in [:update_name, :update_email, :update_password]

  def index(conn, _params) do
    redirect(conn, to: Routes.settings_path(conn, :preferences))
  end

  def team_general(conn, _params) do
    render_team_general(conn)
  end

  def update_team_name(conn, %{"team" => params}) do
    changeset = Teams.Team.name_changeset(conn.assigns.current_team, params)

    case Repo.update(changeset) do
      {:ok, _user} ->
        conn
        |> put_flash(:success, "Team name changed")
        |> redirect(to: Routes.settings_path(conn, :team_general) <> "#update-name")

      {:error, changeset} ->
        render_team_general(conn, team_name_changeset: changeset)
    end
  end

  defp render_team_general(conn, opts \\ []) do
    if Teams.setup?(conn.assigns.current_team) do
      name_changeset =
        Keyword.get(
          opts,
          :team_name_changeset,
          Plausible.Teams.Team.name_changeset(conn.assigns.current_team)
        )

      render(conn, :team_general,
        team_name_changeset: name_changeset,
        layout: {PlausibleWeb.LayoutView, :settings},
        connect_live_socket: true
      )
    else
      conn
      |> redirect(to: Routes.site_path(conn, :index))
    end
  end

  def leave_team(conn, _params) do
    case Teams.Memberships.Leave.leave(conn.assigns.current_team, conn.assigns.current_user) do
      {:ok, _} ->
        conn
        |> put_flash(:success, "You have left \"#{Teams.name(conn.assigns.current_team)}\"")
        |> redirect(to: Routes.site_path(conn, :index, __team: "none"))

      {:error, :only_one_owner} ->
        conn
        |> put_flash(:error, "You can't leave as you are the only Owner on the team")
        |> redirect(to: Routes.settings_path(conn, :team_general))

      {:error, :membership_not_found} ->
        redirect(conn, to: Routes.site_path(conn, :index, __team: "none"))
    end
  end

  def preferences(conn, _params) do
    render_preferences(conn)
  end

  def security(conn, _params) do
    render_security(conn)
  end

  def subscription(conn, _params) do
    team = conn.assigns.current_team
    subscription = Teams.Billing.get_subscription(team)

    render(conn, :subscription,
      layout: {PlausibleWeb.LayoutView, :settings},
      subscription: subscription,
      pageview_limit: Teams.Billing.monthly_pageview_limit(subscription),
      pageview_usage: Teams.Billing.monthly_pageview_usage(team),
      site_usage: Teams.Billing.site_usage(team),
      site_limit: Teams.Billing.site_limit(team),
      team_member_limit: Teams.Billing.team_member_limit(team),
      team_member_usage: Teams.Billing.team_member_usage(team)
    )
  end

  def invoices(conn, _params) do
    subscription = Teams.Billing.get_subscription(conn.assigns.current_team)

    invoices = Plausible.Billing.paddle_api().get_invoices(subscription)
    render(conn, :invoices, layout: {PlausibleWeb.LayoutView, :settings}, invoices: invoices)
  end

  def api_keys(conn, _params) do
    current_user = conn.assigns.current_user
    current_team = conn.assigns[:current_team]

    api_keys = Auth.list_api_keys(current_user, current_team)

    render(conn, :api_keys, layout: {PlausibleWeb.LayoutView, :settings}, api_keys: api_keys)
  end

  def new_api_key(conn, _params) do
    current_team = conn.assigns[:current_team]

    sites_api_enabled? =
      Plausible.Billing.Feature.SitesAPI.check_availability(current_team) == :ok

    changeset = Auth.ApiKey.changeset(%Auth.ApiKey{type: "stats_api"}, current_team, %{})

    render(conn, "new_api_key.html", changeset: changeset, sites_api_enabled?: sites_api_enabled?)
  end

  def create_api_key(conn, %{"api_key" => %{"name" => name, "key" => key, "type" => type}}) do
    current_user = conn.assigns.current_user
    current_team = conn.assigns.current_team

    sites_api_enabled? =
      Plausible.Billing.Feature.SitesAPI.check_availability(current_team) == :ok

    api_key_fn =
      if type == "sites_api" do
        &Auth.create_sites_api_key/4
      else
        &Auth.create_stats_api_key/4
      end

    case api_key_fn.(current_user, current_team, name, key) do
      {:ok, _api_key} ->
        conn
        |> put_flash(:success, "API key created successfully")
        |> redirect(to: Routes.settings_path(conn, :api_keys) <> "#api-keys")

      {:error, :upgrade_required} ->
        conn
        |> put_flash(:error, "Your current subscription plan does not include Sites API access")
        |> redirect(to: Routes.settings_path(conn, :new_api_key))

      {:error, changeset} ->
        render(conn, "new_api_key.html",
          changeset: changeset,
          sites_api_enabled?: sites_api_enabled?
        )
    end
  end

  def delete_api_key(conn, %{"id" => id}) do
    case Auth.delete_api_key(conn.assigns.current_user, id) do
      :ok ->
        conn
        |> put_flash(:success, "API key revoked successfully")
        |> redirect(to: Routes.settings_path(conn, :api_keys) <> "#api-keys")

      {:error, :not_found} ->
        conn
        |> put_flash(:error, "Could not find API Key to delete")
        |> redirect(to: Routes.settings_path(conn, :api_keys) <> "#api-keys")
    end
  end

  def danger_zone(conn, _params) do
    solely_owned_teams =
      conn.assigns.current_user
      |> Teams.Users.owned_teams()
      |> Enum.filter(& &1.setup_complete)
      |> Enum.reject(fn team ->
        Teams.Memberships.owners_count(team) > 1
      end)

    render(conn, :danger_zone,
      solely_owned_teams: solely_owned_teams,
      layout: {PlausibleWeb.LayoutView, :settings}
    )
  end

  def team_danger_zone(conn, _params) do
    render(conn, :team_danger_zone, layout: {PlausibleWeb.LayoutView, :settings})
  end

  def delete_team(conn, _params) do
    team = conn.assigns.current_team

    case Plausible.Teams.delete(team) do
      {:ok, :deleted} ->
        conn
        |> put_flash(:success, ~s|Team "#{Plausible.Teams.name(team)}" deleted|)
        |> redirect(to: Routes.site_path(conn, :index, __team: "none"))

      {:error, :active_subscription} ->
        conn
        |> put_flash(
          :error,
          "Team has an active subscription. You must cancel it first."
        )
        |> redirect(to: Routes.settings_path(conn, :team_danger_zone))
    end
  end

  # Preferences actions

  def update_name(conn, %{"user" => params}) do
    changeset = Auth.User.name_changeset(conn.assigns.current_user, params)

    case Repo.update(changeset) do
      {:ok, _user} ->
        conn
        |> put_flash(:success, "Name changed")
        |> redirect(to: Routes.settings_path(conn, :preferences) <> "#update-name")

      {:error, changeset} ->
        render_preferences(conn, name_changeset: changeset)
    end
  end

  def update_theme(conn, %{"user" => params}) do
    changeset = Auth.User.theme_changeset(conn.assigns.current_user, params)

    case Repo.update(changeset) do
      {:ok, _user} ->
        conn
        |> put_flash(:success, "Theme changed")
        |> redirect(to: Routes.settings_path(conn, :preferences) <> "#update-theme")

      {:error, changeset} ->
        render_preferences(conn, theme_changeset: changeset)
    end
  end

  defp render_preferences(conn, opts \\ []) do
    name_changeset =
      Keyword.get(opts, :name_changeset, Auth.User.name_changeset(conn.assigns.current_user))

    theme_changeset =
      Keyword.get(opts, :theme_changeset, Auth.User.theme_changeset(conn.assigns.current_user))

    render(conn, :preferences,
      name_changeset: name_changeset,
      theme_changeset: theme_changeset,
      layout: {PlausibleWeb.LayoutView, :settings}
    )
  end

  # Security actions

  def update_email(conn, %{"user" => params}) do
    user = conn.assigns.current_user

    with :ok <- Auth.rate_limit(:email_change_user, user),
         changes = Auth.User.email_changeset(user, params),
         {:ok, user} <- Repo.update(changes) do
      if user.email_verified do
        handle_email_updated(conn)
      else
        Auth.EmailVerification.issue_code(user)
        redirect(conn, to: Routes.auth_path(conn, :activate_form))
      end
    else
      {:error, %Ecto.Changeset{} = changeset} ->
        render_security(conn, email_changeset: changeset)

      {:error, {:rate_limit, _}} ->
        changeset =
          user
          |> Auth.User.email_changeset(params)
          |> Ecto.Changeset.add_error(:email, "too many requests, try again in an hour")
          |> Map.put(:action, :validate)

        render_security(conn, email_changeset: changeset)
    end
  end

  def cancel_update_email(conn, _params) do
    changeset = Auth.User.cancel_email_changeset(conn.assigns.current_user)

    case Repo.update(changeset) do
      {:ok, user} ->
        conn
        |> put_flash(:success, "Email changed back to #{user.email}")
        |> redirect(to: Routes.settings_path(conn, :security) <> "#update-email")

      {:error, _} ->
        conn
        |> put_flash(
          :error,
          "Could not cancel email update because previous email has already been taken"
        )
        |> redirect(to: Routes.auth_path(conn, :activate_form))
    end
  end

  def update_password(conn, %{"user" => params}) do
    user = conn.assigns.current_user
    user_session = conn.assigns.current_user_session

    with :ok <- Auth.rate_limit(:password_change_user, user),
         {:ok, user} <- do_update_password(user, params) do
      Auth.UserSessions.revoke_all(user, except: user_session)

      conn
      |> put_flash(:success, "Your password is now changed")
      |> redirect(to: Routes.settings_path(conn, :security) <> "#update-password")
    else
      {:error, %Ecto.Changeset{} = changeset} ->
        render_security(conn, password_changeset: changeset)

      {:error, {:rate_limit, _}} ->
        changeset =
          user
          |> Auth.User.password_changeset(params)
          |> Ecto.Changeset.add_error(:password, "too many attempts, try again in 20 minutes")
          |> Map.put(:action, :validate)

        render_security(conn, password_changeset: changeset)
    end
  end

  defp render_security(conn, opts \\ []) do
    user_sessions = Auth.UserSessions.list_for_user(conn.assigns.current_user)

    email_changeset =
      Keyword.get(
        opts,
        :email_changeset,
        Auth.User.email_changeset(conn.assigns.current_user, %{email: ""})
      )

    password_changeset =
      Keyword.get(
        opts,
        :password_changeset,
        Auth.User.password_changeset(conn.assigns.current_user)
      )

    render(conn, :security,
      totp_enabled?: Auth.TOTP.enabled?(conn.assigns.current_user),
      user_sessions: user_sessions,
      email_changeset: email_changeset,
      password_changeset: password_changeset,
      layout: {PlausibleWeb.LayoutView, :settings}
    )
  end

  def delete_session(conn, %{"id" => session_id}) do
    current_user = conn.assigns.current_user

    :ok = Auth.UserSessions.revoke_by_id(current_user, session_id)

    conn
    |> put_flash(:success, "Session logged out successfully")
    |> redirect(to: Routes.settings_path(conn, :security) <> "#user-sessions")
  end

  defp do_update_password(user, params) do
    changes = Auth.User.password_changeset(user, params)

    Repo.transaction(fn ->
      with {:ok, user} <- Repo.update(changes),
           {:ok, user} <- validate_2fa_code(user, params["two_factor_code"]) do
        user
      else
        {:error, :invalid_2fa} ->
          changes
          |> Ecto.Changeset.add_error(:password, "invalid 2FA code")
          |> Map.put(:action, :validate)
          |> Repo.rollback()

        {:error, changeset} ->
          Repo.rollback(changeset)
      end
    end)
  end

  defp validate_2fa_code(user, code) do
    if Auth.TOTP.enabled?(user) do
      case Auth.TOTP.validate_code(user, code) do
        {:ok, user} -> {:ok, user}
        {:error, :not_enabled} -> {:ok, user}
        {:error, _} -> {:error, :invalid_2fa}
      end
    else
      {:ok, user}
    end
  end

  defp handle_email_updated(conn) do
    conn
    |> put_flash(:success, "Email updated")
    |> redirect(to: Routes.settings_path(conn, :security) <> "#update-email")
  end
end
```

## File: `lib/plausible_web/controllers/site/membership_controller.ex`
```
defmodule PlausibleWeb.Site.MembershipController do
  @moduledoc """
    This controller deals with user management via the UI in Site Settings -> People. It's important to enforce permissions in this controller.

    Owner and Admin - Can manage users, can trigger a 'transfer ownership' request
    Editor and Viewer - Can not access user management settings
    Anyone - Can accept invitations

    Everything else should be explicitly disallowed.
  """

  use PlausibleWeb, :controller
  use Plausible.Repo
  use Plausible

  alias Plausible.Teams

  plug PlausibleWeb.RequireAccountPlug

  plug PlausibleWeb.Plugs.AuthorizeSiteAccess, [:owner, :admin]

  def invite_member_form(conn, _params) do
    site =
      conn.assigns.current_user
      |> Plausible.Sites.get_for_user!(conn.assigns.site.domain)
      |> Plausible.Repo.preload(:owners)

    limit = Teams.Billing.team_member_limit(site.team)
    usage = Teams.Billing.team_member_usage(site.team)
    below_limit? = Plausible.Billing.Quota.below_limit?(usage, limit)

    render(
      conn,
      "invite_member_form.html",
      site: site,
      team_member_limit: limit,
      is_at_limit: not below_limit?,
      skip_plausible_tracking: true
    )
  end

  def invite_member(conn, %{"email" => email, "role" => role}) do
    site_domain = conn.assigns.site.domain

    site =
      Plausible.Sites.get_for_user!(conn.assigns.current_user, site_domain)
      |> Plausible.Repo.preload(:owners)

    case Teams.Invitations.InviteToSite.invite(
           site,
           conn.assigns.current_user,
           email,
           role
         ) do
      {:ok, invitation} ->
        conn
        |> put_flash(
          :success,
          "#{email} has been invited to #{site_domain} as #{PlausibleWeb.SiteView.with_indefinite_article("#{invitation.role}")}"
        )
        |> redirect(to: Routes.site_path(conn, :settings_people, site.domain))

      {:error, :already_a_member} ->
        render(conn, "invite_member_form.html",
          error: "Cannot send invite because #{email} is already a member of #{site.domain}",
          site: site,
          skip_plausible_tracking: true
        )

      {:error, {:over_limit, limit}} ->
        render(conn, "invite_member_form.html",
          error:
            "Your account is limited to #{limit} team members. You can upgrade your plan to increase this limit.",
          site: site,
          skip_plausible_tracking: true,
          is_at_limit: true,
          team_member_limit: limit
        )

      {:error, %Ecto.Changeset{} = changeset} ->
        error_msg =
          case changeset.errors[:invitation] do
            {"already sent", _} ->
              "This invitation has been already sent. To send again, remove it from pending invitations first."

            _ ->
              "Something went wrong."
          end

        conn
        |> put_flash(:error, error_msg)
        |> redirect(to: Routes.site_path(conn, :settings_people, site.domain))
    end
  end

  def transfer_ownership_form(conn, _params) do
    site_domain = conn.assigns.site.domain

    site =
      Plausible.Sites.get_for_user!(conn.assigns.current_user, site_domain)

    render(
      conn,
      "transfer_ownership_form.html",
      site: site,
      skip_plausible_tracking: true
    )
  end

  def transfer_ownership(conn, %{"email" => email}) do
    site_domain = conn.assigns.site.domain

    site =
      Plausible.Sites.get_for_user!(conn.assigns.current_user, site_domain)

    case Teams.Invitations.InviteToSite.invite(
           site,
           conn.assigns.current_user,
           email,
           :owner
         ) do
      {:ok, _invitation} ->
        conn
        |> put_flash(:success, "Site transfer request has been sent to #{email}")
        |> redirect(to: Routes.site_path(conn, :settings_people, site.domain))

      {:error, changeset} ->
        errors = Plausible.ChangesetHelpers.traverse_errors(changeset)

        message =
          case errors do
            %{invitation: ["already sent" | _]} -> "Invitation has already been sent"
            _other -> "Site transfer request to #{email} has failed"
          end

        conn
        |> put_flash(:ttl, :timer.seconds(5))
        |> put_flash(:error_title, "Transfer error")
        |> put_flash(:error, message)
        |> redirect(to: Routes.site_path(conn, :settings_people, site.domain))
    end
  end

  def change_team_form(conn, _params) do
    site_domain = conn.assigns.site.domain
    user = conn.assigns.current_user

    site =
      Plausible.Sites.get_for_user!(user, site_domain)

    render_change_team_form(conn, user, site)
  end

  defp render_change_team_form(conn, user, site, opts \\ []) do
    transferable_teams =
      user
      |> Plausible.Teams.Users.teams(roles: [:owner, :admin])
      |> Enum.reject(&(&1.id == site.team_id))
      |> Enum.map(&{&1.name, &1.identifier})

    render(
      conn,
      "change_team_form.html",
      site: site,
      skip_plausible_tracking: true,
      transferable_teams: transferable_teams,
      error: opts[:error]
    )
  end

  def change_team(conn, %{"team_identifier" => identifier}) do
    site_domain = conn.assigns.site.domain
    user = conn.assigns.current_user

    site =
      Plausible.Sites.get_for_user!(user, site_domain)

    destination_team =
      Repo.one!(Teams.Users.teams_query(user, roles: [:admin, :owner], identifier: identifier))

    case Teams.Sites.Transfer.change_team(
           site,
           conn.assigns.current_user,
           destination_team
         ) do
      :ok ->
        conn
        |> put_flash(:success, "Site team was changed")
        |> redirect(to: Routes.site_path(conn, :index, __team: identifier))

      {:error, :no_plan} ->
        conn
        |> render_change_team_form(conn.assigns.current_user, site,
          error:
            "This team doesn't have a subscription. Please start a subscription for " <>
              "the team first and then try moving the site again"
        )

      {:error, {:over_plan_limits, _}} ->
        conn
        |> render_change_team_form(conn.assigns.current_user, site,
          error:
            "This site's usage is over the limits of the team's subscription. " <>
              "Please upgrade the team to an appropriate subscription and then try moving the site again"
        )

      {:error, _} ->
        conn
        |> render_change_team_form(conn.assigns.current_user, site,
          error: "Sorry, this team cannot be used"
        )
    end
  end

  @doc """
    Updates the role of a user. The user being updated could be the same or different from the user taking
    the action. When updating the role, it's important to enforce permissions:

    Owner - Can update anyone's role except for themselves. If they want to change their own role, they have to use the 'transfer ownership' feature.
    Admin - Can update anyone's role except for owners. Can downgrade their own access to 'viewer'. Can promote a viewer to admin.
  """
  def update_role_by_user(conn, %{"id" => user_id, "new_role" => new_role_str}) do
    %{site: site, current_user: current_user, site_role: site_role} = conn.assigns

    case Teams.Memberships.update_role(
           site,
           user_id,
           new_role_str,
           current_user,
           site_role
         ) do
      {:ok, guest_membership} ->
        redirect_target =
          if guest_membership.team_membership.user_id == current_user.id and
               guest_membership.role == :viewer do
            Routes.stats_path(conn, :stats, site.domain, [])
          else
            Routes.site_path(conn, :settings_people, site.domain)
          end

        conn
        |> put_flash(
          :success,
          "#{guest_membership.team_membership.user.name} is now #{PlausibleWeb.SiteView.with_indefinite_article(to_string(guest_membership.role))}"
        )
        |> redirect(to: redirect_target)

      {:error, _} ->
        conn
        |> put_flash(:error, "You are not allowed to grant the #{new_role_str} role")
        |> redirect(to: Routes.site_path(conn, :settings_people, site.domain))
    end
  end

  def remove_member_by_user(conn, %{"id" => user_id} = _params) do
    site = conn.assigns.site

    if user = Repo.get(Plausible.Auth.User, user_id) do
      Teams.Memberships.remove(site, user)

      redirect_target =
        if user_id == conn.assigns[:current_user].id do
          Routes.stats_path(conn, :index, site.domain, [])
        else
          Routes.site_path(conn, :settings_people, site.domain)
        end

      conn
      |> put_flash(
        :success,
        "#{user.name} has been removed from #{site.domain}"
      )
      |> redirect(to: redirect_target)
    else
      conn
      |> put_flash(
        :success,
        "User has been removed from #{site.domain}"
      )
      |> redirect(to: Routes.site_path(conn, :settings_people, site.domain))
    end
  end
end
```

## File: `lib/plausible_web/controllers/site_controller.ex`
```
defmodule PlausibleWeb.SiteController do
  use PlausibleWeb, :controller
  use Plausible.Repo
  use Plausible

  alias Plausible.Sites

  @unrestricted_actions [:new, :create_site]
  @destructive_actions [:settings_danger_zone, :reset_stats, :delete_site]

  @special_cased_actions @unrestricted_actions ++ @destructive_actions

  plug(PlausibleWeb.RequireAccountPlug)

  plug(
    PlausibleWeb.Plugs.AuthorizeSiteAccess,
    [:owner, :admin, :editor, :super_admin]
    when action not in @special_cased_actions
  )

  plug(
    PlausibleWeb.Plugs.AuthorizeSiteAccess,
    [:owner, :admin, :super_admin] when action in @destructive_actions
  )

  def new(conn, params) do
    flow = params["flow"] || PlausibleWeb.Flows.register()
    team = conn.assigns.current_team

    render(conn, "new.html",
      changeset: Plausible.Site.changeset(%Plausible.Site{}),
      site_limit: Plausible.Teams.Billing.site_limit(team),
      site_limit_exceeded?: Plausible.Teams.Billing.ensure_can_add_new_site(team) != :ok,
      form_submit_url: "/sites?flow=#{flow}",
      flow: flow
    )
  end

  def create_site(conn, %{"site" => site_params}) do
    team = conn.assigns.current_team
    user = conn.assigns.current_user
    first_site? = Plausible.Teams.Billing.site_usage(team) == 0
    flow = conn.params["flow"]

    case Sites.create(user, site_params, team) do
      {:ok, %{site: site}} ->
        if first_site? do
          PlausibleWeb.Email.welcome_email(user)
          |> Plausible.Mailer.send()
        end

        redirect(conn,
          to:
            Routes.site_path(conn, :installation, site.domain,
              site_created: true,
              flow: flow
            )
        )

      {:error, _, :permission_denied, _} ->
        conn
        |> put_flash(:error, "You are not permitted to add sites in the current team")
        |> render("new.html",
          changeset: Plausible.Site.changeset(%Plausible.Site{}),
          first_site?: first_site?,
          site_limit: Plausible.Teams.Billing.site_limit(team),
          site_limit_exceeded?: false,
          flow: flow,
          form_submit_url: "/sites?flow=#{flow}"
        )

      {:error, _, {:over_limit, limit}, _} ->
        render(conn, "new.html",
          changeset: Plausible.Site.changeset(%Plausible.Site{}),
          first_site?: first_site?,
          site_limit: limit,
          site_limit_exceeded?: true,
          flow: flow,
          form_submit_url: "/sites?flow=#{flow}"
        )

      {:error, _, changeset, _} ->
        render(conn, "new.html",
          changeset: changeset,
          first_site?: first_site?,
          site_limit: Plausible.Teams.Billing.site_limit(team),
          site_limit_exceeded?: false,
          flow: flow,
          form_submit_url: "/sites?flow=#{flow}"
        )
    end
  end

  def update_feature_visibility(conn, %{
        "setting" => setting,
        "r" => "/" <> _ = redirect_path,
        "set" => value
      })
      when setting in ~w[conversions_enabled funnels_enabled props_enabled] and
             value in ["true", "false"] do
    site = conn.assigns[:site]
    toggle_field = String.to_existing_atom(setting)

    feature_mod =
      Enum.find(Plausible.Billing.Feature.list(), &(&1.toggle_field() == toggle_field))

    case feature_mod.toggle(site, conn.assigns.current_user, override: value == "true") do
      {:ok, updated_site} ->
        message =
          if Map.fetch!(updated_site, toggle_field) do
            "#{feature_mod.display_name()} are now visible again on your dashboard"
          else
            "#{feature_mod.display_name()} are now hidden from your dashboard"
          end

        conn
        |> put_flash(:success, message)
        |> redirect(to: redirect_path)

      {:error, _} ->
        conn
        |> put_flash(
          :error,
          "Something went wrong. Failed to toggle #{feature_mod.display_name()} on your dashboard."
        )
        |> redirect(to: redirect_path)
    end
  end

  def settings(conn, %{"domain" => domain}) do
    redirect(conn, to: Routes.site_path(conn, :settings_general, domain))
  end

  def settings_general(conn, _params) do
    site = conn.assigns[:site]

    conn
    |> render("settings_general.html",
      site: site,
      changeset: Plausible.Site.changeset(site, %{}),
      connect_live_socket: true,
      dogfood_page_path: "/:dashboard/settings/general",
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def settings_people(conn, _params) do
    site = Repo.preload(conn.assigns.site, :team)

    %{memberships: memberships, invitations: invitations} =
      Sites.list_people(site)

    conn
    |> render("settings_people.html",
      site: site,
      memberships: memberships,
      invitations: invitations,
      dogfood_page_path: "/:dashboard/settings/people",
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def settings_visibility(conn, _params) do
    site = conn.assigns[:site]

    shared_links =
      Repo.all(
        from(l in Plausible.Site.SharedLink,
          where:
            l.site_id == ^site.id and l.name not in ^Plausible.Sites.shared_link_special_names()
        )
      )

    conn
    |> render("settings_visibility.html",
      site: site,
      shared_links: shared_links,
      dogfood_page_path: "/:dashboard/settings/visibility",
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def settings_goals(conn, _params) do
    conn
    |> render("settings_goals.html",
      dogfood_page_path: "/:dashboard/settings/goals",
      connect_live_socket: true,
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def settings_funnels(conn, _params) do
    conn
    |> render("settings_funnels.html",
      dogfood_page_path: "/:dashboard/settings/funnels",
      connect_live_socket: true,
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def settings_props(conn, _params) do
    conn
    |> render("settings_props.html",
      dogfood_page_path: "/:dashboard/settings/properties",
      layout: {PlausibleWeb.LayoutView, "site_settings.html"},
      connect_live_socket: true
    )
  end

  def settings_email_reports(conn, _params) do
    site = conn.assigns[:site]

    conn
    |> render("settings_email_reports.html",
      site: site,
      weekly_report: Repo.get_by(Plausible.Site.WeeklyReport, site_id: site.id),
      monthly_report: Repo.get_by(Plausible.Site.MonthlyReport, site_id: site.id),
      spike_notification:
        Repo.get_by(Plausible.Site.TrafficChangeNotification, site_id: site.id, type: :spike),
      drop_notification:
        Repo.get_by(Plausible.Site.TrafficChangeNotification, site_id: site.id, type: :drop),
      dogfood_page_path: "/:dashboard/settings/email-reports",
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def settings_danger_zone(conn, _params) do
    site = conn.assigns[:site]

    conn
    |> render("settings_danger_zone.html",
      site: site,
      dogfood_page_path: "/:dashboard/settings/danger-zone",
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def settings_integrations(conn, _params) do
    site =
      conn.assigns.site
      |> Repo.preload([:google_auth])

    search_console_domains =
      if site.google_auth do
        Plausible.Google.API.fetch_verified_properties(site.google_auth)
      end

    has_plugins_tokens? = Plausible.Plugins.API.Tokens.any?(site)

    conn
    |> render("settings_integrations.html",
      site: site,
      has_plugins_tokens?: has_plugins_tokens?,
      search_console_domains: search_console_domains,
      dogfood_page_path: "/:dashboard/settings/integrations",
      connect_live_socket: true,
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def settings_shields(conn, %{"shield" => shield})
      when shield in ["ip_addresses", "countries", "pages", "hostnames"] do
    site = conn.assigns.site

    conn
    |> render("settings_shields.html",
      site: site,
      shield: shield,
      dogfood_page_path: "/:dashboard/settings/shields/#{shield}",
      connect_live_socket: true,
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def settings_imports_exports(conn, _params) do
    site = conn.assigns.site

    conn
    |> render("settings_imports_exports.html",
      site: site,
      dogfood_page_path: "/:dashboard/settings/imports-exports",
      connect_live_socket: true,
      layout: {PlausibleWeb.LayoutView, "site_settings.html"}
    )
  end

  def update_google_auth(conn, %{"google_auth" => attrs}) do
    site = conn.assigns[:site] |> Repo.preload(:google_auth)

    Plausible.Site.GoogleAuth.set_property(site.google_auth, attrs)
    |> Repo.update!()

    conn
    |> put_flash(:success, "Google integration saved successfully")
    |> redirect(to: Routes.site_path(conn, :settings_integrations, site.domain))
  end

  def delete_google_auth(conn, _params) do
    site =
      conn.assigns[:site]
      |> Repo.preload(:google_auth)

    Repo.delete!(site.google_auth)

    conn = put_flash(conn, :success, "Google account unlinked from Plausible")

    redirect(conn, to: Routes.site_path(conn, :settings_integrations, site.domain))
  end

  def update_settings(conn, %{"site" => site_params}) do
    site = conn.assigns[:site]
    changeset = Plausible.Site.update_changeset(site, site_params)

    case Repo.update(changeset) do
      {:ok, site} ->
        site_session_key = "authorized_site__" <> site.domain

        conn
        |> put_session(site_session_key, nil)
        |> put_flash(:success, "Your site settings have been saved")
        |> redirect(to: Routes.site_path(conn, :settings_general, site.domain))

      {:error, changeset} ->
        conn
        |> put_flash(:error, "Could not update your site settings")
        |> render("settings_general.html",
          site: site,
          changeset: changeset,
          layout: {PlausibleWeb.LayoutView, "site_settings.html"}
        )
    end
  end

  def reset_stats(conn, _params) do
    site = conn.assigns[:site]
    Plausible.Purge.reset!(site)

    conn
    |> put_flash(:success, "#{site.domain} stats will be reset in a few minutes")
    |> redirect(to: Routes.site_path(conn, :settings_danger_zone, site.domain))
  end

  def delete_site(conn, _params) do
    site = conn.assigns[:site]

    Plausible.Site.Removal.run(site)

    conn
    |> put_flash(:success, "Your site and page views deletion process has started.")
    |> redirect(to: "/sites")
  end

  def make_public(conn, _params) do
    site =
      conn.assigns[:site]
      |> Plausible.Site.make_public()
      |> Repo.update!()

    conn
    |> put_flash(:success, "Stats for #{site.domain} are now public.")
    |> redirect(to: Routes.site_path(conn, :settings_visibility, site.domain))
  end

  def make_private(conn, _params) do
    site =
      conn.assigns[:site]
      |> Plausible.Site.make_private()
      |> Repo.update!()

    conn
    |> put_flash(:success, "Stats for #{site.domain} are now private.")
    |> redirect(to: Routes.site_path(conn, :settings_visibility, site.domain))
  end

  def enable_weekly_report(conn, _params) do
    site = conn.assigns[:site]

    result =
      Plausible.Site.WeeklyReport.changeset(%Plausible.Site.WeeklyReport{}, %{
        site_id: site.id,
        recipients: [conn.assigns[:current_user].email]
      })
      |> Repo.insert()

    :ok = tolerate_unique_contraint_violation(result, "weekly_reports_site_id_index")

    conn
    |> put_flash(:success, "You will receive an email report every Monday going forward")
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def disable_weekly_report(conn, _params) do
    site = conn.assigns[:site]
    Repo.delete_all(from(wr in Plausible.Site.WeeklyReport, where: wr.site_id == ^site.id))

    conn
    |> put_flash(:success, "You will not receive weekly email reports going forward")
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def add_weekly_report_recipient(conn, %{"recipient" => recipient}) do
    site = conn.assigns[:site]

    Repo.get_by(Plausible.Site.WeeklyReport, site_id: site.id)
    |> Plausible.Site.WeeklyReport.add_recipient(recipient)
    |> Repo.update!()

    conn
    |> put_flash(:success, "Added #{recipient} as a recipient for the weekly report")
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def remove_weekly_report_recipient(conn, %{"recipient" => recipient}) do
    site = conn.assigns[:site]

    Repo.get_by(Plausible.Site.WeeklyReport, site_id: site.id)
    |> Plausible.Site.WeeklyReport.remove_recipient(recipient)
    |> Repo.update!()

    conn
    |> put_flash(
      :success,
      "Removed #{recipient} as a recipient for the weekly report"
    )
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def enable_monthly_report(conn, _params) do
    site = conn.assigns[:site]

    result =
      %Plausible.Site.MonthlyReport{}
      |> Plausible.Site.MonthlyReport.changeset(%{
        site_id: site.id,
        recipients: [conn.assigns[:current_user].email]
      })
      |> Repo.insert()

    :ok = tolerate_unique_contraint_violation(result, "monthly_reports_site_id_index")

    conn
    |> put_flash(:success, "You will receive an email report every month going forward")
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def disable_monthly_report(conn, _params) do
    site = conn.assigns[:site]
    Repo.delete_all(from(mr in Plausible.Site.MonthlyReport, where: mr.site_id == ^site.id))

    conn
    |> put_flash(:success, "You will not receive monthly email reports going forward")
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def add_monthly_report_recipient(conn, %{"recipient" => recipient}) do
    site = conn.assigns[:site]

    Repo.get_by(Plausible.Site.MonthlyReport, site_id: site.id)
    |> Plausible.Site.MonthlyReport.add_recipient(recipient)
    |> Repo.update!()

    conn
    |> put_flash(:success, "Added #{recipient} as a recipient for the monthly report")
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def remove_monthly_report_recipient(conn, %{"recipient" => recipient}) do
    site = conn.assigns[:site]

    Repo.get_by(Plausible.Site.MonthlyReport, site_id: site.id)
    |> Plausible.Site.MonthlyReport.remove_recipient(recipient)
    |> Repo.update!()

    conn
    |> put_flash(
      :success,
      "Removed #{recipient} as a recipient for the monthly report"
    )
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def enable_traffic_change_notification(conn, %{"type" => type}) do
    site = conn.assigns[:site]

    res =
      Plausible.Site.TrafficChangeNotification.changeset(
        %Plausible.Site.TrafficChangeNotification{},
        %{
          site_id: site.id,
          type: type,
          threshold: if(type == "spike", do: 10, else: 1),
          recipients: [conn.assigns[:current_user].email]
        }
      )
      |> Repo.insert()

    case res do
      {:ok, _} ->
        conn
        |> put_flash(:success, "Traffic #{type} notifications enabled")
        |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))

      {:error, _} ->
        conn
        |> put_flash(:error, "Unable to create a #{type} notification")
        |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
    end
  end

  def disable_traffic_change_notification(conn, %{"type" => type}) do
    site = conn.assigns[:site]

    Repo.delete_all(
      from(mr in Plausible.Site.TrafficChangeNotification,
        where: mr.site_id == ^site.id and mr.type == ^type
      )
    )

    conn
    |> put_flash(:success, "Traffic #{type} notifications disabled")
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def update_traffic_change_notification(conn, %{
        "traffic_change_notification" => params,
        "type" => type
      }) do
    site = conn.assigns[:site]

    notification =
      Repo.get_by(Plausible.Site.TrafficChangeNotification, site_id: site.id, type: type)

    Plausible.Site.TrafficChangeNotification.changeset(notification, params)
    |> Repo.update!()

    conn
    |> put_flash(:success, "Notification settings updated")
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def add_traffic_change_notification_recipient(conn, %{"recipient" => recipient, "type" => type}) do
    site = conn.assigns[:site]

    Repo.get_by(Plausible.Site.TrafficChangeNotification, site_id: site.id, type: type)
    |> Plausible.Site.TrafficChangeNotification.add_recipient(recipient)
    |> Repo.update!()

    conn
    |> put_flash(:success, "Added #{recipient} as a recipient for the traffic spike notification")
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def remove_traffic_change_notification_recipient(conn, %{
        "recipient" => recipient,
        "type" => type
      }) do
    site = conn.assigns[:site]

    Repo.get_by(Plausible.Site.TrafficChangeNotification, site_id: site.id, type: type)
    |> Plausible.Site.TrafficChangeNotification.remove_recipient(recipient)
    |> Repo.update!()

    conn
    |> put_flash(
      :success,
      "Removed #{recipient} as a recipient for the monthly report"
    )
    |> redirect(to: Routes.site_path(conn, :settings_email_reports, site.domain))
  end

  def new_shared_link(conn, _params) do
    site = conn.assigns[:site]
    changeset = Plausible.Site.SharedLink.changeset(%Plausible.Site.SharedLink{}, %{})

    conn
    |> assign(:skip_plausible_tracking, true)
    |> render("new_shared_link.html",
      site: site,
      changeset: changeset
    )
  end

  def create_shared_link(conn, %{"shared_link" => link}) do
    site = conn.assigns[:site]

    case Sites.create_shared_link(site, link["name"], password: link["password"]) do
      {:ok, _created} ->
        redirect(conn, to: Routes.site_path(conn, :settings_visibility, site.domain))

      {:error, :upgrade_required} ->
        conn
        |> put_flash(:error, "Your current subscription plan does not include Shared Links")
        |> redirect(to: Routes.site_path(conn, :settings_visibility, site.domain))

      {:error, changeset} ->
        conn
        |> assign(:skip_plausible_tracking, true)
        |> render("new_shared_link.html",
          site: site,
          changeset: changeset
        )
    end
  end

  def edit_shared_link(conn, %{"slug" => slug}) do
    site = conn.assigns[:site]
    shared_link = Repo.get_by(Plausible.Site.SharedLink, slug: slug)
    changeset = Plausible.Site.SharedLink.changeset(shared_link, %{})

    conn
    |> assign(:skip_plausible_tracking, true)
    |> render("edit_shared_link.html",
      site: site,
      changeset: changeset
    )
  end

  def update_shared_link(conn, %{"slug" => slug, "shared_link" => params}) do
    site = conn.assigns[:site]
    shared_link = Repo.get_by(Plausible.Site.SharedLink, slug: slug)
    changeset = Plausible.Site.SharedLink.changeset(shared_link, params)

    case Repo.update(changeset) do
      {:ok, _updated} ->
        redirect(conn, to: Routes.site_path(conn, :settings_visibility, site.domain))

      {:error, changeset} ->
        conn
        |> assign(:skip_plausible_tracking, true)
        |> render("edit_shared_link.html",
          site: site,
          changeset: changeset
        )
    end
  end

  def delete_shared_link(conn, %{"slug" => slug}) do
    site = conn.assigns[:site]
    site_id = site.id

    case Repo.delete_all(
           from(l in Plausible.Site.SharedLink,
             where: l.slug == ^slug,
             where: l.site_id == ^site_id
           )
         ) do
      {1, _} ->
        conn
        |> put_flash(:success, "Shared Link deleted")
        |> redirect(to: Routes.site_path(conn, :settings_visibility, site.domain))

      {0, _} ->
        conn
        |> put_flash(:error, "Could not find Shared Link")
        |> redirect(to: Routes.site_path(conn, :settings_visibility, site.domain))
    end
  end

  def forget_import(conn, %{"import_id" => import_id}) do
    site = conn.assigns.site

    if site_import = Plausible.Imported.get_import(site, import_id) do
      Oban.cancel_all_jobs(
        from(j in Oban.Job,
          where:
            j.queue == "analytics_imports" and
              fragment("(? ->> 'import_id')::int", j.args) == ^site_import.id
        )
      )

      Plausible.Purge.delete_imported_stats!(site_import)

      Plausible.Repo.delete!(site_import)
    end

    conn
    |> put_flash(:success, "Imported data has been cleared")
    |> redirect(to: Routes.site_path(conn, :settings_imports_exports, site.domain))
  end

  def forget_imported(conn, _params) do
    site = conn.assigns.site

    import_ids =
      site
      |> Plausible.Imported.list_all_imports()
      |> Enum.map(& &1.id)

    if import_ids != [] do
      Oban.cancel_all_jobs(
        from(j in Oban.Job,
          where:
            j.queue == "analytics_imports" and
              fragment("(? ->> 'import_id')::int", j.args) in ^import_ids
        )
      )

      Plausible.Purge.delete_imported_stats!(site)

      Plausible.Imported.delete_imports_for_site(site)
    end

    conn
    |> put_flash(:success, "Imported data has been cleared")
    |> redirect(to: Routes.site_path(conn, :settings_integrations, site.domain))
  end

  on_ee do
    def download_export(conn, _params) do
      %{id: site_id, domain: domain} = conn.assigns.site

      if s3_export = Plausible.Exports.get_s3_export!(site_id) do
        s3_bucket = Plausible.S3.exports_bucket()
        download_url = Plausible.S3.download_url(s3_bucket, s3_export.path)
        redirect(conn, external: download_url)
      else
        conn
        |> put_flash(:error, "Export not found")
        |> redirect(to: Routes.site_path(conn, :settings_imports_exports, domain))
      end
    end
  else
    def download_export(conn, _params) do
      %{id: site_id, domain: domain, timezone: timezone} = conn.assigns.site

      if local_export = Plausible.Exports.get_local_export(site_id, domain, timezone) do
        %{path: export_path, name: name} = local_export

        conn
        |> put_resp_content_type("application/zip")
        |> put_resp_header("content-disposition", Plausible.Exports.content_disposition(name))
        |> send_file(200, export_path)
      else
        conn
        |> put_flash(:error, "Export not found")
        |> redirect(to: Routes.site_path(conn, :settings_imports_exports, domain))
      end
    end
  end

  def csv_import(conn, _params) do
    conn
    |> assign(:skip_plausible_tracking, true)
    |> render("csv_import.html",
      connect_live_socket: true
    )
  end

  def change_domain(conn, _params) do
    if FunWithFlags.enabled?(:scriptv2, for: conn.assigns.site) do
      redirect(conn,
        to: Routes.site_path(conn, :change_domain_v2, conn.assigns.site.domain)
      )
    else
      changeset = Plausible.Site.update_changeset(conn.assigns.site)

      render(conn, "change_domain.html",
        skip_plausible_tracking: true,
        changeset: changeset
      )
    end
  end

  def change_domain_submit(conn, %{"site" => %{"domain" => new_domain}}) do
    case Plausible.Site.Domain.change(conn.assigns.site, new_domain) do
      {:ok, updated_site} ->
        conn
        |> put_flash(:success, "Website domain changed successfully")
        |> redirect(
          to:
            Routes.site_path(conn, :installation, updated_site.domain,
              flow: PlausibleWeb.Flows.domain_change()
            )
        )

      {:error, changeset} ->
        render(conn, "change_domain.html",
          skip_plausible_tracking: true,
          changeset: changeset
        )
    end
  end

  defp tolerate_unique_contraint_violation(result, name) do
    case result do
      {:ok, _} ->
        :ok

      {:error,
       %{
         errors: [
           site_id: {_, [constraint: :unique, constraint_name: ^name]}
         ]
       }} ->
        :ok

      other ->
        other
    end
  end
end
```

## File: `lib/plausible_web/controllers/stats_controller.ex`
```
defmodule PlausibleWeb.StatsController do
  use Plausible

  @moduledoc """
  This controller is responsible for rendering stats dashboards.

  The stats dashboards are currently the only part of the app that uses client-side
  rendering. Since the dashboards are heavily interactive, they are built with React
  which is an appropriate choice for highly interactive browser UIs.

  <div class="mermaid">
  sequenceDiagram
    Browser->>StatsController: GET /mydomain.com
    StatsController-->>Browser: StatsView.render("stats.html")
    Note left of Browser: ReactDom.render(Dashboard)

    Browser -) Api.StatsController: GET /api/stats/mydomain.com/top-stats
    Api.StatsController --) Browser: {"top_stats": [...]}
    Note left of Browser: TopStats.render()

    Browser -) Api.StatsController: GET /api/stats/mydomain.com/main-graph
    Api.StatsController --) Browser: [{"plot": [...], "labels": [...]}, ...]
    Note left of Browser: VisitorGraph.render()

    Browser -) Api.StatsController: GET /api/stats/mydomain.com/sources
    Api.StatsController --) Browser: [{"name": "Google", "visitors": 292150}, ...]
    Note left of Browser: Sources.render()

    Note over Browser,StatsController: And so on, for all reports in the viewport
  </div>

  This reasoning for this sequence is as follows:
    1. First paint is fast because it doesn't do any data aggregation yet - good UX
    2. The basic structure of the dashboard is rendered with spinners before reports are ready - good UX
    2. Rendering on the frontend allows for maximum interactivity. Re-rendering and re-fetching can be as granular as needed.
    3. Routing on the frontend allows the user to navigate the dashboard without reloading the page and losing context
    4. Rendering on the frontend allows caching results in the browser to reduce pressure on backends and storage
      3.1 No client-side caching has been implemented yet. This is still theoretical. See https://github.com/plausible/analytics/discussions/1278
      3.2 This is a big potential opportunity, because analytics data is mostly immutable. Clients can cache all historical data.
    5. Since frontend rendering & navigation is harder to build and maintain than regular server-rendered HTML, we don't use SPA-style rendering anywhere else
    .The only place currently where the benefits outweigh the costs is the dashboard.
  """

  use PlausibleWeb, :controller
  use Plausible.Repo

  alias Plausible.Sites
  alias Plausible.Stats.{Filters, Query}
  alias Plausible.Teams
  alias PlausibleWeb.Api
  alias Plausible.Billing.Feature.SharedLinks

  plug(PlausibleWeb.Plugs.AuthorizeSiteAccess when action in [:stats, :csv_export])

  def stats(%{assigns: %{site: site}} = conn, _params) do
    site = Plausible.Repo.preload(site, :owners)
    site_role = conn.assigns[:site_role]
    current_user = conn.assigns[:current_user]
    stats_start_date = Plausible.Sites.stats_start_date(site)
    can_see_stats? = not Teams.locked?(site.team) or site_role == :super_admin
    demo = site.domain == "plausible.io"
    dogfood_page_path = if demo, do: "/#{site.domain}", else: "/:dashboard"
    skip_to_dashboard? = conn.params["skip_to_dashboard"] == "true"

    {:ok, segments} = Plausible.Segments.get_all_for_site(site, site_role)

    cond do
      (stats_start_date && can_see_stats?) || (can_see_stats? && skip_to_dashboard?) ->
        flags = get_flags(current_user, site)

        conn
        |> put_resp_header("x-robots-tag", "noindex, nofollow")
        |> render("stats.html",
          site: site,
          site_role: site_role,
          has_goals: Plausible.Sites.has_goals?(site),
          revenue_goals: list_revenue_goals(site),
          funnels: list_funnels(site),
          has_props: Plausible.Props.configured?(site),
          stats_start_date: stats_start_date,
          native_stats_start_date: NaiveDateTime.to_date(site.native_stats_start_at),
          title: title(conn, site),
          demo: demo,
          flags: flags,
          is_dbip: is_dbip(),
          segments: segments,
          load_dashboard_js: true,
          hide_footer?: if(ce?() || demo, do: false, else: site_role != :public)
        )

      !stats_start_date && can_see_stats? ->
        redirect(conn, to: Routes.site_path(conn, :verification, site.domain))

      Teams.locked?(site.team) ->
        site = Plausible.Repo.preload(site, :owners)
        render(conn, "site_locked.html", site: site, dogfood_page_path: dogfood_page_path)
    end
  end

  on_ee do
    defp list_funnels(site) do
      Plausible.Funnels.list(site)
    end

    defp list_revenue_goals(site) do
      Plausible.Goals.list_revenue_goals(site)
    end
  else
    defp list_funnels(_site), do: []
    defp list_revenue_goals(_site), do: []
  end

  @doc """
  The export is limited to 300 entries for other reports and 100 entries for pages because bigger result sets
  start causing failures. Since we request data like time on page or bounce_rate for pages in a separate query
  using the IN filter, it causes the requests to balloon in payload size.
  """
  def csv_export(conn, params) do
    if is_nil(params["interval"]) or Plausible.Stats.Interval.valid?(params["interval"]) do
      site = Plausible.Repo.preload(conn.assigns.site, :owners)
      query = Query.from(site, params, debug_metadata(conn))

      date_range = Query.date_range(query)

      filename =
        ~c"Plausible export #{params["domain"]} #{Date.to_iso8601(date_range.first)}  to #{Date.to_iso8601(date_range.last)} .zip"

      params = Map.merge(params, %{"limit" => "300", "csv" => "True", "detailed" => "True"})
      limited_params = Map.merge(params, %{"limit" => "100"})

      csvs = %{
        ~c"visitors.csv" => fn -> main_graph_csv(site, query) end,
        ~c"sources.csv" => fn -> Api.StatsController.sources(conn, params) end,
        ~c"channels.csv" => fn -> Api.StatsController.channels(conn, params) end,
        ~c"utm_mediums.csv" => fn -> Api.StatsController.utm_mediums(conn, params) end,
        ~c"utm_sources.csv" => fn -> Api.StatsController.utm_sources(conn, params) end,
        ~c"utm_campaigns.csv" => fn -> Api.StatsController.utm_campaigns(conn, params) end,
        ~c"utm_contents.csv" => fn -> Api.StatsController.utm_contents(conn, params) end,
        ~c"utm_terms.csv" => fn -> Api.StatsController.utm_terms(conn, params) end,
        ~c"pages.csv" => fn -> Api.StatsController.pages(conn, limited_params) end,
        ~c"entry_pages.csv" => fn -> Api.StatsController.entry_pages(conn, params) end,
        ~c"exit_pages.csv" => fn -> Api.StatsController.exit_pages(conn, limited_params) end,
        ~c"countries.csv" => fn -> Api.StatsController.countries(conn, params) end,
        ~c"regions.csv" => fn -> Api.StatsController.regions(conn, params) end,
        ~c"cities.csv" => fn -> Api.StatsController.cities(conn, params) end,
        ~c"browsers.csv" => fn -> Api.StatsController.browsers(conn, params) end,
        ~c"browser_versions.csv" => fn -> Api.StatsController.browser_versions(conn, params) end,
        ~c"operating_systems.csv" => fn -> Api.StatsController.operating_systems(conn, params) end,
        ~c"operating_system_versions.csv" => fn ->
          Api.StatsController.operating_system_versions(conn, params)
        end,
        ~c"devices.csv" => fn -> Api.StatsController.screen_sizes(conn, params) end,
        ~c"conversions.csv" => fn -> Api.StatsController.conversions(conn, params) end,
        ~c"referrers.csv" => fn -> Api.StatsController.referrers(conn, params) end,
        ~c"custom_props.csv" => fn -> Api.StatsController.all_custom_prop_values(conn, params) end
      }

      csv_values =
        Map.values(csvs)
        |> Plausible.ClickhouseRepo.parallel_tasks()

      csvs =
        Map.keys(csvs)
        |> Enum.zip(csv_values)
        |> Enum.reject(fn {_k, v} -> is_nil(v) end)
        |> Enum.map(fn {k, v} -> {k, IO.iodata_to_binary(v)} end)

      {:ok, {_, zip_content}} = :zip.create(filename, csvs, [:memory])

      conn
      |> put_resp_content_type("application/zip")
      |> put_resp_header("content-disposition", "attachment; filename=\"#{filename}\"")
      |> delete_resp_cookie("exporting")
      |> send_resp(200, zip_content)
    else
      conn
      |> send_resp(400, "")
      |> halt()
    end
  end

  defp main_graph_csv(site, query) do
    {metrics, column_headers} = csv_graph_metrics(query)

    map_bucket_to_row = fn bucket -> Enum.map([:date | metrics], &bucket[&1]) end
    prepend_column_headers = fn data -> [column_headers | data] end

    Plausible.Stats.timeseries(site, query, metrics)
    |> elem(0)
    |> Enum.map(map_bucket_to_row)
    |> prepend_column_headers.()
    |> NimbleCSV.RFC4180.dump_to_iodata()
  end

  defp csv_graph_metrics(query) do
    include_scroll_depth? =
      !query.include_imported &&
        Filters.filtering_on_dimension?(query, "event:page", behavioral_filters: :ignore)

    {metrics, column_headers} =
      if Filters.filtering_on_dimension?(query, "event:goal", max_depth: 0) do
        {
          [:visitors, :events, :conversion_rate],
          [:date, :unique_conversions, :total_conversions, :conversion_rate]
        }
      else
        metrics = [
          :visitors,
          :pageviews,
          :visits,
          :views_per_visit,
          :bounce_rate,
          :visit_duration
        ]

        metrics = if include_scroll_depth?, do: metrics ++ [:scroll_depth], else: metrics

        {
          metrics,
          [:date | metrics]
        }
      end

    {metrics, column_headers}
  end

  @doc """
    Authorizes and renders a shared link:
    1. Shared link with no password protection: needs to just make sure the shared link entry is still
    in our database. This check makes sure shared link access can be revoked by the site admins. If the
    shared link exists, render it directly.

    2. Shared link with password protection: Same checks as without the password, but an extra step is taken to
    protect the page with a password. When the user passes the password challenge, a cookie is set with Plausible.Auth.Token.sign_shared_link().
    The cookie allows the user to access the dashboard for 24 hours without entering the password again.

    ### Backwards compatibility

    The URL format for shared links was changed in [this pull request](https://github.com/plausible/analytics/pull/752) in order
    to make the URLs easier to bookmark. The old format is supported along with the new in order to not break old links.

    See: https://plausible.io/docs/shared-links
  """
  def shared_link(conn, %{"domain" => domain, "auth" => auth}) do
    case find_shared_link(domain, auth) do
      {:password_protected, shared_link} ->
        render_password_protected_shared_link(conn, shared_link)

      {:unlisted, shared_link} ->
        render_shared_link(conn, shared_link)

      :not_found ->
        render_error(conn, 404)
    end
  end

  @old_format_deprecation_date ~N[2022-01-01 00:00:00]
  def shared_link(conn, %{"domain" => slug}) do
    shared_link =
      Repo.one(
        from(l in Plausible.Site.SharedLink,
          where: l.slug == ^slug and l.inserted_at < ^@old_format_deprecation_date,
          preload: :site
        )
      )

    if shared_link do
      new_link_format = Routes.stats_path(conn, :shared_link, shared_link.site.domain, auth: slug)
      redirect(conn, to: new_link_format)
    else
      render_error(conn, 404)
    end
  end

  def shared_link(conn, _) do
    render_error(conn, 400)
  end

  defp render_password_protected_shared_link(conn, shared_link) do
    with conn <- Plug.Conn.fetch_cookies(conn),
         {:ok, token} <- Map.fetch(conn.req_cookies, shared_link_cookie_name(shared_link.slug)),
         {:ok, %{slug: token_slug}} <- Plausible.Auth.Token.verify_shared_link(token),
         true <- token_slug == shared_link.slug do
      render_shared_link(conn, shared_link)
    else
      _e ->
        conn
        |> render("shared_link_password.html",
          link: shared_link,
          dogfood_page_path: "/share/:dashboard"
        )
    end
  end

  defp find_shared_link(domain, auth) do
    link_query =
      from(link in Plausible.Site.SharedLink,
        inner_join: site in assoc(link, :site),
        inner_join: team in assoc(site, :team),
        where: link.slug == ^auth,
        where: site.domain == ^domain,
        limit: 1,
        preload: [site: {site, team: team}]
      )

    case Repo.one(link_query) do
      %Plausible.Site.SharedLink{password_hash: hash} = link when not is_nil(hash) ->
        {:password_protected, link}

      %Plausible.Site.SharedLink{} = link ->
        {:unlisted, link}

      nil ->
        :not_found
    end
  end

  def authenticate_shared_link(conn, %{"slug" => slug, "password" => password}) do
    shared_link =
      Repo.get_by(Plausible.Site.SharedLink, slug: slug)
      |> Repo.preload(:site)

    if shared_link do
      if Plausible.Auth.Password.match?(password, shared_link.password_hash) do
        token = Plausible.Auth.Token.sign_shared_link(slug)

        conn
        |> put_resp_cookie(shared_link_cookie_name(slug), token)
        |> redirect(to: "/share/#{URI.encode_www_form(shared_link.site.domain)}?auth=#{slug}")
      else
        conn
        |> render("shared_link_password.html",
          link: shared_link,
          error: "Incorrect password. Please try again.",
          dogfood_page_path: "/share/:dashboard"
        )
      end
    else
      render_error(conn, 404)
    end
  end

  defp render_shared_link(conn, shared_link) do
    shared_links_feature_access? =
      SharedLinks.check_availability(shared_link.site.team) == :ok or
        shared_link.name in Plausible.Sites.shared_link_special_names()

    cond do
      Teams.locked?(shared_link.site.team) ->
        owners = Plausible.Repo.preload(shared_link.site, :owners)

        render(conn, "site_locked.html",
          owners: owners,
          site: shared_link.site,
          dogfood_page_path: "/share/:dashboard"
        )

      not shared_links_feature_access? ->
        owners = Plausible.Repo.preload(shared_link.site, :owners)

        render(conn, "site_locked.html",
          only_shared_link_access_missing?: true,
          owners: owners,
          site: shared_link.site,
          dogfood_page_path: "/share/:dashboard"
        )

      not Teams.locked?(shared_link.site.team) ->
        current_user = conn.assigns[:current_user]
        site_role = get_fallback_site_role(conn)
        shared_link = Plausible.Repo.preload(shared_link, site: :owners)
        stats_start_date = Plausible.Sites.stats_start_date(shared_link.site)

        flags = get_flags(current_user, shared_link.site)

        {:ok, segments} = Plausible.Segments.get_all_for_site(shared_link.site, site_role)

        embedded? = conn.params["embed"] == "true"

        conn
        |> put_resp_header("x-robots-tag", "noindex, nofollow")
        |> delete_resp_header("x-frame-options")
        |> render("stats.html",
          site: shared_link.site,
          site_role: site_role,
          has_goals: Sites.has_goals?(shared_link.site),
          revenue_goals: list_revenue_goals(shared_link.site),
          funnels: list_funnels(shared_link.site),
          has_props: Plausible.Props.configured?(shared_link.site),
          stats_start_date: stats_start_date,
          native_stats_start_date: NaiveDateTime.to_date(shared_link.site.native_stats_start_at),
          title: title(conn, shared_link.site),
          demo: false,
          shared_link_auth: shared_link.slug,
          embedded: embedded?,
          background: conn.params["background"],
          theme: conn.params["theme"],
          flags: flags,
          is_dbip: is_dbip(),
          segments: segments,
          load_dashboard_js: true,
          hide_footer?: if(ce?(), do: embedded?, else: embedded? || site_role != :public)
        )
    end
  end

  defp get_fallback_site_role(conn),
    do: if(role = conn.assigns[:site_role], do: role, else: :public)

  defp shared_link_cookie_name(slug), do: "shared-link-" <> slug

  defp get_flags(user, site),
    do:
      []
      |> Enum.map(fn flag ->
        {flag, FunWithFlags.enabled?(flag, for: user) || FunWithFlags.enabled?(flag, for: site)}
      end)
      |> Map.new()

  defp is_dbip() do
    on_ee do
      false
    else
      Plausible.Geo.database_type()
      |> to_string()
      |> String.starts_with?("DBIP")
    end
  end

  defp title(%{path_info: ["plausible.io"]}, _) do
    "Plausible Analytics: Live Demo"
  end

  defp title(_conn, site) do
    "Plausible · " <> site.domain
  end
end
```

## File: `lib/plausible_web/controllers/unsubscribe_controller.ex`
```
defmodule PlausibleWeb.UnsubscribeController do
  use PlausibleWeb, :controller
  use Plausible.Repo
  alias Plausible.Site.{WeeklyReport, MonthlyReport}

  def weekly_report(conn, %{"domain" => domain, "email" => email}) do
    site = Repo.get_by(Plausible.Site, domain: domain)
    weekly_report = site && Repo.get_by(WeeklyReport, site_id: site.id)

    if weekly_report do
      weekly_report
      |> WeeklyReport.remove_recipient(email)
      |> Repo.update!()
    end

    conn
    |> assign(:skip_plausible_tracking, true)
    |> render("success.html",
      interval: "weekly",
      site: site || %{domain: domain}
    )
  end

  def weekly_report(conn, _) do
    render_error(conn, 400)
  end

  def monthly_report(conn, %{"domain" => domain, "email" => email}) do
    site = Repo.get_by(Plausible.Site, domain: domain)
    monthly_report = site && Repo.get_by(MonthlyReport, site_id: site.id)

    if monthly_report do
      monthly_report
      |> MonthlyReport.remove_recipient(email)
      |> Repo.update!()
    end

    conn
    |> assign(:skip_plausible_tracking, true)
    |> render("success.html",
      interval: "monthly",
      site: site || %{domain: domain}
    )
  end

  def monthly_report(conn, _) do
    render_error(conn, 400)
  end
end
```

## File: `lib/plausible_web/email.ex`
```
defmodule PlausibleWeb.Email do
  use Plausible
  import Bamboo.Email
  import Bamboo.PostmarkHelper

  def mailer_email_from do
    Application.get_env(:plausible, :mailer_email)
  end

  def activation_email(user, code) do
    priority_email()
    |> to(user)
    |> tag("activation-email")
    |> subject("#{code} is your Plausible email verification code")
    |> render("activation_email.html", user: user, code: code)
  end

  def welcome_email(user) do
    base_email()
    |> to(user)
    |> tag("welcome-email")
    |> subject("Welcome to Plausible")
    |> render("welcome_email.html", user: user)
  end

  def create_site_email(user) do
    base_email()
    |> to(user)
    |> tag("create-site-email")
    |> subject("Your Plausible setup: Add your website details")
    |> render("create_site_email.html", user: user)
  end

  def site_setup_help(user, team, site) do
    base_email()
    |> to(user)
    |> tag("help-email")
    |> subject("Your Plausible setup: Waiting for the first page views")
    |> render("site_setup_help_email.html",
      user: user,
      site: site,
      site_team: team
    )
  end

  def site_setup_success(user, team, site) do
    base_email()
    |> to(user)
    |> tag("setup-success-email")
    |> subject("Plausible is now tracking your website stats")
    |> render("site_setup_success_email.html",
      user: user,
      site: site,
      site_team: team
    )
  end

  def check_stats_email(user) do
    base_email()
    |> to(user)
    |> tag("check-stats-email")
    |> subject("Check your Plausible website stats")
    |> render("check_stats_email.html", user: user)
  end

  def password_reset_email(email, reset_link) do
    priority_email(%{layout: nil})
    |> to(email)
    |> tag("password-reset-email")
    |> subject("Plausible password reset")
    |> render("password_reset_email.html", reset_link: reset_link)
  end

  def two_factor_enabled_email(user) do
    priority_email()
    |> to(user)
    |> tag("two-factor-enabled-email")
    |> subject("Plausible Two-Factor Authentication enabled")
    |> render("two_factor_enabled_email.html", user: user)
  end

  def two_factor_disabled_email(user) do
    priority_email()
    |> to(user)
    |> tag("two-factor-disabled-email")
    |> subject("Plausible Two-Factor Authentication disabled")
    |> render("two_factor_disabled_email.html", user: user)
  end

  def trial_one_week_reminder(user, team) do
    base_email()
    |> to(user)
    |> tag("trial-one-week-reminder")
    |> subject("Your Plausible trial expires next week")
    |> render("trial_one_week_reminder.html", user: user, team: team)
  end

  def trial_upgrade_email(user, team, day, usage, suggested_volume) do
    base_email()
    |> to(user)
    |> tag("trial-upgrade-email")
    |> subject("Your Plausible trial ends #{day}")
    |> render("trial_upgrade_email.html",
      user: user,
      team: team,
      day: day,
      custom_events: usage.custom_events,
      usage: usage.total,
      suggested_volume: suggested_volume
    )
  end

  def trial_over_email(user, team) do
    base_email()
    |> to(user)
    |> tag("trial-over-email")
    |> subject("Your Plausible trial has ended")
    |> render("trial_over_email.html",
      user: user,
      team: team,
      extra_offset: Plausible.Teams.Team.trial_accept_traffic_until_offset_days()
    )
  end

  def stats_report(email, assigns) do
    base_email(%{layout: nil})
    |> to(email)
    |> tag("#{assigns.type}-report")
    |> subject("#{assigns.name} report for #{assigns.site.domain}")
    |> html_body(PlausibleWeb.MJML.StatsReport.render(assigns))
  end

  def spike_notification(email, site, stats, dashboard_link) do
    base_email()
    |> to(email)
    |> tag("spike-notification")
    |> subject("Traffic Spike on #{site.domain}")
    |> render("spike_notification.html", %{
      site: site,
      current_visitors: stats.current_visitors,
      sources: stats.sources,
      pages: stats.pages,
      link: dashboard_link
    })
  end

  def drop_notification(email, site, current_visitors, dashboard_link, installation_link) do
    base_email()
    |> to(email)
    |> tag("drop-notification")
    |> subject("Traffic Drop on #{site.domain}")
    |> render("drop_notification.html", %{
      site: site,
      current_visitors: current_visitors,
      dashboard_link: dashboard_link,
      installation_link: installation_link
    })
  end

  def over_limit_email(user, team, usage, suggested_volume) do
    priority_email()
    |> to(user)
    |> tag("over-limit")
    |> subject("[Action required] You have outgrown your Plausible subscription tier")
    |> render("over_limit.html", %{
      user: user,
      team: team,
      usage: usage,
      suggested_volume: suggested_volume
    })
  end

  def enterprise_over_limit_internal_email(user, pageview_usage, site_usage, site_allowance) do
    base_email(%{layout: nil})
    |> to("enterprise@plausible.io")
    |> tag("enterprise-over-limit")
    |> subject("#{user.email} has outgrown their enterprise plan")
    |> render("enterprise_over_limit_internal.html", %{
      user: user,
      pageview_usage: pageview_usage,
      site_usage: site_usage,
      site_allowance: site_allowance
    })
  end

  def dashboard_locked(user, team, usage, suggested_volume) do
    priority_email()
    |> to(user)
    |> tag("dashboard-locked")
    |> subject("[Action required] Your Plausible dashboard is now locked")
    |> render("dashboard_locked.html", %{
      user: user,
      team: team,
      usage: usage,
      suggested_volume: suggested_volume
    })
  end

  def yearly_renewal_notification(team, owner) do
    date = Calendar.strftime(team.subscription.next_bill_date, "%B %-d, %Y")

    priority_email()
    |> to(owner)
    |> tag("yearly-renewal")
    |> subject("Your Plausible subscription is up for renewal")
    |> render("yearly_renewal_notification.html", %{
      user: owner,
      team: team,
      date: date,
      next_bill_amount: team.subscription.next_bill_amount,
      currency: team.subscription.currency_code
    })
  end

  def yearly_expiration_notification(team, owner) do
    next_bill_date = Calendar.strftime(team.subscription.next_bill_date, "%B %-d, %Y")

    accept_traffic_until =
      team
      |> Plausible.Teams.accept_traffic_until()
      |> Calendar.strftime("%B %-d, %Y")

    priority_email()
    |> to(owner)
    |> tag("yearly-expiration")
    |> subject("Your Plausible subscription is about to expire")
    |> render("yearly_expiration_notification.html", %{
      user: owner,
      team: team,
      next_bill_date: next_bill_date,
      accept_traffic_until: accept_traffic_until
    })
  end

  def cancellation_email(user) do
    base_email()
    |> to(user.email)
    |> tag("cancelled-email")
    |> subject("Mind sharing your thoughts on Plausible?")
    |> render("cancellation_email.html", user: user)
  end

  def new_user_invitation(email, invitation_id, site, inviter) do
    priority_email()
    |> to(email)
    |> tag("new-user-invitation")
    |> subject("[#{Plausible.product_name()}] You've been invited to #{site.domain}")
    |> render("new_user_invitation.html",
      invitation_id: invitation_id,
      site: site,
      inviter: inviter
    )
  end

  def existing_user_invitation(email, site, inviter) do
    priority_email()
    |> to(email)
    |> tag("existing-user-invitation")
    |> subject("[#{Plausible.product_name()}] You've been invited to #{site.domain}")
    |> render("existing_user_invitation.html",
      site: site,
      inviter: inviter
    )
  end

  def new_user_team_invitation(email, invitation_id, team, inviter) do
    priority_email()
    |> to(email)
    |> tag("new-user-team-invitation")
    |> subject("[#{Plausible.product_name()}] You've been invited to \"#{team.name}\" team")
    |> render("new_user_team_invitation.html",
      invitation_id: invitation_id,
      team: team,
      inviter: inviter
    )
  end

  def existing_user_team_invitation(email, team, inviter) do
    priority_email()
    |> to(email)
    |> tag("existing-user-team-invitation")
    |> subject("[#{Plausible.product_name()}] You've been invited to \"#{team.name}\" team")
    |> render("existing_user_team_invitation.html",
      team: team,
      inviter: inviter
    )
  end

  def guest_to_team_member_promotion(email, team, inviter) do
    priority_email()
    |> to(email)
    |> tag("guest-to-team-member-promotion")
    |> subject("[#{Plausible.product_name()}] Welcome to \"#{team.name}\" team")
    |> render("guest_to_team_member_promotion.html", inviter: inviter, team: team)
  end

  def ownership_transfer_request(email, invitation_id, site, inviter, new_owner_account) do
    priority_email()
    |> to(email)
    |> tag("ownership-transfer-request")
    |> subject("[#{Plausible.product_name()}] Request to transfer ownership of #{site.domain}")
    |> render("ownership_transfer_request.html",
      invitation_id: invitation_id,
      inviter: inviter,
      site: site,
      new_owner_account: new_owner_account
    )
  end

  def guest_invitation_accepted(inviter_email, invitee_email, team, site) do
    priority_email()
    |> to(inviter_email)
    |> tag("guest-invitation-accepted")
    |> subject(
      "[#{Plausible.product_name()}] #{invitee_email} accepted your invitation to #{site.domain}"
    )
    |> render("guest_invitation_accepted.html",
      invitee_email: invitee_email,
      team: team,
      site: site
    )
  end

  def team_invitation_accepted(inviter_email, invitee_email, team) do
    priority_email()
    |> to(inviter_email)
    |> tag("team-invitation-accepted")
    |> subject(
      "[#{Plausible.product_name()}] #{invitee_email} accepted your invitation to \"#{team.name}\" team"
    )
    |> render("team_invitation_accepted.html",
      invitee_email: invitee_email,
      team: team
    )
  end

  def guest_invitation_rejected(guest_invitation) do
    priority_email()
    |> to(guest_invitation.team_invitation.inviter.email)
    |> tag("guest-invitation-rejected")
    |> subject(
      "[#{Plausible.product_name()}] #{guest_invitation.team_invitation.email} rejected your invitation to #{guest_invitation.site.domain}"
    )
    |> render("guest_invitation_rejected.html",
      team: guest_invitation.team_invitation.team,
      guest_invitation: guest_invitation
    )
  end

  def team_invitation_rejected(team_invitation) do
    priority_email()
    |> to(team_invitation.inviter.email)
    |> tag("team-invitation-rejected")
    |> subject(
      "[#{Plausible.product_name()}] #{team_invitation.email} rejected your invitation to \"#{team_invitation.team.name}\" team"
    )
    |> render("team_invitation_rejected.html",
      team: team_invitation.team,
      team_invitation: team_invitation
    )
  end

  def ownership_transfer_accepted(
        new_owner_email,
        inviter_email,
        team,
        site,
        initiator_as_guest_editor?
      ) do
    priority_email()
    |> to(inviter_email)
    |> tag("ownership-transfer-accepted")
    |> subject(
      "[#{Plausible.product_name()}] #{new_owner_email} accepted the ownership transfer of #{site.domain}"
    )
    |> render("ownership_transfer_accepted.html",
      new_owner_email: new_owner_email,
      team: team,
      site: site,
      initiator_as_guest_editor?: initiator_as_guest_editor?
    )
  end

  def team_changed(owner_email, user, team, site) do
    priority_email()
    |> to(owner_email)
    |> tag("team-changed")
    |> subject(
      "[#{Plausible.product_name()}] #{user.email} has transferred #{site.domain} to \"#{team.name}\" team"
    )
    |> render("team_changed.html",
      user: user,
      team: team,
      site: site
    )
  end

  def ownership_transfer_rejected(site_transfer) do
    priority_email()
    |> to(site_transfer.initiator.email)
    |> tag("ownership-transfer-rejected")
    |> subject(
      "[#{Plausible.product_name()}] #{site_transfer.email} rejected the ownership transfer of #{site_transfer.site.domain}"
    )
    |> render("ownership_transfer_rejected.html",
      user: site_transfer.initiator,
      team: site_transfer.site.team,
      site_transfer: site_transfer
    )
  end

  def site_member_removed(guest_membership) do
    priority_email()
    |> to(guest_membership.team_membership.user.email)
    |> tag("site-member-removed")
    |> subject(
      "[#{Plausible.product_name()}] Your access to #{guest_membership.site.domain} has been revoked"
    )
    |> render("site_member_removed.html",
      user: guest_membership.team_membership.user,
      guest_membership: guest_membership
    )
  end

  def team_member_removed(team_membership) do
    priority_email()
    |> to(team_membership.user.email)
    |> tag("team-member-removed")
    |> subject(
      "[#{Plausible.product_name()}] Your access to \"#{team_membership.team.name}\" team has been revoked"
    )
    |> render("team_member_removed.html",
      user: team_membership.user,
      team_membership: team_membership
    )
  end

  def team_member_left(team_membership) do
    priority_email()
    |> to(team_membership.user.email)
    |> tag("team-member-left")
    |> subject(
      "[#{Plausible.product_name()}] You have left \"#{team_membership.team.name}\" team"
    )
    |> render("team_member_left.html",
      user: team_membership.user,
      team_membership: team_membership
    )
  end

  def import_success(site_import, user) do
    import_api = Plausible.Imported.ImportSources.by_name(site_import.source)
    label = import_api.label()
    team = site_import.site.team

    priority_email()
    |> to(user)
    |> tag("import-success-email")
    |> subject("#{label} data imported for #{site_import.site.domain}")
    |> render(import_api.email_template(), %{
      site_import: site_import,
      label: label,
      link:
        PlausibleWeb.Endpoint.url() <>
          "/" <> URI.encode_www_form(site_import.site.domain) <> "?__team=#{team.identifier}",
      user: user,
      success: true
    })
  end

  def import_failure(site_import, user) do
    import_api = Plausible.Imported.ImportSources.by_name(site_import.source)
    label = import_api.label()

    priority_email()
    |> to(user)
    |> tag("import-failure-email")
    |> subject("#{label} import failed for #{site_import.site.domain}")
    |> render(import_api.email_template(), %{
      site_import: site_import,
      label: label,
      user: user,
      success: false
    })
  end

  def export_success(user, site, expires_at) do
    expires_in =
      if expires_at do
        Timex.Format.DateTime.Formatters.Relative.format!(
          expires_at,
          "{relative}"
        )
      end

    download_url =
      PlausibleWeb.Router.Helpers.site_url(
        PlausibleWeb.Endpoint,
        :download_export,
        site.domain
      ) <> "?__team=#{site.team.identifier}"

    priority_email()
    |> to(user)
    |> tag("export-success")
    |> subject("[#{Plausible.product_name()}] Your export is now ready for download")
    |> render("export_success.html",
      user: user,
      site: site,
      download_url: download_url,
      expires_in: expires_in
    )
  end

  def export_failure(user, site) do
    priority_email()
    |> to(user)
    |> subject("[#{Plausible.product_name()}] Your export has failed")
    |> render("export_failure.html", user: user, site: site)
  end

  def error_report(reported_by, trace_id, feedback) do
    Map.new()
    |> Map.put(:layout, nil)
    |> base_email()
    |> to("bugs@plausible.io")
    |> put_param("ReplyTo", reported_by)
    |> tag("sentry")
    |> subject("Feedback to Sentry Trace #{trace_id}")
    |> render("error_report_email.html", %{
      reported_by: reported_by,
      feedback: feedback,
      trace_id: trace_id
    })
  end

  def approaching_accept_traffic_until(notification) do
    base_email()
    |> to(notification.email)
    |> tag("drop-traffic-warning-first")
    |> subject("We'll stop counting your stats")
    |> render("approaching_accept_traffic_until.html",
      time: "next week",
      user: %{email: notification.email, name: notification.name},
      team: notification.team
    )
  end

  def approaching_accept_traffic_until_tomorrow(notification) do
    base_email()
    |> to(notification.email)
    |> tag("drop-traffic-warning-final")
    |> subject("A reminder that we'll stop counting your stats tomorrow")
    |> render("approaching_accept_traffic_until.html",
      time: "tomorrow",
      user: %{email: notification.email, name: notification.name},
      team: notification.team
    )
  end

  on_ee do
    def sso_domain_verification_success(domain, user) do
      priority_email()
      |> to(user.email)
      |> subject("Your SSO domain #{domain} is ready!")
      |> render("sso_domain_verification_success.html", domain: domain)
    end

    def sso_domain_verification_failure(domain, user) do
      priority_email()
      |> to(user)
      |> subject("SSO domain #{domain} verification failure")
      |> render("sso_domain_verification_failure.html", domain: domain)
    end
  end

  @doc """
    Unlike the default 'base' emails, priority emails cannot be unsubscribed from. This is achieved
    by sending them through a dedicated 'priority' message stream in Postmark.
  """
  def priority_email(), do: priority_email(%{layout: "priority_email.html"})

  def priority_email(%{layout: layout}) do
    email = base_email(%{layout: layout})

    if ee?() do
      put_param(email, "MessageStream", "priority")
    else
      email
    end
  end

  def base_email(), do: base_email(%{layout: "base_email.html"})

  def base_email(%{layout: layout}) do
    new_email()
    |> put_param("TrackOpens", false)
    |> from(mailer_email_from())
    |> maybe_put_layout(layout)
  end

  defp maybe_put_layout(email, nil), do: email

  defp maybe_put_layout(%{assigns: assigns} = email, layout) do
    %{email | assigns: Map.put(assigns, :layout, {PlausibleWeb.LayoutView, layout})}
  end

  @doc false
  def render(email, template, assigns \\ []) do
    assigns = Map.merge(email.assigns, Map.new(assigns))
    html = Phoenix.View.render_to_string(PlausibleWeb.EmailView, template, assigns)
    email |> html_body(html) |> text_body(textify(html))
  end

  defp textify(html) do
    Floki.parse_fragment!(html)
    |> traverse_and_textify()
    |> Floki.text()
    |> collapse_whitespace()
  end

  defp traverse_and_textify([head | tail]) do
    [traverse_and_textify(head) | traverse_and_textify(tail)]
  end

  defp traverse_and_textify(text) when is_binary(text) do
    String.replace(text, "\n", "\s")
  end

  defp traverse_and_textify({"a" = tag, attrs, children}) do
    href = with {"href", href} <- List.keyfind(attrs, "href", 0), do: href
    children = traverse_and_textify(children)

    if href do
      text = Floki.text(children)

      if text == href do
        # avoids rendering "http://localhost:8000 (http://localhost:8000)" in base_email footer
        text
      else
        IO.iodata_to_binary([text, " (", href, ?)])
      end
    else
      {tag, attrs, children}
    end
  end

  defp traverse_and_textify({tag, attrs, children}) do
    {tag, attrs, traverse_and_textify(children)}
  end

  defp traverse_and_textify(other), do: other

  defp collapse_whitespace(text) do
    text
    |> String.split("\n")
    |> Enum.map_join("\n", fn line ->
      line
      |> String.split(" ", trim: true)
      |> Enum.join(" ")
    end)
  end
end
```

## File: `lib/plausible_web/endpoint.ex`
```
defmodule PlausibleWeb.Endpoint do
  use Plausible
  use Sentry.PlugCapture
  use Phoenix.Endpoint, otp_app: :plausible

  on_ce do
    plug :maybe_handle_acme_challenge
    plug :maybe_force_ssl, Plug.SSL.init(_no_opts = [])
  end

  @session_options [
    # in EE key is replaced dynamically via runtime_session_opts, see below
    key: "_plausible_key",
    store: :cookie,
    signing_salt: "I45i0SKHEku2f3tJh6y4v8gztrb/eG5KGCOe/o/AwFb7VHeuvDOn7AAq6KsdmOFM",
    # 5 years, this is super long but the SlidingSessionTimeout will log people out if they don't return for 2 weeks
    max_age: 60 * 60 * 24 * 365 * 5,
    extra: "SameSite=Lax"
    # in EE domain is added dynamically via runtime_session_opts, see below
  ]

  socket("/live", Phoenix.LiveView.Socket,
    websocket: [
      check_origin: true,
      connect_info: [
        :peer_data,
        :uri,
        :user_agent,
        session: {__MODULE__, :runtime_session_opts, []}
      ]
    ]
  )

  # Serve at "/" the static files from "priv/static" directory.
  #
  # You should set gzip to true if you are running phx.digest
  # when deploying your static files in production.
  plug(PlausibleWeb.TrackerPlug)
  plug(PlausibleWeb.Favicon)

  static_paths = ~w(css js images favicon.ico)

  static_paths =
    on_ee do
      # NOTE: The Cloud uses custom robots.txt from https://github.com/plausible/website: https://plausible.io/robots.txt
      static_paths
    else
      static_paths ++ ["robots.txt"]
    end

  static_compression =
    if ce?() do
      [brotli: true, gzip: true]
    else
      [gzip: false]
    end

  plug(
    Plug.Static,
    [at: "/", from: :plausible, only: static_paths] ++ static_compression
  )

  # Code reloading can be explicitly enabled under the
  # :code_reloader configuration of your endpoint.
  if code_reloading? do
    socket("/phoenix/live_reload/socket", Phoenix.LiveReloader.Socket)
    plug(Phoenix.LiveReloader)
    plug(Phoenix.CodeReloader)
  end

  plug(Plug.RequestId)
  plug(PromEx.Plug, prom_ex_module: Plausible.PromEx)
  plug(Plug.Telemetry, event_prefix: [:phoenix, :endpoint], log: false)

  plug(Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: ["*/*"],
    json_decoder: Phoenix.json_library()
  )

  plug(Sentry.PlugContext)

  plug(Plug.MethodOverride)
  plug(Plug.Head)

  plug(:runtime_session)

  plug(CORSPlug)
  plug(PlausibleWeb.Router)

  def secure_cookie?, do: config!(:secure_cookie)

  def websocket_url() do
    config!(:websocket_url)
  end

  def runtime_session(conn, _opts) do
    Plug.run(conn, [{Plug.Session, runtime_session_opts()}])
  end

  def runtime_session_opts() do
    session_options =
      on_ee do
        # `host()` provided by Phoenix.Endpoint's compilation hooks
        # is used to inject the domain - this way we can authenticate
        # websocket requests within single root domain, in case websocket_url()
        # returns a ws{s}:// scheme (in which case SameSite=Lax is not applicable).
        Keyword.put(@session_options, :domain, host())
        |> Keyword.put(:key, "_plausible_#{Application.fetch_env!(:plausible, :environment)}")
      else
        # CE setup is simpler and we don't need to worry about WS domain being different
        @session_options
      end

    session_options
    |> Keyword.put(:secure, secure_cookie?())
  end

  defp config!(key) do
    :plausible
    |> Application.fetch_env!(__MODULE__)
    |> Keyword.fetch!(key)
  end

  on_ce do
    require SiteEncrypt
    @behaviour SiteEncrypt
    @force_https_key {:plausible, :force_https}
    @allow_acme_challenges_key {:plausible, :allow_acme_challenges}

    @doc false
    def force_https do
      :persistent_term.put(@force_https_key, true)
    end

    @doc false
    def allow_acme_challenges do
      :persistent_term.put(@allow_acme_challenges_key, true)
    end

    defp maybe_handle_acme_challenge(conn, _opts) do
      if :persistent_term.get(@allow_acme_challenges_key, false) do
        SiteEncrypt.AcmeChallenge.call(conn, _endpoint = __MODULE__)
      else
        conn
      end
    end

    defp maybe_force_ssl(conn, opts) do
      if :persistent_term.get(@force_https_key, false) do
        Plug.SSL.call(conn, opts)
      else
        conn
      end
    end

    @impl SiteEncrypt
    def handle_new_cert, do: :ok

    @doc false
    def app_env_config do
      # this function is being used by site_encrypt
      Application.get_env(:plausible, _endpoint = __MODULE__, [])
    end

    @impl SiteEncrypt
    def certification do
      selfhost_config = Application.fetch_env!(:plausible, :selfhost)
      config = Keyword.fetch!(selfhost_config, :site_encrypt)

      domain = Keyword.fetch!(config, :domain)
      email = Keyword.fetch!(config, :email)
      db_folder = Keyword.fetch!(config, :db_folder)
      directory_url = Keyword.fetch!(config, :directory_url)

      SiteEncrypt.configure(
        mode: :auto,
        log_level: :notice,
        client: :certbot,
        domains: [domain],
        emails: [email],
        db_folder: db_folder,
        directory_url: directory_url
      )
    end
  end
end
```

## File: `lib/plausible_web/flows.ex`
```
defmodule PlausibleWeb.Flows do
  @moduledoc """
  Static compile-time definitions for user progress flows.
  See `PlausibleWeb.Components.FlowProgress` for rendering capabilities.
  """

  @flows %{
    review: [
      "Install Plausible",
      "Verify installation"
    ],
    domain_change: [
      "Set up new domain",
      "Install Plausible",
      "Verify installation"
    ],
    register: [
      "Register",
      "Activate account",
      "Add site info",
      "Install Plausible",
      "Verify installation"
    ],
    invitation: [
      "Register",
      "Activate account"
    ],
    provisioning: [
      "Add site info",
      "Install Plausible",
      "Verify installation"
    ]
  }

  @valid_values @flows
                |> Enum.flat_map(fn {_, steps} -> steps end)
                |> Enum.uniq()

  @valid_keys @flows
              |> Map.keys()
              |> Enum.map(&to_string/1)

  @spec steps(binary() | atom()) :: list(binary())
  def steps(flow) when flow in @valid_keys do
    steps(String.to_existing_atom(flow))
  end

  def steps(flow) when is_atom(flow) do
    Map.get(@flows, flow, [])
  end

  def steps(_), do: []

  @spec valid_values() :: list(binary())
  def valid_values(), do: @valid_values

  @spec valid_values() :: list(binary())
  def valid_keys(), do: @valid_keys

  for {flow, _} <- @flows do
    @spec unquote(flow)() :: binary()
    def unquote(flow)(), do: unquote(to_string(flow))
  end
end
```

## File: `lib/plausible_web/live/auth_context.ex`
```
defmodule PlausibleWeb.Live.AuthContext do
  @moduledoc """
  This module supplies LiveViews with currently logged in user data _if_ session
  data contains a valid token.

  Must be kept in sync with `PlausibleWeb.AuthPlug`.
  """

  import Phoenix.Component

  alias PlausibleWeb.UserAuth

  defmacro __using__(_) do
    quote do
      on_mount unquote(__MODULE__)
    end
  end

  def on_mount(:default, _params, session, socket) do
    socket =
      socket
      |> assign_new(:current_user_session, fn ->
        case UserAuth.get_user_session(session) do
          {:ok, user_session} -> user_session
          _ -> nil
        end
      end)
      |> assign_new(:current_user, fn context ->
        case context.current_user_session do
          %{user: user} -> user
          _ -> nil
        end
      end)
      |> assign_new(:team_from_session, fn
        %{current_user: nil} ->
          nil

        %{current_user: user} ->
          if current_team_id = session["current_team_id"] do
            user.team_memberships
            |> Enum.find(%{}, &(&1.team.identifier == current_team_id))
            |> Map.get(:team)
          end
      end)
      |> assign_new(:my_team, fn
        %{current_user: nil} ->
          nil

        %{current_user: user} ->
          user.team_memberships
          |> Enum.find(%{}, &(&1.role == :owner and &1.team.setup_complete == false))
          |> Map.get(:team)
      end)
      |> assign_new(:current_team, fn
        %{current_user: nil} ->
          nil

        %{team_from_session: %{} = team_from_session} ->
          team_from_session

        %{my_team: %{} = my_team} ->
          my_team

        _ ->
          nil
      end)
      |> assign_new(
        :current_team_role,
        fn
          %{current_user: user = %{}, current_team: current_team = %{}} ->
            Enum.find_value(user.team_memberships, fn team_membership ->
              if team_membership.team_id == current_team.id do
                team_membership.role
              end
            end)

          %{my_team: %{}} ->
            :owner

          _ ->
            nil
        end
      )
      |> assign_new(:teams, fn
        %{current_user: nil} ->
          []

        %{current_user: user} ->
          user.team_memberships
          |> Enum.sort_by(fn tm -> [tm.role != :owner, tm.team_id] end)
          |> Enum.map(&Map.fetch!(&1, :team))
          |> Enum.take(3)
      end)
      |> assign_new(:teams_count, fn
        %{current_user: nil} -> 0
        %{current_user: user} -> length(user.team_memberships)
      end)
      |> assign_new(:more_teams?, fn context ->
        context.teams_count > 3
      end)

    {:cont, socket}
  end
end
```

## File: `lib/plausible_web/live/change_domain_v2.ex`
```
defmodule PlausibleWeb.Live.ChangeDomainV2 do
  @moduledoc """
  LiveView for the change domain v2 flow.
  """
  use PlausibleWeb, :live_view

  alias Plausible.Site
  alias PlausibleWeb.Router.Helpers, as: Routes

  def mount(
        %{"domain" => domain},
        _session,
        socket
      ) do
    site =
      Plausible.Sites.get_for_user!(socket.assigns.current_user, domain, [
        :owner,
        :admin,
        :super_admin
      ])

    changeset = Site.update_changeset(site)

    {:ok,
     assign(socket,
       site: site,
       changeset: changeset,
       domain: domain
     )}
  end

  def render(assigns) do
    ~H"""
    <.focus_box>
      <:title>Change your website domain</:title>
      <:subtitle>
        If you have changed the domain name of your site and would like your new domain name to be displayed in your Plausible dashboard, you can do so here. You won't lose any of your historical stats in this process.
      </:subtitle>

      <:footer>
        <.focus_list>
          <:item>
            Changed your mind? Go back to
            <.styled_link href={Routes.site_path(@socket, :settings_general, @site.domain)}>
              Site Settings
            </.styled_link>
          </:item>
        </.focus_list>
      </:footer>

      <.form :let={f} for={@changeset} phx-submit="submit">
        <.input
          help_text="Just the naked domain or subdomain without 'www', 'https' etc."
          type="text"
          placeholder="example.com"
          field={f[:domain]}
          label="Domain"
        />

        <.button type="submit" class="mt-4 w-full">
          Change Domain
        </.button>

        <.notice class="mt-4" title="Additional Steps May Be Required">
          If you are using the Wordpress plugin, NPM module, or Events API for tracking, you must also update the tracking
          <code>domain</code>
          to match the updated domain. See
          <.styled_link new_tab href="https://plausible.io/docs/change-domain-name/">
            documentation
          </.styled_link>
          for details.
        </.notice>
      </.form>
    </.focus_box>
    """
  end

  def handle_event("submit", %{"site" => %{"domain" => new_domain}}, socket) do
    case Site.Domain.change(socket.assigns.site, new_domain) do
      {:ok, updated_site} ->
        {:noreply,
         socket
         |> put_flash(:success, "Website domain changed successfully")
         |> push_navigate(to: Routes.site_path(socket, :settings_general, updated_site.domain))}

      {:error, changeset} ->
        {:noreply, assign(socket, changeset: changeset)}
    end
  end
end
```

## File: `lib/plausible_web/live/choose_plan.ex`
```
defmodule PlausibleWeb.Live.ChoosePlan do
  @moduledoc """
  LiveView for upgrading to a plan, or changing an existing plan.
  """
  use PlausibleWeb, :live_view

  require Plausible.Billing.Subscription.Status

  alias PlausibleWeb.Components.Billing.{PlanBox, Notice, PageviewSlider}
  alias Plausible.Billing.{Plans, Quota, PlanBenefits}
  alias PlausibleWeb.Router.Helpers, as: Routes

  @contact_link "https://plausible.io/contact"
  @billing_faq_link "https://plausible.io/docs/billing"

  def mount(_params, %{"remote_ip" => remote_ip}, socket) do
    socket =
      socket
      |> assign_new(:pending_ownership_site_ids, fn %{current_user: current_user} ->
        Plausible.Teams.Memberships.all_pending_site_transfers(current_user.email)
      end)
      |> assign_new(:usage, fn %{
                                 current_team: current_team,
                                 pending_ownership_site_ids: pending_ownership_site_ids
                               } ->
        Plausible.Teams.Billing.quota_usage(current_team,
          with_features: true,
          pending_ownership_site_ids: pending_ownership_site_ids
        )
      end)
      |> assign_new(:subscription, fn %{current_team: current_team} ->
        Plausible.Teams.Billing.get_subscription(current_team)
      end)
      |> assign_new(:owned_plan, fn %{subscription: subscription} ->
        Plans.get_regular_plan(subscription, only_non_expired: true)
      end)
      |> assign_new(:owned_tier, fn %{owned_plan: owned_plan} ->
        if owned_plan, do: Map.get(owned_plan, :kind), else: nil
      end)
      |> assign_new(:current_interval, fn %{subscription: subscription} ->
        current_user_subscription_interval(subscription)
      end)
      |> assign_new(:available_plans, fn %{subscription: subscription} ->
        Plans.available_plans_for(subscription, with_prices: true, customer_ip: remote_ip)
      end)
      |> assign_new(:recommended_tier, fn %{
                                            usage: usage,
                                            available_plans: available_plans,
                                            owned_tier: owned_tier
                                          } ->
        highest_starter_plan = List.last(available_plans.starter)
        highest_growth_plan = List.last(available_plans.growth)
        highest_business_plan = List.last(available_plans.business)

        Quota.suggest_tier(
          usage,
          highest_starter_plan,
          highest_growth_plan,
          highest_business_plan,
          owned_tier
        )
      end)
      |> assign_new(:available_volumes, fn %{available_plans: available_plans} ->
        get_available_volumes(available_plans)
      end)
      |> assign_new(:selected_volume, fn %{
                                           usage: usage,
                                           available_volumes: available_volumes
                                         } ->
        default_selected_volume(usage.monthly_pageviews, available_volumes)
      end)
      |> assign_new(:selected_interval, fn %{current_interval: current_interval} ->
        current_interval || :yearly
      end)
      |> assign_new(:selected_starter_plan, fn %{
                                                 available_plans: available_plans,
                                                 selected_volume: selected_volume
                                               } ->
        get_plan_by_volume(available_plans.starter, selected_volume)
      end)
      |> assign_new(:selected_growth_plan, fn %{
                                                available_plans: available_plans,
                                                selected_volume: selected_volume
                                              } ->
        get_plan_by_volume(available_plans.growth, selected_volume)
      end)
      |> assign_new(:selected_business_plan, fn %{
                                                  available_plans: available_plans,
                                                  selected_volume: selected_volume
                                                } ->
        get_plan_by_volume(available_plans.business, selected_volume)
      end)

    {:ok, socket}
  end

  def render(assigns) do
    growth_plan_to_render =
      assigns.selected_growth_plan || List.last(assigns.available_plans.growth)

    business_plan_to_render =
      assigns.selected_business_plan || List.last(assigns.available_plans.business)

    starter_plan_to_render =
      assigns.selected_starter_plan || List.last(assigns.available_plans.starter)

    starter_benefits =
      if starter_plan_to_render do
        PlanBenefits.for_starter(starter_plan_to_render)
      else
        []
      end

    growth_benefits =
      PlanBenefits.for_growth(growth_plan_to_render, starter_benefits)

    business_benefits =
      PlanBenefits.for_business(business_plan_to_render, growth_benefits, starter_benefits)

    enterprise_benefits = PlanBenefits.for_enterprise(business_benefits)

    assigns =
      assigns
      |> assign(:starter_plan_to_render, starter_plan_to_render)
      |> assign(:growth_plan_to_render, growth_plan_to_render)
      |> assign(:business_plan_to_render, business_plan_to_render)
      |> assign(:starter_benefits, starter_benefits)
      |> assign(:growth_benefits, growth_benefits)
      |> assign(:business_benefits, business_benefits)
      |> assign(:enterprise_benefits, enterprise_benefits)

    ~H"""
    <div class="pt-1 pb-12 sm:pb-16 text-gray-900 dark:text-gray-100">
      <div class={[
        "mx-auto px-6 lg:px-8",
        if(is_nil(@starter_plan_to_render), do: "max-w-5xl", else: "max-w-7xl")
      ]}>
        <Notice.pending_site_ownerships_notice
          class="pb-6"
          pending_ownership_count={length(@pending_ownership_site_ids)}
        />
        <Notice.subscription_past_due class="pb-6" subscription={@subscription} />
        <Notice.subscription_paused class="pb-6" subscription={@subscription} />
        <Notice.upgrade_ineligible :if={not Quota.eligible_for_upgrade?(@usage)} />

        <div class="mt-6 w-full md:flex">
          <a
            href={Routes.settings_path(PlausibleWeb.Endpoint, :subscription)}
            class="hidden md:flex md:w-1/6 h-max md:mt-2 text-indigo-600 hover:text-indigo-700 dark:text-indigo-500 dark:hover:text-indigo-600 text-sm font-bold gap-1 items-center"
          >
            <span>←</span>
            <p>Back to Settings</p>
          </a>
          <div class="md:w-4/6">
            <h1 class="mx-auto max-w-4xl text-center text-2xl font-bold tracking-tight lg:text-3xl">
              Traffic based plans that match your growth
            </h1>
            <p class="mx-auto max-w-2xl mt-2 text-center text-gray-600 dark:text-gray-400">
              {if @owned_plan,
                do: "Change your subscription plan",
                else: "Upgrade your trial to a paid plan"}
            </p>
          </div>
        </div>
        <div class="md:hidden mt-6 max-w-md mx-auto">
          <a
            href={Routes.settings_path(PlausibleWeb.Endpoint, :subscription)}
            class="text-indigo-600 hover:text-indigo-700 dark:text-indigo-500 dark:hover:text-indigo-600 text-sm font-bold"
          >
            ← Back to Settings
          </a>
        </div>
        <div class="mt-10 flex flex-col gap-8 lg:flex-row items-center lg:items-baseline">
          <.interval_picker selected_interval={@selected_interval} />
          <PageviewSlider.render
            selected_volume={@selected_volume}
            available_volumes={@available_volumes}
          />
        </div>
        <div class={[
          "mt-6 isolate mx-auto grid max-w-md grid-cols-1 gap-4 lg:max-w-none lg:mx-0",
          if(is_nil(@starter_plan_to_render), do: "lg:grid-cols-3", else: "lg:grid-cols-4")
        ]}>
          <PlanBox.standard
            :if={@growth_plan_to_render.generation == 5}
            kind={:starter}
            owned={@owned_tier == :starter}
            recommended={@recommended_tier == :starter}
            plan_to_render={@starter_plan_to_render}
            benefits={@starter_benefits}
            available={!!@selected_starter_plan}
            {assigns}
          />
          <PlanBox.standard
            kind={:growth}
            owned={@owned_tier == :growth}
            recommended={@recommended_tier == :growth}
            plan_to_render={@growth_plan_to_render}
            benefits={@growth_benefits}
            available={!!@selected_growth_plan}
            {assigns}
          />
          <PlanBox.standard
            kind={:business}
            owned={@owned_tier == :business}
            recommended={@recommended_tier == :business}
            plan_to_render={@business_plan_to_render}
            benefits={@business_benefits}
            available={!!@selected_business_plan}
            {assigns}
          />
          <PlanBox.enterprise
            benefits={@enterprise_benefits}
            recommended={@recommended_tier == :custom}
          />
        </div>
        <div class="mt-2 mx-auto max-w-md lg:max-w-3xl">
          <.accordion_menu>
            <.accordion_item
              open_by_default={true}
              id="usage"
              title="What's my current usage?"
              title_class="text-gray-900 dark:text-gray-200"
            >
              <p class="text-gray-600 dark:text-gray-300">
                <.render_usage pageview_usage={@usage.monthly_pageviews} />
              </p>
            </.accordion_item>

            <.accordion_item
              id="over-limit"
              title="What happens if I go over my monthly pageview limit?"
              title_class="text-gray-900 dark:text-gray-200"
            >
              <p class="text-gray-600 dark:text-gray-300">
                You will never be charged extra for an occasional traffic spike. There are no surprise fees and your card will never be charged unexpectedly. If your pageviews exceed your plan for two consecutive months, we will contact you to upgrade to a higher plan for the following month. You will have two weeks to make a decision. You can decide to continue with a higher plan or to cancel your account at that point.
              </p>
            </.accordion_item>
          </.accordion_menu>
        </div>
        <.help_links />
      </div>
    </div>
    <PlausibleWeb.Components.Billing.paddle_script />
    """
  end

  defp render_usage(assigns) do
    ~H"""
    You have used
    <span :if={@pageview_usage[:last_30_days]} class="inline">
      <b><%= PlausibleWeb.AuthView.delimit_integer(@pageview_usage.last_30_days.total) %></b> billable pageviews in the last 30 days.
    </span>
    <span :if={@pageview_usage[:last_cycle]} class="inline">
      <b>{PlausibleWeb.AuthView.delimit_integer(@pageview_usage.last_cycle.total)}</b>
      billable pageviews in the last billing cycle.
    </span>
    Please see your full usage report (including sites and team members) under the
    <a
      class="text-indigo-600 inline hover:underline"
      href={Routes.settings_path(PlausibleWeb.Endpoint, :subscription)}
    >
      "Subscription" section
    </a> in your account settings.
    """
  end

  def handle_event("set_interval", %{"interval" => interval}, socket) do
    new_interval =
      case interval do
        "yearly" -> :yearly
        "monthly" -> :monthly
      end

    {:noreply, assign(socket, selected_interval: new_interval)}
  end

  def handle_event("slide", %{"slider" => index}, socket) do
    index = String.to_integer(index)
    %{available_plans: available_plans, available_volumes: available_volumes} = socket.assigns

    new_volume =
      if index == length(available_volumes) do
        :enterprise
      else
        Enum.at(available_volumes, index)
      end

    {:noreply,
     assign(socket,
       selected_volume: new_volume,
       selected_starter_plan: get_plan_by_volume(available_plans.starter, new_volume),
       selected_growth_plan: get_plan_by_volume(available_plans.growth, new_volume),
       selected_business_plan: get_plan_by_volume(available_plans.business, new_volume)
     )}
  end

  defp default_selected_volume(pageview_usage, available_volumes) do
    total =
      case pageview_usage do
        %{last_30_days: usage} -> usage.total
        %{last_cycle: usage} -> usage.total
      end

    Enum.find(available_volumes, &(total < &1)) || :enterprise
  end

  defp current_user_subscription_interval(subscription) do
    case Plans.subscription_interval(subscription) do
      "yearly" -> :yearly
      "monthly" -> :monthly
      _ -> nil
    end
  end

  defp get_plan_by_volume(_, :enterprise), do: nil

  defp get_plan_by_volume(plans, volume) do
    Enum.find(plans, &(&1.monthly_pageview_limit == volume))
  end

  defp interval_picker(assigns) do
    ~H"""
    <div class="lg:flex-1 lg:order-3 lg:justify-end flex">
      <div class="relative">
        <.two_months_free />
        <fieldset class="grid grid-cols-2 gap-x-1 rounded-full bg-white dark:bg-gray-700 p-1 text-center text-sm font-semibold leading-5 shadow dark:ring-gray-600">
          <label
            class={"cursor-pointer rounded-full px-2.5 py-1 text-gray-900 dark:text-white #{if @selected_interval == :monthly, do: "bg-indigo-600 text-white"}"}
            phx-click="set_interval"
            phx-value-interval="monthly"
          >
            <input type="radio" name="frequency" value="monthly" class="sr-only" />
            <span>Monthly</span>
          </label>
          <label
            class={"cursor-pointer rounded-full px-2.5 py-1 text-gray-900 dark:text-white #{if @selected_interval == :yearly, do: "bg-indigo-600 text-white"}"}
            phx-click="set_interval"
            phx-value-interval="yearly"
          >
            <input type="radio" name="frequency" value="yearly" class="sr-only" />
            <span>Yearly</span>
          </label>
        </fieldset>
      </div>
    </div>
    """
  end

  def two_months_free(assigns) do
    ~H"""
    <span class="absolute -right-5 -top-4 whitespace-no-wrap w-max px-2.5 py-0.5 rounded-full text-xs font-medium leading-4 bg-yellow-100 border border-yellow-300 text-yellow-700">
      2 months free
    </span>
    """
  end

  defp help_links(assigns) do
    ~H"""
    <div class="mt-16 -mb-16 text-center">
      Any other questions?
      <a class="text-indigo-600 hover:underline" href={contact_link()}>Contact us</a>
      or see <a class="text-indigo-600 hover:underline" href={billing_faq_link()}>billing FAQ</a>
    </div>
    """
  end

  defp get_available_volumes(%{business: business_plans, growth: growth_plans}) do
    growth_volumes = Enum.map(growth_plans, & &1.monthly_pageview_limit)
    business_volumes = Enum.map(business_plans, & &1.monthly_pageview_limit)

    (growth_volumes ++ business_volumes)
    |> Enum.uniq()
  end

  defp contact_link(), do: @contact_link

  defp billing_faq_link(), do: @billing_faq_link
end
```

## File: `lib/plausible_web/live/components/combo_box.ex`
```
defmodule PlausibleWeb.Live.Components.ComboBox do
  @moduledoc """
  Phoenix LiveComponent for a combobox UI element with search and selection
  functionality. 

  The component allows users to select an option from a list of options,
  which can be searched by typing in the input field.

  The component renders an input field with a dropdown anchor and a
  hidden input field for submitting the selected value. In order to remain
  functional, the component must be embedded in a `<form/>`.

  The number of options displayed in the dropdown is limited to 15
  by default but can be customized. When a user types into the input
  field, the component searches the available options and provides
  suggestions based on the input.

  Any function can be supplied via `suggest_fun` attribute
  - see the provided `ComboBox.StaticSearch`.

  In most cases the `suggest_fun` runs an operation that could be deferred,
  so by default, the `async={true}` attr calls it in a background Task
  and updates the suggestions asynchronously. This way, you can render
  the component without having to wait for suggestions to load.

  If you explicitly need to make the operation synchronous, you may
  pass `async={false}` option.

  If your initial `options` are not provided up-front at initial render,
  lack of `options` attr value combined with `async=true` calls the
  `suggest_fun.("", [])` asynchronously - that special clause can be used
  to provide the initial set of suggestions updated right after the initial render.

  To simplify integration testing, suggestions load up synchronously during
  tests. This lets you skip waiting for suggestions messages
  to arrive. The asynchronous behaviour alone is already tested in
  ComboBox own test suite, so there is no need for additional
  verification.
  """
  use PlausibleWeb, :live_component

  @default_suggestions_limit 15

  def update(assigns, socket) do
    socket =
      socket
      |> assign(assigns)
      |> select_default()

    socket =
      if connected?(socket) do
        socket
        |> assign_options()
      else
        socket
      end
      |> assign_suggestions(assigns[:suggestions])

    {:ok, socket}
  end

  attr(:placeholder, :string, default: "Select option or search by typing")
  attr(:id, :any, required: true)
  attr(:options, :list, default: [])
  attr(:submit_name, :string, required: true)
  attr(:display_value, :string, default: "")
  attr(:submit_value, :string, default: "")
  attr(:selected, :any)
  attr(:suggest_fun, :any, required: true)
  attr(:suggestions_limit, :integer)
  attr(:class, :string, default: "")
  attr(:required, :boolean, default: false)
  attr(:creatable, :boolean, default: false)
  attr(:errors, :list, default: [])
  attr(:async, :boolean, default: Mix.env() != :test)
  attr(:on_selection_made, :any)

  def render(assigns) do
    ~H"""
    <div
      id={"input-picker-main-#{@id}"}
      class={@class}
      x-data={"comboBox('#{@id}')"}
      x-on:keydown.arrow-up.prevent="focusPrev"
      x-on:keydown.arrow-down.prevent="focusNext"
      x-on:keydown.enter.prevent="select"
      x-on:keydown.tab="close"
      x-on:keydown.escape="close"
    >
      <div class="relative w-full">
        <div
          @click.away="close"
          class="pl-2 pr-8 py-1 w-full dark:bg-gray-900 dark:text-gray-300 rounded-md shadow-sm border border-gray-300 dark:border-gray-700 focus-within:border-indigo-500 focus-within:ring-1 focus-within:ring-indigo-500"
        >
          <input
            type="text"
            autocomplete="off"
            id={@id}
            name={"display-#{@id}"}
            placeholder={@placeholder}
            x-on:focus="open"
            x-on:selection-change={assigns[:"x-on-selection-change"]}
            phx-change="search"
            x-on:keydown="open"
            phx-target={@myself}
            phx-debounce={200}
            value={@display_value}
            class="text-sm [&.phx-change-loading+svg.spinner]:block border-none py-1.5 px-1.5 w-full inline-block rounded-md focus:outline-none focus:ring-0"
            style="background-color: inherit;"
            required={@required}
          />

          <.spinner class="spinner hidden absolute inset-y-3 right-8" />
          <.spinner
            id={"selection-in-progress-#{@id}"}
            phx-update="ignore"
            x-show="selectionInProgress"
            class="spinner absolute inset-y-3 right-8"
          />

          <.dropdown_anchor id={@id} />

          <input
            type="hidden"
            x-init={"trackSubmitValueChange('#{Phoenix.HTML.javascript_escape(to_string(@submit_value))}')"}
            name={@submit_name}
            value={@submit_value}
            phx-target={@myself}
            id={"submit-#{@id}"}
          />
        </div>

        <.combo_dropdown
          ref={@id}
          suggest_fun={@suggest_fun}
          suggestions={@suggestions}
          target={@myself}
          creatable={@creatable}
          display_value={@display_value}
        />
      </div>
    </div>
    """
  end

  attr(:id, :any, required: true)

  def dropdown_anchor(assigns) do
    ~H"""
    <div x-on:click="open" class="cursor-pointer absolute inset-y-0 right-0 flex items-center pr-2">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 20 20"
        fill="currentColor"
        aria-hidden="true"
        class="h-4 w-4 text-gray-500"
      >
        <path
          fill-rule="evenodd"
          d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z"
          clip-rule="evenodd"
        >
        </path>
      </svg>
    </div>
    """
  end

  attr(:ref, :string, required: true)
  attr(:suggestions, :list, default: [])
  attr(:suggest_fun, :any, required: true)
  attr(:target, :any)
  attr(:creatable, :boolean, required: true)
  attr(:display_value, :string, required: true)

  def combo_dropdown(assigns) do
    ~H"""
    <ul
      tabindex="-1"
      id={"dropdown-#{@ref}"}
      x-show="isOpen"
      x-ref="suggestions"
      class="text-sm w-full dropdown z-50 absolute mt-1 max-h-60 overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none dark:bg-gray-900"
      style="display: none;"
    >
      <.option
        :if={display_creatable_option?(assigns)}
        idx={0}
        submit_value={@display_value}
        display_value={@display_value}
        target={@target}
        ref={@ref}
        creatable
      />

      <.option
        :for={
          {{submit_value, display_value}, idx} <-
            Enum.with_index(
              @suggestions,
              fn {option_value, option}, idx -> {{option_value, to_string(option)}, idx + 1} end
            )
        }
        :if={@suggestions != []}
        idx={idx}
        submit_value={submit_value}
        display_value={display_value}
        target={@target}
        ref={@ref}
      />

      <div
        :if={@suggestions == [] && !@creatable}
        class="relative cursor-default select-none py-2 px-4 text-gray-700 dark:text-gray-300"
      >
        No matches found. Try searching for something different.
      </div>
      <div
        :if={@suggestions == [] && @creatable && String.trim(@display_value) == ""}
        class="relative cursor-default select-none py-2 px-4 text-gray-700 dark:text-gray-300"
      >
        Create an item by typing.
      </div>
    </ul>
    """
  end

  attr(:display_value, :string, required: true)
  attr(:submit_value, :string, required: true)
  attr(:ref, :string, required: true)
  attr(:target, :any)
  attr(:idx, :integer, required: true)
  attr(:creatable, :boolean, default: false)

  def option(assigns) do
    assigns = assign(assigns, :suggestions_limit, suggestions_limit(assigns))

    ~H"""
    <li
      class={[
        "relative select-none cursor-pointer dark:text-gray-300",
        @creatable && "creatable"
      ]}
      @mouseenter={"setFocus(#{@idx})"}
      x-bind:class={ "{'text-white bg-indigo-500': focus === #{@idx}}" }
      id={"dropdown-#{@ref}-option-#{@idx}"}
    >
      <a
        x-ref={"dropdown-#{@ref}-option-#{@idx}"}
        x-on:click={not @creatable && "selectionInProgress = true"}
        phx-click={select_option(@ref, @submit_value, @display_value)}
        phx-value-submit-value={@submit_value}
        phx-value-display-value={@display_value}
        phx-target={@target}
        class="block truncate py-2 px-3"
      >
        <%= if @creatable do %>
          Create "{@display_value}"
        <% else %>
          {@display_value}
        <% end %>
      </a>
    </li>
    <div :if={@idx == @suggestions_limit} class="text-xs text-gray-500 relative py-2 px-3">
      Max results reached. Refine your search by typing.
    </div>
    """
  end

  def select_option(js \\ %JS{}, id, submit_value, display_value) do
    js
    |> JS.dispatch("phx:notify-selection-change",
      detail: %{
        id: id,
        value: %{"submitValue" => submit_value, "displayValue" => display_value}
      }
    )
    |> JS.push("select-option",
      value: %{"submit-value" => submit_value, "display-value" => display_value}
    )
  end

  def handle_event(
        "select-option",
        %{"submit-value" => submit_value, "display-value" => display_value},
        socket
      ) do
    socket = do_select(socket, submit_value, display_value)
    {:noreply, socket}
  end

  def handle_event(
        "search",
        %{"_target" => [target]} = params,
        %{assigns: %{options: options}} = socket
      ) do
    input = params[target]

    input_len = input |> String.trim() |> String.length()

    socket =
      if socket.assigns[:creatable] do
        assign(socket, display_value: input, submit_value: input)
      else
        socket
      end

    suggestions =
      if input_len > 0 do
        run_suggest_fun(input, options, socket.assigns, :suggestions)
      else
        options
      end
      |> Enum.take(suggestions_limit(socket.assigns))

    {:noreply, assign(socket, %{suggestions: suggestions})}
  end

  defp do_select(socket, submit_value, display_value) do
    id = socket.assigns.id

    socket =
      socket
      |> push_event("update-value", %{id: id, value: display_value, fire: false})
      |> push_event("update-value", %{id: "submit-#{id}", value: submit_value, fire: true})
      |> assign(:display_value, display_value)
      |> assign(:submit_value, submit_value)

    if socket.assigns[:on_selection_made] do
      socket.assigns.on_selection_made.(submit_value, id)
    end

    socket
  end

  defp suggestions_limit(assigns) do
    Map.get(assigns, :suggestions_limit, @default_suggestions_limit)
  end

  defp display_creatable_option?(assigns) do
    empty_input? = String.length(assigns.display_value) == 0

    input_matches_suggestion? =
      Enum.any?(assigns.suggestions, fn {suggestion, _} -> assigns.display_value == suggestion end)

    assigns.creatable && not empty_input? && not input_matches_suggestion?
  end

  defp assign_options(socket) do
    assign_new(socket, :options, fn ->
      run_suggest_fun("", [], socket.assigns, :options)
    end)
  end

  defp assign_suggestions(socket, nil = _suggestions_from_update) do
    suggestions =
      socket.assigns
      |> Map.get(:options, [])
      |> Enum.take(suggestions_limit(socket.assigns))

    assign(socket, suggestions: suggestions)
  end

  defp assign_suggestions(socket, _suggestions_from_update) do
    socket
  end

  defp select_default(socket) do
    case {socket.assigns[:selected], socket.assigns[:submit_value]} do
      {{submit_value, display_value}, nil} ->
        assign(socket, submit_value: submit_value, display_value: display_value)

      {submit_and_display_value, nil} when is_binary(submit_and_display_value) ->
        assign(socket,
          submit_value: submit_and_display_value,
          display_value: submit_and_display_value
        )

      _ ->
        socket
    end
  end

  defp run_suggest_fun(input, options, %{id: id, suggest_fun: fun} = assigns, key_to_update) do
    if assigns[:async] do
      pid = self()

      Task.start(fn ->
        result = fun.(input, options)

        send_update(
          pid,
          __MODULE__,
          Keyword.new([
            {:id, id},
            {key_to_update, result}
          ])
        )
      end)

      # This prevents flashing the suggestions container
      # before the update is received on a subsequent render
      assigns[key_to_update] || []
    else
      fun.(input, options)
    end
  end
end
```

## File: `lib/plausible_web/live/components/combo_box/static_search.ex`
```
defmodule PlausibleWeb.Live.Components.ComboBox.StaticSearch do
  @moduledoc """
  Default suggestion engine for the `ComboBox` component.

  Assumes, the user have already queried the database and the data set is
  small enough to be kept in state and filtered based on external input.

  Favours exact matches. Skips entries shorter than input.
  Allows fuzzy matching based on Jaro Distance.
  """

  @spec suggest(String.t(), [{any(), any()}]) :: [{any(), any()}]
  def suggest(input, choices, opts \\ []) do
    input = String.trim(input)

    if input != "" do
      weight_threshold = Keyword.get(opts, :weight_threshold, 0.6)

      choices
      |> Enum.map(fn
        {_, value} = choice ->
          {choice, weight(value, input, opts)}

        value ->
          {value, weight(value, input, opts)}
      end)
      |> Enum.reject(fn {_choice, weight} -> weight < weight_threshold end)
      |> Enum.sort_by(fn {_choice, weight} -> weight end, :desc)
      |> Enum.map(fn {choice, _weight} -> choice end)
    else
      choices
    end
  end

  defp weight(value, input, opts) do
    to_str = Keyword.get(opts, :to_string, &to_string/1)
    value = to_str.(value)

    case {value, input} do
      {value, input} when value == input ->
        3

      {value, input} when byte_size(input) > byte_size(value) ->
        0

      {value, input} ->
        input = String.downcase(input)
        value = String.downcase(value)
        weight = if String.contains?(value, input), do: 1, else: 0
        weight + String.jaro_distance(value, input)
    end
  end
end
```

## File: `lib/plausible_web/live/components/form.ex`
```
defmodule PlausibleWeb.Live.Components.Form do
  @moduledoc """
  Generic components stolen from mix phx.new templates
  """

  use Phoenix.Component

  @doc """
  Renders an input with label and error messages.

  A `Phoenix.HTML.FormField` may be passed as argument,
  which is used to retrieve the input name, id, and values.
  Otherwise all attributes may be passed explicitly.

  ## Examples

  <.input field={@form[:email]} type="email" />
  <.input name="my-input" errors={["oh no!"]} />
  """

  @default_input_class "text-sm text-gray-900 dark:text-white dark:bg-gray-900 block pl-3.5 py-2.5 border-gray-300 dark:border-gray-700 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 rounded-md"

  attr(:id, :any, default: nil)
  attr(:name, :any)
  attr(:label, :string, default: nil)
  attr(:help_text, :string, default: nil)
  attr(:value, :any)
  attr(:width, :string, default: "w-full")

  attr(:type, :string,
    default: "text",
    values: ~w(checkbox color date datetime-local email file hidden month number password
         range radio search select tel text textarea time url week)
  )

  attr(:field, Phoenix.HTML.FormField,
    doc: "a form field struct retrieved from the form, for example: @form[:email]"
  )

  attr(:errors, :list, default: [])
  attr(:checked, :boolean, doc: "the checked flag for checkbox inputs")
  attr(:prompt, :string, default: nil, doc: "the prompt for select inputs")
  attr(:options, :list, doc: "the options to pass to Phoenix.HTML.Form.options_for_select/2")
  attr(:multiple, :boolean, default: false, doc: "the multiple flag for select inputs")

  attr(:rest, :global,
    include: ~w(accept autocomplete capture cols disabled form list max maxlength min minlength
         multiple pattern placeholder readonly required rows size step x-model)
  )

  attr(:class, :any, default: @default_input_class)

  attr(:mt?, :boolean, default: true)
  attr(:max_one_error, :boolean, default: false)
  slot(:help_content)
  slot(:inner_block)

  def input(%{field: %Phoenix.HTML.FormField{} = field} = assigns) do
    errors = if Phoenix.Component.used_input?(field), do: field.errors, else: []

    assigns
    |> assign(
      field: nil,
      id: assigns.id || field.id,
      class: assigns.class,
      mt?: assigns.mt?,
      width: assigns.width
    )
    |> assign(:errors, Enum.map(errors, &translate_error(&1)))
    |> assign_new(:name, fn -> if assigns.multiple, do: field.name <> "[]", else: field.name end)
    |> assign_new(:value, fn -> field.value end)
    |> input()
  end

  def input(%{type: "select"} = assigns) do
    ~H"""
    <div class={@mt? && "mt-2"}>
      <.label for={@id} class="mb-2">{@label}</.label>

      <p :if={@help_text} class="text-gray-500 dark:text-gray-400 mb-2 text-sm">
        {@help_text}
      </p>
      <select id={@id} name={@name} multiple={@multiple} class={[@class, @width]} {@rest}>
        <option :if={@prompt} value="">{@prompt}</option>
        {Phoenix.HTML.Form.options_for_select(@options, @value)}
      </select>
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  def input(%{type: "checkbox"} = assigns) do
    assigns =
      assign_new(assigns, :checked, fn ->
        Phoenix.HTML.Form.normalize_value("checkbox", assigns[:value])
      end)

    ~H"""
    <div class={[
      @mt? && "mt-2"
    ]}>
      <.label
        for={@id}
        class="font-normal gap-x-2 flex flex-inline items-center sm:justify-start justify-center "
      >
        <input type="hidden" name={@name} value="false" disabled={@rest[:disabled]} />
        <input
          type="checkbox"
          value="true"
          checked={@checked}
          id={@id}
          name={@name}
          class="block h-5 w-5 rounded dark:bg-gray-700 border-gray-300 text-indigo-600 focus:ring-indigo-600"
          {@rest}
        />
        {@label}
      </.label>
    </div>
    """
  end

  def input(%{type: "radio"} = assigns) do
    ~H"""
    <div class={[
      "flex flex-inline items-center justify-start gap-x-3",
      @mt? && "mt-2"
    ]}>
      <input
        type="radio"
        value={@value}
        id={@id}
        name={@name}
        checked={assigns[:checked]}
        class="block dark:bg-gray-900 h-4 w-4 mt-0.5 cursor-pointer text-indigo-600 border-gray-300 dark:border-gray-500 focus:ring-indigo-500"
        {@rest}
      />
      <.label :if={@label} class="flex flex-col flex-inline" for={@id}>
        <span>{@label}</span>

        <span
          :if={@help_text || @help_content != []}
          class="text-gray-500 dark:text-gray-400 mb-2 text-sm"
        >
          {@help_text}
          {render_slot(@help_content)}
        </span>
      </.label>
    </div>
    """
  end

  def input(%{type: "textarea"} = assigns) do
    ~H"""
    <div class={@mt? && "mt-2"}>
      <.label class="mb-2" for={@id}>{@label}</.label>
      <textarea
        id={@id}
        rows={@rest[:rows] || "6"}
        name={@name}
        class="block w-full textarea border-1 border-gray-300 rounded-md p-4 text-sm text-gray-700 dark:border-gray-500 dark:bg-gray-900 dark:text-gray-300"
        {@rest}
      >{Phoenix.HTML.Form.normalize_value("textarea", @value)}</textarea>
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  # All other inputs text, datetime-local, url, password, etc. are handled here...
  def input(assigns) do
    errors =
      if assigns.max_one_error do
        Enum.take(assigns.errors, 1)
      else
        assigns.errors
      end

    assigns = assign(assigns, :errors, errors)

    ~H"""
    <div class={@mt? && "mt-2"}>
      <.label :if={@label != nil and @label != ""} for={@id} class="mb-2">
        {@label}
      </.label>
      <p :if={@help_text} class="text-gray-500 dark:text-gray-400 mb-2 text-sm">
        {@help_text}
      </p>
      <input
        type={@type}
        name={@name}
        id={@id}
        value={Phoenix.HTML.Form.normalize_value(@type, @value)}
        class={[@class, @width, assigns[:rest][:disabled] && "text-gray-500 dark:text-gray-400"]}
        {@rest}
      />
      {render_slot(@inner_block)}
      <.error :for={msg <- @errors}>
        {msg}
      </.error>
    </div>
    """
  end

  attr(:rest, :global)
  attr(:id, :string, required: true)
  attr(:name, :string, required: true)
  attr(:label, :string, default: nil)
  attr(:value, :string, default: "")

  def input_with_clipboard(assigns) do
    class = [@default_input_class, "pr-20 w-full"]
    assigns = assign(assigns, class: class)

    ~H"""
    <div>
      <div :if={@label}>
        <.label for={@id} class="mb-2">
          {@label}
        </.label>
      </div>
      <div class="relative">
        <.input
          mt?={false}
          id={@id}
          name={@name}
          value={@value}
          type="text"
          readonly="readonly"
          class={@class}
          {@rest}
        />
        <a
          onclick={"var input = document.getElementById('#{@id}'); input.focus(); input.select(); document.execCommand('copy'); event.stopPropagation();"}
          href="javascript:void(0)"
          class="absolute flex items-center text-xs font-medium text-indigo-600 no-underline hover:underline top-3 right-4"
        >
          <Heroicons.document_duplicate class="pr-1 text-indigo-600 dark:text-indigo-500 w-5 h-5" />
          <span>
            COPY
          </span>
        </a>
      </div>
    </div>
    """
  end

  attr(:id, :any, default: nil)
  attr(:label, :string, default: nil)

  attr(:field, Phoenix.HTML.FormField,
    doc: "a form field struct retrieved from the form, for example: @form[:password]",
    required: true
  )

  attr(:strength, :any)

  attr(:rest, :global,
    include: ~w(autocomplete disabled form maxlength minlength readonly required size)
  )

  def password_input_with_strength(%{field: field} = assigns) do
    {too_weak?, errors} =
      case pop_strength_errors(field.errors) do
        {strength_errors, other_errors} when strength_errors != [] ->
          {true, other_errors}

        {[], other_errors} ->
          {false, other_errors}
      end

    strength =
      if too_weak? and assigns.strength.score >= 3 do
        %{assigns.strength | score: 2}
      else
        assigns.strength
      end

    assigns =
      assigns
      |> assign(:too_weak?, too_weak?)
      |> assign(:field, %{field | errors: errors})
      |> assign(:strength, strength)
      |> assign(
        :show_meter?,
        Phoenix.Component.used_input?(field) && (too_weak? || strength.score > 0)
      )

    ~H"""
    <.input field={@field} type="password" autocomplete="new-password" label={@label} id={@id} {@rest}>
      <.strength_meter :if={@show_meter?} {@strength} />
    </.input>
    """
  end

  attr(:minimum, :integer, required: true)

  attr(:class, :any)
  attr(:ok_class, :any)
  attr(:error_class, :any)

  attr(:field, Phoenix.HTML.FormField,
    doc: "a form field struct retrieved from the form, for example: @form[:password]",
    required: true
  )

  def password_length_hint(%{field: field} = assigns) do
    {strength_errors, _} = pop_strength_errors(field.errors)

    ok_class = assigns[:ok_class] || "text-gray-500"
    error_class = assigns[:error_class] || "text-red-500"
    class = assigns[:class] || ["text-xs", "mt-1"]

    color =
      if :length in strength_errors do
        error_class
      else
        ok_class
      end

    final_class = [color | class]

    assigns = assign(assigns, :class, final_class)

    ~H"""
    <p class={@class}>Min {@minimum} characters</p>
    """
  end

  defp pop_strength_errors(errors) do
    Enum.reduce(errors, {[], []}, fn {_, meta} = error, {detected, other_errors} ->
      cond do
        meta[:validation] == :required ->
          {[:required | detected], other_errors}

        meta[:validation] == :length and meta[:kind] == :min ->
          {[:length | detected], other_errors}

        meta[:validation] == :strength ->
          {[:strength | detected], other_errors}

        true ->
          {detected, [error | other_errors]}
      end
    end)
  end

  attr(:score, :integer, default: 0)
  attr(:warning, :string, default: "")
  attr(:suggestions, :list, default: [])

  def strength_meter(assigns) do
    color =
      cond do
        assigns.score <= 1 -> ["bg-red-500", "dark:bg-red-500"]
        assigns.score == 2 -> ["bg-red-300", "dark:bg-red-300"]
        assigns.score == 3 -> ["bg-indigo-300", "dark:bg-indigo-300"]
        assigns.score >= 4 -> ["bg-indigo-600", "dark:bg-indigo-500"]
      end

    feedback =
      cond do
        assigns.warning != "" -> assigns.warning <> "."
        assigns.suggestions != [] -> List.first(assigns.suggestions)
        true -> nil
      end

    assigns =
      assigns
      |> assign(:color, color)
      |> assign(:feedback, feedback)

    ~H"""
    <div class="w-full bg-gray-200 rounded-full h-1.5 mb-2 mt-2 dark:bg-gray-700 mt-1">
      <div
        class={["h-1.5", "rounded-full"] ++ @color}
        style={["width: " <> to_string(@score * 25) <> "%"]}
      >
      </div>
    </div>
    <p :if={@score <= 2} class="text-sm text-red-500">
      Password is too weak
    </p>
    <p :if={@feedback} class="text-xs text-gray-500">
      {@feedback}
    </p>
    """
  end

  @doc """
  Renders a label.
  """
  attr :for, :string, default: nil
  slot :inner_block, required: true
  attr :class, :string, default: ""

  def label(assigns) do
    ~H"""
    <label for={@for} class={["text-sm block font-medium dark:text-gray-100", @class]}>
      {render_slot(@inner_block)}
    </label>
    """
  end

  @doc """
  Generates a generic error message.
  """
  slot(:inner_block, required: true)

  def error(assigns) do
    ~H"""
    <p class="flex gap-3 text-sm leading-6 text-red-500">
      {render_slot(@inner_block)}
    </p>
    """
  end

  def translate_error({msg, opts}) do
    Enum.reduce(opts, msg, fn {key, value}, acc ->
      String.replace(acc, "%{#{key}}", fn _ -> to_string(value) end)
    end)
  end

  attr :conn, Plug.Conn, required: true
  attr :name, :string, required: true
  attr :options, :list, required: true
  attr :value, :any, default: nil
  attr :href_base, :string, default: "/"
  attr :selected_fn, :any, required: true

  def mobile_nav_dropdown(%{options: options} = assigns) do
    assigns = assign(assigns, :options, flatten_options(options))

    ~H"""
    <.form for={@conn} class="lg:hidden py-4">
      <.input
        value={
          @options
          |> Enum.find_value(fn {_k, v} ->
            apply(@selected_fn, [v]) && v
          end)
        }
        name={@name}
        type="select"
        options={@options}
        onchange={"if (event.target.value) { location.href = '#{@href_base}' + event.target.value }"}
        class="dark:bg-gray-800 mt-1 block w-full pl-3.5 pr-10 py-2.5 text-base border-gray-300 dark:border-gray-500 outline-none focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 rounded-md dark:text-gray-100"
      />
    </.form>
    """
  end

  defp flatten_options(options, prefix \\ "") do
    options
    |> Enum.map(fn
      {key, suboptions} when is_list(suboptions) ->
        flatten_options(suboptions, prefix <> key <> ": ")

      {key, value} when is_binary(value) ->
        {prefix <> key, value}

      %{value: value, key: key} when is_binary(value) ->
        {prefix <> key, value}

      %{value: submenu_items, key: parent_key} when is_list(submenu_items) ->
        Enum.map(submenu_items, fn submenu_item ->
          {"#{prefix}#{parent_key}: #{submenu_item.key}", submenu_item.value}
        end)
    end)
    |> List.flatten()
  end
end
```

## File: `lib/plausible_web/live/components/modal.ex`
```
defmodule PlausibleWeb.Live.Components.Modal do
  @moduledoc ~S"""
  LiveView implementation of modal component.

  This component is a general purpose modal implementation for LiveView
  with emphasis on keeping nested components largely agnostic of the fact
  that they are placed in a modal and maintaining good user experience
  on connections with high latency.

  ## Usage

  An example use case for a modal is embedding a form inside
  existing live view which allows adding new entries of some kind:

  ```
  <.live_component module={Modal} id="some-form-modal" :let={modal_unique_id}>
    <.live_component
      module={SomeForm}
      id={"some-form-#{modal_unique_id}"}
      on_save_form={
        fn entry, socket ->
          send(self(), {:entry_added, entry})
          Modal.close(socket, "some-form-modal")
        end
      }
    />
  </.live_component>
  ```

  Then somewhere in the same live view the modal is rendered in:

  ```
  <.button x-data x-on:click={Modal.JS.open("goals-form-modal")}>
    + Add Entry
  </.button>
  ```

  ## Explanation

  The component embedded inside the modal is always rendered when
  the live view is mounted but is kept hidden until `Modal.JS.open`
  is called on it. On subsequent openings within the same session
  the contents of the modal are completely remounted. This assures
  that any stateful components inside the modal are reset to their
  initial state. The modal component provides `modal_unique_id`
  as an argument to its inner block. Appending this ID to every
  live components' ID nested inside the modal is important for
  consistent state reset on every reopening. This also applies
  to live components nested inside live components embedded directly
  in the modal's inner block - then the unique ID should be also
  passed down as an attribute and appended accordingly. Appending can
  be skipped if embedded component handles state reset explicitly
  (via, for instance, `phx-click-away` callback).

  `Modal` exposes a number of functions for managing window state:

    * `Modal.JS.preopen/1` - to preopen the modal on the frontend.
      Useful when the actual opening is done server-side with
      `Modal.open/2` - helps avoid lack of feedback to the end user
      when server-side state change before opening the modal is
      still in progress.
    * `Modal.JS.open/1` - to open the modal from the frontend. It's
      important to make sure the element triggering that call is
      wrapped in an Alpine UI component - or is an Alpine component
      itself - adding `x-data` attribute without any value is enough
      to ensure that.
    * `Modal.open/2` - to open the modal from the backend; usually
      called from `handle_event/2` of component wrapping the modal
      and providing the state. Should be used together with
      `Modal.JS.preopen/1` for optimal user experience.
    * `Modal.close/2` - to close the modal from the backend; usually
      done inside wrapped component's `handle_event/2`. The example
      quoted above shows one way to implement this, under that assumption
      that the component exposes a callback, like this:

      ```
      defmodule SomeForm do
        use Phoenix.LiveComponent

        def update(assigns, socket) do
          # ...

          {:ok, assign(socket, :on_save_form, assigns.on_save_form)}
        end

        #...

        def handle_event("save-form", %{"form" => form}, socket) do
          case save_entry(form) do
            {:ok, entry} ->
              {:noreply, socket.assigns.on_save_form(entry, socket)}

            # error case handling ...
          end
        end
      end
      ```

      Using callback approach has an added benefit of making the
      component more flexible.

  """

  @test_preload_override? Mix.env() in [:test, :ce_test]

  use PlausibleWeb, :live_component

  alias Phoenix.LiveView

  defmodule JS do
    @moduledoc false

    @spec open(String.t()) :: String.t()
    def open(id) do
      "$dispatch('open-modal', '#{id}')"
    end

    @spec preopen(String.t()) :: String.t()
    def preopen(id) do
      "$dispatch('preopen-modal', '#{id}')"
    end
  end

  @spec open(LiveView.Socket.t(), String.t()) :: LiveView.Socket.t()
  def open(socket, id) do
    LiveView.push_event(socket, "open-modal", %{id: id})
  end

  @spec close(LiveView.Socket.t(), String.t()) :: LiveView.Socket.t()
  def close(socket, id) do
    LiveView.push_event(socket, "close-modal", %{id: id})
  end

  @impl true
  def update(assigns, socket) do
    # NOTE: This is a workaround for @test_preload_override? being computed
    # at build time, where Mix.env() is available. Otherwise, dialyzer
    # complains.
    preload_override? = :erlang.phash2(1, 1) == 0 and @test_preload_override?
    preload? = preload_override? || Map.get(assigns, :preload?, true)

    socket =
      assign(socket,
        id: assigns.id,
        inner_block: assigns.inner_block,
        # Initial value is constant, as dead view ID
        # must match the ID after the connection is
        # established. Otherwise, there will be problems
        # with live components relying on ID for setup
        # on mount (using AlpineJS, for instance).
        load_content?: preload?,
        preload?: preload?,
        modal_sequence_id: 0
      )

    {:ok, socket}
  end

  attr :id, :any, required: true
  attr :class, :string, default: ""
  attr :preload?, :boolean, default: true
  slot :inner_block, required: true

  def render(assigns) do
    class = [
      "md:w-1/2 w-full max-w-md mx-auto bg-white dark:bg-gray-800 shadow-xl rounded-lg px-8 pt-6 pb-8 top-24",
      assigns.class
    ]

    assigns =
      assign(assigns,
        class: ["modal-dialog relative opacity-0 translate-y-4 sm:translate-y-0" | class],
        dialog_id: assigns.id <> "-dialog"
      )

    ~H"""
    <div
      id={@id}
      class="relative z-[2049] [&[data-phx-ref]_div.modal-dialog]:hidden [&[data-phx-ref]_div.modal-loading]:block"
      data-modal
      x-cloak
      x-data="{
        firstLoadDone: false,
        modalOpen: false,
        modalPreopen: false,
        preopenModal() {
          document.body.style['overflow-y'] = 'hidden';

          this.modalPreopen = true;
        },
        openModal() {
          document.body.style['overflow-y'] = 'hidden';

          if (this.firstLoadDone) {
            liveSocket.execJS($el, $el.dataset.onopen);
          } else {
            this.firstLoadDone = true;
          }

          this.modalPreopen = false;
          this.modalOpen = true;
        },
        closeModal() {
          this.modalPreopen = false;
          this.modalOpen = false;
          liveSocket.execJS($el, $el.dataset.onclose);

          setTimeout(function() {
            document.body.style['overflow-y'] = 'auto';
          }, 200);
        }
      }"
      x-init={"firstLoadDone = #{not @preload?}"}
      x-on:preopen-modal.window={"if ($event.detail === '#{@id}') preopenModal()"}
      x-on:open-modal.window={"if ($event.detail === '#{@id}') openModal()"}
      x-on:close-modal.window={"if ($event.detail === '#{@id}') closeModal()"}
      data-onopen={LiveView.JS.push("open", target: @myself)}
      data-onclose={LiveView.JS.push("close", target: @myself)}
      x-on:keydown.escape.window="closeModal()"
      role="dialog"
      aria-modal="true"
    >
      <div
        x-show="modalOpen || modalPreopen"
        x-transition:enter="transition ease-out duration-300"
        x-transition:enter-start="bg-opacity-0"
        x-transition:enter-end="bg-opacity-75"
        x-transition:leave="transition ease-in duration-200"
        x-transition:leave-start="bg-opacity-75"
        x-transition:leave-end="bg-opacity-0"
        class="fixed inset-0 bg-gray-500 bg-opacity-75 z-[2050]"
      >
      </div>
      <div
        x-show="modalPreopen"
        class="fixed flex inset-0 items-start z-[2050] overflow-y-auto overflow-x-hidden"
      >
        <div class="modal-pre-loading w-full self-center">
          <div class="text-center">
            <.spinner class="inline-block h-8 w-8" />
          </div>
        </div>
      </div>
      <div
        x-show="modalOpen"
        class="fixed flex inset-0 items-start z-[2050] overflow-y-auto overflow-x-hidden"
      >
        <Phoenix.Component.focus_wrap
          :if={@load_content?}
          phx-mounted={
            LiveView.JS.show(
              time: 300,
              transition:
                {"ease-out duration-300", "opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95",
                 "opacity-100 translate-y-0 sm:scale-100"}
            )
          }
          id={@dialog_id}
          class={@class}
          x-show="modalOpen"
          x-transition:enter="transition ease-out duration-300"
          x-transition:enter-start="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
          x-transition:enter-end="opacity-100 translate-y-0 sm:scale-100"
          x-transition:leave="transition ease-in duration-200"
          x-transition:leave-start="opacity-100 translate-y-0 sm:scale-100"
          x-transition:leave-end="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
          x-on:click.outside="closeModal()"
        >
          {render_slot(@inner_block, modal_unique_id(@modal_sequence_id))}
        </Phoenix.Component.focus_wrap>
        <div x-show="modalOpen" class="modal-loading hidden w-full self-center">
          <div class="text-center">
            <.spinner class="inline-block h-8 w-8" />
          </div>
        </div>
      </div>
    </div>
    """
  end

  @impl true
  def handle_event("open", _, socket) do
    {:noreply, assign(socket, load_content?: true)}
  end

  def handle_event("close", _, socket) do
    socket =
      socket
      |> assign(:load_content?, false)
      |> update(:modal_sequence_id, &(&1 + 1))

    {:noreply, socket}
  end

  defp modal_unique_id(sequence_id) do
    "modalseq#{sequence_id}"
  end
end
```

## File: `lib/plausible_web/live/components/pagination.ex`
```
defmodule PlausibleWeb.Live.Components.Pagination do
  @moduledoc """
  Pagination components for LiveViews.
  """
  use Phoenix.Component

  def pagination(assigns) do
    ~H"""
    <nav
      class="px-4 py-3 flex items-center justify-between border-t border-gray-200 dark:border-gray-500 sm:px-6"
      aria-label="Pagination"
    >
      <div class="hidden sm:block">
        <p class="text-sm text-gray-700 dark:text-gray-300">
          {render_slot(@inner_block)}
        </p>
      </div>
      <div class="flex-1 flex justify-between sm:justify-end">
        <.pagination_link
          page_number={@page_number}
          total_pages={@total_pages}
          uri={@uri}
          type={:prev}
        />
        <.pagination_link
          page_number={@page_number}
          total_pages={@total_pages}
          class="ml-4"
          uri={@uri}
          type={:next}
        />
      </div>
    </nav>
    """
  end

  attr :class, :string, default: nil
  attr :uri, URI, required: true
  attr :type, :atom, required: true
  attr :page_number, :integer, required: true
  attr :total_pages, :integer, required: true

  defp pagination_link(assigns) do
    {active?, uri} =
      case {assigns.type, assigns.page_number, assigns.total_pages} do
        {:next, n, total} when n < total ->
          params = URI.decode_query(assigns.uri.query, %{"page" => n + 1})
          {true, %{assigns.uri | query: URI.encode_query(params)}}

        {:prev, n, _total} when n > 1 ->
          params = URI.decode_query(assigns.uri.query, %{"page" => n - 1})
          {true, %{assigns.uri | query: URI.encode_query(params)}}

        {_, _, _} ->
          {false, nil}
      end

    assigns = assign(assigns, uri: active? && URI.to_string(uri), active?: active?)

    ~H"""
    <.link
      navigate={@uri}
      class={[
        "pagination-link relative inline-flex items-center px-4 py-2 border text-sm font-medium rounded-md",
        if @active? do
          "active button "
        else
          "inactive border-gray-300 text-gray-300 dark:border-gray-500 dark:bg-gray-800 dark:text-gray-600 hover:shadow-none hover:bg-gray-300 cursor-not-allowed"
        end,
        @class
      ]}
    >
      <span :if={@type == :prev}>← Previous</span>
      <span :if={@type == :next}>Next →</span>
    </.link>
    """
  end
end
```

## File: `lib/plausible_web/live/components/team.ex`
```
defmodule PlausibleWeb.Live.Components.Team do
  @moduledoc """
  Shared component base for listing team members/invitations
  alongside with the role dropdown.
  """
  use PlausibleWeb, :component
  import PlausibleWeb.Components.Generic

  alias Plausible.Auth.User

  attr(:user, User, required: true)
  attr(:label, :string, default: nil)
  attr(:role, :atom, default: nil)
  attr(:my_role, :atom, required: true)
  attr(:disabled, :boolean, default: false)
  attr(:remove_disabled, :boolean, default: false)

  def member(assigns) do
    ~H"""
    <div
      class="mt-4"
      id={"member-row-#{:erlang.phash2(@user.email)}"}
      data-test-kind={if @role == :guest, do: "guest", else: "member"}
      data-role-changed={
        JS.show(
          transition: {"duration-500", "opacity-0 shadow-2xl -translate-y-6", "opacity-100 shadow"},
          time: 400
        )
      }
    >
      <div class="flex items-center gap-x-5">
        <img src={User.profile_img_url(@user)} class="w-7 rounded-full bg-gray-300" />
        <span class="text-sm">
          {@user.name}
          <span
            :if={@label}
            class="ml-1 dark:bg-indigo-600 dark:text-gray-200 bg-gray-100 text-gray-500 text-xs px-1 rounded"
          >
            {@label}
          </span>

          <br /><span class="text-gray-500 text-xs">{@user.email}</span>
        </span>
        <div class="flex-1 text-right">
          <.dropdown id={"role-dropdown-#{@user.email}"}>
            <:button class="role bg-transparent text-gray-800 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700 focus-visible:outline-gray-100 whitespace-nowrap truncate inline-flex items-center gap-x-2 font-medium rounded-md px-3.5 py-2.5 text-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 disabled:bg-gray-400 dark:disabled:text-white dark:disabled:text-gray-400 dark:disabled:bg-gray-700">
              <span :if={@disabled} class="text-gray-400">
                {@role |> to_string() |> String.capitalize()}
              </span>
              <span :if={not @disabled}>
                {@role |> to_string() |> String.capitalize()}
              </span>
              <Heroicons.chevron_down :if={@disabled} mini class="text-gray-400 size-4 mt-0.5" />
              <Heroicons.chevron_down :if={not @disabled} mini class="size-4 mt-0.5" />
            </:button>
            <:menu class="dropdown-items max-w-60">
              <.role_item
                user={@user}
                id={"option-#{:erlang.phash2(@user.email)}-owner"}
                phx-value-email={@user.email}
                phx-value-name={@user.name}
                role={:owner}
                disabled={@disabled or @role == :owner}
                dispatch_animation?={@role == :guest}
              >
                Manage the team without restrictions
              </.role_item>
              <.role_item
                user={@user}
                id={"option-#{:erlang.phash2(@user.email)}-admin"}
                phx-value-email={@user.email}
                phx-value-name={@user.name}
                role={:admin}
                disabled={@disabled or @role == :admin}
                dispatch_animation?={@role == :guest}
              >
                Manage all team settings
              </.role_item>
              <.role_item
                user={@user}
                id={"option-#{:erlang.phash2(@user.email)}-editor"}
                phx-value-email={@user.email}
                phx-value-name={@user.name}
                role={:editor}
                disabled={@disabled or @role == :editor}
                dispatch_animation?={@role == :guest}
              >
                Create and view new sites
              </.role_item>
              <.role_item
                user={@user}
                id={"option-#{:erlang.phash2(@user.email)}-billing"}
                phx-value-email={@user.email}
                phx-value-name={@user.name}
                role={:billing}
                disabled={@disabled or @role == :billing}
                dispatch_animation?={@role == :guest}
              >
                Manage subscription
              </.role_item>
              <.role_item
                user={@user}
                id={"option-#{:erlang.phash2(@user.email)}-viewer"}
                phx-value-email={@user.email}
                phx-value-name={@user.name}
                role={:viewer}
                disabled={@disabled or @role == :viewer}
                dispatch_animation?={@role == :guest}
              >
                View all sites under your team
              </.role_item>
              <.dropdown_divider />

              <.dropdown_item
                id={"#{:erlang.phash2(@user.email)}-remove"}
                href="#"
                disabled={@disabled or @remove_disabled}
                phx-click="remove-member"
                phx-value-email={@user.email}
                phx-value-name={@user.name}
              >
                <div class={
                  not @remove_disabled &&
                    "text-red-600 hover:text-red-600 dark:text-red-500 hover:dark:text-red-400"
                }>
                  Remove member
                </div>
                <div class="text-gray-500 dark:text-gray-400 text-xs/5">
                  Remove member from your team
                </div>
              </.dropdown_item>
            </:menu>
          </.dropdown>
        </div>
      </div>
    </div>
    """
  end

  attr(:role, :atom, required: true)
  attr(:disabled, :boolean, default: false)
  attr(:dispatch_animation?, :boolean, default: false)
  attr(:rest, :global)
  attr(:user, :map, default: %{email: nil})
  attr(:id, :string, default: nil)

  slot(:inner_block, required: true)

  def role_item(assigns) do
    click =
      cond do
        phx_click = assigns.rest[:"phx-click"] ->
          phx_click

        assigns.dispatch_animation? ->
          JS.hide(
            transition: {"duration-500", "opacity-100", "opacity-0"},
            to: "#member-row-#{:erlang.phash2(assigns.user.email)}",
            time: 500
          )
          |> JS.push("update-role")

        true ->
          "update-role"
      end

    assigns = assign(assigns, :click, click)

    ~H"""
    <.dropdown_item
      id={@id}
      href="#"
      phx-click={@click}
      phx-value-role={@role}
      disabled={@disabled}
      {@rest}
    >
      <div>{@role |> Atom.to_string() |> String.capitalize()}</div>
      <div class="text-gray-500 dark:text-gray-400 text-xs/5">
        {render_slot(@inner_block)}
      </div>
    </.dropdown_item>
    """
  end
end
```

## File: `lib/plausible_web/live/components/verification.ex`
```
defmodule PlausibleWeb.Live.Components.Verification do
  @moduledoc """
  This component is responsible for rendering the verification progress
  and diagnostics.
  """
  use Phoenix.LiveComponent
  use Plausible

  alias PlausibleWeb.Router.Helpers, as: Routes
  alias Plausible.InstallationSupport.{State, Result}

  import PlausibleWeb.Components.Generic

  attr(:domain, :string, required: true)

  attr(:message, :string,
    default: "We're visiting your site to ensure that everything is working"
  )

  attr(:super_admin?, :boolean, default: false)
  attr(:finished?, :boolean, default: false)
  attr(:success?, :boolean, default: false)
  attr(:verification_state, State, default: nil)
  attr(:interpretation, Result, default: nil)
  attr(:attempts, :integer, default: 0)
  attr(:flow, :string, default: "")
  attr(:installation_type, :string, default: nil)
  attr(:awaiting_first_pageview?, :boolean, default: false)

  def render(assigns) do
    ~H"""
    <div id="progress-indicator">
      <.focus_box>
        <div
          :if={not @finished?}
          class="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-green-100 dark:bg-gray-700"
        >
          <div class="block pulsating-circle"></div>
        </div>

        <div
          :if={@finished? and @success?}
          class="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-green-100 dark:bg-green-500"
          id="check-circle"
        >
          <Heroicons.check_badge class="h-6 w-6 text-green-600 bg-green-100 dark:bg-green-500 dark:text-green-200" />
        </div>

        <div
          :if={@finished? and not @success?}
          class="mx-auto flex h-12 w-12 items-center justify-center rounded-full bg-red-100 dark:bg-red-200"
          id="error-circle"
        >
          <Heroicons.exclamation_triangle class="h-6 w-6 text-red-600 bg-red-100 dark:bg-red-200 dark:text-red-800" />
        </div>

        <div class="mt-8">
          <.title>
            <span :if={@finished? and @success?}>Success!</span>
            <span :if={not @finished?}>Verifying your installation</span>

            <span :if={@finished? and not @success? and @interpretation}>
              {List.first(@interpretation.errors)}
            </span>
          </.title>
          <p :if={@finished? and @success?} id="progress" class="text-sm mt-4">
            Your installation is working and visitors are being counted accurately
          </p>
          <p
            :if={@finished? and @success? and @awaiting_first_pageview?}
            id="awaiting"
            class="text-sm mt-4 animate-pulse"
          >
            Awaiting your first pageview
          </p>
          <p :if={not @finished?} class="text-sm mt-4 animate-pulse" id="progress">{@message}</p>

          <p
            :if={@finished? and not @success? and @interpretation}
            class="mt-4 text-sm text-ellipsis overflow-hidden"
            id="recommendation"
          >
            <span>{List.first(@interpretation.recommendations).text}.&nbsp;</span>
            <.styled_link href={List.first(@interpretation.recommendations).url} new_tab={true}>
              Learn more
            </.styled_link>
          </p>
        </div>

        <div :if={@finished?} class="mt-6">
          <.button_link :if={not @success?} mt?={false} href="#" phx-click="retry" class="w-full">
            Verify installation again
          </.button_link>
          <.button_link
            :if={@success?}
            mt?={false}
            href={"/#{URI.encode_www_form(@domain)}?skip_to_dashboard=true"}
            class="w-full font-bold mb-4"
          >
            Go to the dashboard
          </.button_link>
        </div>

        <:footer :if={@finished? and not @success?}>
          <.focus_list>
            <:item :if={ee?() and @attempts >= 3}>
              <b>Need further help with your installation?</b>
              <.styled_link href="https://plausible.io/contact">
                Contact us
              </.styled_link>
            </:item>
            <:item>
              Need to see installation instructions again?
              <.styled_link href={
                Routes.site_path(PlausibleWeb.Endpoint, :installation, @domain,
                  flow: @flow,
                  installation_type: @installation_type
                )
              }>
                Click here
              </.styled_link>
            </:item>
            <:item>
              Run verification later and go to site settings?
              <.styled_link href={"/#{URI.encode_www_form(@domain)}/settings/general"}>
                Click here
              </.styled_link>
            </:item>
          </.focus_list>
          <div
            :if={@verification_state && @super_admin? && @finished?}
            class="flex flex-col dark:text-gray-200 mt-4 pt-4 border-t border-gray-300 dark:border-gray-700"
            x-data="{ showDiagnostics: false }"
            id="super-admin-report"
          >
            <p class="text-sm">
              <a
                href="#"
                @click.prevent="showDiagnostics = !showDiagnostics"
                class="bg-yellow-100 dark:text-gray-800"
              >
                As a super-admin, you're eligible to see diagnostics details. Click to expand.
              </a>
            </p>
            <div x-show="showDiagnostics" x-cloak>
              <.focus_list>
                <:item :for={{diag, value} <- Map.from_struct(@verification_state.diagnostics)}>
                  <span class="text-sm">
                    {Phoenix.Naming.humanize(diag)}:
                    <span class="font-mono">{to_string_value(value)}</span>
                  </span>
                </:item>
              </.focus_list>
            </div>
          </div>
        </:footer>
      </.focus_box>
    </div>
    """
  end

  defp to_string_value(value) when is_binary(value), do: value
  defp to_string_value(value), do: inspect(value)
end
```

## File: `lib/plausible_web/live/components/visitors.ex`
```
defmodule PlausibleWeb.Live.Components.Visitors do
  @moduledoc """
  Component rendering mini-graph of site's visitors over the last 24 hours.

  The `gradient_defs` component should be rendered once before using `chart`
  one or more times.

  Accepts input generated via `Plausible.Stats.Clickhouse.last_24h_visitors_hourly_intervals/2`.
  """

  use Phoenix.Component

  attr :intervals, :list, required: true
  attr :height, :integer, default: 50
  attr :tick, :integer, default: 20

  def chart(assigns) do
    points =
      assigns.intervals
      |> scale(assigns.height)
      |> Enum.with_index(fn scaled_value, index ->
        "#{index * assigns.tick},#{scaled_value}"
      end)

    clip_points =
      List.flatten([
        "0,#{assigns.height + 1}",
        points,
        "#{(length(points) - 1) * assigns.tick},#{assigns.height + 1}",
        "0,#{assigns.height + 1}"
      ])

    assigns =
      assigns
      |> assign(:points_len, length(points))
      |> assign(:points, Enum.join(points, " "))
      |> assign(:clip_points, Enum.join(clip_points, " "))
      |> assign(:id, Ecto.UUID.generate())

    ~H"""
    <svg viewBox={"0 -1 #{(@points_len - 1) * @tick} #{@height + 3}"} class="chart w-full mb-2">
      <defs>
        <clipPath id={"gradient-cut-off-#{@id}"}>
          <polyline points={@clip_points} />
        </clipPath>
      </defs>
      <rect
        x="0"
        y="1"
        width={@points_len * @tick}
        height={@height}
        fill="url(#chart-gradient-cut-off)"
        clip-path={"url(#gradient-cut-off-#{@id})"}
      />
      <polyline fill="none" stroke="rgba(101,116,205)" stroke-width="2.6" points={@points} />
    </svg>
    """
  end

  def gradient_defs(assigns) do
    ~H"""
    <svg width="0" height="0">
      <defs class="text-white dark:text-indigo-800">
        <linearGradient id="chart-gradient-cut-off" x1="0" x2="0" y1="0" y2="1">
          <stop offset="0%" stop-color="rgba(101,116,205,0.2)" />
          <stop offset="100%" stop-color="rgba(101,116,205,0)" />
        </linearGradient>
      </defs>
    </svg>
    """
  end

  defp scale(data, target_range) do
    max_value = Enum.max_by(data, fn %{visitors: visitors} -> visitors end)

    scaling_factor = if max_value.visitors > 0, do: target_range / max_value.visitors, else: 0

    Enum.map(data, fn %{visitors: visitors} ->
      round(target_range - visitors * scaling_factor)
    end)
  end
end
```

## File: `lib/plausible_web/live/csv_export.ex`
```
defmodule PlausibleWeb.Live.CSVExport do
  @moduledoc """
  LiveView allowing scheduling, watching, downloading, and deleting S3 and local exports.
  """
  use PlausibleWeb, :live_view

  alias Plausible.Exports

  # :not_mounted_at_router ensures we have already done auth checks in the controller
  # if this liveview becomes available from the router, please make sure
  # to check that site_role is allowed to manage site exports
  @impl true
  def mount(:not_mounted_at_router, session, socket) do
    %{
      "storage" => storage,
      "site_id" => site_id,
      "email_to" => email_to
    } = session

    socket =
      socket
      |> assign(site_id: site_id, email_to: email_to, storage: storage)
      |> assign_new(:site, fn -> Plausible.Repo.get!(Plausible.Site, site_id) end)
      |> fetch_export()

    if connected?(socket) do
      Exports.oban_listen()
    end

    {:ok, socket}
  end

  defp fetch_export(socket) do
    %{storage: storage, site_id: site_id} = socket.assigns

    get_export =
      case storage do
        "s3" ->
          &Exports.get_s3_export!/1

        "local" ->
          %{domain: domain, timezone: timezone} = socket.assigns.site
          &Exports.get_local_export(&1, domain, timezone)
      end

    socket = assign(socket, export: nil)

    if job = Exports.get_last_export_job(site_id) do
      %Oban.Job{state: state} = job

      case state do
        _ when state in ["scheduled", "available", "retryable"] ->
          assign(socket, status: "in_progress")

        "executing" ->
          # Exports.oban_notify/1 is called in `perform/1` and
          # the notification arrives while the job.state is still "executing"
          if export = get_export.(site_id) do
            assign(socket, status: "ready", export: export)
          else
            assign(socket, status: "in_progress")
          end

        "completed" ->
          if export = get_export.(site_id) do
            assign(socket, status: "ready", export: export)
          else
            assign(socket, status: "can_schedule")
          end

        "discarded" ->
          assign(socket, status: "export_failed")

        "cancelled" ->
          # credo:disable-for-next-line Credo.Check.Refactor.Nesting
          if export = get_export.(site_id) do
            assign(socket, status: "ready", export: export)
          else
            assign(socket, status: "can_schedule")
          end
      end
    else
      if export = get_export.(site_id) do
        assign(socket, status: "ready", export: export)
      else
        assign(socket, status: "can_schedule")
      end
    end
  rescue
    _e ->
      assign(socket, status: "fetch_error", export: nil)
  end

  @impl true
  def render(assigns) do
    ~H"""
    <%= case @status do %>
      <% "can_schedule" -> %>
        <.prepare_download />
      <% "in_progress" -> %>
        <.in_progress />
      <% "export_failed" -> %>
        <.export_failed />
      <% "fetch_error" -> %>
        <.fetch_export_failed />
      <% "ready" -> %>
        <.download
          storage={@storage}
          export={@export}
          href={Routes.site_path(@socket, :download_export, @site.domain)}
        />
    <% end %>
    """
  end

  defp prepare_download(assigns) do
    ~H"""
    <p class="text-sm">
      Prepare your data for download by clicking the button below. When that's done, a Zip file that you can download will appear.
    </p>
    <.button phx-click="export">Prepare download</.button>
    """
  end

  defp in_progress(assigns) do
    ~H"""
    <div class="flex items-center justify-between space-x-2">
      <div class="flex items-center">
        <.spinner />
        <span class="ml-2 text-sm">We are preparing your download ...</span>
      </div>
      <button
        phx-click="cancel"
        class="text-red-500 font-semibold text-sm"
        data-confirm="Are you sure you want to cancel this export?"
      >
        Cancel
      </button>
    </div>
    <p class="text-sm mt-4">
      The preparation of your stats might take a while. Depending on the volume of your data, it might take up to 20 minutes. Feel free to leave the page and return later.
    </p>
    """
  end

  defp fetch_export_failed(assigns) do
    ~H"""
    <.notice title="Something went wrong when fetching exports" theme={:red}>
      Please try again later.
    </.notice>
    """
  end

  defp export_failed(assigns) do
    ~H"""
    <div class="flex items-center">
      <Heroicons.exclamation_circle class="w-4 h-4 text-red-500" />
      <p class="ml-2 text-sm">
        Something went wrong when preparing your download. Please
        <button phx-click="export" class="text-indigo-500">try again.</button>
      </p>
    </div>
    """
  end

  defp download(assigns) do
    ~H"""
    <.table rows={[@export]}>
      <:thead>
        <.th>Export</.th>
        <.th invisible>Actions</.th>
      </:thead>
      <:tbody :let={export}>
        <.td>
          <.styled_link href={@href}>
            {export.name}
          </.styled_link>
        </.td>
        <.td actions>
          <.delete_button
            phx-click="delete"
            data-confirm="Are you sure you want to delete this export?"
          />
        </.td>
      </:tbody>
    </.table>

    <p :if={@export.expires_at} class="text-sm">
      Note: this file will expire
      <.hint message={@export.expires_at}>
        {Timex.Format.DateTime.Formatters.Relative.format!(@export.expires_at, "{relative}")}.
      </.hint>
    </p>

    <p :if={@storage == "local"} class="text-sm">
      Located at
      <.hint message={@export.path}>{format_path(@export.path)}</.hint>
      ({format_bytes(@export.size)})
    </p>
    """
  end

  defp hint(assigns) do
    ~H"""
    <span title={@message} class="underline cursor-help underline-offset-2 decoration-dashed">
      {render_slot(@inner_block)}
    </span>
    """
  end

  @impl true
  def handle_event("export", _params, socket) do
    %{storage: storage, site_id: site_id, email_to: email_to} =
      socket.assigns

    schedule_result =
      case storage do
        "s3" -> Exports.schedule_s3_export(site_id, email_to)
        "local" -> Exports.schedule_local_export(site_id, email_to)
      end

    socket =
      case schedule_result do
        {:ok, _job} ->
          fetch_export(socket)

        {:error, :no_data} ->
          socket
          |> put_flash(:error, "There is no data to export")
          |> redirect(
            to: Routes.site_path(socket, :settings_imports_exports, socket.assigns.site.domain)
          )
      end

    {:noreply, socket}
  end

  def handle_event("cancel", _params, socket) do
    if job = Exports.get_last_export_job(socket.assigns.site_id), do: Oban.cancel_job(job)
    {:noreply, fetch_export(socket)}
  end

  def handle_event("delete", _params, socket) do
    %{storage: storage, site_id: site_id} = socket.assigns

    case storage do
      "s3" -> Exports.delete_s3_export!(site_id)
      "local" -> Exports.delete_local_export(site_id)
    end

    {:noreply, fetch_export(socket)}
  end

  @impl true
  def handle_info({:notification, Exports, %{"site_id" => site_id}}, socket) do
    socket =
      if site_id == socket.assigns.site_id do
        fetch_export(socket)
      else
        socket
      end

    {:noreply, socket}
  end

  @format_path_regex ~r/^(?<beginning>((.+?\/){3})).*(?<ending>(\/.*){3})$/

  defp format_path(path) do
    path_string =
      path
      |> to_string()
      |> String.replace_prefix("\"", "")
      |> String.replace_suffix("\"", "")

    case Regex.named_captures(@format_path_regex, path_string) do
      %{"beginning" => beginning, "ending" => ending} -> "#{beginning}...#{ending}"
      _ -> path_string
    end
  end

  defp format_bytes(bytes) when is_integer(bytes) do
    cond do
      bytes >= memory_unit("TiB") -> format_bytes(bytes, "TiB")
      bytes >= memory_unit("GiB") -> format_bytes(bytes, "GiB")
      bytes >= memory_unit("MiB") -> format_bytes(bytes, "MiB")
      bytes >= memory_unit("KiB") -> format_bytes(bytes, "KiB")
      true -> format_bytes(bytes, "B")
    end
  end

  defp format_bytes(bytes, "B"), do: "#{bytes} B"

  defp format_bytes(bytes, unit) do
    value = bytes / memory_unit(unit)
    "#{:erlang.float_to_binary(value, decimals: 1)} #{unit}"
  end

  defp memory_unit("TiB"), do: 1024 * 1024 * 1024 * 1024
  defp memory_unit("GiB"), do: 1024 * 1024 * 1024
  defp memory_unit("MiB"), do: 1024 * 1024
  defp memory_unit("KiB"), do: 1024
end
```

## File: `lib/plausible_web/live/csv_import.ex`
```
defmodule PlausibleWeb.Live.CSVImport do
  @moduledoc """
  LiveView allowing uploading CSVs for imported tables to S3 or local storage
  """

  use PlausibleWeb, :live_view

  require Plausible.Imported.SiteImport
  alias Plausible.Imported.CSVImporter
  alias Plausible.Imported

  # :not_mounted_at_router ensures we have already done auth checks in the controller
  # if this liveview becomes available from the router, please make sure
  # to check that site_role is allowed to make site imports
  @impl true
  def mount(:not_mounted_at_router, session, socket) do
    %{"site_id" => site_id, "storage" => storage} = session

    upload_opts = [
      accept: [".csv", "text/csv"],
      auto_upload: true,
      max_entries: length(Imported.tables()),
      # 1GB
      max_file_size: 1_000_000_000,
      progress: &handle_progress/3
    ]

    upload_opts =
      case storage do
        "s3" -> [{:external, &presign_upload/2} | upload_opts]
        "local" -> upload_opts
      end

    upload_consumer =
      case storage do
        "s3" ->
          fn meta, entry ->
            {:ok, %{"s3_url" => meta.s3_url, "filename" => entry.client_name}}
          end

        "local" ->
          local_dir = CSVImporter.local_dir(site_id)
          File.mkdir_p!(local_dir)

          fn meta, entry ->
            local_path = Path.join(local_dir, Path.basename(meta.path))
            Plausible.File.mv!(meta.path, local_path)
            {:ok, %{"local_path" => local_path, "filename" => entry.client_name}}
          end
      end

    %{assigns: %{site: site}} =
      socket = assign_new(socket, :site, fn -> Plausible.Repo.get!(Plausible.Site, site_id) end)

    # we'll listen for new completed imports to know
    # when to reload the occupied ranges
    if connected?(socket), do: Imported.listen()

    occupied_ranges = Imported.get_occupied_date_ranges(site)
    native_stats_start_date = Plausible.Sites.native_stats_start_date(site)

    socket =
      socket
      |> assign(
        site_id: site_id,
        storage: storage,
        upload_consumer: upload_consumer,
        occupied_ranges: occupied_ranges,
        native_stats_start_date: native_stats_start_date
      )
      |> allow_upload(:import, upload_opts)
      |> process_imported_tables()

    {:ok, socket}
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div>
      <form action="#" method="post" phx-change="validate-upload-form" phx-submit="submit-upload-form">
        <.csv_picker upload={@uploads.import} imported_tables={@imported_tables} />
        <.confirm_button date_range={@clamped_date_range} can_confirm?={@can_confirm?} />
        <.maybe_date_range_warning
          :if={@original_date_range}
          clamped={@clamped_date_range}
          original={@original_date_range}
        />
        <p :for={error <- upload_errors(@uploads.import)} class="text-red-400">
          {error_to_string(error)}
        </p>
      </form>
    </div>
    """
  end

  defp csv_picker(assigns) do
    ~H"""
    <label
      phx-drop-target={@upload.ref}
      class="block border-2 dark:border-gray-600 rounded-md p-4 hover:bg-gray-50 dark:hover:bg-gray-900 hover:border-indigo-500 dark:hover:border-indigo-600 transition cursor-pointer"
    >
      <div class="hidden md:flex items-center text-gray-500 dark:text-gray-500">
        <Heroicons.document_plus class="w-5 h-5 transition" />
        <span class="ml-1.5 text-sm">
          (or drag-and-drop your unzipped CSVs here)
        </span>
        <.live_file_input upload={@upload} class="hidden" />
      </div>

      <ul id="imported-tables" class="truncate mt-3.5 mb-0.5 space-y-1.5">
        <.imported_table
          :for={{table, upload} <- @imported_tables}
          table={table}
          upload={upload}
          errors={if(upload, do: upload_errors(@upload, upload), else: [])}
        />
      </ul>
    </label>
    """
  end

  defp confirm_button(assigns) do
    ~H"""
    <.button type="submit" disabled={not @can_confirm?} class="w-full">
      <%= if @date_range do %>
        Confirm import <.dates range={@date_range} />
      <% else %>
        Confirm import
      <% end %>
    </.button>
    """
  end

  defp maybe_date_range_warning(assigns) do
    ~H"""
    <%= if @clamped do %>
      <.notice :if={@clamped != @original} title="Dates Adjusted" theme={:yellow} class="mt-4">
        The dates <.dates range={@original} />
        overlap with previous imports, so we'll use the next best period, <.dates range={@clamped} />
      </.notice>
    <% else %>
      <.notice title="Dates Conflict" theme={:red} class="mt-4">
        The dates <.dates range={@original} />
        overlap with dates we've already imported and cannot be used for new imports.
      </.notice>
    <% end %>
    """
  end

  defp dates(assigns) do
    ~H"""
    <span class="whitespace-nowrap">
      <span class="font-medium">{@range.first}</span>
      to <span class="font-medium">{@range.last}</span>
    </span>
    """
  end

  defp imported_table(assigns) do
    status =
      cond do
        assigns.upload && assigns.upload.progress == 100 -> :success
        assigns.upload && assigns.upload.progress > 0 -> :in_progress
        not Enum.empty?(assigns.errors) -> :error
        true -> :empty
      end

    assigns = assign(assigns, status: status)

    ~H"""
    <li id={@table} class="ml-0.5">
      <div class="flex items-center space-x-2 text-gray-600 dark:text-gray-500">
        <Heroicons.document_check :if={@status == :success} class="w-4 h-4" />
        <.spinner :if={@status == :in_progress} class="w-4 h-4" />
        <Heroicons.document :if={@status == :empty} class="w-4 h-4 opacity-80" />
        <Heroicons.document :if={@status == :error} class="w-4 h-4 text-red-600 dark:text-red-700" />

        <span class={[
          "text-sm",
          if(@status == :empty, do: "opacity-80"),
          if(@status == :error, do: "text-red-600 dark:text-red-700")
        ]}>
          <%= if @upload do %>
            {@upload.client_name}
          <% else %>
            {@table}_YYYYMMDD_YYYYMMDD.csv
          <% end %>
        </span>
      </div>

      <p :for={error <- @errors} class="ml-6 text-sm text-red-600 dark:text-red-700">
        {error_to_string(error)}
      </p>
    </li>
    """
  end

  @impl true
  def handle_event("validate-upload-form", _params, socket) do
    {:noreply, process_imported_tables(socket)}
  end

  def handle_event("submit-upload-form", _params, socket) do
    %{
      storage: storage,
      site: site,
      current_user: current_user,
      clamped_date_range: clamped_date_range,
      upload_consumer: upload_consumer
    } =
      socket.assigns

    uploads = consume_uploaded_entries(socket, :import, upload_consumer)

    {:ok, _job} =
      CSVImporter.new_import(site, current_user,
        start_date: clamped_date_range.first,
        end_date: clamped_date_range.last,
        uploads: uploads,
        storage: storage
      )

    redirect_to =
      Routes.site_path(socket, :settings_imports_exports, site.domain)

    {:noreply, redirect(socket, to: redirect_to)}
  end

  @impl true
  def handle_info({:notification, :analytics_imports_jobs, details}, socket) do
    site = socket.assigns.site

    socket =
      if details["site_id"] == site.id and details["event"] == "complete" do
        occupied_ranges = Imported.get_occupied_date_ranges(site)
        socket |> assign(occupied_ranges: occupied_ranges) |> process_imported_tables()
      else
        socket
      end

    {:noreply, socket}
  end

  defp error_to_string(:too_large), do: "is too large (max size is 1 gigabyte)"
  defp error_to_string(:too_many_files), do: "too many files"
  defp error_to_string(:not_accepted), do: "unacceptable file types"
  defp error_to_string(:external_client_failure), do: "browser upload failed"

  defp presign_upload(entry, socket) do
    %{s3_url: s3_url, presigned_url: upload_url} =
      Plausible.S3.import_presign_upload(socket.assigns.site_id, random_suffix(entry.client_name))

    {:ok, %{uploader: "S3", s3_url: s3_url, url: upload_url}, socket}
  end

  defp random_suffix(filename) do
    # based on Plug.Upload.path/2
    # https://github.com/elixir-plug/plug/blob/eabf0b9d43060c10663a9105cb1baf984d272a6c/lib/plug/upload.ex#L154-L159
    sec = Integer.to_string(:os.system_time(:second))
    rand = Integer.to_string(:rand.uniform(999_999_999_999))
    scheduler_id = Integer.to_string(:erlang.system_info(:scheduler_id))
    filename <> "-" <> sec <> "-" <> rand <> "-" <> scheduler_id
  end

  defp handle_progress(:import, entry, socket) do
    if entry.done? do
      {:noreply, process_imported_tables(socket)}
    else
      {:noreply, socket}
    end
  end

  defp process_imported_tables(socket) do
    tables = Imported.tables()
    {completed, in_progress} = uploaded_entries(socket, :import)

    {valid_uploads, invalid_uploads} =
      Enum.split_with(completed ++ in_progress, &CSVImporter.valid_filename?(&1.client_name))

    imported_tables_all_uploads =
      Enum.map(tables, fn table ->
        uploads =
          Enum.filter(valid_uploads, fn upload ->
            CSVImporter.extract_table(upload.client_name) == table
          end)

        {upload, replaced_uploads} = List.pop_at(uploads, -1)
        {table, upload, replaced_uploads}
      end)

    imported_tables =
      Enum.map(imported_tables_all_uploads, fn {table, upload, _replaced_uploads} ->
        {table, upload}
      end)

    replaced_uploads =
      Enum.flat_map(imported_tables_all_uploads, fn {_table, _upload, replaced_uploads} ->
        replaced_uploads
      end)

    original_date_range = CSVImporter.date_range(Enum.map(valid_uploads, & &1.client_name))

    clamped_date_range =
      if original_date_range do
        %Date.Range{first: start_date, last: end_date} = original_date_range

        %{
          site: site,
          occupied_ranges: occupied_ranges,
          native_stats_start_date: native_stats_start_date
        } = socket.assigns

        cutoff_date = native_stats_start_date || Timex.today(site.timezone)

        case Imported.clamp_dates(occupied_ranges, cutoff_date, start_date, end_date) do
          {:ok, start_date, end_date} -> Date.range(start_date, end_date)
          {:error, :no_time_window} -> nil
        end
      end

    all_uploaded? = completed != [] and in_progress == []
    can_confirm? = all_uploaded? and not is_nil(clamped_date_range)

    socket
    |> cancel_uploads(invalid_uploads)
    |> cancel_uploads(replaced_uploads)
    |> assign(
      imported_tables: imported_tables,
      can_confirm?: can_confirm?,
      original_date_range: original_date_range,
      clamped_date_range: clamped_date_range
    )
  end

  defp cancel_uploads(socket, uploads) do
    Enum.reduce(uploads, socket, fn upload, socket ->
      cancel_upload(socket, :import, upload.ref)
    end)
  end
end
```

## File: `lib/plausible_web/live/flash.ex`
```
defmodule PlausibleWeb.Live.Flash do
  @moduledoc """
  Flash component for LiveViews - works also when embedded within dead views
  """

  use Phoenix.Component
  alias Phoenix.LiveView.JS
  alias Phoenix.Flash

  @flash_timer_assigns %{
    success: :clear_flash_success,
    error: :clear_flash_error
  }

  @flash_timer_timeout_ms 5000

  defmacro __using__(_opts) do
    quote do
      import PlausibleWeb.Live.Flash, only: [put_live_flash: 3, flash_messages: 1]

      def handle_info({:clear_live_flash, key}, socket) do
        {:noreply, Phoenix.LiveView.clear_flash(socket, key)}
      end
    end
  end

  def put_live_flash(socket, key, message) when key in [:success, :error] do
    timer_key = Map.fetch!(@flash_timer_assigns, key)

    if flash_timer = socket.assigns[timer_key] do
      Process.cancel_timer(flash_timer)
    end

    flash_timer =
      Process.send_after(
        self(),
        {:clear_live_flash, key},
        @flash_timer_timeout_ms
      )

    socket
    |> Phoenix.LiveView.put_flash(key, message)
    |> assign(timer_key, flash_timer)
  end

  def flash_messages(assigns) do
    ~H"""
    <div>
      <div
        :if={@flash != %{} or Application.get_env(:plausible, :environment) == "dev"}
        class="inset-0 z-50 fixed flex flex-col-reverse items-center sm:items-end justify-start sm:justify-end px-4 py-6 pointer-events-none sm:p-6"
      >
        <.flash :if={Flash.get(@flash, :success)} key="success">
          <:icon>
            <.icon_success />
          </:icon>
          <:title>
            {Flash.get(@flash, :success_title) || "Success!"}
          </:title>
          <:message>
            {Flash.get(@flash, :success)}
          </:message>
        </.flash>
        <.flash :if={Flash.get(@flash, :error)} key="error">
          <:icon>
            <.icon_error />
          </:icon>
          <:title>
            {Flash.get(@flash, :error_title) || "Error!"}
          </:title>
          <:message>
            {Flash.get(@flash, :error)}
          </:message>
        </.flash>
        <.flash
          :if={Application.get_env(:plausible, :environment) == "dev"}
          id="live-view-connection-status"
          class="hidden"
          phx-disconnected={JS.show()}
          phx-connected={JS.hide()}
          on_close={JS.hide()}
        >
          <:icon>
            <.icon_error />
          </:icon>
          <:title>
            Oops, a server blip
          </:title>
          <:message>
            Live socket disconnected.
          </:message>
        </.flash>
      </div>
    </div>
    """
  end

  slot(:icon, required: true)
  slot(:title, required: true)
  slot(:message, required: true)
  attr(:key, :string, default: nil)
  attr(:on_close, :any, default: "lv:clear-flash")
  attr(:class, :string, default: "")
  attr(:rest, :global)

  def flash(assigns) do
    ~H"""
    <div
      class={[
        @class,
        "mb-4 max-w-sm w-full bg-white dark:bg-gray-800 shadow-lg rounded-lg pointer-events-auto"
      ]}
      {@rest}
    >
      <div class="rounded-lg ring-1 ring-black ring-opacity-5 overflow-hidden">
        <div class="p-4">
          <div class="flex items-start">
            {render_slot(@icon)}
            <div class="ml-3 w-0 flex-1 pt-0.5">
              <p class="text-sm leading-5 font-medium text-gray-900 dark:text-gray-100">
                {render_slot(@title)}
              </p>
              <p class="mt-1 text-sm leading-5 text-gray-500 dark:text-gray-200">
                {render_slot(@message)}
              </p>
            </div>
            <div class="ml-4 flex-shrink-0 flex">
              <.clear_flash_button on_close={@on_close} key={@key} />
            </div>
          </div>
        </div>
      </div>
    </div>
    """
  end

  def icon_success(assigns) do
    ~H"""
    <div class="flex-shrink-0">
      <svg
        class="h-6 w-6 text-green-400"
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          stroke-width="2"
          d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
        />
      </svg>
    </div>
    """
  end

  def icon_error(assigns) do
    ~H"""
    <svg
      class="w-6 h-6 text-red-400"
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
      >
      </path>
    </svg>
    """
  end

  def clear_flash_button(assigns) do
    ~H"""
    <button
      class="inline-flex text-gray-400 focus:outline-none focus:text-gray-500 dark:focus:text-gray-200 transition ease-in-out duration-150"
      phx-click={@on_close}
      phx-value-key={@key}
    >
      <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
        <path
          fill-rule="evenodd"
          d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
          clip-rule="evenodd"
        />
      </svg>
    </button>
    """
  end
end
```

## File: `lib/plausible_web/live/goal_settings.ex`
```
defmodule PlausibleWeb.Live.GoalSettings do
  @moduledoc """
  LiveView allowing listing, creating and deleting goals.
  """
  use PlausibleWeb, :live_view

  alias Plausible.Goals
  alias PlausibleWeb.Live.Components.Modal

  def mount(
        _params,
        %{"site_id" => site_id, "domain" => domain},
        socket
      ) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        current_user
        |> Plausible.Sites.get_for_user!(domain, [:owner, :admin, :editor, :super_admin])
      end)
      |> assign_new(:site_role, fn %{site: site, current_user: current_user} ->
        if Plausible.Auth.is_super_admin?(current_user) do
          :super_admin
        else
          {:ok, {_, role}} = Plausible.Teams.Memberships.site_role(site, current_user)
          role
        end
      end)
      |> assign_new(:all_goals, fn %{site: site} ->
        Goals.for_site(site, preload_funnels?: true)
      end)
      |> assign_new(:event_name_options, fn %{site: site, all_goals: all_goals} ->
        exclude =
          all_goals
          |> Enum.reject(&is_nil(&1.event_name))
          |> Enum.map(& &1.event_name)

        Plausible.Stats.GoalSuggestions.suggest_event_names(site, "",
          exclude: exclude,
          limit: :unlimited
        )
      end)

    {:ok,
     assign(socket,
       site_team: socket.assigns.site.team,
       site_id: site_id,
       domain: domain,
       displayed_goals: socket.assigns.all_goals,
       filter_text: "",
       form_goal: nil
     )}
  end

  # Flash sharing with live views within dead views can be done via re-rendering the flash partial.
  # Normally, we'd have to use live_patch which we can't do with views unmounted at the router it seems.
  def render(assigns) do
    ~H"""
    <div id="goal-settings-main">
      <.flash_messages flash={@flash} />

      <.live_component :let={modal_unique_id} module={Modal} preload?={false} id="goals-form-modal">
        <.live_component
          module={PlausibleWeb.Live.GoalSettings.Form}
          id={"goals-form-#{modal_unique_id}"}
          context_unique_id={modal_unique_id}
          event_name_options={@event_name_options}
          domain={@domain}
          site={@site}
          current_user={@current_user}
          site_role={@site_role}
          site_team={@site_team}
          existing_goals={@all_goals}
          goal={@form_goal}
          on_save_goal={
            fn goal, socket ->
              send(self(), {:goal_added, goal})
              Modal.close(socket, "goals-form-modal")
            end
          }
          on_autoconfigure={
            fn socket ->
              send(self(), :autoconfigure)
              Modal.close(socket, "goals-form-modal")
            end
          }
        />
      </.live_component>
      <.live_component
        module={PlausibleWeb.Live.GoalSettings.List}
        id="goals-list"
        goals={@displayed_goals}
        domain={@domain}
        filter_text={@filter_text}
        site={@site}
      />
    </div>
    """
  end

  def handle_event("reset-filter-text", _params, socket) do
    {:noreply, assign(socket, filter_text: "", displayed_goals: socket.assigns.all_goals)}
  end

  def handle_event("filter", %{"filter-text" => filter_text}, socket) do
    new_list =
      PlausibleWeb.Live.Components.ComboBox.StaticSearch.suggest(
        filter_text,
        socket.assigns.all_goals
      )

    {:noreply, assign(socket, displayed_goals: new_list, filter_text: filter_text)}
  end

  def handle_event("edit-goal", %{"goal-id" => goal_id}, socket) do
    goal_id = String.to_integer(goal_id)
    form_goal = Plausible.Goals.get(socket.assigns.site, goal_id)

    socket = socket |> assign(form_goal: form_goal) |> Modal.open("goals-form-modal")
    {:noreply, socket}
  end

  def handle_event("add-goal", _, socket) do
    socket = socket |> assign(form_goal: nil) |> Modal.open("goals-form-modal")
    {:noreply, socket}
  end

  def handle_event("delete-goal", %{"goal-id" => goal_id} = params, socket) do
    goal_id = String.to_integer(goal_id)

    case Plausible.Goals.delete(goal_id, socket.assigns.site_id) do
      :ok ->
        event_name_options =
          if goal_name = params["goal-name"] do
            [goal_name | socket.assigns.event_name_options]
          else
            socket.assigns.event_name_options
          end

        socket =
          socket
          |> put_live_flash(:success, "Goal deleted successfully")
          |> assign(
            all_goals: Enum.reject(socket.assigns.all_goals, &(&1.id == goal_id)),
            event_name_options: event_name_options,
            displayed_goals: Enum.reject(socket.assigns.displayed_goals, &(&1.id == goal_id))
          )

        {:noreply, socket}

      _ ->
        {:noreply, socket}
    end
  end

  def handle_info({:goal_added, goal}, socket) do
    all_goals = Goals.for_site(socket.assigns.site, preload_funnels?: true)

    socket =
      socket
      |> assign(
        filter_text: "",
        all_goals: all_goals,
        event_name_options:
          Enum.reject(socket.assigns.event_name_options, &(&1 == goal.event_name)),
        displayed_goals: all_goals,
        form_goal: nil
      )
      |> put_live_flash(:success, "Goal saved successfully")

    {:noreply, socket}
  end

  def handle_info(:autoconfigure, socket) do
    %{event_name_options: names, site: site} = socket.assigns

    added_goals =
      names
      |> Plausible.Goals.batch_create_event_goals(site)
      |> Enum.map(&Map.put(&1, :funnels, []))

    socket =
      socket
      |> assign(
        filter_text: "",
        all_goals: added_goals ++ socket.assigns.all_goals,
        event_name_options: [],
        displayed_goals: added_goals ++ socket.assigns.all_goals
      )
      |> put_live_flash(:success, "All goals added successfully")

    {:noreply, socket}
  end
end
```

## File: `lib/plausible_web/live/goal_settings/form.ex`
```
defmodule PlausibleWeb.Live.GoalSettings.Form do
  @moduledoc """
  Live view for the goal creation form
  """
  use PlausibleWeb, :live_component
  use Plausible

  alias PlausibleWeb.Live.Components.ComboBox
  alias Plausible.Repo

  def update(assigns, socket) do
    site = Repo.preload(assigns.site, [:team, :owners])

    has_access_to_revenue_goals? =
      Plausible.Billing.Feature.RevenueGoals.check_availability(site.team) == :ok

    form =
      (assigns.goal || %Plausible.Goal{})
      |> Plausible.Goal.changeset()
      |> to_form()

    selected_tab =
      case assigns.goal do
        %{page_path: p, scroll_threshold: s} when not is_nil(p) and s > -1 -> "scroll"
        %{page_path: p} when not is_nil(p) -> "pageviews"
        _goal_or_nil -> "custom_events"
      end

    socket =
      socket
      |> assign(
        id: assigns.id,
        context_unique_id: assigns.context_unique_id,
        form: form,
        event_name_options_count: length(assigns.event_name_options),
        event_name_options: Enum.map(assigns.event_name_options, &{&1, &1}),
        current_user: assigns.current_user,
        site_role: assigns.site_role,
        site_team: assigns.site_team,
        domain: assigns.domain,
        selected_tab: selected_tab,
        tab_sequence_id: 0,
        site: site,
        has_access_to_revenue_goals?: has_access_to_revenue_goals?,
        existing_goals: assigns.existing_goals,
        on_save_goal: assigns.on_save_goal,
        on_autoconfigure: assigns.on_autoconfigure,
        goal: assigns.goal
      )

    {:ok, socket}
  end

  # Regular functions instead of component calls are used here
  # explicitly to avoid breaking change tracking. Done following
  # advice from https://hexdocs.pm/phoenix_live_view/assigns-eex.html#the-assigns-variable.
  def render(assigns) do
    ~H"""
    <div id={@id}>
      {if @goal, do: edit_form(assigns)}
      {if is_nil(@goal), do: create_form(assigns)}
    </div>
    """
  end

  def edit_form(assigns) do
    ~H"""
    <.form :let={f} for={@form} phx-submit="save-goal" phx-target={@myself}>
      <.title>Edit Goal for {@domain}</.title>

      <.custom_event_fields
        :if={@selected_tab == "custom_events"}
        f={f}
        suffix={@context_unique_id}
        site_role={@site_role}
        site_team={@site_team}
        site={@site}
        goal={@goal}
        existing_goals={@existing_goals}
        goal_options={@event_name_options}
        has_access_to_revenue_goals?={@has_access_to_revenue_goals?}
      />
      <.pageview_fields
        :if={@selected_tab == "pageviews"}
        f={f}
        goal={@goal}
        suffix={@context_unique_id}
        site={@site}
      />
      <.scroll_fields
        :if={@selected_tab == "scroll"}
        f={f}
        goal={@goal}
        suffix={@context_unique_id}
        site={@site}
      />

      <.button type="submit" class="w-full">
        Update Goal
      </.button>
    </.form>
    """
  end

  def create_form(assigns) do
    ~H"""
    <.form
      :let={f}
      x-data="{ tabSelectionInProgress: false }"
      for={@form}
      phx-submit="save-goal"
      phx-target={@myself}
    >
      <.spinner class="spinner block absolute right-9 top-8" x-show="tabSelectionInProgress" />

      <.title>Add Goal for {@domain}</.title>

      <.tabs current_user={@current_user} site={@site} selected_tab={@selected_tab} myself={@myself} />

      <.custom_event_fields
        :if={@selected_tab == "custom_events"}
        x-show="!tabSelectionInProgress"
        f={f}
        suffix={suffix(@context_unique_id, @tab_sequence_id)}
        site_role={@site_role}
        site_team={@site_team}
        site={@site}
        existing_goals={@existing_goals}
        goal_options={@event_name_options}
        has_access_to_revenue_goals?={@has_access_to_revenue_goals?}
        x-init="tabSelectionInProgress = false"
      />
      <.pageview_fields
        :if={@selected_tab == "pageviews"}
        x-show="!tabSelectionInProgress"
        f={f}
        suffix={suffix(@context_unique_id, @tab_sequence_id)}
        site={@site}
        x-init="tabSelectionInProgress = false"
      />
      <.scroll_fields
        :if={@selected_tab == "scroll"}
        x-show="!tabSelectionInProgress"
        f={f}
        suffix={suffix(@context_unique_id, @tab_sequence_id)}
        site={@site}
        x-init="tabSelectionInProgress = false"
      />

      <div x-show="!tabSelectionInProgress">
        <.button type="submit" class="w-full">
          Add Goal
        </.button>
      </div>

      <button
        :if={@selected_tab == "custom_events" && @event_name_options_count > 0}
        x-show="!tabSelectionInProgress"
        class="mt-4 text-sm hover:underline text-indigo-600 dark:text-indigo-400 text-left"
        phx-click="autoconfigure"
        phx-target={@myself}
      >
        <span :if={@event_name_options_count > 1}>
          Already sending custom events? We've found {@event_name_options_count} custom events from the last 6 months that are not yet configured as goals. Click here to add them.
        </span>
        <span :if={@event_name_options_count == 1}>
          Already sending custom events? We've found 1 custom event from the last 6 months that is not yet configured as a goal. Click here to add it.
        </span>
      </button>
    </.form>
    """
  end

  attr(:f, Phoenix.HTML.Form)
  attr(:site, Plausible.Site)
  attr(:suffix, :string)
  attr(:goal, Plausible.Goal, default: nil)
  attr(:rest, :global)

  def pageview_fields(assigns) do
    ~H"""
    <div id="pageviews-form" class="py-2" {@rest}>
      <div class="text-sm pb-6 text-gray-500 dark:text-gray-400 text-justify rounded-md">
        Pageview goals allow you to measure how many people visit a specific page or section of your site. Learn more in
        <.styled_link href="https://plausible.io/docs/pageview-goals" new_tab={true}>
          our docs
        </.styled_link>.
      </div>

      <.label for={"page_path_input_#{@suffix}"}>
        Page Path
      </.label>

      <.live_component
        id={"page_path_input_#{@suffix}"}
        submit_name="goal[page_path]"
        class={[
          "py-2"
        ]}
        module={ComboBox}
        suggest_fun={fn input, _options -> suggest_page_paths(input, @site) end}
        selected={if @goal && @goal.page_path, do: @goal.page_path}
        creatable
        x-on-selection-change="document.getElementById('pageview_display_name_input').setAttribute('value', 'Visit ' + $event.detail.value.displayValue)"
      />

      <.error :for={msg <- Enum.map(@f[:page_path].errors, &translate_error/1)}>
        {msg}
      </.error>

      <.input
        label="Display Name"
        id="pageview_display_name_input"
        field={@f[:display_name]}
        type="text"
        x-data="{ firstFocus: true }"
        x-on:focus="if (firstFocus) { $el.select(); firstFocus = false; }"
      />
    </div>
    """
  end

  attr(:f, Phoenix.HTML.Form)
  attr(:site, Plausible.Site)
  attr(:suffix, :string)
  attr(:goal, Plausible.Goal, default: nil)
  attr(:rest, :global)

  def scroll_fields(assigns) do
    js =
      if is_nil(assigns.goal) do
        """
        {
          scrollThreshold: '90',
          pagePath: '',
          displayName: '',
          updateDisplayName() {
            if (this.scrollThreshold && this.pagePath) {
              this.displayName = `Scroll ${this.scrollThreshold}% on ${this.pagePath}`
            }
          }
        }
        """
      else
        """
        {
          scrollThreshold: '#{assigns.goal.scroll_threshold}',
          pagePath: '#{assigns.goal.page_path}',
          displayName: '#{assigns.goal.display_name}',
          updateDisplayName() {}
        }
        """
      end

    assigns = assign(assigns, :js, js)

    ~H"""
    <div id="scroll-form" class="py-2" x-data={@js} {@rest}>
      <div class="text-sm pb-6 text-gray-500 dark:text-gray-400 text-justify rounded-md">
        Scroll Depth goals allow you to see how many people scroll beyond your desired scroll depth percentage threshold. Learn more in
        <.styled_link href="https://plausible.io/docs/scroll-depth" new_tab={true}>
          our docs
        </.styled_link>.
      </div>

      <.label for={"scroll_threshold_input_#{@suffix}"}>
        Scroll Percentage Threshold (1-100)
      </.label>

      <.input
        id={"scroll_threshold_input_#{@suffix}"}
        required
        field={@f[:scroll_threshold]}
        type="number"
        min="1"
        max="100"
        step="1"
        x-model="scrollThreshold"
        x-on:change="updateDisplayName"
      />

      <.label for={"scroll_page_path_input_#{@suffix}"} class="mt-3">
        Page Path
      </.label>

      <.live_component
        id={"scroll_page_path_input_#{@suffix}"}
        submit_name="goal[page_path]"
        class={[
          "py-2"
        ]}
        module={ComboBox}
        suggest_fun={fn input, _options -> suggest_page_paths(input, @site) end}
        selected={if @goal && @goal.page_path, do: @goal.page_path}
        creatable
        x-on-selection-change="pagePath = $event.detail.value.displayValue; updateDisplayName()"
      />

      <.error :for={msg <- Enum.map(@f[:page_path].errors, &translate_error/1)}>
        {msg}
      </.error>

      <.input
        label="Display Name"
        id="scroll_display_name_input"
        field={@f[:display_name]}
        type="text"
        x-model="displayName"
        x-data="{ firstFocus: true }"
        x-on:focus="if (firstFocus) { $el.select(); firstFocus = false; }"
      />
    </div>
    """
  end

  attr(:f, Phoenix.HTML.Form)
  attr(:site, Plausible.Site)
  attr(:site_role, :atom)
  attr(:site_team, Plausible.Teams.Team)
  attr(:suffix, :string)
  attr(:existing_goals, :list)
  attr(:goal_options, :list)
  attr(:goal, Plausible.Goal, default: nil)
  attr(:has_access_to_revenue_goals?, :boolean)

  attr(:rest, :global)

  def custom_event_fields(assigns) do
    ~H"""
    <div id="custom-events-form" class="py-2" {@rest}>
      <div id="event-fields">
        <div class="text-sm pb-6 text-gray-500 dark:text-gray-400 text-justify rounded-md">
          Custom Events are not tracked by default - you have to configure them on your site to be sent to Plausible. See examples and learn more in
          <.styled_link href="https://plausible.io/docs/custom-event-goals" new_tab={true}>
            our docs
          </.styled_link>.
        </div>

        <div>
          <.label for={"event_name_input_#{@suffix}"}>
            Event Name
          </.label>

          <.live_component
            id={"event_name_input_#{@suffix}"}
            submit_name="goal[event_name]"
            placeholder="e.g. Signup"
            class={[
              "py-2"
            ]}
            module={ComboBox}
            suggest_fun={fn input, _options -> suggest_event_names(input, @site, @existing_goals) end}
            options={@goal_options}
            selected={if @goal && @goal.event_name, do: @goal.event_name}
            creatable
            x-on-selection-change="document.getElementById('custom_event_display_name_input').setAttribute('value', $event.detail.value.displayValue)"
          />

          <.error :for={msg <- Enum.map(@f[:event_name].errors, &translate_error/1)}>
            {msg}
          </.error>
        </div>

        <div class="mt-2">
          <.input
            label="Display Name"
            id="custom_event_display_name_input"
            field={@f[:display_name]}
            type="text"
            x-data="{ firstFocus: true }"
            x-on:focus="if (firstFocus) { $el.select(); firstFocus = false; }"
          />
        </div>

        <.revenue_goal_settings
          :if={ee?()}
          f={@f}
          site={@site}
          site_role={@site_role}
          site_team={@site_team}
          has_access_to_revenue_goals?={@has_access_to_revenue_goals?}
          goal={@goal}
          suffix={@suffix}
        />
      </div>
    </div>
    """
  end

  def revenue_goal_settings(%{goal: %{currency: nil}} = assigns) do
    ~H"""
    <div class="h-2"></div>
    """
  end

  def revenue_goal_settings(assigns) do
    js_data =
      Jason.encode!(%{
        active: !!assigns.f[:currency].value and assigns.f[:currency].value != "",
        currency: assigns.f[:currency].value
      })

    assigns = assign(assigns, selected_currency: currency_option(assigns.goal), js_data: js_data)

    ~H"""
    <div x-data={@js_data}>
      <%= if is_nil(@goal) do %>
        <div class="mt-6 mb-3">
          <.revenue_toggle {assigns} />
        </div>
      <% else %>
        <label
          data-test="goal-currency-label"
          class="mt-4 mb-2 text-sm block font-medium dark:text-gray-100"
        >
          Currency
        </label>
      <% end %>
      <div class="mb-2" x-show="active" id={"revenue-input-#{@suffix}"}>
        <.live_component
          id={"currency_input_#{@suffix}"}
          submit_name={@f[:currency].name}
          module={ComboBox}
          selected={@selected_currency}
          suggest_fun={
            on_ee do
              fn
                "", [] ->
                  Plausible.Goal.Revenue.currency_options()

                input, options ->
                  ComboBox.StaticSearch.suggest(input, options, weight_threshold: 0.8)
              end
            end
          }
        />
      </div>
    </div>
    """
  end

  def tabs(assigns) do
    ~H"""
    <div class="text-sm mt-6 font-medium dark:text-gray-100">Goal Trigger</div>
    <div class="my-2 text-sm w-full flex rounded border border-gray-300 dark:border-gray-500 overflow-hidden">
      <.custom_events_tab selected?={@selected_tab == "custom_events"} myself={@myself} />
      <.pageviews_tab selected?={@selected_tab == "pageviews"} myself={@myself} />
      <.scroll_tab selected?={@selected_tab == "scroll"} myself={@myself} />
    </div>
    """
  end

  defp custom_events_tab(assigns) do
    ~H"""
    <a
      class={[
        "flex-1 text-center py-2.5 border-r dark:border-gray-500",
        "cursor-pointer",
        @selected? && "shadow-inner font-medium bg-indigo-600 text-white",
        !@selected? && "dark:text-gray-100 text-gray-800"
      ]}
      id="event-tab"
      x-on:click={!@selected? && "tabSelectionInProgress = true"}
      phx-click="switch-tab"
      phx-value-tab="custom_events"
      phx-target={@myself}
    >
      Custom Event
    </a>
    """
  end

  def pageviews_tab(assigns) do
    ~H"""
    <a
      class={[
        "flex-1 text-center py-2.5 cursor-pointer",
        @selected? && "shadow-inner font-medium bg-indigo-600 text-white",
        !@selected? && "dark:text-gray-100 text-gray-800"
      ]}
      id="pageview-tab"
      x-on:click={!@selected? && "tabSelectionInProgress = true"}
      phx-click="switch-tab"
      phx-value-tab="pageviews"
      phx-target={@myself}
    >
      Pageview
    </a>
    """
  end

  def scroll_tab(assigns) do
    ~H"""
    <a
      class={[
        "flex-1 text-center py-2.5 cursor-pointer border-l dark:border-gray-500",
        @selected? && "shadow-inner font-medium bg-indigo-600 text-white",
        !@selected? && "dark:text-gray-100 text-gray-800"
      ]}
      id="scroll-tab"
      x-on:click={!@selected? && "tabSelectionInProgress = true"}
      phx-click="switch-tab"
      phx-value-tab="scroll"
      phx-target={@myself}
    >
      Scroll Depth
    </a>
    """
  end

  def handle_event("switch-tab", %{"tab" => tab}, socket) do
    socket =
      socket
      |> assign(:selected_tab, tab)
      |> update(:tab_sequence_id, &(&1 + 1))

    {:noreply, socket}
  end

  def handle_event("save-goal", %{"goal" => goal_params}, %{assigns: %{goal: nil}} = socket) do
    case Plausible.Goals.create(socket.assigns.site, goal_params) do
      {:ok, goal} ->
        socket =
          goal
          |> Map.put(:funnels, [])
          |> socket.assigns.on_save_goal.(socket)

        {:noreply, socket}

      {:error, %Ecto.Changeset{} = changeset} ->
        {:noreply, assign(socket, form: to_form(changeset))}
    end
  end

  def handle_event(
        "save-goal",
        %{"goal" => goal_params},
        %{assigns: %{goal: %Plausible.Goal{} = goal}} = socket
      ) do
    case Plausible.Goals.update(goal, goal_params) do
      {:ok, goal} ->
        socket = socket.assigns.on_save_goal.(goal, socket)

        {:noreply, socket}

      {:error, %Ecto.Changeset{} = changeset} ->
        {:noreply, assign(socket, form: to_form(changeset))}
    end
  end

  def handle_event("autoconfigure", _params, socket) do
    {:noreply, socket.assigns.on_autoconfigure.(socket)}
  end

  def suggest_page_paths(input, site) do
    query = Plausible.Stats.Query.from(site, %{"with_imported" => "true", "period" => "all"})

    site
    |> Plausible.Stats.filter_suggestions(query, "page", input)
    |> Enum.map(fn %{label: label, value: value} -> {label, value} end)
  end

  def suggest_event_names(input, site, existing_goals) do
    existing_names =
      existing_goals
      |> Enum.reject(&is_nil(&1.event_name))
      |> Enum.map(& &1.event_name)

    site
    |> Plausible.Stats.GoalSuggestions.suggest_event_names(input, exclude: existing_names)
    |> Enum.map(fn name -> {name, name} end)
  end

  defp suffix(context_unique_id, tab_sequence_id) do
    "#{context_unique_id}-tabseq#{tab_sequence_id}"
  end

  on_ee do
    defp currency_option(nil), do: nil

    defp currency_option(goal) do
      Plausible.Goal.Revenue.revenue?(goal) &&
        Plausible.Goal.Revenue.currency_option(goal.currency)
    end
  else
    defp currency_option(_), do: nil
  end

  defp revenue_toggle(assigns) do
    ~H"""
    <.tooltip enabled?={not @has_access_to_revenue_goals?}>
      <:tooltip_content>
        <div class="text-xs">
          To get access to this feature
          <PlausibleWeb.Components.Billing.upgrade_call_to_action
            current_role={@site_role}
            current_team={@site_team}
          />.
        </div>
      </:tooltip_content>
      <div class="flex itemx-center mb-3">
        <PlausibleWeb.Components.Generic.toggle_switch
          id="enable-revenue-tracking"
          id_suffix={@suffix}
          js_active_var="active"
          disabled={not @has_access_to_revenue_goals?}
        />
        <span class={[
          "ml-3 text-sm font-medium",
          if(@has_access_to_revenue_goals?,
            do: "text-gray-900 dark:text-gray-100",
            else: "text-gray-500 dark:text-gray-400"
          )
        ]}>
          Enable Revenue Tracking
        </span>
      </div>
    </.tooltip>
    """
  end
end
```

## File: `lib/plausible_web/live/goal_settings/list.ex`
```
defmodule PlausibleWeb.Live.GoalSettings.List do
  @moduledoc """
  Phoenix LiveComponent module that renders a list of goals
  """
  use PlausibleWeb, :live_component
  alias PlausibleWeb.Live.Components.Modal

  attr(:goals, :list, required: true)
  attr(:domain, :string, required: true)
  attr(:filter_text, :string)
  attr(:site, Plausible.Site, required: true)

  def render(assigns) do
    revenue_goals_enabled? = Plausible.Billing.Feature.RevenueGoals.enabled?(assigns.site)
    assigns = assign(assigns, revenue_goals_enabled?: revenue_goals_enabled?)

    ~H"""
    <div>
      <.filter_bar filter_text={@filter_text} placeholder="Search Goals">
        <.button
          id="add-goal-button"
          phx-click="add-goal"
          mt?={false}
          x-data
          x-on:click={Modal.JS.preopen("goals-form-modal")}
        >
          Add Goal
        </.button>
      </.filter_bar>

      <%= if Enum.count(@goals) > 0 do %>
        <.table rows={@goals}>
          <:tbody :let={goal}>
            <.td max_width="max-w-40" height="h-16">
              <%= if not @revenue_goals_enabled? && goal.currency do %>
                <div class="truncate">{goal}</div>
                <.tooltip>
                  <:tooltip_content>
                    <p class="text-xs">
                      Revenue Goals act like regular custom<br />
                      events without a Business subscription<br />
                    </p>
                  </:tooltip_content>
                  <span class="w-max flex items-center text-gray-500 italic text-sm">
                    <Heroicons.lock_closed solid class="size-4 mr-1" /> Upgrade Required
                  </span>
                </.tooltip>
              <% else %>
                <div class="truncate">
                  <.goal_description goal={goal} />
                </div>
                <div class="truncate">{goal}</div>
              <% end %>
            </.td>
            <.td hide_on_mobile height="h-16">
              <span :if={goal.page_path && goal.scroll_threshold > -1}>Scroll</span>
              <span :if={goal.page_path && goal.scroll_threshold == -1}>Pageview</span>
              <span :if={goal.event_name && !goal.currency}>Custom Event</span>
              <span :if={goal.currency}>Revenue Goal ({goal.currency})</span>
              <span :if={not Enum.empty?(goal.funnels)} class="text-gray-400 dark:text-gray-600">
                <br />Belongs to funnel(s)
              </span>
            </.td>
            <.td actions height="h-16">
              <.edit_button
                :if={!goal.currency || (goal.currency && @revenue_goals_enabled?)}
                x-data
                x-on:click={Modal.JS.preopen("goals-form-modal")}
                phx-click="edit-goal"
                phx-value-goal-id={goal.id}
                id={"edit-goal-#{goal.id}"}
              />
              <.edit_button
                :if={goal.currency && !@revenue_goals_enabled?}
                id={"edit-goal-#{goal.id}-disabled"}
                disabled
                class="cursor-not-allowed"
              />
              <.delete_button
                id={"delete-goal-#{goal.id}"}
                phx-click="delete-goal"
                phx-value-goal-id={goal.id}
                phx-value-goal-name={goal.event_name}
                data-confirm={delete_confirmation_text(goal)}
              />
            </.td>
          </:tbody>
        </.table>
      <% else %>
        <p class="mt-12 mb-8 text-center text-sm">
          <span :if={String.trim(@filter_text) != ""}>
            No goals found for this site. Please refine or
            <.styled_link phx-click="reset-filter-text" id="reset-filter-hint">
              reset your search.
            </.styled_link>
          </span>
          <span :if={String.trim(@filter_text) == "" && Enum.empty?(@goals)}>
            No goals configured for this site.
          </span>
        </p>
      <% end %>
    </div>
    """
  end

  defp page_scroll_description(goal) do
    case pageview_description(goal) do
      "" -> "Scroll > #{goal.scroll_threshold}"
      path -> "Scroll > #{goal.scroll_threshold} on #{path}"
    end
  end

  defp pageview_description(goal) do
    path = goal.page_path

    case goal.display_name do
      "Visit " <> ^path -> ""
      _ -> "#{path}"
    end
  end

  defp custom_event_description(goal) do
    if goal.display_name == goal.event_name, do: "", else: "#{goal.event_name}"
  end

  defp goal_description(assigns) do
    ~H"""
    <span
      :if={@goal.page_path && @goal.scroll_threshold > -1}
      class="block truncate text-gray-400 dark:text-gray-600"
    >
      {page_scroll_description(@goal)}
    </span>

    <span
      :if={@goal.page_path && @goal.scroll_threshold == -1}
      class="block truncate text-gray-400 dark:text-gray-600"
    >
      {pageview_description(@goal)}
    </span>

    <span :if={@goal.event_name} class="block truncate text-gray-400 dark:text-gray-600">
      {custom_event_description(@goal)}
    </span>
    """
  end

  defp delete_confirmation_text(goal) do
    if Enum.empty?(goal.funnels) do
      """
      Are you sure you want to remove the following goal:

      #{goal}

      This will just affect the UI, all of your analytics data will stay intact.
      """
    else
      """
      The goal:

      #{goal}

      is part of some funnel(s). If you are going to delete it, the associated funnels will be either reduced or deleted completely. Are you sure you want to remove the goal?
      """
    end
  end
end
```

## File: `lib/plausible_web/live/imports_exports_settings.ex`
```
defmodule PlausibleWeb.Live.ImportsExportsSettings do
  @moduledoc """
  LiveView allowing listing and deleting imports.
  """
  use PlausibleWeb, :live_view

  import PlausibleWeb.TextHelpers

  alias Plausible.Imported
  alias Plausible.Imported.SiteImport

  require Plausible.Imported.SiteImport

  def mount(_params, %{"domain" => domain}, socket) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        Plausible.Sites.get_for_user!(current_user, domain, [
          :owner,
          :admin,
          :editor,
          :super_admin
        ])
      end)
      |> assign_new(:site_imports, fn %{site: site} ->
        site
        |> Imported.list_all_imports()
        |> Enum.map(
          &%{site_import: &1, live_status: &1.status, tooltip: notice_label(&1, &1.status)}
        )
      end)
      |> assign_new(:pageview_counts, fn %{site: site} ->
        Plausible.Stats.Clickhouse.imported_pageview_counts(site)
      end)

    :ok = Imported.listen()

    {:ok, assign(socket, max_imports: Imported.max_complete_imports())}
  end

  def render(assigns) do
    import_in_progress? =
      Enum.any?(
        assigns.site_imports,
        &(&1.live_status in [SiteImport.pending(), SiteImport.importing()])
      )

    at_maximum? = length(assigns.site_imports) >= assigns.max_imports

    import_warning =
      cond do
        import_in_progress? ->
          "No new imports can be started until the import in progress is completed or cancelled."

        at_maximum? ->
          "Maximum of #{assigns.max_imports} imports is reached. " <>
            "Delete or cancel an existing import to start a new one."

        true ->
          nil
      end

    assigns =
      assign(assigns,
        import_in_progress?: import_in_progress?,
        at_maximum?: at_maximum?,
        import_warning: import_warning
      )

    ~H"""
    <.notice :if={@import_warning} theme={:gray}>
      {@import_warning}
    </.notice>

    <div class="mt-4 flex justify-end gap-x-4">
      <.button_link
        theme="bright"
        href={Plausible.Google.API.import_authorize_url(@site.id)}
        disabled={@import_in_progress? or @at_maximum?}
      >
        Import from
        <img
          src="/images/icon/google_analytics_logo.svg"
          alt="Google Analytics import"
          class="h-6 w-12"
        />
      </.button_link>
      <.button_link
        disabled={@import_in_progress? or @at_maximum?}
        href={"/#{URI.encode_www_form(@site.domain)}/settings/import"}
      >
        Import from CSV
      </.button_link>
    </div>

    <p :if={Enum.empty?(@site_imports)} class="text-center text-sm mt-8 mb-12">
      There are no imports yet for this site.
    </p>

    <div class="mt-8">
      <.table :if={not Enum.empty?(@site_imports)} rows={@site_imports}>
        <:thead>
          <.th>Import</.th>
          <.th hide_on_mobile>Date Range</.th>
          <.th hide_on_mobile>
            <div class="text-right">Pageviews</div>
          </.th>
          <.th invisible>Actions</.th>
        </:thead>

        <:tbody :let={entry}>
          <.td max_width="max-w-40">
            <div class="flex items-center gap-x-2 truncate">
              <div class="w-6" title={notice_message(entry.tooltip)}>
                <Heroicons.clock
                  :if={entry.live_status == SiteImport.pending()}
                  class="block h-6 w-6 text-indigo-600 dark:text-green-600"
                />
                <.spinner
                  :if={entry.live_status == SiteImport.importing()}
                  class="block h-6 w-6 text-indigo-600 dark:text-green-600"
                />
                <Heroicons.check
                  :if={entry.live_status == SiteImport.completed()}
                  class="block h-6 w-6 text-indigo-600 dark:text-green-600"
                />
                <Heroicons.exclamation_triangle
                  :if={entry.live_status == SiteImport.failed()}
                  class="block h-6 w-6 text-red-700 dark:text-red-500"
                />
              </div>
              <div
                class="max-w-sm"
                title={"#{Plausible.Imported.SiteImport.label(entry.site_import)} created at #{format_date(entry.site_import.inserted_at)}"}
              >
                {Plausible.Imported.SiteImport.label(entry.site_import)}
              </div>
            </div>
          </.td>

          <.td hide_on_mobile>
            {format_date(entry.site_import.start_date)} - {format_date(entry.site_import.end_date)}
          </.td>

          <.td>
            <div class="text-right">
              {if entry.live_status == SiteImport.completed(),
                do:
                  PlausibleWeb.StatsView.large_number_format(
                    pageview_count(entry.site_import, @pageview_counts)
                  )}
            </div>
          </.td>
          <.td actions>
            <.delete_button
              href={"/#{URI.encode_www_form(@site.domain)}/settings/forget-import/#{entry.site_import.id}"}
              method="delete"
              data-confirm="Are you sure you want to delete this import?"
            />
          </.td>
        </:tbody>
      </.table>
    </div>
    """
  end

  def handle_info({:notification, :analytics_imports_jobs, details}, socket) do
    {site_imports, updated?} =
      update_imports(socket.assigns.site_imports, details["import_id"], details["event"])

    pageview_counts =
      if updated? do
        Plausible.Stats.Clickhouse.imported_pageview_counts(socket.assigns.site)
      else
        socket.assigns.pageview_counts
      end

    {:noreply, assign(socket, site_imports: site_imports, pageview_counts: pageview_counts)}
  end

  defp pageview_count(site_import, pageview_counts) do
    count = Map.get(pageview_counts, site_import.id, 0)

    if site_import.legacy do
      count + Map.get(pageview_counts, 0, 0)
    else
      count
    end
  end

  defp update_imports(site_imports, import_id, status_str) do
    Enum.map_reduce(site_imports, false, fn
      %{site_import: %{id: ^import_id}} = entry, _changed? ->
        new_status =
          case status_str do
            "complete" -> SiteImport.completed()
            "fail" -> SiteImport.failed()
            "transient_fail" -> SiteImport.importing()
          end

        {%{entry | live_status: new_status, tooltip: notice_label(entry.site_import, new_status)},
         true}

      entry, changed? ->
        {entry, changed?}
    end)
  end

  defp notice_label(site_import, status) do
    now = NaiveDateTime.utc_now()
    seconds_since_update = NaiveDateTime.diff(now, site_import.updated_at, :second)
    in_progress? = status in [SiteImport.pending(), SiteImport.importing()]

    if in_progress? and seconds_since_update >= 300 do
      :slow_import
    end
  end

  defp notice_message(:slow_import) do
    """
    The import process might be taking longer due to the amount of data
    and rate limiting enforced by Google Analytics.
    """
  end

  defp notice_message(_), do: nil
end
```

## File: `lib/plausible_web/live/installation.ex`
```
defmodule PlausibleWeb.Live.Installation do
  @moduledoc """
  User assistance module around Plausible installation instructions/onboarding
  """
  use PlausibleWeb, :live_view
  alias Plausible.InstallationSupport.{State, Checks, LegacyVerification}

  @script_extension_params %{
    "outbound_links" => "outbound-links",
    "tagged_events" => "tagged-events",
    "file_downloads" => "file-downloads",
    "hash_based_routing" => "hash",
    "pageview_props" => "pageview-props",
    "revenue_tracking" => "revenue"
  }

  @script_config_params ["track_404_pages" | Map.keys(@script_extension_params)]

  @installation_types [
    "gtm",
    "manual",
    "wordpress"
  ]

  @valid_qs_params @script_config_params ++ ["installation_type", "flow"]

  def script_extension_params, do: @script_extension_params

  def mount(
        %{"domain" => domain} = params,
        _session,
        socket
      ) do
    site =
      Plausible.Sites.get_for_user!(socket.assigns.current_user, domain, [
        :owner,
        :admin,
        :editor,
        :super_admin,
        :viewer
      ])

    if FunWithFlags.enabled?(:scriptv2, for: site) do
      {:ok,
       redirect(socket,
         to: Routes.site_path(socket, :installation_v2, site.domain, flow: params["flow"])
       )}
    else
      flow = params["flow"]

      tracker_script_configuration =
        PlausibleWeb.Tracker.get_or_create_tracker_script_configuration!(site)

      installation_type = get_installation_type(flow, tracker_script_configuration, params)

      config =
        Map.new(@script_config_params, fn key ->
          string_key = String.to_existing_atom(key)
          {key, Map.get(tracker_script_configuration, string_key)}
        end)

      if connected?(socket) and is_nil(installation_type) do
        LegacyVerification.Checks.run("https://#{domain}", domain,
          checks: [
            Checks.FetchBody,
            Checks.ScanBody
          ],
          report_to: self(),
          async?: true,
          slowdown: 0
        )
      end

      {:ok,
       assign(socket,
         uri_params: Map.take(params, @valid_qs_params),
         connected?: connected?(socket),
         site: site,
         site_created?: params["site_created"] == "true",
         flow: flow,
         installation_type: installation_type,
         initial_installation_type: installation_type,
         domain: domain,
         config: config
       )}
    end
  end

  def handle_info({:all_checks_done, %State{} = state}, socket) do
    installation_type =
      case state.diagnostics do
        %{wordpress_likely?: true} -> "wordpress"
        %{gtm_likely?: true} -> "gtm"
        _ -> "manual"
      end

    {:noreply,
     assign(socket,
       initial_installation_type: installation_type,
       installation_type: installation_type
     )}
  end

  def handle_info(_msg, socket) do
    {:noreply, socket}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.flash_messages flash={@flash} />
      <PlausibleWeb.Components.FirstDashboardLaunchBanner.set :if={@site_created?} site={@site} />
      <PlausibleWeb.Components.FlowProgress.render flow={@flow} current_step="Install Plausible" />

      <.focus_box>
        <:title :if={is_nil(@installation_type)}>
          <div class="flex w-full mx-auto justify-center">
            <.spinner class="spinner block text-center h-8 w-8" />
          </div>
        </:title>
        <:title :if={@installation_type == "wordpress"}>
          Install WordPress plugin
        </:title>
        <:title :if={@installation_type == "gtm"}>
          Install Google Tag Manager
        </:title>
        <:title :if={@installation_type == "manual"}>
          Manual installation
        </:title>

        <:subtitle :if={is_nil(@installation_type)}>
          <div class="text-center mt-8">
            Determining installation type...
            <.styled_link
              :if={@connected?}
              href="#"
              phx-click="switch-installation-type"
              phx-value-method="manual"
            >
              Skip
            </.styled_link>
          </div>
        </:subtitle>

        <:subtitle :if={@flow == PlausibleWeb.Flows.domain_change()}>
          <p class="mb-4">
            Your domain has been changed.
            <strong>
              You must update the Plausible Installation on your site within 72 hours to guarantee continuous tracking.
            </strong>
            <br />
            <br /> If you're using the API, please also make sure to update your API credentials.
          </p>
        </:subtitle>

        <:subtitle :if={@flow == PlausibleWeb.Flows.review() and not is_nil(@installation_type)}>
          <p class="mb-4">
            Review your existing installation. You can skip this step and proceed to verifying your installation.
          </p>
        </:subtitle>

        <:subtitle :if={@installation_type == "wordpress"}>
          We've detected your website is using WordPress. Here's how to integrate Plausible:
          <.focus_list>
            <:item>
              <.styled_link href="https://plausible.io/wordpress-analytics-plugin" new_tab={true}>
                Install our WordPress plugin
              </.styled_link>
            </:item>
            <:item>
              After activating our plugin, click the button below to verify your installation
            </:item>
          </.focus_list>
        </:subtitle>
        <:subtitle :if={@installation_type == "gtm"}>
          We've detected your website is using Google Tag Manager. Here's how to integrate Plausible:
          <.focus_list>
            <:item>
              <.styled_link href="https://plausible.io/docs/google-tag-manager" new_tab={true}>
                Read our Tag Manager guide
              </.styled_link>
            </:item>
            <:item>
              Paste this snippet into GTM's Custom HTML section. Once done, click the button below to verify your installation.
            </:item>
          </.focus_list>
        </:subtitle>

        <:subtitle :if={@installation_type == "manual"}>
          Paste this snippet into the <code>&lt;head&gt;</code>
          section of your site. See our
          <.styled_link href="https://plausible.io/docs/integration-guides" new_tab={true}>
            installation guides.
          </.styled_link>
          Once done, click the button below to verify your installation.
        </:subtitle>

        <div :if={@installation_type in ["manual", "gtm"]}>
          <.snippet_form installation_type={@installation_type} config={@config} domain={@domain} />
        </div>

        <.button_link
          :if={not is_nil(@installation_type)}
          href={"/#{URI.encode_www_form(@domain)}/verification?#{URI.encode_query(@uri_params)}"}
          type="submit"
          class="w-full mt-8"
        >
          <%= if @flow == PlausibleWeb.Flows.domain_change() do %>
            I understand, I'll update my website
          <% else %>
            <%= if @flow == PlausibleWeb.Flows.review() do %>
              Verify your installation
            <% else %>
              Start collecting data
            <% end %>
          <% end %>
        </.button_link>

        <:footer :if={@initial_installation_type == "wordpress" and @installation_type == "manual"}>
          <.styled_link href={} phx-click="switch-installation-type" phx-value-method="wordpress">
            Click here
          </.styled_link>
          if you prefer WordPress installation method.
        </:footer>

        <:footer :if={
          (@initial_installation_type == "gtm" and @installation_type == "manual") or
            (@initial_installation_type == "manual" and @installation_type == "manual")
        }>
          <.styled_link href={} phx-click="switch-installation-type" phx-value-method="gtm">
            Click here
          </.styled_link>
          if you prefer Google Tag Manager installation method.
        </:footer>

        <:footer :if={not is_nil(@installation_type) and @installation_type != "manual"}>
          <.styled_link href={} phx-click="switch-installation-type" phx-value-method="manual">
            Click here
          </.styled_link>
          if you prefer manual installation method.
        </:footer>
      </.focus_box>
    </div>
    """
  end

  defp render_snippet("manual", domain, %{"track_404_pages" => true} = script_config) do
    script_config = Map.put(script_config, "track_404_pages", false)

    """
    #{render_snippet("manual", domain, script_config)}
    #{render_snippet_404()}
    """
  end

  defp render_snippet("manual", domain, script_config) do
    ~s|<script defer data-domain="#{domain}" src="#{tracker_url(script_config)}"></script>|
  end

  defp render_snippet("gtm", domain, %{"track_404_pages" => true} = script_config) do
    script_config = Map.put(script_config, "track_404_pages", false)

    """
    #{render_snippet("gtm", domain, script_config)}
    #{render_snippet_404("gtm")}
    """
  end

  defp render_snippet("gtm", domain, script_config) do
    """
    <script>
    var script = document.createElement('script');
    script.defer = true;
    script.dataset.domain = "#{domain}";
    script.dataset.api = "https://plausible.io/api/event";
    script.src = "#{tracker_url(script_config)}";
    document.getElementsByTagName('head')[0].appendChild(script);
    </script>
    """
  end

  def render_snippet_404() do
    "<script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>"
  end

  def render_snippet_404("gtm") do
    render_snippet_404()
  end

  defp script_extension_control(assigns) do
    ~H"""
    <div class="mt-2 p-1 text-sm">
      <div class="flex items-center">
        <input
          type="checkbox"
          id={"check-#{@variant}"}
          name={@variant}
          checked={Map.get(@config, @variant, false)}
          class="block h-5 w-5 rounded dark:bg-gray-700 border-gray-300 text-indigo-600 focus:ring-indigo-600 mr-2"
        />
        <label for={"check-#{@variant}"}>
          {@label}
        </label>
        <div class="ml-2 collapse md:visible">
          <.tooltip sticky?={false}>
            <:tooltip_content>
              {@tooltip}
              <br /><br />Click to learn more.
            </:tooltip_content>
            <a href={@learn_more} target="_blank" rel="noopener noreferrer">
              <Heroicons.information_circle class="text-indigo-700 dark:text-gray-500 w-5 h-5 hover:stroke-2" />
            </a>
          </.tooltip>
        </div>
        <div class="ml-2 visible md:invisible">
          <a href={@learn_more} target="_blank" rel="noopener noreferrer">
            <Heroicons.information_circle class="text-indigo-700 dark:text-gray-500 w-5 h-5 hover:stroke-2" />
          </a>
        </div>
      </div>
    </div>
    """
  end

  defp snippet_form(assigns) do
    ~H"""
    <form id="snippet-form" phx-change="update-script-config">
      <div class="relative">
        <textarea
          id="snippet"
          class="w-full border-1 border-gray-300 rounded-md p-4 text-sm text-gray-700 dark:border-gray-500 dark:bg-gray-900 dark:text-gray-300"
          rows="5"
          readonly
        ><%= render_snippet(@installation_type, @domain, @config) %></textarea>

        <a
          onclick="var input = document.getElementById('snippet'); input.focus(); input.select(); document.execCommand('copy'); event.stopPropagation();"
          href="javascript:void(0)"
          class="absolute flex items-center text-xs font-medium text-indigo-600 no-underline hover:underline bottom-2 right-4 p-2 bg-white dark:bg-gray-900"
        >
          <Heroicons.document_duplicate class="pr-1 text-indigo-600 dark:text-indigo-500 w-5 h-5" />
          <span>
            COPY
          </span>
        </a>
      </div>

      <.h2 class="mt-8 text-sm font-medium">Enable optional measurements:</.h2>
      <.script_extension_control
        config={@config}
        variant="outbound_links"
        label="Outbound links"
        tooltip="Automatically track clicks on external links. These count towards your billable pageviews."
        learn_more="https://plausible.io/docs/outbound-link-click-tracking"
      />
      <.script_extension_control
        config={@config}
        variant="file_downloads"
        label="File downloads"
        tooltip="Automatically track file downloads. These count towards your billable pageviews."
        learn_more="https://plausible.io/docs/file-downloads-tracking"
      />
      <.script_extension_control
        config={@config}
        variant="track_404_pages"
        label="404 error pages"
        tooltip="Find 404 error pages on your site. These count towards your billable pageviews. Additional action required."
        learn_more="https://plausible.io/docs/error-pages-tracking-404"
      />
      <.script_extension_control
        config={@config}
        variant="hash_based_routing"
        label="Hashed page paths"
        tooltip="Automatically track page paths that use a # in the URL."
        learn_more="https://plausible.io/docs/hash-based-routing"
      />
      <.script_extension_control
        config={@config}
        variant="tagged_events"
        label="Custom events"
        tooltip="Tag site elements like buttons, links and forms to track user activity. These count towards your billable pageviews. Additional action required."
        learn_more="https://plausible.io/docs/custom-event-goals"
      />
      <.script_extension_control
        config={@config}
        variant="pageview_props"
        label="Custom properties"
        tooltip="Attach custom properties (also known as custom dimensions) to pageviews or custom events to create custom metrics. Additional action required."
        learn_more="https://plausible.io/docs/custom-props/introduction"
      />
      <.script_extension_control
        config={@config}
        variant="revenue_tracking"
        label="Ecommerce revenue"
        tooltip="Assign monetary values to purchases and track revenue attribution. Additional action required."
        learn_more="https://plausible.io/docs/ecommerce-revenue-tracking"
      />
    </form>
    """
  end

  def handle_event("switch-installation-type", %{"method" => method}, socket)
      when method in @installation_types do
    socket = update_uri_params(socket, %{"installation_type" => method})
    {:noreply, socket}
  end

  def handle_event("update-script-config", params, socket) do
    new_config =
      @script_config_params
      |> Map.new(fn key -> {key, Map.get(params, key) == "on"} end)

    flash = snippet_change_flash(socket.assigns.config, new_config)

    socket =
      if flash do
        put_live_flash(socket, :success, flash)
      else
        socket
      end

    socket = update_uri_params(socket, new_config)
    {:noreply, socket}
  end

  def handle_params(params, _uri, socket) do
    socket =
      socket
      |> update_installation_type(params)
      |> update_script_config(params)
      |> persist_tracker_script_configuration()

    {:noreply, socket}
  end

  defp update_installation_type(socket, %{"installation_type" => installation_type})
       when installation_type in @installation_types do
    assign(socket,
      installation_type: installation_type,
      uri_params: Map.put(socket.assigns.uri_params, "installation_type", installation_type)
    )
  end

  defp update_installation_type(socket, _params), do: socket

  defp update_script_config(socket, params) do
    configuration_update =
      @script_config_params
      |> Enum.filter(&Map.has_key?(params, &1))
      |> Map.new(fn key -> {key, Map.get(params, key) == "true"} end)

    assign(socket,
      config: Map.merge(socket.assigns.config, configuration_update)
    )
  end

  defp update_uri_params(socket, params) when is_map(params) do
    uri_params = Map.merge(socket.assigns.uri_params, params)

    socket
    |> assign(uri_params: uri_params)
    |> push_patch(
      to:
        Routes.site_path(
          socket,
          :installation,
          socket.assigns.domain,
          uri_params
        ),
      replace: true
    )
  end

  @domain_change PlausibleWeb.Flows.domain_change()
  defp get_installation_type(@domain_change, tracker_script_configuration, params) do
    case tracker_script_configuration.installation_type do
      nil ->
        get_installation_type(nil, nil, params)

      installation_type ->
        Atom.to_string(installation_type)
    end
  end

  defp get_installation_type(_type, _tracker_script_configuration, params) do
    Enum.find(@installation_types, &(&1 == params["installation_type"]))
  end

  defp tracker_url(script_config) do
    extensions =
      @script_extension_params
      |> Enum.flat_map(fn {key, extension} ->
        if(Map.get(script_config, key), do: [extension], else: [])
      end)

    tracker = Enum.join(["script" | extensions], ".")

    "#{PlausibleWeb.Endpoint.url()}/js/#{tracker}.js"
  end

  defp persist_tracker_script_configuration(socket) do
    tracker_script_config_update =
      Map.merge(socket.assigns.config, %{
        "site_id" => socket.assigns.site.id,
        "installation_type" => socket.assigns.installation_type
      })

    PlausibleWeb.Tracker.update_script_configuration(
      socket.assigns.site,
      tracker_script_config_update,
      :installation
    )

    socket
  end

  defp snippet_change_flash(old_config, new_config) do
    change =
      Enum.find(new_config, fn {key, new_value} ->
        Map.get(old_config, key) != new_value
      end)

    case change do
      nil ->
        nil

      {k, false} when k in ["outbound_links", "file_downloads", "track_404_pages"] ->
        "Snippet updated and goal deleted. Please insert the newest snippet into your site"

      {_, _} ->
        "Snippet updated. Please insert the newest snippet into your site"
    end
  end
end
```

## File: `lib/plausible_web/live/installationv2.ex`
```
defmodule PlausibleWeb.Live.InstallationV2 do
  @moduledoc """
  User assistance module around Plausible installation instructions/onboarding
  """
  alias PlausibleWeb.Flows
  alias Plausible.InstallationSupport.{State, Checks, LegacyVerification}
  use PlausibleWeb, :live_view

  def mount(
        %{"domain" => domain} = params,
        _session,
        socket
      ) do
    site =
      Plausible.Sites.get_for_user!(socket.assigns.current_user, domain, [
        :owner,
        :admin,
        :editor,
        :super_admin,
        :viewer
      ])

    tracker_script_configuration =
      PlausibleWeb.Tracker.get_or_create_tracker_script_configuration!(site, %{
        outbound_links: true,
        form_submissions: true,
        file_downloads: true,
        installation_type: :manual
      })

    flow = params["flow"] || Flows.provisioning()

    detect_installation_type? =
      connected?(socket) and flow == Flows.provisioning() and !params["type"]

    if detect_installation_type? do
      LegacyVerification.Checks.run("https://#{site.domain}", site.domain,
        checks: [
          Checks.FetchBody,
          Checks.ScanBody
        ],
        report_to: self(),
        async?: true,
        slowdown: 0
      )
    end

    {:ok,
     assign(socket,
       site: site,
       tracker_script_configuration_form:
         to_form(
           Plausible.Site.TrackerScriptConfiguration.installation_changeset(
             tracker_script_configuration,
             %{}
           )
         ),
       flow: params["flow"] || "provisioning",
       detect_installation_type?: detect_installation_type?,
       installation_type: get_installation_type(params, tracker_script_configuration),
       recommended_installation_type: nil
     )}
  end

  def handle_info({:all_checks_done, %State{} = state}, socket) do
    installation_type =
      case state.diagnostics do
        %{wordpress_likely?: true} -> "wordpress"
        %{gtm_likely?: true} -> "gtm"
        _ -> "manual"
      end

    {:noreply,
     assign(socket,
       installation_type: installation_type,
       recommended_installation_type: installation_type
     )}
  end

  def handle_info({:check_start, _}, socket) do
    {:noreply, socket}
  end

  def handle_params(params, _url, socket) do
    {:noreply,
     assign(socket,
       installation_type:
         get_installation_type(params, socket.assigns.tracker_script_configuration_form.data)
     )}
  end

  def render(assigns) do
    ~H"""
    <div>
      <PlausibleWeb.Components.FlowProgress.render flow={@flow} current_step="Install Plausible" />

      <.focus_box>
        <div class="flex flex-row gap-2 bg-gray-100 rounded-md p-1">
          <.tab patch={"?type=manual&flow=#{@flow}"} selected={@installation_type == "manual"}>
            <.script_icon /> Script
          </.tab>
          <.tab patch={"?type=wordpress&flow=#{@flow}"} selected={@installation_type == "wordpress"}>
            <.wordpress_icon /> WordPress
          </.tab>
          <.tab patch={"?type=gtm&flow=#{@flow}"} selected={@installation_type == "gtm"}>
            <.tag_manager_icon /> Tag Manager
          </.tab>
          <.tab patch={"?type=npm&flow=#{@flow}"} selected={@installation_type == "npm"}>
            <.npm_icon /> NPM
          </.tab>
        </div>

        <div
          :if={@detect_installation_type? and is_nil(@recommended_installation_type)}
          class="flex items-center justify-center py-8"
        >
          <.spinner class="w-6 h-6" />
        </div>

        <.form
          :if={
            not @detect_installation_type? or
              (@detect_installation_type? and not is_nil(@recommended_installation_type))
          }
          for={@tracker_script_configuration_form}
          phx-submit="submit"
          class="mt-4"
        >
          <.input
            type="hidden"
            field={@tracker_script_configuration_form[:installation_type]}
            value={@installation_type}
          />
          <.manual_instructions
            :if={@installation_type == "manual"}
            tracker_script_configuration_form={@tracker_script_configuration_form}
          />

          <.wordpress_instructions
            :if={@installation_type == "wordpress"}
            flow={@flow}
            recommended_installation_type={@recommended_installation_type}
          />
          <.gtm_instructions
            :if={@installation_type == "gtm"}
            recommended_installation_type={@recommended_installation_type}
          />
          <.npm_instructions :if={@installation_type == "npm"} />

          <.button type="submit" class="w-full mt-8">
            <%= if @flow == PlausibleWeb.Flows.review() do %>
              Verify your installation
            <% else %>
              Start collecting data
            <% end %>
          </.button>
        </.form>
      </.focus_box>
    </div>
    """
  end

  attr :tracker_script_configuration_form, :map, required: true

  defp manual_instructions(assigns) do
    ~H"""
    <.title class="mt-4">
      Script installation
    </.title>

    <div class="text-sm mt-4 leading-6">
      Paste this snippet into the <code>&lt;head&gt;</code>
      section of your site. See our
      <.styled_link href="https://plausible.io/docs/integration-guides" new_tab={true}>
        installation guides.
      </.styled_link>
      Once done, click the button below to verify your installation.
    </div>

    <.snippet_form tracker_script_configuration={@tracker_script_configuration_form.data} />
    <.h2 class="mt-8 text-sm font-medium">Optional measurements</.h2>
    <.script_config_control
      field={@tracker_script_configuration_form[:outbound_links]}
      label="Outbound links"
      tooltip="Automatically track clicks on external links. These count towards your billable pageviews."
      learn_more="https://plausible.io/docs/outbound-link-click-tracking"
    />
    <.script_config_control
      field={@tracker_script_configuration_form[:file_downloads]}
      label="File downloads"
      tooltip="Automatically track file downloads. These count towards your billable pageviews."
      learn_more="https://plausible.io/docs/file-downloads-tracking"
    />
    <.script_config_control
      field={@tracker_script_configuration_form[:form_submissions]}
      label="Form submissions"
      tooltip="Automatically track form submissions. These count towards your billable pageviews."
      learn_more="https://plausible.io/docs/form-submissions-tracking"
    />

    <.disclosure>
      <.disclosure_button class="mt-4 flex items-center group">
        <.h2 class="text-sm font-medium">Advanced options</.h2>
        <Heroicons.chevron_down mini class="size-4 ml-1 mt-0.5 group-data-[open=true]:rotate-180" />
      </.disclosure_button>
      <.disclosure_panel>
        <ul class="list-disc list-inside mt-2 space-y-2">
          <.advanced_option
            variant="tagged-events"
            label="Manual tagging"
            tooltip="Tag site elements like buttons, links and forms to track user activity. These count towards your billable pageviews. Additional action required."
            learn_more="https://plausible.io/docs/custom-event-goals"
          />
          <.advanced_option
            variant="404"
            label="404 error pages"
            tooltip="Find 404 error pages on your site. These count towards your billable pageviews. Additional action required."
            learn_more="https://plausible.io/docs/error-pages-tracking-404"
          />
          <.advanced_option
            variant="hash"
            label="Hashed page paths"
            tooltip="Automatically track page paths that use a # in the URL."
            learn_more="https://plausible.io/docs/hash-based-routing"
          />
          <.advanced_option
            variant="pageview-props"
            label="Custom properties"
            tooltip="Attach custom properties (also known as custom dimensions) to pageviews or custom events to create custom metrics. Additional action required."
            learn_more="https://plausible.io/docs/custom-props/introduction"
          />
          <.advanced_option
            variant="revenue"
            label="Ecommerce revenue"
            tooltip="Assign monetary values to purchases and track revenue attribution. Additional action required."
            learn_more="https://plausible.io/docs/ecommerce-revenue-tracking"
          />
        </ul>
      </.disclosure_panel>
    </.disclosure>
    """
  end

  attr :field, :any, required: true
  attr :label, :string, required: true
  attr :tooltip, :string, required: true
  attr :learn_more, :string, required: true

  defp script_config_control(assigns) do
    ~H"""
    <div class="mt-2 p-1 text-sm">
      <div class="flex items-center">
        <.input mt?={false} field={@field} label={@label} type="checkbox" />
        <div class="ml-2 collapse md:visible">
          <.tooltip sticky?={false}>
            <:tooltip_content>
              {@tooltip}
              <br /><br />Click to learn more.
            </:tooltip_content>
            <a href={@learn_more} target="_blank" rel="noopener noreferrer">
              <Heroicons.information_circle class="text-indigo-700 dark:text-gray-500 w-5 h-5 hover:stroke-2" />
            </a>
          </.tooltip>
        </div>
        <div class="ml-2 visible md:invisible">
          <a href={@learn_more} target="_blank" rel="noopener noreferrer">
            <Heroicons.information_circle class="text-indigo-700 dark:text-gray-500 w-5 h-5 hover:stroke-2" />
          </a>
        </div>
      </div>
    </div>
    """
  end

  defp advanced_option(assigns) do
    ~H"""
    <li class="p-1 text-sm">
      <div class="inline-flex items-center">
        <div>{@label}</div>
        <div class="ml-2 collapse md:visible">
          <.tooltip sticky?={false}>
            <:tooltip_content>
              {@tooltip}
              <br /><br />Click to learn more.
            </:tooltip_content>
            <a href={@learn_more} target="_blank" rel="noopener noreferrer">
              <Heroicons.information_circle class="text-indigo-700 dark:text-gray-500 w-5 h-5 hover:stroke-2" />
            </a>
          </.tooltip>
        </div>
        <div class="ml-2 visible md:invisible">
          <a href={@learn_more} target="_blank" rel="noopener noreferrer">
            <Heroicons.information_circle class="text-indigo-700 dark:text-gray-500 w-5 h-5 hover:stroke-2" />
          </a>
        </div>
      </div>
    </li>
    """
  end

  defp wordpress_instructions(assigns) do
    ~H"""
    <.title class="mt-4">
      WordPress installation
    </.title>
    <div class="text-sm mt-4 leading-6">
      <span :if={@recommended_installation_type == "wordpress"}>
        We've detected your website is using WordPress. Here's how to integrate Plausible:
      </span>
      <span :if={@recommended_installation_type != "wordpress"}>
        Using Wordpress? Here's how to integrate Plausible:
      </span>
      <.focus_list>
        <:item>
          <.styled_link href="https://plausible.io/wordpress-analytics-plugin" new_tab={true}>
            Install our WordPress plugin
          </.styled_link>
        </:item>
        <:item>
          After activating our plugin, click the button below to verify your installation
        </:item>
      </.focus_list>
    </div>
    """
  end

  defp gtm_instructions(assigns) do
    ~H"""
    <.title class="mt-4">
      Tag Manager installation
    </.title>
    <div class="text-sm mt-4 leading-6">
      <span :if={@recommended_installation_type == "gtm"}>
        We've detected your website is using Google Tag Manager. Here's how to integrate Plausible:
      </span>
      <span :if={@recommended_installation_type != "gtm"}>
        Using Google Tag Manager? Here's how to integrate Plausible:
      </span>
      <.focus_list>
        <:item>
          <.styled_link href="https://plausible.io/docs/google-tag-manager" new_tab={true}>
            Read our Tag Manager guide
          </.styled_link>
        </:item>
        <:item>
          Paste this snippet into GTM's Custom HTML section. Once done, click the button below to verify your installation.
        </:item>
      </.focus_list>
    </div>
    """
  end

  defp npm_instructions(assigns) do
    ~H"""
    <.title class="mt-4">
      NPM installation
    </.title>
    <div class="text-sm mt-4 leading-6">
      TBD
    </div>
    """
  end

  attr :selected, :boolean, default: false
  attr :patch, :string, required: true
  slot :inner_block, required: true

  defp tab(assigns) do
    assigns =
      if assigns[:selected] do
        assign(assigns, class: "bg-white rounded-md px-3.5 text-sm font-medium flex items-center")
      else
        assign(assigns,
          class:
            "bg-gray-100 rounded-md px-3.5 py-2.5 text-sm font-medium flex items-center cursor-pointer"
        )
      end

    ~H"""
    <.link patch={@patch} class={@class}>
      {render_slot(@inner_block)}
    </.link>
    """
  end

  defp snippet_form(assigns) do
    ~H"""
    <div class="relative">
      <textarea
        id="snippet"
        class="w-full border-1 border-gray-300 rounded-md p-4 text-sm text-gray-700 dark:border-gray-500 dark:bg-gray-900 dark:text-gray-300 "
        rows="4"
        readonly
      ><%= render_snippet(@tracker_script_configuration) %></textarea>

      <a
        onclick="var input = document.getElementById('snippet'); input.focus(); input.select(); document.execCommand('copy'); event.stopPropagation();"
        href="javascript:void(0)"
        class="absolute flex items-center text-xs font-medium text-indigo-600 no-underline hover:underline bottom-2 right-4 p-2 bg-white dark:bg-gray-900"
      >
        <Heroicons.document_duplicate class="pr-1 text-indigo-600 dark:text-indigo-500 w-5 h-5" />
        <span>
          COPY
        </span>
      </a>
    </div>
    """
  end

  def handle_event("submit", %{"tracker_script_configuration" => params}, socket) do
    PlausibleWeb.Tracker.update_script_configuration(
      socket.assigns.site,
      params,
      :installation
    )

    {:noreply,
     push_navigate(socket,
       to:
         Routes.site_path(socket, :verification, socket.assigns.site.domain,
           flow: socket.assigns.flow
         )
     )}
  end

  defp render_snippet(tracker_script_configuration) do
    """
    <script>
    window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)},window.plausible.init=function(i){window.plausible.o=i||{}};var script=document.createElement("script");script.type="text/javascript",script.defer=!0,script.src="#{tracker_url(tracker_script_configuration)}";var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(script,r);
    plausible.init()
    </script>
    """
  end

  defp tracker_url(tracker_script_configuration) do
    "https://plausible.io/js/s-#{tracker_script_configuration.id}.js"
  end

  defp script_icon(assigns) do
    ~H"""
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="w-4 h-4 mr-1"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="2"
      stroke="currentColor"
      class="size-6"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 16.5"
      />
    </svg>
    """
  end

  defp wordpress_icon(assigns) do
    ~H"""
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="w-4 h-4 mr-1"
      viewBox="0 0 50 50"
      width="50px"
      height="50px"
    >
      <path d="M25,2C12.317,2,2,12.318,2,25s10.317,23,23,23s23-10.318,23-23S37.683,2,25,2z M25,7c4.26,0,8.166,1.485,11.247,3.955 c-0.956,0.636-1.547,1.74-1.547,2.945c0,1.6,0.9,3,1.9,4.6c0.8,1.3,1.6,3,1.6,5.4c0,1.7-0.5,3.8-1.5,6.4l-2,6.6l-7.1-21.2 c1.2-0.1,2.3-0.2,2.3-0.2c1-0.1,0.9-1.6-0.1-1.6c0,0,0,0-0.1,0c0,0-3.2,0.3-5.3,0.3c-1.9,0-5.2-0.3-5.2-0.3s0,0-0.1,0 c-1,0-1.1,1.6-0.1,1.6c0,0,1,0.1,2.1,0.2l3.1,8.4L19.9,37l-7.2-21.4c1.2-0.1,2.3-0.2,2.3-0.2c1-0.1,0.9-1.6-0.1-1.6c0,0,0,0-0.1,0 c0,0-2.152,0.202-4.085,0.274C14.003,9.78,19.168,7,25,7z M7,25c0-1.8,0.271-3.535,0.762-5.174l7.424,20.256 C10.261,36.871,7,31.323,7,25z M19.678,42.2L25,26.6l5.685,15.471C28.897,42.665,26.989,43,25,43 C23.147,43,21.36,42.719,19.678,42.2z M35.304,39.75L35.304,39.75L40.6,24.4c0.786-2,1.21-3.742,1.39-5.304 C42.633,20.947,43,22.928,43,25C43,31.111,39.954,36.497,35.304,39.75z" />
    </svg>
    """
  end

  defp tag_manager_icon(assigns) do
    ~H"""
    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4 mr-1 -ml-2" viewBox="0 0 80 80">
      <path
        d="M 40 3.0058594 C 38.232848 3.0058594 36.465803 3.6767752 35.125 5.0175781 L 5.0175781 35.125 C 2.3359722 37.806606 2.3359722 42.193394 5.0175781 44.875 L 35.125 74.982422 C 36.465803 76.323225 38.236969 77 40 77 C 41.763031 77 43.534197 76.323225 44.875 74.982422 L 74.982422 44.875 C 77.665111 42.193478 77.665111 37.806522 74.982422 35.125 L 44.875 5.0175781 C 43.534197 3.6767752 41.767152 3.0058594 40 3.0058594 z M 40 4.9960938 C 41.251848 4.9960936 42.50374 5.4744436 43.460938 6.4316406 L 73.568359 36.539062 C 75.48367 38.453541 75.48367 41.54646 73.568359 43.460938 L 43.460938 73.568359 C 42.50374 74.525556 41.254969 75 40 75 C 38.745031 75 37.49626 74.525556 36.539062 73.568359 L 6.4316406 43.460938 C 4.5172466 41.546543 4.5172466 38.453457 6.4316406 36.539062 L 36.539062 6.4316406 C 37.49626 5.4744436 38.748152 4.9960938 40 4.9960938 z M 52.681641 18.007812 C 52.386328 17.980859 52.083359 18.085812 51.880859 18.289062 C 51.790859 18.389062 51.710156 18.499141 51.660156 18.619141 C 51.610156 18.739141 51.589844 18.87 51.589844 19 C 51.589844 19.13 51.610156 19.260859 51.660156 19.380859 C 51.710156 19.500859 51.780859 19.609938 51.880859 19.710938 C 51.970859 19.800937 52.079219 19.869922 52.199219 19.919922 C 52.319219 19.969922 52.449844 20 52.589844 20 C 52.719844 20 52.850703 19.969922 52.970703 19.919922 C 53.090703 19.869922 53.199062 19.800937 53.289062 19.710938 C 53.479063 19.520938 53.589844 19.27 53.589844 19 C 53.589844 18.87 53.559766 18.739141 53.509766 18.619141 C 53.459766 18.489141 53.389063 18.389063 53.289062 18.289062 C 53.199063 18.199063 53.090703 18.130078 52.970703 18.080078 C 52.878203 18.040078 52.780078 18.016797 52.681641 18.007812 z M 50.085938 20.496094 C 49.830938 20.496094 49.575859 20.593563 49.380859 20.789062 C 48.990859 21.179063 48.990859 21.819938 49.380859 22.210938 C 49.570859 22.399938 49.829844 22.5 50.089844 22.5 C 50.339844 22.5 50.599063 22.399938 50.789062 22.210938 C 51.179063 21.819938 51.179062 21.179062 50.789062 20.789062 C 50.594062 20.593563 50.340937 20.496094 50.085938 20.496094 z M 47.585938 22.996094 C 47.330938 22.996094 47.075859 23.093563 46.880859 23.289062 C 46.490859 23.679063 46.490859 24.319938 46.880859 24.710938 C 47.070859 24.899938 47.329844 25 47.589844 25 C 47.839844 25 48.099063 24.899938 48.289062 24.710938 C 48.679063 24.319938 48.679062 23.679062 48.289062 23.289062 C 48.094062 23.093563 47.840937 22.996094 47.585938 22.996094 z M 45.085938 25.496094 C 44.830938 25.496094 44.575859 25.593563 44.380859 25.789062 C 43.990859 26.179063 43.990859 26.819938 44.380859 27.210938 C 44.570859 27.399938 44.829844 27.5 45.089844 27.5 C 45.339844 27.5 45.599063 27.399938 45.789062 27.210938 C 46.179063 26.819938 46.179062 26.179062 45.789062 25.789062 C 45.594062 25.593563 45.340937 25.496094 45.085938 25.496094 z M 42.486328 28.005859 C 42.388672 28.015547 42.291719 28.040078 42.199219 28.080078 C 42.079219 28.130078 41.970859 28.199062 41.880859 28.289062 C 41.790859 28.389063 41.710156 28.489141 41.660156 28.619141 C 41.610156 28.739141 41.589844 28.87 41.589844 29 C 41.589844 29.27 41.690859 29.520937 41.880859 29.710938 C 41.970859 29.800937 42.079219 29.869922 42.199219 29.919922 C 42.319219 29.969922 42.449844 30 42.589844 30 C 42.719844 30 42.850703 29.969922 42.970703 29.919922 C 43.090703 29.869922 43.199063 29.800938 43.289062 29.710938 C 43.479062 29.520937 43.589844 29.27 43.589844 29 C 43.589844 28.87 43.559766 28.739141 43.509766 28.619141 C 43.459766 28.499141 43.389062 28.389062 43.289062 28.289062 C 43.079062 28.079062 42.779297 27.976797 42.486328 28.005859 z M 40 30.001953 L 30.001953 40 L 30.708984 40.707031 L 40 49.998047 L 49.998047 40 L 40 30.001953 z M 40 32.830078 L 47.169922 40 L 40 47.169922 L 32.830078 40 L 40 32.830078 z M 37.585938 50.003906 C 37.455937 50.003906 37.324219 50.029578 37.199219 50.080078 C 37.079219 50.130078 36.970859 50.199062 36.880859 50.289062 C 36.790859 50.389062 36.710156 50.499141 36.660156 50.619141 C 36.610156 50.739141 36.589844 50.87 36.589844 51 C 36.589844 51.13 36.610156 51.260859 36.660156 51.380859 C 36.710156 51.500859 36.780859 51.609938 36.880859 51.710938 C 37.070859 51.899937 37.319844 52 37.589844 52 C 37.849844 52 38.109062 51.899938 38.289062 51.710938 C 38.389063 51.609938 38.459766 51.500859 38.509766 51.380859 C 38.559766 51.260859 38.589844 51.13 38.589844 51 C 38.589844 50.87 38.559766 50.739141 38.509766 50.619141 C 38.459766 50.489141 38.389063 50.389063 38.289062 50.289062 C 38.199063 50.199063 38.090703 50.130078 37.970703 50.080078 C 37.845703 50.029578 37.715938 50.003906 37.585938 50.003906 z M 42.414062 50.003906 C 42.284062 50.003906 42.154297 50.029578 42.029297 50.080078 C 41.909297 50.130078 41.800937 50.199063 41.710938 50.289062 C 41.520938 50.478063 41.410156 50.74 41.410156 51 C 41.410156 51.13 41.440234 51.260859 41.490234 51.380859 C 41.540234 51.500859 41.610937 51.609938 41.710938 51.710938 C 41.800938 51.800938 41.909297 51.869922 42.029297 51.919922 C 42.149297 51.969922 42.280156 52 42.410156 52 C 42.680156 52 42.929141 51.899937 43.119141 51.710938 C 43.209141 51.609938 43.289844 51.500859 43.339844 51.380859 C 43.389844 51.260859 43.410156 51.13 43.410156 51 C 43.410156 50.87 43.389844 50.739141 43.339844 50.619141 C 43.289844 50.489141 43.209141 50.389062 43.119141 50.289062 C 43.029141 50.199062 42.920781 50.130078 42.800781 50.080078 C 42.675781 50.029578 42.544063 50.003906 42.414062 50.003906 z M 35.085938 52.496094 C 34.830937 52.496094 34.575859 52.593563 34.380859 52.789062 C 33.990859 53.179063 33.990859 53.819938 34.380859 54.210938 C 34.570859 54.399938 34.829844 54.5 35.089844 54.5 C 35.339844 54.5 35.599062 54.399937 35.789062 54.210938 C 36.179063 53.819938 36.179063 53.179062 35.789062 52.789062 C 35.594062 52.593563 35.340938 52.496094 35.085938 52.496094 z M 44.914062 52.496094 C 44.659063 52.496094 44.405937 52.593563 44.210938 52.789062 C 43.820937 53.179063 43.820938 53.819938 44.210938 54.210938 C 44.400937 54.399938 44.660156 54.5 44.910156 54.5 C 45.170156 54.5 45.429141 54.399937 45.619141 54.210938 C 46.009141 53.819938 46.009141 53.179062 45.619141 52.789062 C 45.424141 52.593563 45.169062 52.496094 44.914062 52.496094 z M 32.585938 54.996094 C 32.330937 54.996094 32.075859 55.093563 31.880859 55.289062 C 31.490859 55.679063 31.490859 56.319938 31.880859 56.710938 C 32.070859 56.899938 32.329844 57 32.589844 57 C 32.839844 57 33.099062 56.899937 33.289062 56.710938 C 33.679063 56.319938 33.679063 55.679062 33.289062 55.289062 C 33.094062 55.093563 32.840938 54.996094 32.585938 54.996094 z M 47.414062 54.996094 C 47.159063 54.996094 46.905937 55.093563 46.710938 55.289062 C 46.320937 55.679063 46.320938 56.319938 46.710938 56.710938 C 46.900937 56.899938 47.160156 57 47.410156 57 C 47.670156 57 47.929141 56.899937 48.119141 56.710938 C 48.509141 56.319938 48.509141 55.679062 48.119141 55.289062 C 47.924141 55.093563 47.669062 54.996094 47.414062 54.996094 z M 30.085938 57.496094 C 29.830938 57.496094 29.575859 57.593563 29.380859 57.789062 C 28.990859 58.179063 28.990859 58.819938 29.380859 59.210938 C 29.570859 59.399938 29.829844 59.5 30.089844 59.5 C 30.339844 59.5 30.599062 59.399937 30.789062 59.210938 C 31.179063 58.819938 31.179063 58.179062 30.789062 57.789062 C 30.594062 57.593563 30.340937 57.496094 30.085938 57.496094 z M 49.914062 57.496094 C 49.659063 57.496094 49.405937 57.593563 49.210938 57.789062 C 48.820937 58.179063 48.820938 58.819938 49.210938 59.210938 C 49.400937 59.399938 49.660156 59.5 49.910156 59.5 C 50.170156 59.5 50.429141 59.399937 50.619141 59.210938 C 51.009141 58.819938 51.009141 58.179062 50.619141 57.789062 C 50.424141 57.593563 50.169062 57.496094 49.914062 57.496094 z M 27.585938 60.003906 C 27.455938 60.003906 27.324219 60.029578 27.199219 60.080078 C 27.079219 60.130078 26.970859 60.199063 26.880859 60.289062 C 26.690859 60.478063 26.589844 60.74 26.589844 61 C 26.589844 61.27 26.690859 61.520937 26.880859 61.710938 C 27.070859 61.899938 27.319844 62 27.589844 62 C 27.849844 62 28.109062 61.899937 28.289062 61.710938 C 28.479063 61.520938 28.589844 61.27 28.589844 61 C 28.589844 60.74 28.479062 60.478062 28.289062 60.289062 C 28.199063 60.199062 28.090703 60.130078 27.970703 60.080078 C 27.845703 60.029578 27.715937 60.003906 27.585938 60.003906 z M 52.316406 60.005859 C 52.21875 60.015547 52.121797 60.040078 52.029297 60.080078 C 51.909297 60.130078 51.800938 60.199062 51.710938 60.289062 C 51.520938 60.478062 51.410156 60.74 51.410156 61 C 51.410156 61.27 51.520938 61.520938 51.710938 61.710938 C 51.900938 61.899937 52.149922 62 52.419922 62 C 52.679922 62 52.929141 61.899938 53.119141 61.710938 C 53.309141 61.520937 53.410156 61.27 53.410156 61 C 53.410156 60.74 53.309141 60.478063 53.119141 60.289062 C 52.909141 60.079063 52.609375 59.976797 52.316406 60.005859 z"
        stroke="black"
        stroke-width="4"
        fill="black"
      />
    </svg>
    """
  end

  defp npm_icon(assigns) do
    ~H"""
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="16"
      height="16"
      class="w-4 h-4 mr-1"
      viewBox="0 0 16 16"
    >
      <path class="fill-black" d="M0,16V0H16V16ZM3,3V13H8V5h3v8h2V3Z" /><path
        class="fill-white"
        d="M3,3H13V13H11V5H8v8H3Z"
      />
    </svg>
    """
  end

  defp get_installation_type(params, tracker_script_configuration) do
    if params["type"] do
      params["type"]
    else
      Atom.to_string(tracker_script_configuration.installation_type)
    end
  end
end
```

## File: `lib/plausible_web/live/legacy_choose_plan.ex`
```
defmodule PlausibleWeb.Live.LegacyChoosePlan do
  @moduledoc """
  [DEPRECATED] This file is essentially a copy of
  `PlausibleWeb.Live.ChoosePlan` with the
  intent of keeping the old behaviour in place for the users without
  the `starter_tier` feature flag enabled.
  """
  use PlausibleWeb, :live_view

  require Plausible.Billing.Subscription.Status

  alias PlausibleWeb.Components.Billing.{
    LegacyPlanBox,
    LegacyPlanBenefits,
    Notice,
    PageviewSlider
  }

  alias Plausible.Billing.{Plans, Quota}

  @contact_link "https://plausible.io/contact"
  @billing_faq_link "https://plausible.io/docs/billing"

  def mount(_params, %{"remote_ip" => remote_ip}, socket) do
    socket =
      socket
      |> assign_new(:pending_ownership_site_ids, fn %{current_user: current_user} ->
        Plausible.Teams.Memberships.all_pending_site_transfers(current_user.email)
      end)
      |> assign_new(:usage, fn %{
                                 current_team: current_team,
                                 pending_ownership_site_ids: pending_ownership_site_ids
                               } ->
        Plausible.Teams.Billing.quota_usage(current_team,
          with_features: true,
          pending_ownership_site_ids: pending_ownership_site_ids
        )
      end)
      |> assign_new(:subscription, fn %{current_team: current_team} ->
        Plausible.Teams.Billing.get_subscription(current_team)
      end)
      |> assign_new(:owned_plan, fn %{subscription: subscription} ->
        Plans.get_regular_plan(subscription, only_non_expired: true)
      end)
      |> assign_new(:owned_tier, fn %{owned_plan: owned_plan} ->
        if owned_plan, do: Map.get(owned_plan, :kind), else: nil
      end)
      |> assign_new(:current_interval, fn %{subscription: subscription} ->
        current_user_subscription_interval(subscription)
      end)
      |> assign_new(:available_plans, fn %{subscription: subscription} ->
        Plans.available_plans_for(subscription,
          with_prices: true,
          customer_ip: remote_ip,
          legacy?: true
        )
      end)
      |> assign_new(:recommended_tier, fn %{
                                            usage: usage,
                                            available_plans: available_plans,
                                            owned_tier: owned_tier
                                          } ->
        highest_growth_plan = List.last(available_plans.growth)
        highest_business_plan = List.last(available_plans.business)
        Quota.legacy_suggest_tier(usage, highest_growth_plan, highest_business_plan, owned_tier)
      end)
      |> assign_new(:available_volumes, fn %{available_plans: available_plans} ->
        get_available_volumes(available_plans)
      end)
      |> assign_new(:selected_volume, fn %{
                                           usage: usage,
                                           available_volumes: available_volumes
                                         } ->
        default_selected_volume(usage.monthly_pageviews, available_volumes)
      end)
      |> assign_new(:selected_interval, fn %{current_interval: current_interval} ->
        current_interval || :monthly
      end)
      |> assign_new(:selected_growth_plan, fn %{
                                                available_plans: available_plans,
                                                selected_volume: selected_volume
                                              } ->
        get_plan_by_volume(available_plans.growth, selected_volume)
      end)
      |> assign_new(:selected_business_plan, fn %{
                                                  available_plans: available_plans,
                                                  selected_volume: selected_volume
                                                } ->
        get_plan_by_volume(available_plans.business, selected_volume)
      end)

    {:ok, socket}
  end

  def render(assigns) do
    growth_plan_to_render =
      assigns.selected_growth_plan || List.last(assigns.available_plans.growth)

    business_plan_to_render =
      assigns.selected_business_plan || List.last(assigns.available_plans.business)

    growth_benefits =
      LegacyPlanBenefits.for_growth(growth_plan_to_render)

    business_benefits =
      LegacyPlanBenefits.for_business(business_plan_to_render, growth_benefits)

    enterprise_benefits = LegacyPlanBenefits.for_enterprise(business_benefits)

    assigns =
      assigns
      |> assign(:growth_plan_to_render, growth_plan_to_render)
      |> assign(:business_plan_to_render, business_plan_to_render)
      |> assign(:growth_benefits, growth_benefits)
      |> assign(:business_benefits, business_benefits)
      |> assign(:enterprise_benefits, enterprise_benefits)

    ~H"""
    <div class="pt-1 pb-12 sm:pb-16 text-gray-900 dark:text-gray-100">
      <div class="mx-auto max-w-7xl px-6 lg:px-8">
        <Notice.pending_site_ownerships_notice
          class="pb-6"
          pending_ownership_count={length(@pending_ownership_site_ids)}
        />
        <Notice.subscription_past_due class="pb-6" subscription={@subscription} />
        <Notice.subscription_paused class="pb-6" subscription={@subscription} />
        <Notice.upgrade_ineligible :if={not Quota.eligible_for_upgrade?(@usage)} />
        <div class="mx-auto max-w-4xl text-center">
          <p class="text-4xl font-bold tracking-tight lg:text-5xl">
            {if @owned_plan,
              do: "Change subscription plan",
              else: "Upgrade your account"}
          </p>
        </div>
        <div class="mt-12 flex flex-col gap-8 lg:flex-row items-center lg:items-baseline">
          <.interval_picker selected_interval={@selected_interval} />
          <PageviewSlider.render
            selected_volume={@selected_volume}
            available_volumes={@available_volumes}
          />
        </div>
        <div class="mt-6 isolate mx-auto grid max-w-md grid-cols-1 gap-8 lg:mx-0 lg:max-w-none lg:grid-cols-3">
          <LegacyPlanBox.standard
            kind={:growth}
            owned={@owned_tier == :growth}
            recommended={@recommended_tier == :growth}
            plan_to_render={@growth_plan_to_render}
            benefits={@growth_benefits}
            available={!!@selected_growth_plan}
            {assigns}
          />
          <LegacyPlanBox.standard
            kind={:business}
            owned={@owned_tier == :business}
            recommended={@recommended_tier == :business}
            plan_to_render={@business_plan_to_render}
            benefits={@business_benefits}
            available={!!@selected_business_plan}
            {assigns}
          />
          <LegacyPlanBox.enterprise
            benefits={@enterprise_benefits}
            recommended={@recommended_tier == :custom}
          />
        </div>
        <p class="mx-auto mt-8 max-w-2xl text-center text-lg leading-8 text-gray-600 dark:text-gray-400">
          <.render_usage pageview_usage={@usage.monthly_pageviews} />
        </p>
        <.pageview_limit_notice :if={!@owned_plan} />
        <.help_links />
      </div>
    </div>
    <PlausibleWeb.Components.Billing.paddle_script />
    """
  end

  defp render_usage(assigns) do
    case assigns.pageview_usage do
      %{last_30_days: _} ->
        ~H"""
        You have used
        <b><%= PlausibleWeb.AuthView.delimit_integer(@pageview_usage.last_30_days.total) %></b> billable pageviews in the last 30 days
        """

      %{last_cycle: _} ->
        ~H"""
        You have used
        <b><%= PlausibleWeb.AuthView.delimit_integer(@pageview_usage.last_cycle.total) %></b> billable pageviews in the last billing cycle
        """
    end
  end

  def handle_event("set_interval", %{"interval" => interval}, socket) do
    new_interval =
      case interval do
        "yearly" -> :yearly
        "monthly" -> :monthly
      end

    {:noreply, assign(socket, selected_interval: new_interval)}
  end

  def handle_event("slide", %{"slider" => index}, socket) do
    index = String.to_integer(index)
    %{available_plans: available_plans, available_volumes: available_volumes} = socket.assigns

    new_volume =
      if index == length(available_volumes) do
        :enterprise
      else
        Enum.at(available_volumes, index)
      end

    {:noreply,
     assign(socket,
       selected_volume: new_volume,
       selected_growth_plan: get_plan_by_volume(available_plans.growth, new_volume),
       selected_business_plan: get_plan_by_volume(available_plans.business, new_volume)
     )}
  end

  defp default_selected_volume(pageview_usage, available_volumes) do
    total =
      case pageview_usage do
        %{last_30_days: usage} -> usage.total
        %{last_cycle: usage} -> usage.total
      end

    Enum.find(available_volumes, &(total < &1)) || :enterprise
  end

  defp current_user_subscription_interval(subscription) do
    case Plans.subscription_interval(subscription) do
      "yearly" -> :yearly
      "monthly" -> :monthly
      _ -> nil
    end
  end

  defp get_plan_by_volume(_, :enterprise), do: nil

  defp get_plan_by_volume(plans, volume) do
    Enum.find(plans, &(&1.monthly_pageview_limit == volume))
  end

  defp interval_picker(assigns) do
    ~H"""
    <div class="lg:flex-1 lg:order-3 lg:justify-end flex">
      <div class="relative">
        <.two_months_free />
        <fieldset class="grid grid-cols-2 gap-x-1 rounded-full bg-white dark:bg-gray-700 p-1 text-center text-sm font-semibold leading-5 shadow dark:ring-gray-600">
          <label
            class={"cursor-pointer rounded-full px-2.5 py-1 text-gray-900 dark:text-white #{if @selected_interval == :monthly, do: "bg-indigo-600 text-white"}"}
            phx-click="set_interval"
            phx-value-interval="monthly"
          >
            <input type="radio" name="frequency" value="monthly" class="sr-only" />
            <span>Monthly</span>
          </label>
          <label
            class={"cursor-pointer rounded-full px-2.5 py-1 text-gray-900 dark:text-white #{if @selected_interval == :yearly, do: "bg-indigo-600 text-white"}"}
            phx-click="set_interval"
            phx-value-interval="yearly"
          >
            <input type="radio" name="frequency" value="yearly" class="sr-only" />
            <span>Yearly</span>
          </label>
        </fieldset>
      </div>
    </div>
    """
  end

  def two_months_free(assigns) do
    ~H"""
    <span class="absolute -right-5 -top-4 whitespace-no-wrap w-max px-2.5 py-0.5 rounded-full text-xs font-medium leading-4 bg-yellow-100 border border-yellow-300 text-yellow-700">
      2 months free
    </span>
    """
  end

  defp pageview_limit_notice(assigns) do
    ~H"""
    <div class="mt-12 mx-auto mt-6 max-w-2xl">
      <dt>
        <p class="w-full text-center text-gray-900 dark:text-gray-100">
          <span class="text-center font-semibold leading-7">
            What happens if I go over my page views limit?
          </span>
        </p>
      </dt>
      <dd class="mt-3">
        <div class="text-justify leading-7 block text-gray-600 dark:text-gray-100">
          You will never be charged extra for an occasional traffic spike. There are no surprise fees and your card will never be charged unexpectedly.               If your page views exceed your plan for two consecutive months, we will contact you to upgrade to a higher plan for the following month. You will have two weeks to make a decision. You can decide to continue with a higher plan or to cancel your account at that point.
        </div>
      </dd>
    </div>
    """
  end

  defp help_links(assigns) do
    ~H"""
    <div class="mt-8 text-center">
      Questions? <a class="text-indigo-600" href={contact_link()}>Contact us</a>
      or see <a class="text-indigo-600" href={billing_faq_link()}>billing FAQ</a>
    </div>
    """
  end

  defp get_available_volumes(%{business: business_plans, growth: growth_plans}) do
    growth_volumes = Enum.map(growth_plans, & &1.monthly_pageview_limit)
    business_volumes = Enum.map(business_plans, & &1.monthly_pageview_limit)

    (growth_volumes ++ business_volumes)
    |> Enum.uniq()
  end

  defp contact_link(), do: @contact_link

  defp billing_faq_link(), do: @billing_faq_link
end
```

## File: `lib/plausible_web/live/plugins/api/settings.ex`
```
defmodule PlausibleWeb.Live.Plugins.API.Settings do
  @moduledoc """
  LiveView allowing listing, creating and revoking Plugins API tokens.
  """

  use PlausibleWeb, :live_view

  alias Plausible.Plugins.API.Tokens

  def mount(_params, %{"domain" => domain} = session, socket) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        Plausible.Sites.get_for_user!(current_user, domain, [
          :owner,
          :admin,
          :editor,
          :super_admin
        ])
      end)
      |> assign_new(:displayed_tokens, fn %{site: site} ->
        Tokens.list(site)
      end)

    {:ok,
     assign(socket,
       domain: domain,
       create_token?: not is_nil(session["new_token"]),
       token_description: session["new_token"] || ""
     )}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.flash_messages flash={@flash} />

      <%= if @create_token? do %>
        {live_render(
          @socket,
          PlausibleWeb.Live.Plugins.API.TokenForm,
          id: "token-form",
          session: %{
            "domain" => @domain,
            "token_description" => @token_description,
            "rendered_by" => self()
          }
        )}
      <% end %>

      <div>
        <.filter_bar filtering_enabled?={false}>
          <.button phx-click="create-token" mt?={false}>
            Create Plugin Token
          </.button>
        </.filter_bar>

        <.table :if={not Enum.empty?(@displayed_tokens)} rows={@displayed_tokens}>
          <:thead>
            <.th>Description</.th>
            <.th hide_on_mobile>Hint</.th>
            <.th hide_on_mobile>Last used</.th>
            <.th invisible>Actions</.th>
          </:thead>
          <:tbody :let={token}>
            <.td>
              <span class="token-description">
                {token.description}
              </span>
            </.td>
            <.td hide_on_mobile>
              **********{token.hint}
            </.td>
            <.td hide_on_mobile>
              {Plausible.Plugins.API.Token.last_used_humanize(token)}
            </.td>
            <.td actions>
              <.delete_button
                id={"revoke-token-#{token.id}"}
                phx-click="revoke-token"
                phx-value-token-id={token.id}
                data-confirm="Are you sure you want to revoke this Token? This action cannot be reversed."
              />
            </.td>
          </:tbody>
        </.table>
      </div>
    </div>
    """
  end

  def handle_event("create-token", _params, socket) do
    {:noreply, assign(socket, :create_token?, true)}
  end

  def handle_event("revoke-token", %{"token-id" => token_id}, socket) do
    :ok = Tokens.delete(socket.assigns.site, token_id)
    displayed_tokens = Enum.reject(socket.assigns.displayed_tokens, &(&1.id == token_id))
    {:noreply, assign(socket, create_token?: false, displayed_tokens: displayed_tokens)}
  end

  def handle_info(:close_token_modal, socket) do
    {:noreply, assign(socket, create_token?: false)}
  end

  def handle_info({:token_created, token}, socket) do
    displayed_tokens = [token | socket.assigns.displayed_tokens]

    socket = put_live_flash(socket, :success, "Plugins Token created successfully")

    {:noreply,
     assign(socket,
       displayed_tokens: displayed_tokens,
       token_description: ""
     )}
  end
end
```

## File: `lib/plausible_web/live/plugins/api/token_form.ex`
```
defmodule PlausibleWeb.Live.Plugins.API.TokenForm do
  @moduledoc """
  Live view for the goal creation form
  """
  use PlausibleWeb, live_view: :no_sentry_context
  import PlausibleWeb.Live.Components.Form

  alias Plausible.Plugins.API.{Token, Tokens}

  def mount(
        _params,
        %{
          "token_description" => token_description,
          "domain" => domain,
          "rendered_by" => pid
        },
        socket
      ) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        Plausible.Sites.get_for_user!(current_user, domain, [
          :owner,
          :admin,
          :editor,
          :super_admin
        ])
      end)

    token = Token.generate()
    form = to_form(Token.insert_changeset(socket.assigns.site, token))

    {:ok,
     assign(socket,
       token_description: token_description,
       token: token,
       form: form,
       domain: domain,
       rendered_by: pid,
       token_generated: false
     )}
  end

  def render(assigns) do
    ~H"""
    <div
      class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity z-50"
      phx-window-keydown="close-tokens-modal"
      phx-key="Escape"
    >
    </div>
    <div class="fixed inset-0 flex items-center justify-center mt-16 z-50 overflow-y-auto overflow-x-hidden">
      <div class="w-1/2 h-full">
        <div
          class="max-w-md w-full mx-auto bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4 mt-8"
          phx-click-away="close-token-modal"
        >
          <%= if @token_generated do %>
            <div class="mt-4">
              <.input_with_clipboard
                id="token-clipboard"
                name="token_clipboard"
                label="Plugin Token"
                value={@token.raw}
              />
            </div>
            <p class="mt-4 text-sm text-gray-500 dark:text-gray-400">
              Please copy the token and store it in a secure place as it won't be shown again.
              <span :if={@token_description == "WordPress"}>
                You'll need to paste the token in the settings area of the Plausible WordPress plugin.
              </span>
            </p>
            <.button
              phx-click="close-token-modal"
              class="w-full border !border-gray-300 dark:!border-gray-500 !text-gray-700 dark:!text-gray-300 !bg-transparent hover:!bg-gray-100 dark:hover:!bg-gray-850"
            >
              Close modal
            </.button>
          <% else %>
            <.form :let={f} for={@form} phx-submit="generate-token">
              <.title>
                Create Plugin Token for {@domain}
              </.title>

              <div class="mt-4">
                <.input
                  autofocus
                  field={f[:description]}
                  label="Description"
                  placeholder="e.g. Your Plugin Name"
                  value={@token_description}
                  autocomplete="off"
                  disabled={@token_generated}
                />
              </div>

              <p class="mt-4 text-sm text-gray-500 dark:text-gray-400">
                Once created, we will display the token so it can be copied.
              </p>
              <.button type="submit" class="w-full">
                Create Plugin Token
              </.button>
            </.form>
          <% end %>
        </div>
      </div>
    </div>
    """
  end

  def handle_event("generate-token", %{"token" => %{"description" => description}}, socket) do
    case Tokens.create(socket.assigns.site, description, socket.assigns.token) do
      {:ok, token, _} ->
        send(socket.assigns.rendered_by, {:token_created, token})
        {:noreply, assign(socket, token_generated: true)}

      {:error, changeset} ->
        {:noreply, assign(socket, form: to_form(changeset))}
    end
  end

  def handle_event("close-token-modal", _value, socket) do
    send(socket.assigns.rendered_by, :close_token_modal)
    {:noreply, socket}
  end
end
```

## File: `lib/plausible_web/live/props_settings.ex`
```
defmodule PlausibleWeb.Live.PropsSettings do
  @moduledoc """
  LiveView allowing listing, allowing and disallowing custom event properties.
  """

  use PlausibleWeb, :live_view

  alias PlausibleWeb.Live.Components.ComboBox

  def mount(_params, %{"site_id" => site_id, "domain" => domain}, socket) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        Plausible.Sites.get_for_user!(current_user, domain, [
          :owner,
          :admin,
          :editor,
          :super_admin
        ])
      end)
      |> assign_new(:all_props, fn %{site: site} ->
        site.allowed_event_props || []
      end)
      |> assign_new(:displayed_props, fn %{all_props: props} ->
        props
      end)

    {:ok,
     assign(socket,
       site_team: socket.assigns.site.team,
       site_id: site_id,
       domain: domain,
       add_prop?: false,
       filter_text: ""
     )}
  end

  def render(assigns) do
    ~H"""
    <section id="props-settings-main">
      <.flash_messages flash={@flash} />
      <%= if @add_prop? do %>
        {live_render(
          @socket,
          PlausibleWeb.Live.PropsSettings.Form,
          id: "props-form",
          session: %{
            "domain" => @domain,
            "site_id" => @site_id,
            "rendered_by" => self()
          }
        )}
      <% end %>

      <.live_component
        module={PlausibleWeb.Live.PropsSettings.List}
        id="props-list"
        props={@displayed_props}
        domain={@domain}
        filter_text={@filter_text}
      />
    </section>
    """
  end

  def handle_event("allow", %{"prop" => prop}, socket) do
    case Plausible.Props.allow(socket.assigns.site, prop) do
      {:ok, site} ->
        send_update(ComboBox, id: :prop_input, display_value: "", submit_value: "")

        {:noreply,
         assign(socket,
           site: site,
           form: new_form(site)
         )}

      {:error, changeset} ->
        {:noreply,
         assign(socket,
           form: to_form(Map.put(changeset, :action, :validate))
         )}
    end
  end

  def handle_event("add-prop", _value, socket) do
    {:noreply, assign(socket, add_prop?: true)}
  end

  def handle_event("filter", %{"filter-text" => filter_text}, socket) do
    new_list =
      ComboBox.StaticSearch.suggest(
        filter_text,
        socket.assigns.all_props
      )

    {:noreply, assign(socket, displayed_props: new_list, filter_text: filter_text)}
  end

  def handle_event("reset-filter-text", _params, socket) do
    {:noreply, assign(socket, filter_text: "", displayed_props: socket.assigns.all_props)}
  end

  def handle_event("disallow-prop", %{"prop" => prop}, socket) do
    {:ok, site} = Plausible.Props.disallow(socket.assigns.site, prop)

    socket =
      socket
      |> put_live_flash(:success, "Property removed successfully")
      |> assign(
        all_props: Enum.reject(socket.assigns.all_props, &(&1 == prop)),
        displayed_props: Enum.reject(socket.assigns.displayed_props, &(&1 == prop)),
        site: site
      )

    {:noreply, socket}
  end

  def handle_event("allow-existing-props", _params, socket) do
    {:ok, site} = Plausible.Props.allow_existing_props(socket.assigns.site)

    {:noreply,
     assign(socket,
       site: site
     )}
  end

  def handle_info(:cancel_add_prop, socket) do
    {:noreply, assign(socket, add_prop?: false)}
  end

  def handle_info({:props_allowed, props}, socket) when is_list(props) do
    socket =
      socket
      |> assign(
        add_prop?: false,
        filter_text: "",
        all_props: props,
        displayed_props: props,
        site: %{socket.assigns.site | allowed_event_props: props}
      )
      |> put_live_flash(:success, "Properties added successfully")

    {:noreply, socket}
  end

  def handle_info(
        {:prop_allowed, prop},
        %{assigns: %{site: site}} = socket
      )
      when is_binary(prop) do
    allowed_event_props = [prop | site.allowed_event_props || []]

    socket =
      socket
      |> assign(
        add_prop?: false,
        filter_text: "",
        all_props: allowed_event_props,
        displayed_props: allowed_event_props,
        site: %{site | allowed_event_props: allowed_event_props}
      )
      |> put_live_flash(:success, "Property added successfully")

    {:noreply, socket}
  end

  defp new_form(site) do
    to_form(Plausible.Props.allow_changeset(site, []))
  end
end
```

## File: `lib/plausible_web/live/props_settings/form.ex`
```
defmodule PlausibleWeb.Live.PropsSettings.Form do
  @moduledoc """
  Live view for the custom props creation form
  """
  use PlausibleWeb, :live_view
  import PlausibleWeb.Live.Components.Form
  alias PlausibleWeb.Live.Components.ComboBox

  def mount(
        _params,
        %{
          "site_id" => _site_id,
          "domain" => domain,
          "rendered_by" => pid
        },
        socket
      ) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        Plausible.Sites.get_for_user!(current_user, domain, [
          :owner,
          :admin,
          :editor,
          :super_admin
        ])
      end)
      |> assign_new(:form, fn %{site: site} ->
        new_form(site)
      end)

    {:ok,
     assign(socket,
       domain: domain,
       rendered_by: pid,
       prop_key_options_count: 0
     )}
  end

  def render(assigns) do
    ~H"""
    <div
      class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity z-50"
      phx-window-keydown="cancel-allow-prop"
      phx-key="Escape"
    >
    </div>
    <div class="fixed inset-0 flex items-center justify-center mt-16 z-50 overflow-y-auto overflow-x-hidden">
      <div class="w-1/2 h-full">
        <.form
          :let={f}
          for={@form}
          class="max-w-md w-full mx-auto bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4 mt-8"
          phx-submit="allow-prop"
          phx-click-away="cancel-allow-prop"
        >
          <.title>Add Property for {@domain}</.title>

          <div class="mt-6">
            <.label for="prop_input">
              Property
            </.label>

            <.live_component
              id="prop_input"
              submit_name="prop"
              class={[
                "py-2"
              ]}
              module={ComboBox}
              suggest_fun={
                pid = self()

                fn
                  "", [] ->
                    options =
                      @site
                      |> Plausible.Props.suggest_keys_to_allow()
                      |> Enum.map(&{&1, &1})

                    send(pid, {:update_prop_key_options_count, Enum.count(options)})

                    options

                  input, options ->
                    ComboBox.StaticSearch.suggest(input, options)
                end
              }
              creatable
            />

            <.error :for={{msg, opts} <- f[:allowed_event_props].errors}>
              {Enum.reduce(opts, msg, fn {key, value}, acc ->
                String.replace(acc, "%{#{key}}", fn _ -> to_string(value) end)
              end)}
            </.error>
          </div>

          <.button type="submit" class="w-full">
            Add Property →
          </.button>

          <button
            :if={@prop_key_options_count > 0}
            title="Use this to add any existing properties from your past events into your settings. This allows you to set up properties without having to manually enter each item."
            class="mt-4 text-sm hover:underline text-indigo-600 dark:text-indigo-400 text-left"
            phx-click="allow-existing-props"
          >
            Already sending custom properties? Click to add {@prop_key_options_count} existing properties we found.
          </button>
        </.form>
      </div>
    </div>
    """
  end

  def handle_info({:update_prop_key_options_count, count}, socket) do
    {:noreply, assign(socket, prop_key_options_count: count)}
  end

  def handle_event("allow-prop", %{"prop" => prop}, socket) do
    case Plausible.Props.allow(socket.assigns.site, prop) do
      {:ok, site} ->
        send(socket.assigns.rendered_by, {:prop_allowed, prop})

        {:noreply,
         assign(socket,
           site: site,
           form: new_form(site)
         )}

      {:error, changeset} ->
        {:noreply,
         assign(socket,
           form: to_form(Map.put(changeset, :action, :validate))
         )}
    end
  end

  def handle_event("allow-existing-props", _params, socket) do
    {:ok, site} = Plausible.Props.allow_existing_props(socket.assigns.site)
    send(socket.assigns.rendered_by, {:props_allowed, site.allowed_event_props})

    {:noreply,
     assign(socket,
       site: site,
       form: new_form(site),
       prop_key_options_count: 0
     )}
  end

  def handle_event("cancel-allow-prop", _value, socket) do
    send(socket.assigns.rendered_by, :cancel_add_prop)
    {:noreply, socket}
  end

  defp new_form(site) do
    to_form(Plausible.Props.allow_changeset(site, []))
  end
end
```

## File: `lib/plausible_web/live/props_settings/list.ex`
```
defmodule PlausibleWeb.Live.PropsSettings.List do
  @moduledoc """
  Phoenix LiveComponent module that renders a list of custom properties
  """
  use PlausibleWeb, :live_component

  attr(:props, :list, required: true)
  attr(:domain, :string, required: true)
  attr(:filter_text, :string)

  def render(assigns) do
    ~H"""
    <div>
      <.filter_bar filter_text={@filter_text} placeholder="Search Properties">
        <.button phx-click="add-prop" mt?={false}>
          Add Property
        </.button>
      </.filter_bar>
      <%= if is_list(@props) && length(@props) > 0 do %>
        <.table id="allowed-props" rows={Enum.with_index(@props)}>
          <:tbody :let={{prop, index}}>
            <.td id={"prop-#{index}"}><span class="font-medium">{prop}</span></.td>
            <.td actions>
              <.delete_button
                id={"disallow-prop-#{prop}"}
                data-confirm={delete_confirmation_text(prop)}
                phx-click="disallow-prop"
                phx-value-prop={prop}
                aria-label={"Remove #{prop} property"}
              />
            </.td>
          </:tbody>
        </.table>
      <% else %>
        <p class="mt-12 mb-8 text-center text-sm">
          <span :if={String.trim(@filter_text) != ""}>
            No properties found for this site. Please refine or
            <.styled_link phx-click="reset-filter-text" id="reset-filter-hint">
              reset your search.
            </.styled_link>
          </span>
          <span :if={String.trim(@filter_text) == "" && Enum.empty?(@props)}>
            No properties configured for this site.
          </span>
        </p>
      <% end %>
    </div>
    """
  end

  defp delete_confirmation_text(prop) do
    """
    Are you sure you want to remove the following property:

    #{prop}

    This will just affect the UI, all of your analytics data will stay intact.
    """
  end
end
```

## File: `lib/plausible_web/live/register_form.ex`
```
defmodule PlausibleWeb.Live.RegisterForm do
  @moduledoc """
  LiveView for registration form.
  """

  use PlausibleWeb, :live_view

  alias Plausible.Auth
  alias Plausible.Repo
  alias Plausible.Teams

  def mount(params, _session, socket) do
    socket =
      socket
      |> assign_new(:invitation, fn ->
        if invitation_id = params["invitation_id"] do
          find_by_id_unified(invitation_id)
        end
      end)
      |> assign_new(:team_identifier, fn %{invitation: invitation} ->
        if invitation do
          invitation.team_identifier
        end
      end)

    if socket.assigns.live_action == :register_from_invitation_form and
         socket.assigns.invitation == nil do
      {:ok, assign(socket, invitation_expired: true)}
    else
      changeset =
        if invitation = socket.assigns.invitation do
          Auth.User.settings_changeset(%Auth.User{email: invitation.email})
        else
          Auth.User.settings_changeset(%Auth.User{})
        end

      {:ok,
       assign(socket,
         form: to_form(changeset),
         captcha_error: nil,
         password_strength: Auth.User.password_strength(changeset),
         disable_submit: false,
         trigger_submit: false
       )}
    end
  end

  def render(%{invitation_expired: true} = assigns) do
    ~H"""
    <div class="mx-auto mt-6 text-center dark:text-gray-300">
      <h1 class="text-3xl font-black">{Plausible.product_name()}</h1>
      <div class="text-xl font-medium">Lightweight and privacy-friendly web analytics</div>
    </div>

    <div class="w-full max-w-md mx-auto bg-white dark:bg-gray-800 shadow-md rounded px-8 py-6 mb-4 mt-8">
      <h2 class="text-xl font-black dark:text-gray-100">Invitation expired</h2>

      <p class="mt-4">
        Your invitation has expired or been revoked. Please request fresh one or you can
        <.styled_link href={Routes.auth_path(@socket, :register_form)}>sign up</.styled_link>
        for a 30-day unlimited free trial without an invitation.
      </p>
    </div>
    """
  end

  def render(assigns) do
    ~H"""
    <div class="mx-auto text-center dark:text-gray-300">
      <h1 class="text-3xl font-black">
        <%= if ce?() or @live_action == :register_from_invitation_form do %>
          Register your {Plausible.product_name()} account
        <% else %>
          Register your 30-day free trial
        <% end %>
      </h1>
      <div class="text-xl font-medium mt-2">
        Set up privacy-friendly analytics with just a few clicks
      </div>
    </div>

    <PlausibleWeb.Components.FlowProgress.render
      :if={@live_action == :register_form}
      flow={PlausibleWeb.Flows.register()}
      current_step="Register"
    />
    <PlausibleWeb.Components.FlowProgress.render
      :if={@live_action == :register_from_invitation_form}
      flow={PlausibleWeb.Flows.invitation()}
      current_step="Register"
    />

    <.focus_box>
      <:title>
        Enter your details
      </:title>

      <.form
        :let={f}
        for={@form}
        id="register-form"
        action={Routes.auth_path(@socket, :login)}
        phx-hook="Metrics"
        phx-change="validate"
        phx-submit="register"
        phx-trigger-action={@trigger_submit}
      >
        <input name="user[register_action]" type="hidden" value={@live_action} />
        <input
          :if={@team_identifier}
          name="user[team_identifier]"
          type="hidden"
          value={@team_identifier}
        />

        <%= if @invitation do %>
          <.email_input field={f[:email]} for_invitation={true} />
          <.name_input field={f[:name]} />
        <% else %>
          <.name_input field={f[:name]} />
          <.email_input field={f[:email]} for_invitation={false} />
        <% end %>

        <div class="my-4">
          <div class="flex justify-between">
            <label for={f[:password].name} class="block font-medium text-gray-700 dark:text-gray-300">
              Password
            </label>
            <.password_length_hint minimum={12} field={f[:password]} />
          </div>
          <div class="mt-1">
            <.password_input_with_strength
              field={f[:password]}
              strength={@password_strength}
              phx-debounce={200}
              class="dark:bg-gray-900 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full border-gray-300 dark:border-gray-500 rounded-md dark:text-gray-300"
            />
          </div>
        </div>

        <div class="my-4">
          <label
            for={f[:password_confirmation].name}
            class="block font-medium text-gray-700 dark:text-gray-300"
          >
            Confirm password
          </label>
          <div class="mt-1">
            <.input
              type="password"
              autocomplete="new-password"
              field={f[:password_confirmation]}
              phx-debounce={200}
              class="dark:bg-gray-900 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full border-gray-300 dark:border-gray-500 rounded-md dark:text-gray-300"
            />
          </div>
        </div>

        <%= if PlausibleWeb.Captcha.enabled?() do %>
          <div class="mt-4">
            <div
              phx-update="ignore"
              id="hcaptcha-placeholder"
              class="h-captcha"
              data-sitekey={PlausibleWeb.Captcha.sitekey()}
            >
            </div>
            <%= if @captcha_error do %>
              <div class="text-red-500 text-xs italic mt-3" x-data x-init="hcaptcha.reset()">
                {@captcha_error}
              </div>
            <% end %>
            <script
              phx-update="ignore"
              id="hcaptcha-script"
              src="https://hcaptcha.com/1/api.js"
              async
              defer
            >
            </script>
          </div>
        <% end %>

        <% submit_text =
          if ce?() or @invitation do
            "Create my account"
          else
            "Start my free trial"
          end %>
        <.button id="register" disabled={@disable_submit} type="submit" class="mt-4 w-full">
          {submit_text}
        </.button>

        <p class="text-center text-gray-600 dark:text-gray-500  mt-4">
          Already have an account?
          <.styled_link href="/login">
            Log in
          </.styled_link>
        </p>
      </.form>
    </.focus_box>
    """
  end

  defp name_input(assigns) do
    ~H"""
    <div class="my-4">
      <label for={@field.name} class="block font-medium text-gray-700 dark:text-gray-300">
        Full name
      </label>
      <div class="mt-1">
        <.input
          field={@field}
          placeholder="Jane Doe"
          phx-debounce={200}
          class="dark:bg-gray-900 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-full border-gray-300 dark:border-gray-500 rounded-md dark:text-gray-300"
        />
      </div>
    </div>
    """
  end

  defp email_input(assigns) do
    email_classes = ~w(
      dark:bg-gray-900
      shadow-sm
      focus:ring-indigo-500
      focus:border-indigo-500
      block
      w-full
      border-gray-300
      dark:border-gray-500
      rounded-md
      dark:text-gray-300
    )

    {email_readonly, email_extra_classes} =
      if assigns[:for_invitation] do
        {[readonly: "readonly"], ["bg-gray-100"]}
      else
        {[], []}
      end

    assigns =
      assigns
      |> assign(:email_readonly, email_readonly)
      |> assign(:email_classes, email_classes ++ email_extra_classes)

    ~H"""
    <div class="my-4">
      <div class="flex justify-between">
        <label for={@field.name} class="block font-medium text-gray-700 dark:text-gray-300">
          Email
        </label>
        <p class="text-xs text-gray-500 mt-1">No spam, guaranteed.</p>
      </div>
      <div class="mt-1">
        <.input
          type="email"
          field={@field}
          placeholder="example@email.com"
          phx-debounce={200}
          class={@email_classes}
          {@email_readonly}
        />
      </div>
    </div>
    """
  end

  def handle_event("validate", %{"user" => params}, socket) do
    changeset =
      params
      |> Auth.User.new()
      |> Map.put(:action, :validate)

    password_strength = Auth.User.password_strength(changeset)

    {:noreply,
     assign(socket,
       form: to_form(changeset),
       password_strength: password_strength,
       captcha_error: nil
     )}
  end

  def handle_event(
        "register",
        %{"user" => _} = params,
        %{assigns: %{invitation: %{} = invitation}} = socket
      ) do
    if not PlausibleWeb.Captcha.enabled?() or
         PlausibleWeb.Captcha.verify(params["h-captcha-response"]) do
      user =
        params["user"]
        |> Map.put("email", invitation.email)
        |> Auth.User.new()

      with_team? = invitation.type == :site_transfer

      add_user(socket, user, with_team?: with_team?)
    else
      {:noreply, assign(socket, :captcha_error, "Please complete the captcha to register")}
    end
  end

  def handle_event("register", %{"user" => _} = params, socket) do
    if not PlausibleWeb.Captcha.enabled?() or
         PlausibleWeb.Captcha.verify(params["h-captcha-response"]) do
      user = Auth.User.new(params["user"])

      add_user(socket, user)
    else
      {:noreply, assign(socket, :captcha_error, "Please complete the captcha to register")}
    end
  end

  def handle_event("send-metrics-after", _params, socket) do
    {:noreply, assign(socket, trigger_submit: true)}
  end

  defp add_user(socket, user, opts \\ []) do
    result =
      Repo.transaction(fn ->
        do_add_user(user, opts)
      end)

    case result do
      {:ok, _user} ->
        socket = assign(socket, disable_submit: true)

        on_ee do
          event_name = "Signup#{if socket.assigns.invitation, do: " via invitation"}"
          {:noreply, push_event(socket, "send-metrics", %{event_name: event_name})}
        else
          {:noreply, assign(socket, trigger_submit: true)}
        end

      {:error, changeset} ->
        {:noreply,
         assign(socket,
           form: to_form(Map.put(changeset, :action, :validate))
         )}
    end
  end

  defp do_add_user(user, opts) do
    case Repo.insert(user) do
      {:ok, user} ->
        if opts[:with_team?] do
          {:ok, _} = Plausible.Teams.get_or_create(user)
        end

        user

      {:error, reason} ->
        Repo.rollback(reason)
    end
  end

  defp find_by_id_unified(invitation_or_transfer_id) do
    result =
      with {:error, :invitation_not_found} <-
             find_team_invitation_by_id_unified(invitation_or_transfer_id),
           {:error, :invitation_not_found} <-
             find_invitation_by_id_unified(invitation_or_transfer_id) do
        find_transfer_by_id_unified(invitation_or_transfer_id)
      end

    case result do
      {:error, :invitation_not_found} -> nil
      {:ok, unified} -> unified
    end
  end

  defp find_team_invitation_by_id_unified(id) do
    invitation =
      Teams.Invitation
      |> Repo.get_by(invitation_id: id)
      |> Repo.preload(:team)

    case invitation do
      nil ->
        {:error, :invitation_not_found}

      team_invitation ->
        {:ok,
         %{
           type: :team_invitation,
           email: team_invitation.email,
           team_identifier: team_invitation.team.identifier
         }}
    end
  end

  defp find_invitation_by_id_unified(id) do
    invitation =
      Teams.GuestInvitation
      |> Repo.get_by(invitation_id: id)
      |> Repo.preload(:team_invitation)

    case invitation do
      nil ->
        {:error, :invitation_not_found}

      guest_invitation ->
        {:ok,
         %{
           type: :guest_invitation,
           email: guest_invitation.team_invitation.email,
           team_identifier: nil
         }}
    end
  end

  defp find_transfer_by_id_unified(id) do
    transfer =
      Teams.SiteTransfer
      |> Repo.get_by(transfer_id: id)

    case transfer do
      nil ->
        {:error, :invitation_not_found}

      transfer ->
        {:ok,
         %{
           type: :site_transfer,
           email: transfer.email,
           team_identifier: nil
         }}
    end
  end
end
```

## File: `lib/plausible_web/live/reset_password_form.ex`
```
defmodule PlausibleWeb.Live.ResetPasswordForm do
  @moduledoc """
  LiveView for password reset form.
  """

  use PlausibleWeb, :live_view

  alias Plausible.Auth
  alias Plausible.Repo

  def mount(_params, %{"email" => email}, socket) do
    socket =
      assign_new(socket, :user, fn ->
        Repo.get_by!(Auth.User, email: email)
      end)

    changeset = Auth.User.settings_changeset(socket.assigns.user)

    {:ok,
     assign(socket,
       form: to_form(changeset),
       password_strength: Auth.User.password_strength(changeset),
       trigger_submit: false
     )}
  end

  def render(assigns) do
    ~H"""
    <.form
      :let={f}
      for={@form}
      method="post"
      phx-change="validate"
      phx-submit="set"
      phx-trigger-action={@trigger_submit}
      class="bg-white dark:bg-gray-800 max-w-md w-full mx-auto shadow-md rounded px-8 py-6 mt-8"
    >
      <input name="_csrf_token" type="hidden" value={Plug.CSRFProtection.get_csrf_token()} />
      <h2 class="text-xl font-black dark:text-gray-100">
        Reset your password
      </h2>
      <div class="my-4">
        <.password_length_hint
          minimum={12}
          field={f[:password]}
          class={["text-sm", "mt-1", "mb-2"]}
          ok_class="text-gray-600 dark:text-gray-600"
          error_class="text-red-600 dark:text-red-500"
        />
        <.password_input_with_strength
          field={f[:password]}
          strength={@password_strength}
          phx-debounce={200}
          class="transition bg-gray-100 dark:bg-gray-900 outline-none appearance-none border border-transparent rounded w-full p-2 text-gray-700 dark:text-gray-300 leading-normal appearance-none focus:outline-none focus:bg-white dark:focus:bg-gray-800 focus:border-gray-300 dark:focus:border-gray-500"
        />
      </div>
      <.button id="set" type="submit" class="mt-4 w-full">
        Set password →
      </.button>
      <p class="text-center text-gray-500 text-xs mt-4">
        Don't have an account?
        <.styled_link href="/register">Register</.styled_link>
        instead.
      </p>
    </.form>
    """
  end

  def handle_event("validate", %{"user" => %{"password" => password}}, socket) do
    changeset =
      socket.assigns.user
      |> Auth.User.set_password(password)
      |> Map.put(:action, :validate)

    password_strength = Auth.User.password_strength(changeset)

    {:noreply, assign(socket, form: to_form(changeset), password_strength: password_strength)}
  end

  def handle_event("set", %{"user" => %{"password" => password}}, socket) do
    result =
      Repo.transaction(fn ->
        changeset = Auth.User.set_password(socket.assigns.user, password)

        case Repo.update(changeset) do
          {:ok, user} ->
            Auth.TOTP.reset_token(user)

          {:error, changeset} ->
            Repo.rollback(changeset)
        end
      end)

    case result do
      {:ok, user} ->
        Auth.UserSessions.revoke_all(user)
        {:noreply, assign(socket, trigger_submit: true)}

      {:error, changeset} ->
        {:noreply,
         assign(socket,
           form: to_form(Map.put(changeset, :action, :validate))
         )}
    end
  end
end
```

## File: `lib/plausible_web/live/sentry_context.ex`
```
defmodule PlausibleWeb.Live.SentryContext do
  @moduledoc """
  This module tries to supply LiveViews with some common Sentry context
  (without it, there is practically none).

  Use via `use PlausibleWeb.Live.SentryContext` in your LiveView module,
  or preferably via `use PlausibleWeb, :live_view`.

  In case you have multiple LiveViews, there is `use PlausibleWeb, live_view: :no_sentry_context`
  exposed that allows you to skip using this module. This is because
  only the root LiveView has access to `connect_info` and an exception will be
  thrown otherwise.
  """

  defmacro __using__(_) do
    quote do
      on_mount PlausibleWeb.Live.SentryContext
    end
  end

  def on_mount(:default, _params, _session, socket) do
    if Phoenix.LiveView.connected?(socket) do
      peer = Phoenix.LiveView.get_connect_info(socket, :peer_data)
      uri = Phoenix.LiveView.get_connect_info(socket, :uri)

      user_agent =
        Phoenix.LiveView.get_connect_info(socket, :user_agent)

      request_context =
        %{
          url: socket.host_uri,
          env: %{
            "REMOTE_ADDR" => get_ip(peer),
            "REMOTE_PORT" => peer && peer.port,
            "SEVER_NAME" => uri && uri.host
          }
        }

      request_context =
        if user_agent do
          Map.merge(request_context, %{
            headers: %{
              "User-Agent" => user_agent
            }
          })
        else
          request_context
        end

      Sentry.Context.set_request_context(request_context)

      if current_user = socket.assigns[:current_user] do
        Sentry.Context.set_user_context(%{
          id: current_user.id
        })
      end
    end

    {:cont, socket}
  end

  defp get_ip(%{address: addr}) do
    case :inet.ntoa(addr) do
      {:error, _} -> ""
      address -> to_string(address)
    end
  end

  defp get_ip(_), do: ""
end
```

## File: `lib/plausible_web/live/shields/countries.ex`
```
defmodule PlausibleWeb.Live.Shields.Countries do
  @moduledoc """
  LiveView for IP Addresses Shield
  """
  use PlausibleWeb, :live_view

  alias Plausible.Shields

  def mount(
        _params,
        %{"domain" => domain},
        socket
      ) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        Plausible.Sites.get_for_user!(current_user, domain, [
          :owner,
          :admin,
          :editor,
          :super_admin
        ])
      end)
      |> assign_new(:country_rules_count, fn %{site: site} ->
        Shields.count_country_rules(site)
      end)

    {:ok, socket}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.flash_messages flash={@flash} />
      <.live_component
        module={PlausibleWeb.Live.Shields.CountryRules}
        current_user={@current_user}
        country_rules_count={@country_rules_count}
        site={@site}
        id={"country-rules-#{@current_user.id}"}
      />
    </div>
    """
  end

  def handle_info({:flash, kind, message}, socket) do
    socket = put_live_flash(socket, kind, message)
    {:noreply, socket}
  end
end
```

## File: `lib/plausible_web/live/shields/country_rules.ex`
```
defmodule PlausibleWeb.Live.Shields.CountryRules do
  @moduledoc """
  LiveView allowing Country Rules management
  """

  use PlausibleWeb, :live_component

  alias PlausibleWeb.Live.Components.Modal
  alias Plausible.Shields
  alias Plausible.Shield

  def update(assigns, socket) do
    socket =
      socket
      |> assign(
        country_rules_count: assigns.country_rules_count,
        site: assigns.site,
        current_user: assigns.current_user,
        form: new_form()
      )
      |> assign_new(:country_rules, fn %{site: site} ->
        Shields.list_country_rules(site)
      end)

    {:ok, socket}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.settings_tiles>
        <.tile docs="excluding">
          <:title>Country Block List</:title>
          <:subtitle>Reject incoming traffic from specific countries</:subtitle>
          <.filter_bar
            :if={@country_rules_count < Shields.maximum_country_rules()}
            filtering_enabled?={false}
          >
            <.button
              id="add-country-rule"
              x-data
              x-on:click={Modal.JS.open("country-rule-form-modal")}
              mt?={false}
            >
              Add Country
            </.button>
          </.filter_bar>

          <.notice
            :if={@country_rules_count >= Shields.maximum_country_rules()}
            class="mt-4"
            title="Maximum number of countries reached"
            theme={:gray}
          >
            <p>
              You've reached the maximum number of countries you can block ({Shields.maximum_country_rules()}). Please remove one before adding another.
            </p>
          </.notice>

          <p :if={Enum.empty?(@country_rules)} class="mt-12 mb-8 text-center text-sm">
            No Country Rules configured for this site.
          </p>

          <.table :if={not Enum.empty?(@country_rules)} rows={@country_rules}>
            <:thead>
              <.th>Country</.th>
              <.th hide_on_mobile>Status</.th>
              <.th invisible>Actions</.th>
            </:thead>
            <:tbody :let={rule}>
              <% country = Location.Country.get_country(rule.country_code) %>
              <.td>
                <div class="flex items-center">
                  <span
                    id={"country-#{rule.id}"}
                    class="mr-4 cursor-help"
                    title={"Added at #{format_added_at(rule.inserted_at, @site.timezone)} by #{rule.added_by}"}
                  >
                    {country.flag} {country.name}
                  </span>
                </div>
              </.td>
              <.td hide_on_mobile>
                <span :if={rule.action == :deny}>
                  Blocked
                </span>
                <span :if={rule.action == :allow}>
                  Allowed
                </span>
              </.td>
              <.td actions>
                <.delete_button
                  id={"remove-country-rule-#{rule.id}"}
                  phx-target={@myself}
                  phx-click="remove-country-rule"
                  phx-value-rule-id={rule.id}
                  data-confirm="Are you sure you want to revoke this rule?"
                />
              </.td>
            </:tbody>
          </.table>

          <.live_component :let={modal_unique_id} module={Modal} id="country-rule-form-modal">
            <.form
              :let={f}
              for={@form}
              phx-submit="save-country-rule"
              phx-target={@myself}
              class="max-w-md w-full mx-auto bg-white dark:bg-gray-800"
            >
              <.title>Add Country to Block List</.title>

              <.live_component
                class="mt-4"
                submit_name="country_rule[country_code]"
                submit_value={f[:country_code].value}
                display_value=""
                module={PlausibleWeb.Live.Components.ComboBox}
                suggest_fun={&PlausibleWeb.Live.Components.ComboBox.StaticSearch.suggest/2}
                id={"#{f[:country_code].id}-#{modal_unique_id}"}
                suggestions_limit={300}
                options={options(@country_rules)}
              />

              <p class="mt-4 text-sm text-gray-500 dark:text-gray-400">
                Once added, we will start rejecting traffic from this country within a few minutes.
              </p>
              <.button type="submit" class="w-full">
                Add Country
              </.button>
            </.form>
          </.live_component>
        </.tile>
      </.settings_tiles>
    </div>
    """
  end

  def handle_event("save-country-rule", %{"country_rule" => params}, socket) do
    user = socket.assigns.current_user

    case Shields.add_country_rule(
           socket.assigns.site.id,
           params,
           added_by: user
         ) do
      {:ok, rule} ->
        country_rules = [rule | socket.assigns.country_rules]

        socket =
          socket
          |> Modal.close("country-rule-form-modal")
          |> assign(
            form: new_form(),
            country_rules: country_rules,
            country_rules_count: socket.assigns.country_rules_count + 1
          )

        send_flash(
          :success,
          "Country rule added successfully. Traffic will be rejected within a few minutes."
        )

        {:noreply, socket}

      {:error, %Ecto.Changeset{} = changeset} ->
        {:noreply, assign(socket, form: to_form(changeset))}
    end
  end

  def handle_event("remove-country-rule", %{"rule-id" => rule_id}, socket) do
    Shields.remove_country_rule(socket.assigns.site.id, rule_id)

    send_flash(
      :success,
      "Country rule removed successfully. Traffic will be resumed within a few minutes."
    )

    {:noreply,
     socket
     |> assign(
       country_rules_count: socket.assigns.country_rules_count - 1,
       country_rules: Enum.reject(socket.assigns.country_rules, &(&1.id == rule_id))
     )}
  end

  def send_flash(kind, message) do
    send(self(), {:flash, kind, message})
  end

  defp new_form() do
    %Shield.CountryRule{}
    |> Shield.CountryRule.changeset(%{})
    |> to_form()
  end

  defp options(country_rules) do
    Location.Country.all()
    |> Enum.sort_by(& &1.name)
    |> Enum.map(fn c -> {c.alpha_2, c.flag <> " " <> c.name} end)
    |> Enum.reject(fn {country_code, _} ->
      country_code in Enum.map(country_rules, & &1.country_code)
    end)
  end

  defp format_added_at(dt, tz) do
    dt
    |> Plausible.Timezones.to_datetime_in_timezone(tz)
    |> Calendar.strftime("%Y-%m-%d %H:%M:%S")
  end
end
```

## File: `lib/plausible_web/live/shields/hostname_rules.ex`
```
defmodule PlausibleWeb.Live.Shields.HostnameRules do
  @moduledoc """
  LiveView allowing hostname Rules management
  """

  use PlausibleWeb, :live_component

  alias PlausibleWeb.Live.Components.Modal
  alias Plausible.Shields
  alias Plausible.Shield

  def update(assigns, socket) do
    socket =
      socket
      |> assign(
        hostname_rules_count: assigns.hostname_rules_count,
        site: assigns.site,
        current_user: assigns.current_user,
        form: new_form()
      )
      |> assign_new(:hostname_rules, fn %{site: site} ->
        Shields.list_hostname_rules(site)
      end)
      |> assign_new(:redundant_rules, fn %{hostname_rules: hostname_rules} ->
        detect_redundancy(hostname_rules)
      end)

    {:ok, socket}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.settings_tiles>
        <.tile docs="excluding#exclude-visits-by-hostname">
          <:title>Hostnames Allow List</:title>
          <:subtitle>Accept incoming traffic only from familiar hostnames</:subtitle>
          <.filter_bar
            :if={@hostname_rules_count < Shields.maximum_hostname_rules()}
            filtering_enabled?={false}
          >
            <.button
              id="add-hostname-rule"
              x-data
              x-on:click={Modal.JS.open("hostname-rule-form-modal")}
              mt?={false}
            >
              Add Hostname
            </.button>
          </.filter_bar>

          <.notice
            :if={@hostname_rules_count >= Shields.maximum_hostname_rules()}
            class="mt-4"
            title="Maximum number of hostnames reached"
            theme={:gray}
          >
            <p>
              You've reached the maximum number of hostnames you can block ({Shields.maximum_hostname_rules()}). Please remove one before adding another.
            </p>
          </.notice>

          <p :if={Enum.empty?(@hostname_rules)} class="mt-12 mb-8 text-center text-sm">
            No Hostname Rules configured for this site.
            <strong>
              Traffic from all hostnames is currently accepted.
            </strong>
          </p>

          <.table :if={not Enum.empty?(@hostname_rules)} rows={@hostname_rules}>
            <:thead>
              <.th>Hostname</.th>
              <.th hide_on_mobile>Status</.th>
              <.th invisible>Actions</.th>
            </:thead>
            <:tbody :let={rule}>
              <.td>
                <div class="flex items-center">
                  <span
                    id={"hostname-#{rule.id}"}
                    class="mr-4 cursor-help text-ellipsis truncate max-w-xs"
                    title={"Added at #{format_added_at(rule.inserted_at, @site.timezone)} by #{rule.added_by}"}
                  >
                    {rule.hostname}
                  </span>
                </div>
              </.td>
              <.td hide_on_mobile>
                <div class="flex items-center">
                  <span :if={rule.action == :deny}>
                    Blocked
                  </span>
                  <span :if={rule.action == :allow}>
                    Allowed
                  </span>
                  <span
                    :if={@redundant_rules[rule.id]}
                    title={"This rule might be redundant because the following rules may match first:\n\n#{Enum.join(@redundant_rules[rule.id], "\n")}"}
                    class="pl-4 cursor-help"
                  >
                    <Heroicons.exclamation_triangle class="h-5 w-5 text-red-800" />
                  </span>
                </div>
              </.td>
              <.td actions>
                <.delete_button
                  id={"remove-hostname-rule-#{rule.id}"}
                  phx-target={@myself}
                  phx-click="remove-hostname-rule"
                  phx-value-rule-id={rule.id}
                  data-confirm="Are you sure you want to revoke this rule?"
                />
              </.td>
            </:tbody>
          </.table>

          <.live_component :let={modal_unique_id} module={Modal} id="hostname-rule-form-modal">
            <.form
              :let={f}
              for={@form}
              phx-submit="save-hostname-rule"
              phx-target={@myself}
              class="max-w-md w-full mx-auto bg-white dark:bg-gray-800"
            >
              <.title>Add Hostname to Allow List</.title>

              <.live_component
                class="mt-8"
                submit_name="hostname_rule[hostname]"
                submit_value={f[:hostname].value}
                display_value={f[:hostname].value || ""}
                module={PlausibleWeb.Live.Components.ComboBox}
                suggest_fun={fn input, options -> suggest_hostnames(input, options, @site) end}
                id={"#{f[:hostname].id}-#{modal_unique_id}"}
                creatable
              />
              <.error :for={msg <- f[:hostname].errors}>{translate_error(msg)}</.error>

              <p class="mt-4 text-sm text-gray-500 dark:text-gray-400">
                You can use a wildcard (<code>*</code>) to match multiple hostnames. For example,
                <code>*{@site.domain}</code>
                will only record traffic on your main domain and all of its subdomains.<br /><br />

                <%= if @hostname_rules_count >= 1 do %>
                  Once added, we will start accepting traffic from this hostname within a few minutes.
                <% else %>
                  NB: Once added, we will start rejecting traffic from non-matching hostnames within a few minutes.
                <% end %>
              </p>
              <.button type="submit" class="w-full">
                Add Hostname
              </.button>
            </.form>
          </.live_component>
        </.tile>
      </.settings_tiles>
    </div>
    """
  end

  def handle_event("save-hostname-rule", %{"hostname_rule" => params}, socket) do
    user = socket.assigns.current_user

    case Shields.add_hostname_rule(
           socket.assigns.site.id,
           params,
           added_by: user
         ) do
      {:ok, rule} ->
        hostname_rules = [rule | socket.assigns.hostname_rules]

        socket =
          socket
          |> Modal.close("hostname-rule-form-modal")
          |> assign(
            form: new_form(),
            hostname_rules: hostname_rules,
            hostname_rules_count: socket.assigns.hostname_rules_count + 1,
            redundant_rules: detect_redundancy(hostname_rules)
          )

        send_flash(
          :success,
          "Hostname rule added successfully. Traffic will be limited within a few minutes."
        )

        {:noreply, socket}

      {:error, %Ecto.Changeset{} = changeset} ->
        {:noreply, assign(socket, form: to_form(changeset))}
    end
  end

  def handle_event("remove-hostname-rule", %{"rule-id" => rule_id}, socket) do
    Shields.remove_hostname_rule(socket.assigns.site.id, rule_id)

    send_flash(
      :success,
      "Hostname rule removed successfully. Traffic will be re-adjusted within a few minutes."
    )

    hostname_rules = Enum.reject(socket.assigns.hostname_rules, &(&1.id == rule_id))

    {:noreply,
     socket
     |> assign(
       hostname_rules_count: socket.assigns.hostname_rules_count - 1,
       hostname_rules: hostname_rules,
       redundant_rules: detect_redundancy(hostname_rules)
     )}
  end

  def send_flash(kind, message) do
    send(self(), {:flash, kind, message})
  end

  defp new_form() do
    %Shield.HostnameRule{}
    |> Shield.HostnameRule.changeset(%{})
    |> to_form()
  end

  defp format_added_at(dt, tz) do
    dt
    |> Plausible.Timezones.to_datetime_in_timezone(tz)
    |> Calendar.strftime("%Y-%m-%d %H:%M:%S")
  end

  def suggest_hostnames(input, _options, site) do
    query = Plausible.Stats.Query.from(site, %{})

    site
    |> Plausible.Stats.filter_suggestions(query, "hostname", input)
    |> Enum.map(fn %{label: label, value: value} -> {label, value} end)
  end

  defp detect_redundancy(hostname_rules) do
    hostname_rules
    |> Enum.reduce(%{}, fn rule, acc ->
      {[^rule], remaining_rules} =
        Enum.split_with(
          hostname_rules,
          fn r -> r == rule end
        )

      conflicting =
        remaining_rules
        |> Enum.filter(fn candidate ->
          rule
          |> Map.fetch!(:hostname_pattern)
          |> maybe_compile()
          |> Regex.match?(candidate.hostname)
        end)
        |> Enum.map(& &1.id)

      Enum.reduce(conflicting, acc, fn conflicting_rule_id, acc ->
        Map.update(acc, conflicting_rule_id, [rule.hostname], fn existing ->
          [rule.hostname | existing]
        end)
      end)
    end)
  end

  defp maybe_compile(pattern) when is_binary(pattern), do: Regex.compile!(pattern)
  defp maybe_compile(%Regex{} = pattern), do: pattern
end
```

## File: `lib/plausible_web/live/shields/hostnames.ex`
```
defmodule PlausibleWeb.Live.Shields.Hostnames do
  @moduledoc """
  LiveView for Hostnames Shield
  """
  use PlausibleWeb, :live_view

  alias Plausible.Shields

  def mount(_params, %{"domain" => domain}, socket) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        Plausible.Sites.get_for_user!(current_user, domain, [
          :owner,
          :admin,
          :editor,
          :super_admin
        ])
      end)
      |> assign_new(:hostname_rules_count, fn %{site: site} ->
        Shields.count_hostname_rules(site)
      end)

    {:ok, socket}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.flash_messages flash={@flash} />
      <.live_component
        module={PlausibleWeb.Live.Shields.HostnameRules}
        current_user={@current_user}
        hostname_rules_count={@hostname_rules_count}
        site={@site}
        id={"hostname-rules-#{@current_user.id}"}
      />
    </div>
    """
  end

  def handle_info({:flash, kind, message}, socket) do
    socket = put_live_flash(socket, kind, message)
    {:noreply, socket}
  end
end
```

## File: `lib/plausible_web/live/shields/ip_addresses.ex`
```
defmodule PlausibleWeb.Live.Shields.IPAddresses do
  @moduledoc """
  LiveView for IP Addresses Shield
  """
  use PlausibleWeb, :live_view

  alias Plausible.Shields

  def mount(
        _params,
        %{
          "remote_ip" => remote_ip,
          "domain" => domain
        },
        socket
      ) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        Plausible.Sites.get_for_user!(current_user, domain, [
          :owner,
          :admin,
          :editor,
          :super_admin
        ])
      end)
      |> assign_new(:ip_rules_count, fn %{site: site} ->
        Shields.count_ip_rules(site)
      end)
      |> assign_new(:remote_ip, fn -> remote_ip end)

    {:ok, socket}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.flash_messages flash={@flash} />
      <.live_component
        module={PlausibleWeb.Live.Shields.IPRules}
        current_user={@current_user}
        ip_rules_count={@ip_rules_count}
        site={@site}
        remote_ip={@remote_ip}
        id={"ip-rules-#{@current_user.id}"}
      />
    </div>
    """
  end

  def handle_info({:flash, kind, message}, socket) do
    socket = put_live_flash(socket, kind, message)
    {:noreply, socket}
  end
end
```

## File: `lib/plausible_web/live/shields/ip_rules.ex`
```
defmodule PlausibleWeb.Live.Shields.IPRules do
  @moduledoc """
  LiveView allowing IP Rules management
  """

  use PlausibleWeb, :live_component

  alias PlausibleWeb.Live.Components.Modal
  alias Plausible.Shields
  alias Plausible.Shield

  def update(assigns, socket) do
    socket =
      socket
      |> assign(
        ip_rules_count: assigns.ip_rules_count,
        remote_ip: assigns.remote_ip,
        site: assigns.site,
        current_user: assigns.current_user,
        form: new_form()
      )
      |> assign_new(:ip_rules, fn %{site: site} ->
        Shields.list_ip_rules(site)
      end)

    {:ok, socket}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.settings_tiles>
        <.tile docs="excluding">
          <:title>IP Block List</:title>
          <:subtitle>Reject incoming traffic from specific IP addresses</:subtitle>
          <.filter_bar :if={@ip_rules_count < Shields.maximum_ip_rules()} filtering_enabled?={false}>
            <.button
              id="add-ip-rule"
              x-data
              x-on:click={Modal.JS.open("ip-rule-form-modal")}
              mt?={false}
            >
              Add IP Address
            </.button>
          </.filter_bar>

          <.notice
            :if={@ip_rules_count >= Shields.maximum_ip_rules()}
            class="mt-4"
            title="Maximum number of addresses reached"
            theme={:gray}
          >
            <p>
              You've reached the maximum number of IP addresses you can block ({Shields.maximum_ip_rules()}). Please remove one before adding another.
            </p>
          </.notice>

          <p :if={Enum.empty?(@ip_rules)} class="mt-12 mb-8 text-center text-sm">
            No IP Rules configured for this site.
          </p>

          <.table :if={not Enum.empty?(@ip_rules)} rows={@ip_rules}>
            <:thead>
              <.th>IP Address</.th>
              <.th hide_on_mobile>Status</.th>
              <.th hide_on_mobile>Description</.th>
              <.th invisible>Actions</.th>
            </:thead>
            <:tbody :let={rule}>
              <.td max_width="max-w-40">
                <div class="flex items-center truncate">
                  <span
                    :if={to_string(rule.inet) == @remote_ip}
                    class="inline-flex items-center gap-x-1.5 rounded-md px-2 mr-2 py-1 text-xs font-medium text-gray-700 dark:text-white ring-1 ring-inset ring-gray-300 dark:ring-gray-700"
                  >
                    <svg class="h-1.5 w-1.5 fill-green-400" viewBox="0 0 6 6" aria-hidden="true">
                      <circle cx="3" cy="3" r="3" />
                    </svg>
                    YOU
                  </span>
                  <span
                    id={"inet-#{rule.id}"}
                    class="cursor-help"
                    title={"Added at #{format_added_at(rule.inserted_at, @site.timezone)} by #{rule.added_by}"}
                  >
                    {rule.inet}
                  </span>
                </div>
              </.td>
              <.td hide_on_mobile>
                <span :if={rule.action == :deny}>
                  Blocked
                </span>
                <span :if={rule.action == :allow}>
                  Allowed
                </span>
              </.td>
              <.td hide_on_mobile truncate>
                <span :if={rule.description} title={rule.description}>
                  {rule.description}
                </span>
                <span :if={!rule.description} class="text-gray-400 dark:text-gray-600">
                  --
                </span>
              </.td>
              <.td actions>
                <.delete_button
                  id={"remove-ip-rule-#{rule.id}"}
                  phx-target={@myself}
                  phx-click="remove-ip-rule"
                  phx-value-rule-id={rule.id}
                  data-confirm="Are you sure you want to revoke this rule?"
                />
              </.td>
            </:tbody>
          </.table>

          <.live_component module={Modal} id="ip-rule-form-modal">
            <.form
              :let={f}
              for={@form}
              phx-submit="save-ip-rule"
              phx-target={@myself}
              class="max-w-md w-full mx-auto bg-white dark:bg-gray-800"
            >
              <.title>Add IP to Block List</.title>

              <div class="mt-4">
                <p
                  :if={not ip_rule_present?(@ip_rules, @remote_ip)}
                  class="text-sm text-gray-500 dark:text-gray-400 mb-4"
                >
                  Your current IP address is: <span class="font-mono"><%= @remote_ip %></span>.
                  <.styled_link phx-target={@myself} phx-click="prefill-own-ip-rule">
                    Click here
                  </.styled_link>
                  to block your own traffic, or enter a custom address below.
                </p>

                <.input
                  autofocus
                  field={f[:inet]}
                  label="IP Address"
                  placeholder="e.g. 192.168.127.12"
                />
              </div>

              <.input
                field={f[:description]}
                label="Description (optional)"
                placeholder="e.g. The Office"
              />

              <p class="mt-4 text-sm text-gray-500 dark:text-gray-400">
                Once added, we will start rejecting traffic from this IP within a few minutes.
              </p>
              <.button type="submit" class="w-full">
                Add IP Address →
              </.button>
            </.form>
          </.live_component>
        </.tile>
      </.settings_tiles>
    </div>
    """
  end

  def handle_event("prefill-own-ip-rule", %{}, socket) do
    form =
      %Plausible.Shield.IPRule{}
      |> Plausible.Shield.IPRule.changeset(%{
        inet: socket.assigns.remote_ip,
        description: socket.assigns.current_user.name
      })
      |> to_form()

    {:noreply, assign(socket, form: form)}
  end

  def handle_event("save-ip-rule", %{"ip_rule" => params}, socket) do
    user = socket.assigns.current_user

    case Shields.add_ip_rule(
           socket.assigns.site.id,
           params,
           added_by: user
         ) do
      {:ok, rule} ->
        socket =
          socket
          |> Modal.close("ip-rule-form-modal")
          |> assign(
            form: new_form(),
            ip_rules: [rule | socket.assigns.ip_rules],
            ip_rules_count: socket.assigns.ip_rules_count + 1
          )

        send_flash(
          :success,
          "IP rule added successfully. Traffic will be rejected within a few minutes."
        )

        {:noreply, socket}

      {:error, %Ecto.Changeset{} = changeset} ->
        {:noreply, assign(socket, form: to_form(changeset))}
    end
  end

  def handle_event("remove-ip-rule", %{"rule-id" => rule_id}, socket) do
    Shields.remove_ip_rule(socket.assigns.site.id, rule_id)

    send_flash(
      :success,
      "IP rule removed successfully. Traffic will be resumed within a few minutes."
    )

    {:noreply,
     socket
     |> assign(
       ip_rules_count: socket.assigns.ip_rules_count - 1,
       ip_rules: Enum.reject(socket.assigns.ip_rules, &(&1.id == rule_id))
     )}
  end

  def send_flash(kind, message) do
    send(self(), {:flash, kind, message})
  end

  defp new_form() do
    %Shield.IPRule{}
    |> Shield.IPRule.changeset(%{})
    |> to_form()
  end

  defp ip_rule_present?(rules, ip) do
    not is_nil(Enum.find(rules, &(to_string(&1.inet) == ip)))
  end

  defp format_added_at(dt, tz) do
    dt
    |> Plausible.Timezones.to_datetime_in_timezone(tz)
    |> Calendar.strftime("%Y-%m-%d %H:%M:%S")
  end
end
```

## File: `lib/plausible_web/live/shields/page_rules.ex`
```
defmodule PlausibleWeb.Live.Shields.PageRules do
  @moduledoc """
  LiveView allowing page Rules management
  """

  use PlausibleWeb, :live_component

  alias PlausibleWeb.Live.Components.Modal
  alias Plausible.Shields
  alias Plausible.Shield

  def update(assigns, socket) do
    socket =
      socket
      |> assign(
        page_rules_count: assigns[:page_rules_count] || socket.assigns.page_rules_count,
        site: assigns[:site] || socket.assigns.site,
        current_user: assigns[:current_user] || socket.assigns.current_user,
        form: new_form()
      )
      |> assign_new(:page_rules, fn %{site: site} ->
        Shields.list_page_rules(site)
      end)
      |> assign_new(:redundant_rules, fn %{page_rules: page_rules} ->
        detect_redundancy(page_rules)
      end)

    {:ok, socket}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.settings_tiles>
        <.tile docs="top-pages#block-traffic-from-specific-pages-or-sections">
          <:title>Pages Block List</:title>
          <:subtitle>Reject incoming traffic for specific pages</:subtitle>
          <.filter_bar
            :if={@page_rules_count < Shields.maximum_page_rules()}
            filtering_enabled?={false}
          >
            <.button
              id="add-page-rule"
              x-data
              x-on:click={Modal.JS.open("page-rule-form-modal")}
              mt?={false}
            >
              Add Page
            </.button>
          </.filter_bar>

          <.notice
            :if={@page_rules_count >= Shields.maximum_page_rules()}
            class="mt-4"
            title="Maximum number of pages reached"
            theme={:gray}
          >
            <p>
              You've reached the maximum number of pages you can block ({Shields.maximum_page_rules()}). Please remove one before adding another.
            </p>
          </.notice>

          <p :if={Enum.empty?(@page_rules)} class="mt-12 mb-8 text-center text-sm">
            No Page Rules configured for this site.
          </p>

          <.table :if={not Enum.empty?(@page_rules)} rows={@page_rules}>
            <:thead>
              <.th>Page</.th>
              <.th hide_on_mobile>Status</.th>
              <.th invisible>Actions</.th>
            </:thead>
            <:tbody :let={rule}>
              <.td max_width="max-w-40" truncate>
                <span
                  id={"page-#{rule.id}"}
                  class="mr-4 cursor-help text-ellipsis truncate max-w-xs"
                  title={"Added at #{format_added_at(rule.inserted_at, @site.timezone)} by #{rule.added_by}"}
                >
                  {rule.page_path}
                </span>
              </.td>
              <.td hide_on_mobile>
                <div class="flex items-center">
                  <span :if={rule.action == :deny}>
                    Blocked
                  </span>
                  <span :if={rule.action == :allow}>
                    Allowed
                  </span>
                  <span
                    :if={@redundant_rules[rule.id]}
                    title={"This rule might be redundant because the following rules may match first:\n\n#{Enum.join(@redundant_rules[rule.id], "\n")}"}
                    class="pl-4 cursor-help"
                  >
                    <Heroicons.exclamation_triangle class="h-5 w-5 text-red-800" />
                  </span>
                </div>
              </.td>
              <.td actions>
                <.delete_button
                  id={"remove-page-rule-#{rule.id}"}
                  phx-target={@myself}
                  phx-click="remove-page-rule"
                  phx-value-rule-id={rule.id}
                  data-confirm="Are you sure you want to revoke this rule?"
                />
              </.td>
            </:tbody>
          </.table>

          <.live_component :let={modal_unique_id} module={Modal} id="page-rule-form-modal">
            <.form
              :let={f}
              for={@form}
              phx-submit="save-page-rule"
              phx-target={@myself}
              class="max-w-md w-full mx-auto bg-white dark:bg-gray-800"
            >
              <.title>Add Page to Block List</.title>

              <.live_component
                class="mt-4"
                submit_name="page_rule[page_path]"
                submit_value={f[:page_path].value}
                display_value={f[:page_path].value || ""}
                module={PlausibleWeb.Live.Components.ComboBox}
                suggest_fun={fn input, options -> suggest_page_paths(input, options, @site) end}
                id={"#{f[:page_path].id}-#{modal_unique_id}"}
                creatable
              />

              <.error :for={msg <- f[:page_path].errors}>{translate_error(msg)}</.error>

              <p class="mt-4 text-sm text-gray-500 dark:text-gray-400">
                You can use a wildcard (<code>*</code>) to match multiple pages. For example,
                <code>/blog/*</code>
                will match <code>/blog/post</code>.
                Once added, we will start rejecting traffic from this page within a few minutes.
              </p>
              <.button type="submit" class="w-full">
                Add Page
              </.button>
            </.form>
          </.live_component>
        </.tile>
      </.settings_tiles>
    </div>
    """
  end

  def handle_event("save-page-rule", %{"page_rule" => params}, socket) do
    user = socket.assigns.current_user

    case Shields.add_page_rule(
           socket.assigns.site.id,
           params,
           added_by: user
         ) do
      {:ok, rule} ->
        page_rules = [rule | socket.assigns.page_rules]

        socket =
          socket
          |> Modal.close("page-rule-form-modal")
          |> assign(
            form: new_form(),
            page_rules: page_rules,
            page_rules_count: socket.assigns.page_rules_count + 1,
            redundant_rules: detect_redundancy(page_rules)
          )

        send_flash(
          :success,
          "Page rule added successfully. Traffic will be rejected within a few minutes."
        )

        {:noreply, socket}

      {:error, %Ecto.Changeset{} = changeset} ->
        {:noreply, assign(socket, form: to_form(changeset))}
    end
  end

  def handle_event("remove-page-rule", %{"rule-id" => rule_id}, socket) do
    Shields.remove_page_rule(socket.assigns.site.id, rule_id)

    send_flash(
      :success,
      "Page rule removed successfully. Traffic will be resumed within a few minutes."
    )

    page_rules = Enum.reject(socket.assigns.page_rules, &(&1.id == rule_id))

    {:noreply,
     socket
     |> assign(
       page_rules_count: socket.assigns.page_rules_count - 1,
       page_rules: page_rules,
       redundant_rules: detect_redundancy(page_rules)
     )}
  end

  def send_flash(kind, message) do
    send(self(), {:flash, kind, message})
  end

  defp new_form() do
    %Shield.PageRule{}
    |> Shield.PageRule.changeset(%{})
    |> to_form()
  end

  defp format_added_at(dt, tz) do
    dt
    |> Plausible.Timezones.to_datetime_in_timezone(tz)
    |> Calendar.strftime("%Y-%m-%d %H:%M:%S")
  end

  def suggest_page_paths(input, _options, site) do
    query = Plausible.Stats.Query.from(site, %{})

    site
    |> Plausible.Stats.filter_suggestions(query, "page", input)
    |> Enum.map(fn %{label: label, value: value} -> {label, value} end)
  end

  defp detect_redundancy(page_rules) do
    page_rules
    |> Enum.reduce(%{}, fn rule, acc ->
      {[^rule], remaining_rules} =
        Enum.split_with(
          page_rules,
          fn r -> r == rule end
        )

      conflicting =
        remaining_rules
        |> Enum.filter(fn candidate ->
          rule
          |> Map.fetch!(:page_path_pattern)
          |> maybe_compile()
          |> Regex.match?(candidate.page_path)
        end)
        |> Enum.map(& &1.id)

      Enum.reduce(conflicting, acc, fn conflicting_rule_id, acc ->
        Map.update(acc, conflicting_rule_id, [rule.page_path], fn existing ->
          [rule.page_path | existing]
        end)
      end)
    end)
  end

  defp maybe_compile(pattern) when is_binary(pattern), do: Regex.compile!(pattern)
  defp maybe_compile(%Regex{} = pattern), do: pattern
end
```

## File: `lib/plausible_web/live/shields/pages.ex`
```
defmodule PlausibleWeb.Live.Shields.Pages do
  @moduledoc """
  LiveView for IP Addresses Shield
  """
  use PlausibleWeb, :live_view

  alias Plausible.Shields

  def mount(_params, %{"domain" => domain}, socket) do
    socket =
      socket
      |> assign_new(:site, fn %{current_user: current_user} ->
        Plausible.Sites.get_for_user!(current_user, domain, [
          :owner,
          :admin,
          :editor,
          :super_admin
        ])
      end)
      |> assign_new(:page_rules_count, fn %{site: site} ->
        Shields.count_page_rules(site)
      end)

    {:ok, socket}
  end

  def render(assigns) do
    ~H"""
    <div>
      <.flash_messages flash={@flash} />
      <.live_component
        module={PlausibleWeb.Live.Shields.PageRules}
        current_user={@current_user}
        page_rules_count={@page_rules_count}
        site={@site}
        id={"page-rules-#{@current_user.id}"}
      />
    </div>
    """
  end

  def handle_info({:flash, kind, message}, socket) do
    socket = put_live_flash(socket, kind, message)
    {:noreply, socket}
  end
end
```

## File: `lib/plausible_web/live/sites.ex`
```
defmodule PlausibleWeb.Live.Sites do
  @moduledoc """
  LiveView for sites index.
  """

  use PlausibleWeb, :live_view
  import PlausibleWeb.Live.Components.Pagination
  require Logger

  alias Plausible.Sites
  alias Plausible.Teams

  def mount(params, _session, socket) do
    uri =
      ("/sites?" <> URI.encode_query(Map.take(params, ["filter_text"])))
      |> URI.new!()

    socket =
      socket
      |> assign(:uri, uri)
      |> assign(
        :team_invitations,
        Teams.Invitations.all(socket.assigns.current_user)
      )
      |> assign(:filter_text, String.trim(params["filter_text"] || ""))

    {:ok, socket}
  end

  def handle_params(params, _uri, socket) do
    socket =
      socket
      |> assign(:params, params)
      |> load_sites()
      |> assign_new(:has_sites?, fn %{current_user: current_user} ->
        Teams.Users.has_sites?(current_user, include_pending?: true)
      end)
      |> assign_new(:needs_to_upgrade, fn %{
                                            current_user: current_user,
                                            current_team: current_team
                                          } ->
        current_team &&
          Teams.Users.owns_sites?(current_user, include_pending?: true, only_team: current_team) &&
          Teams.Billing.check_needs_to_upgrade(current_team)
      end)

    {:noreply, socket}
  end

  def render(assigns) do
    ~H"""
    <.flash_messages flash={@flash} />
    <div
      x-ref="invitation_data"
      x-data={"{selectedInvitation: null, invitationOpen: false, invitations: #{Enum.map(@invitations, &({&1.invitation.invitation_id, &1})) |> Enum.into(%{}) |> Jason.encode!}}"}
      x-on:keydown.escape.window="invitationOpen = false"
      class="container pt-6"
    >
      <PlausibleWeb.Live.Components.Visitors.gradient_defs />
      <.upgrade_nag_screen :if={
        @needs_to_upgrade == {:needs_to_upgrade, :no_active_trial_or_subscription}
      } />

      <div class="group mt-6 pb-5 border-b border-gray-200 dark:border-gray-500 flex items-center justify-between">
        <h2 class="text-2xl font-bold leading-7 text-gray-900 dark:text-gray-100 sm:text-3xl sm:leading-9 sm:truncate flex-shrink-0">
          {Teams.name(@current_team)}
          <.unstyled_link
            :if={Teams.setup?(@current_team)}
            data-test-id="team-settings-link"
            href={Routes.settings_path(@socket, :team_general)}
          >
            <Heroicons.cog_6_tooth class="hidden group-hover:inline size-4 dark:text-gray-100 text-gray-900" />
          </.unstyled_link>
        </h2>
      </div>

      <PlausibleWeb.Team.Notice.team_invitations team_invitations={@team_invitations} />

      <div class="border-t border-gray-200 pt-4 sm:flex sm:items-center sm:justify-between">
        <.search_form :if={@has_sites?} filter_text={@filter_text} uri={@uri} />
        <p :if={not @has_sites?} class="dark:text-gray-100">
          You don't have any sites yet.
        </p>
        <div class="mt-4 flex sm:ml-4 sm:mt-0">
          <a href={"/sites/new?flow=#{PlausibleWeb.Flows.provisioning()}"} class="button">
            + Add Website
          </a>
        </div>
      </div>

      <p :if={@filter_text != "" and @sites.entries == []} class="mt-4 dark:text-gray-100 text-center">
        No sites found. Please search for something else.
      </p>

      <p
        :if={
          @has_sites? and not Teams.setup?(@current_team) and @sites.entries == [] and
            @filter_text == ""
        }
        class="mt-4 dark:text-gray-100 text-center"
      >
        You currently have no personal sites. Are you looking for your team’s sites?
        <.styled_link href={Routes.auth_path(@socket, :select_team)}>
          Go to your team &rarr;
        </.styled_link>
      </p>

      <div :if={@has_sites?}>
        <ul class="my-6 grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3">
          <%= for site <- @sites.entries do %>
            <.site
              :if={site.entry_type in ["pinned_site", "site"]}
              site={site}
              hourly_stats={@hourly_stats[site.domain]}
            />
            <.invitation
              :if={site.entry_type == "invitation"}
              site={site}
              invitation={hd(site.invitations)}
              hourly_stats={@hourly_stats[site.domain]}
            />
          <% end %>
        </ul>

        <.pagination
          :if={@sites.total_pages > 1}
          id="sites-pagination"
          uri={@uri}
          page_number={@sites.page_number}
          total_pages={@sites.total_pages}
        >
          Total of <span class="font-medium">{@sites.total_entries}</span> sites
        </.pagination>
        <.invitation_modal :if={Enum.any?(@sites.entries, &(&1.entry_type == "invitation"))} />
      </div>
    </div>
    """
  end

  def upgrade_nag_screen(assigns) do
    ~H"""
    <div class="rounded-md bg-yellow-100 p-4">
      <div class="flex">
        <div class="flex-shrink-0">
          <svg
            class="h-5 w-5 text-yellow-400"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            aria-hidden="true"
          >
            <path
              fill-rule="evenodd"
              d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
              clip-rule="evenodd"
            />
          </svg>
        </div>
        <div class="ml-3">
          <h3 class="text-sm font-medium text-yellow-800">
            Payment required
          </h3>
          <div class="mt-2 text-sm text-yellow-700">
            <p>
              To access the sites you own, you need to subscribe to a monthly or yearly payment plan.
              <.styled_link href={Routes.settings_path(PlausibleWeb.Endpoint, :subscription)}>
                Upgrade now →
              </.styled_link>
            </p>
          </div>
        </div>
      </div>
    </div>
    """
  end

  attr(:site, Plausible.Site, required: true)
  attr(:invitation, :map, required: true)
  attr(:hourly_stats, :map, required: true)

  def invitation(assigns) do
    ~H"""
    <li
      class="group cursor-pointer"
      id={"site-card-#{hash_domain(@site.domain)}"}
      data-domain={@site.domain}
      x-on:click={"invitationOpen = true; selectedInvitation = invitations['#{@invitation.invitation_id}']"}
    >
      <div class="col-span-1 bg-white dark:bg-gray-800 rounded-lg shadow p-4 group-hover:shadow-lg cursor-pointer">
        <div class="w-full flex items-center justify-between space-x-4">
          <img
            src={"/favicon/sources/#{@site.domain}"}
            onerror="this.onerror=null; this.src='/favicon/sources/placeholder';"
            class="w-4 h-4 flex-shrink-0 mt-px"
          />
          <div class="flex-1 truncate -mt-px">
            <h3 class="text-gray-900 font-medium text-lg truncate dark:text-gray-100">
              {@site.domain}
            </h3>
          </div>

          <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-100 text-green-800">
            Pending invitation
          </span>
        </div>
        <.site_stats hourly_stats={@hourly_stats} />
      </div>
    </li>
    """
  end

  attr(:site, Plausible.Site, required: true)
  attr(:hourly_stats, :map, required: true)

  def site(assigns) do
    ~H"""
    <li
      class="group relative"
      id={"site-card-#{hash_domain(@site.domain)}"}
      data-domain={@site.domain}
      data-pin-toggled={
        JS.show(
          transition: {"duration-500", "opacity-0 shadow-2xl -translate-y-6", "opacity-100 shadow"},
          time: 400
        )
      }
      data-pin-failed={
        JS.show(
          transition: {"duration-500", "opacity-0", "opacity-100"},
          time: 200
        )
      }
    >
      <.unstyled_link href={"/#{URI.encode_www_form(@site.domain)}"}>
        <div class="col-span-1 bg-white dark:bg-gray-800 rounded-lg shadow p-4 group-hover:shadow-lg cursor-pointer">
          <div class="w-full flex items-center justify-between space-x-4">
            <.favicon domain={@site.domain} />
            <div class="flex-1 -mt-px w-full">
              <h3
                class="text-gray-900 font-medium text-lg truncate dark:text-gray-100"
                style="width: calc(100% - 4rem)"
              >
                {@site.domain}
              </h3>
            </div>
          </div>
          <.site_stats hourly_stats={@hourly_stats} />
        </div>
      </.unstyled_link>

      <div class="absolute right-0 top-2">
        <.ellipsis_menu site={@site} />
      </div>
    </li>
    """
  end

  def ellipsis_menu(assigns) do
    ~H"""
    <.dropdown>
      <:button class="size-10 rounded-md hover:cursor-pointer text-gray-400 dark:text-gray-600 hover:text-black dark:hover:text-indigo-400">
        <Heroicons.ellipsis_vertical class="absolute top-3 right-3 size-4" />
      </:button>
      <:menu class="!mt-0 mr-4 min-w-40">
        <!-- adjust position because click area is much bigger than icon. Default positioning from click area looks weird -->
        <.dropdown_item
          :if={List.first(@site.memberships).role != :viewer}
          href={"/#{URI.encode_www_form(@site.domain)}/settings/general"}
          class="!flex items-center gap-x-2"
        >
          <Heroicons.cog_6_tooth class="size-4" />
          <span>Settings</span>
        </.dropdown_item>

        <.dropdown_item
          href="#"
          x-on:click.prevent
          phx-click={
            JS.hide(
              transition: {"duration-500", "opacity-100", "opacity-0"},
              to: "#site-card-#{hash_domain(@site.domain)}",
              time: 500
            )
            |> JS.push("pin-toggle")
          }
          phx-value-domain={@site.domain}
          class="!flex items-center gap-x-2"
        >
          <.icon_pin
            :if={@site.pinned_at}
            class="size-4 text-red-400 stroke-red-500 dark:text-yellow-600 dark:stroke-yellow-700"
          />
          <span :if={@site.pinned_at}>Unpin Site</span>

          <.icon_pin :if={!@site.pinned_at} class="size-4" />
          <span :if={!@site.pinned_at}>Pin Site</span>
        </.dropdown_item>
      </:menu>
    </.dropdown>
    """
  end

  attr(:rest, :global)

  def icon_pin(assigns) do
    ~H"""
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="16"
      height="16"
      fill="currentColor"
      viewBox="0 0 16 16"
      {@rest}
    >
      <path d="M9.828.722a.5.5 0 0 1 .354.146l4.95 4.95a.5.5 0 0 1 0 .707c-.48.48-1.072.588-1.503.588-.177 0-.335-.018-.46-.039l-3.134 3.134a5.927 5.927 0 0 1 .16 1.013c.046.702-.032 1.687-.72 2.375a.5.5 0 0 1-.707 0l-2.829-2.828-3.182 3.182c-.195.195-1.219.902-1.414.707-.195-.195.512-1.22.707-1.414l3.182-3.182-2.828-2.829a.5.5 0 0 1 0-.707c.688-.688 1.673-.767 2.375-.72a5.922 5.922 0 0 1 1.013.16l3.134-3.133a2.772 2.772 0 0 1-.04-.461c0-.43.108-1.022.589-1.503a.5.5 0 0 1 .353-.146z" />
    </svg>
    """
  end

  attr(:hourly_stats, :any, required: true)

  def site_stats(assigns) do
    ~H"""
    <div class="md:h-[68px] sm:h-[58px] h-20 pl-8 pr-8 pt-2">
      <div :if={@hourly_stats == :loading} class="text-center animate-pulse">
        <div class="md:h-[34px] sm:h-[30px] h-11 dark:bg-gray-700 bg-gray-100 rounded-md"></div>
        <div class="md:h-[26px] sm:h-[18px] h-6 mt-1 dark:bg-gray-700 bg-gray-100 rounded-md"></div>
      </div>
      <div
        :if={is_map(@hourly_stats)}
        class="hidden h-50px"
        phx-mounted={JS.show(transition: {"ease-in duration-500", "opacity-0", "opacity-100"})}
      >
        <span class="text-gray-600 dark:text-gray-400 text-sm truncate">
          <PlausibleWeb.Live.Components.Visitors.chart intervals={@hourly_stats.intervals} />
          <div class="flex justify-between items-center">
            <p>
              <span class="text-gray-800 dark:text-gray-200">
                <b>{PlausibleWeb.StatsView.large_number_format(@hourly_stats.visitors)}</b>
                visitor<span :if={@hourly_stats.visitors != 1}>s</span> in last 24h
              </span>
            </p>

            <.percentage_change change={@hourly_stats.change} />
          </div>
        </span>
      </div>
    </div>
    """
  end

  attr(:change, :integer, required: true)

  # Related React component: <ChangeArrow />
  def percentage_change(assigns) do
    ~H"""
    <p class="dark:text-gray-100">
      <span :if={@change == 0} class="font-semibold">〰</span>
      <svg
        :if={@change > 0}
        xmlns="http://www.w3.org/2000/svg"
        fill="currentColor"
        viewBox="0 0 24 24"
        class="text-green-500 h-3 w-3 inline-block stroke-[1px] stroke-current"
      >
        <path
          fill-rule="evenodd"
          d="M8.25 3.75H19.5a.75.75 0 01.75.75v11.25a.75.75 0 01-1.5 0V6.31L5.03 20.03a.75.75 0 01-1.06-1.06L17.69 5.25H8.25a.75.75 0 010-1.5z"
          clip-rule="evenodd"
        >
        </path>
      </svg>
      <svg
        :if={@change < 0}
        xmlns="http://www.w3.org/2000/svg"
        fill="currentColor"
        viewBox="0 0 24 24"
        class="text-red-400 h-3 w-3 inline-block stroke-[1px] stroke-current"
      >
        <path
          fill-rule="evenodd"
          d="M3.97 3.97a.75.75 0 011.06 0l13.72 13.72V8.25a.75.75 0 011.5 0V19.5a.75.75 0 01-.75.75H8.25a.75.75 0 010-1.5h9.44L3.97 5.03a.75.75 0 010-1.06z"
          clip-rule="evenodd"
        >
        </path>
      </svg>

      {abs(@change)}%
    </p>
    """
  end

  def invitation_modal(assigns) do
    ~H"""
    <div
      x-cloak
      x-show="invitationOpen"
      class="fixed z-10 inset-0 overflow-y-auto"
      aria-labelledby="modal-title"
      role="dialog"
      aria-modal="true"
    >
      <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
        <div
          x-show="invitationOpen"
          x-transition:enter="transition ease-out duration-300"
          x-transition:enter-start="opacity-0"
          x-transition:enter-end="opacity-100"
          x-transition:leave="transition ease-in duration-200"
          x-transition:leave-start="opacity-100"
          x-transition:leave-end="opacity-0"
          class="fixed inset-0 bg-gray-500 dark:bg-gray-800 bg-opacity-75 dark:bg-opacity-75 transition-opacity"
          aria-hidden="true"
          x-on:click="invitationOpen = false"
        >
        </div>
        <!-- This element is to trick the browser into centering the modal contents. -->
        <span class="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">
          &#8203;
        </span>

        <div
          x-show="invitationOpen"
          x-transition:enter="transition ease-out duration-300"
          x-transition:enter-start="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
          x-transition:enter-end="opacity-100 translate-y-0 sm:scale-100"
          x-transition:leave="transition ease-in duration-200"
          x-transition:leave-start="opacity-100 translate-y-0 sm:scale-100"
          x-transition:leave-end="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
          class="inline-block align-bottom bg-white dark:bg-gray-900 rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full"
        >
          <div class="bg-white dark:bg-gray-850 px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
            <div class="hidden sm:block absolute top-0 right-0 pt-4 pr-4">
              <button
                x-on:click="invitationOpen = false"
                class="bg-white dark:bg-gray-800 rounded-md text-gray-400 dark:text-gray-500 hover:text-gray-500 dark:hover:text-gray-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
              >
                <span class="sr-only">Close</span>
                <Heroicons.x_mark class="h-6 w-6" />
              </button>
            </div>
            <div class="sm:flex sm:items-start">
              <div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-green-100 sm:mx-0 sm:h-10 sm:w-10">
                <Heroicons.user_group class="h-6 w-6" />
              </div>
              <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left">
                <h3
                  class="text-lg leading-6 font-medium text-gray-900 dark:text-gray-100"
                  id="modal-title"
                >
                  Invitation for
                  <span x-text="selectedInvitation && selectedInvitation.invitation.site.domain">
                  </span>
                </h3>
                <div class="mt-2">
                  <p class="text-sm text-gray-500 dark:text-gray-200">
                    You've been invited to the
                    <span x-text="selectedInvitation && selectedInvitation.invitation.site.domain">
                    </span>
                    analytics dashboard as <b
                      class="capitalize"
                      x-text="selectedInvitation && selectedInvitation.invitation.role"
                    >Admin</b>.
                  </p>
                  <div
                    x-show="selectedInvitation && !(selectedInvitation.exceeded_limits || selectedInvitation.no_plan) && selectedInvitation.invitation.role === 'owner'"
                    class="mt-2 text-sm text-gray-500 dark:text-gray-200"
                  >
                    If you accept the ownership transfer, you will be responsible for billing going forward.
                  </div>
                </div>
              </div>
            </div>
            <.notice
              x-show="selectedInvitation && selectedInvitation.missing_features"
              title="Missing features"
              class="mt-4 shadow-sm dark:shadow-none"
            >
              <p>
                The site uses <span x-text="selectedInvitation && selectedInvitation.missing_features"></span>,
                which your current subscription does not support. After accepting ownership of this site,
                you will not be able to access them unless you
                <.styled_link
                  class="inline-block"
                  href={Routes.billing_path(PlausibleWeb.Endpoint, :choose_plan)}
                >
                  upgrade to a suitable plan
                </.styled_link>.
              </p>
            </.notice>
            <.notice
              x-show="selectedInvitation && selectedInvitation.exceeded_limits"
              title="Unable to accept site ownership"
              class="mt-4 shadow-sm dark:shadow-none"
            >
              <p>
                Owning this site would exceed your <span x-text="selectedInvitation && selectedInvitation.exceeded_limits"></span>. Please check your usage in
                <.styled_link
                  class="inline-block"
                  href={Routes.settings_path(PlausibleWeb.Endpoint, :subscription)}
                >
                  account settings
                </.styled_link>
                and upgrade your subscription to accept the site ownership.
              </p>
            </.notice>
            <.notice
              x-show="selectedInvitation && selectedInvitation.no_plan"
              title="No subscription"
              class="mt-4 shadow-sm dark:shadow-none"
            >
              You are unable to accept the ownership of this site because your account does not have a subscription. To become the owner of this site, you should upgrade to a suitable plan.
            </.notice>
          </div>
          <div class="bg-gray-50 dark:bg-gray-850 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
            <.button
              x-show="selectedInvitation && !(selectedInvitation.exceeded_limits || selectedInvitation.no_plan)"
              class="sm:ml-3 w-full sm:w-auto sm:text-sm"
              data-method="post"
              data-csrf={Plug.CSRFProtection.get_csrf_token()}
              x-bind:data-to="selectedInvitation && ('/sites/invitations/' + selectedInvitation.invitation.invitation_id + '/accept')"
            >
              Accept &amp; Continue
            </.button>
            <.button_link
              x-show="selectedInvitation && (selectedInvitation.exceeded_limits || selectedInvitation.no_plan)"
              href={Routes.billing_path(PlausibleWeb.Endpoint, :choose_plan)}
              class="sm:ml-3 w-full sm:w-auto sm:text-sm"
            >
              Upgrade
            </.button_link>
            <.button_link
              href="#"
              theme="bright"
              data-method="post"
              data-csrf={Plug.CSRFProtection.get_csrf_token()}
              x-bind:data-to="selectedInvitation && ('/sites/invitations/' + selectedInvitation.invitation.invitation_id + '/reject')"
            >
              Reject
            </.button_link>
          </div>
        </div>
      </div>
    </div>
    """
  end

  attr(:filter_text, :string, default: "")
  attr(:uri, URI, required: true)

  def search_form(assigns) do
    ~H"""
    <.filter_bar filter_text={@filter_text} placeholder="Search Sites"></.filter_bar>
    """
  end

  def favicon(assigns) do
    src = "/favicon/sources/#{assigns.domain}"
    assigns = assign(assigns, :src, src)

    ~H"""
    <img src={@src} class="w-4 h-4 flex-shrink-0 mt-px" />
    """
  end

  def handle_event("pin-toggle", %{"domain" => domain}, socket) do
    site = Enum.find(socket.assigns.sites.entries, &(&1.domain == domain))

    if site do
      socket =
        case Sites.toggle_pin(socket.assigns.current_user, site) do
          {:ok, preference} ->
            flash_message =
              if preference.pinned_at do
                "Site pinned"
              else
                "Site unpinned"
              end

            socket
            |> put_live_flash(:success, flash_message)
            |> load_sites()
            |> push_event("js-exec", %{
              to: "#site-card-#{hash_domain(site.domain)}",
              attr: "data-pin-toggled"
            })

          {:error, :too_many_pins} ->
            flash_message =
              "Looks like you've hit the pinned sites limit! " <>
                "Please unpin one of your pinned sites to make room for new pins"

            socket
            |> put_live_flash(:error, flash_message)
            |> push_event("js-exec", %{
              to: "#site-card-#{hash_domain(site.domain)}",
              attr: "data-pin-failed"
            })
        end

      {:noreply, socket}
    else
      Sentry.capture_message("Attempting to toggle pin for invalid domain.",
        extra: %{domain: domain, user: socket.assigns.current_user.id}
      )

      {:noreply, socket}
    end
  end

  def handle_event(
        "filter",
        %{"filter-text" => filter_text},
        %{assigns: %{filter_text: filter_text}} = socket
      ) do
    {:noreply, socket}
  end

  def handle_event("filter", %{"filter-text" => filter_text}, socket) do
    socket =
      socket
      |> reset_pagination()
      |> set_filter_text(filter_text)

    {:noreply, socket}
  end

  def handle_event("reset-filter-text", _params, socket) do
    socket =
      socket
      |> reset_pagination()
      |> set_filter_text("")

    {:noreply, socket}
  end

  defp loading(sites) do
    sites.entries
    |> Enum.into(%{}, fn site ->
      {site.domain, :loading}
    end)
  end

  defp load_sites(%{assigns: assigns} = socket) do
    sites =
      Sites.list_with_invitations(assigns.current_user, assigns.params,
        filter_by_domain: assigns.filter_text,
        team: assigns.current_team
      )

    hourly_stats =
      if connected?(socket) do
        try do
          Plausible.Stats.Clickhouse.last_24h_visitors_hourly_intervals(sites.entries)
        catch
          kind, value ->
            Logger.error(
              "Could not render 24h visitors hourly intervals: #{inspect(kind)} #{inspect(value)}"
            )

            loading(sites)
        end
      else
        loading(sites)
      end

    invitations = extract_invitations(sites.entries, assigns.current_team)

    assign(
      socket,
      sites: sites,
      invitations: invitations,
      hourly_stats: hourly_stats
    )
  end

  defp extract_invitations(sites, team) do
    sites
    |> Enum.filter(&(&1.entry_type == "invitation"))
    |> Enum.flat_map(& &1.invitations)
    |> Enum.map(&check_limits(&1, team))
  end

  on_ee do
    defp check_limits(%{role: :owner, site: site} = invitation, team) do
      case ensure_can_take_ownership(site, team) do
        :ok ->
          check_features(invitation, team)

        {:error, :no_plan} ->
          %{invitation: invitation, no_plan: true}

        {:error, {:over_plan_limits, limits}} ->
          limits = PlausibleWeb.TextHelpers.pretty_list(limits)
          %{invitation: invitation, exceeded_limits: limits}
      end
    end
  end

  defp check_limits(invitation, _), do: %{invitation: invitation}

  defdelegate ensure_can_take_ownership(site, team), to: Teams.Invitations

  def check_features(%{role: :owner, site: site} = invitation, team) do
    case check_feature_access(site, team) do
      :ok ->
        %{invitation: invitation}

      {:error, {:missing_features, features}} ->
        feature_names =
          features
          |> Enum.map(& &1.display_name())
          |> PlausibleWeb.TextHelpers.pretty_list()

        %{invitation: invitation, missing_features: feature_names}
    end
  end

  defp check_feature_access(site, new_team) do
    missing_features =
      Teams.Billing.features_usage(nil, [site.id])
      |> Enum.filter(&(&1.check_availability(new_team) != :ok))

    if missing_features == [] do
      :ok
    else
      {:error, {:missing_features, missing_features}}
    end
  end

  defp set_filter_text(socket, filter_text) do
    filter_text = String.trim(filter_text)
    uri = socket.assigns.uri

    uri_params =
      uri.query
      |> URI.decode_query()
      |> Map.put("filter_text", filter_text)
      |> URI.encode_query()

    uri = %{uri | query: uri_params}

    socket
    |> assign(:filter_text, filter_text)
    |> assign(:uri, uri)
    |> push_patch(to: URI.to_string(uri), replace: true)
  end

  defp reset_pagination(socket) do
    pagination_fields = ["page"]
    uri = socket.assigns.uri

    uri_params =
      uri.query
      |> URI.decode_query()
      |> Map.drop(pagination_fields)
      |> URI.encode_query()

    assign(socket,
      uri: %{uri | query: uri_params},
      params: Map.drop(socket.assigns.params, pagination_fields)
    )
  end

  defp hash_domain(domain) do
    :sha |> :crypto.hash(domain) |> Base.encode16()
  end
end
```

## File: `lib/plausible_web/live/team_management.ex`
```
defmodule PlausibleWeb.Live.TeamManagement do
  @moduledoc """
  Live view for enqueuing and applying team membership adjustments.
  """
  use PlausibleWeb, :live_view

  alias Plausible.Teams
  alias Plausible.Auth.User
  import PlausibleWeb.Live.Components.Team

  alias Plausible.Teams.Management.Layout

  def mount(_params, session, socket) do
    mode =
      if session["mode"] == "team-setup" do
        :team_setup
      else
        :team_management
      end

    {:ok, socket |> assign(mode: mode) |> reset()}
  end

  defp reset(%{assigns: %{current_user: current_user, current_team: current_team}} = socket) do
    {:ok, my_role} = Teams.Memberships.team_role(current_team, current_user)

    layout = Layout.init(current_team)
    team_members_limit = Plausible.Teams.Billing.team_member_limit(current_team)

    assign(socket,
      team_members_limit: team_members_limit,
      layout: layout,
      my_role: my_role,
      team_layout_changed?: false,
      input_role: :viewer,
      input_email: ""
    )
  end

  def render(assigns) do
    ~H"""
    <.flash_messages flash={@flash} />

    <PlausibleWeb.Components.Billing.Notice.limit_exceeded
      :if={@team_members_limit != 0 and at_limit?(@layout, @team_members_limit)}
      current_role={@current_team_role}
      current_team={@current_team}
      limit={@team_members_limit}
      resource="members"
      class="mb-4"
    />
    <div>
      <.form id="team-layout-form" for={} phx-submit="input-invitation" phx-change="form-changed">
        <div class="flex gap-x-3 mb-8">
          <div class="flex-1">
            <.input
              name="input-email"
              type="email"
              value={@input_email}
              placeholder="Enter e-mail"
              phx-debounce={200}
              readonly={at_limit?(@layout, @team_members_limit) or @my_role not in [:admin, :owner]}
              mt?={false}
            />
          </div>

          <.dropdown id="input-role-picker">
            <:button class="role border rounded border-indigo-700 bg-transparent text-gray-800 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700 focus-visible:outline-gray-100 whitespace-nowrap truncate inline-flex items-center gap-x-2 font-medium rounded-md px-3 py-2 text-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 disabled:bg-gray-400 dark:disabled:text-white dark:disabled:text-gray-400 dark:disabled:bg-gray-700">
              {@input_role |> Atom.to_string() |> String.capitalize()}
              <Heroicons.chevron_down mini class="size-4 mt-0.5" />
            </:button>
            <:menu class="dropdown-items max-w-60">
              <.role_item role={:owner} disabled={@my_role != :owner} phx-click="switch-role">
                Manage the team without restrictions
              </.role_item>
              <.role_item
                role={:admin}
                disabled={@my_role not in [:owner, :admin]}
                phx-click="switch-role"
              >
                Manage all team settings
              </.role_item>
              <.role_item
                role={:editor}
                disabled={@my_role not in [:owner, :admin]}
                phx-click="switch-role"
              >
                Create and view new sites
              </.role_item>
              <.role_item
                role={:billing}
                disabled={@my_role not in [:owner, :admin]}
                phx-click="switch-role"
              >
                Manage subscription
              </.role_item>
              <.role_item
                role={:viewer}
                disabled={@my_role not in [:owner, :admin]}
                phx-click="switch-role"
              >
                View all sites under your team
              </.role_item>
            </:menu>
          </.dropdown>

          <.button
            id="invite-member"
            type="submit"
            mt?={false}
            disabled={at_limit?(@layout, @team_members_limit) or @my_role not in [:admin, :owner]}
          >
            Invite
          </.button>
        </div>
      </.form>

      <div id="member-list">
        <.member
          :for={{email, entry} <- Layout.sorted_for_display(@layout)}
          :if={entry.role != :guest}
          user={%User{email: entry.email, name: entry.name}}
          role={entry.role}
          label={entry_label(entry, @current_user)}
          my_role={@my_role}
          remove_disabled={not Layout.removable?(@layout, email)}
          disabled={
            (entry.role == :owner && Layout.owners_count(@layout) == 1) or
              @my_role not in [:owner, :admin]
          }
        />
      </div>

      <div :if={Layout.has_guests?(@layout)} class="flex items-center mt-4 mb-4" id="guests-hr">
        <hr class="flex-grow border-t border-gray-200 dark:border-gray-600" />
        <span class="mx-4 text-gray-500 text-sm">
          Guests
        </span>
        <hr class="flex-grow border-t border-gray-200 dark:border-gray-600" />
      </div>

      <div :if={Layout.has_guests?(@layout)} id="guest-list">
        <.member
          :for={{email, entry} <- Layout.sorted_for_display(@layout)}
          :if={entry.role == :guest}
          user={%User{email: entry.email, name: entry.name}}
          role={entry.role}
          label={entry_label(entry, @current_user)}
          my_role={@my_role}
          remove_disabled={not Layout.removable?(@layout, email)}
          disabled={@my_role not in [:owner, :admin]}
        />
      </div>

      <.button
        :if={@mode == :team_setup}
        id="save-layout"
        type="submit"
        phx-click="save-team-layout"
        class="mt-8 w-full"
      >
        Create Team
      </.button>
    </div>
    """
  end

  @roles Plausible.Teams.Membership.roles() -- [:guest]
  @roles_cast_map Enum.into(@roles, %{}, fn role -> {to_string(role), role} end)

  def handle_event("form-changed", params, socket) do
    {:noreply, assign(socket, input_email: params["input-email"])}
  end

  def handle_event("switch-role", %{"role" => role}, socket) do
    socket = assign(socket, input_role: Map.fetch!(@roles_cast_map, role))
    {:noreply, socket}
  end

  def handle_event(
        "input-invitation",
        %{"input-email" => email},
        %{assigns: %{layout: layout, input_role: role}} = socket
      ) do
    email = String.trim(email)

    existing_entry = Map.get(layout, email)

    socket =
      cond do
        existing_entry && existing_entry.queued_op == :delete ->
          # bring back previously deleted entry (either invitation or membership), and only update role
          socket
          |> update_layout(Layout.update_role(layout, email, role))
          |> assign(input_email: "")

        existing_entry ->
          # trying to add e-mail that's already in the layout
          socket
          |> assign(input_email: email)
          |> put_live_flash(
            :error,
            "Make sure the e-mail is valid and is not taken already in your team layout"
          )

        valid_email?(email) ->
          socket
          |> update_layout(Layout.schedule_send(layout, email, role))
          |> assign(input_email: "")

        true ->
          socket
          |> assign(input_email: email)
          |> put_live_flash(
            :error,
            "Make sure the e-mail is valid and is not taken already in your team layout"
          )
      end

    {:noreply, socket}
  end

  def handle_event(
        "save-team-layout",
        _params,
        socket
      ) do
    socket = save_team_layout(socket)

    {:noreply, socket}
  end

  def handle_event("remove-member", %{"email" => email}, %{assigns: %{layout: layout}} = socket) do
    socket =
      case Layout.verify_removable(layout, email) do
        :ok ->
          update_layout(socket, Layout.schedule_delete(layout, email))

        {:error, message} ->
          socket
          |> put_live_flash(
            :error,
            message
          )
      end

    {:noreply, socket}
  end

  def handle_event(
        "update-role",
        %{"email" => email, "role" => role},
        %{assigns: %{layout: layout}} = socket
      ) do
    socket =
      update_layout(socket, Layout.update_role(layout, email, Map.fetch!(@roles_cast_map, role)))
      |> push_event("js-exec", %{
        to: "#member-row-#{:erlang.phash2(email)}",
        attr: "data-role-changed"
      })

    {:noreply, socket}
  end

  defp valid_email?(email) do
    String.contains?(email, "@") and String.contains?(email, ".")
  end

  defp update_layout(socket, layout) do
    socket =
      assign(socket,
        layout: layout,
        team_layout_changed?: true
      )

    if socket.assigns.mode == :team_management do
      save_team_layout(socket)
    else
      socket
    end
  end

  defp save_team_layout(
         %{assigns: %{layout: layout, current_team: current_team, current_user: current_user}} =
           socket
       ) do
    result =
      Layout.persist(layout, %{
        current_user: current_user,
        current_team: Plausible.Repo.reload!(current_team)
      })

    case {result, socket.assigns.mode} do
      {{:ok, _}, :team_setup} ->
        socket
        |> put_flash(:success, "Your team is now created")
        |> redirect(
          to: Routes.settings_path(socket, :team_general, __team: current_team.identifier)
        )

      {{:ok, _}, :team_management} ->
        reset(socket)

      {{:error, :permission_denied}, _} ->
        socket
        |> put_live_flash(
          :error,
          "Permission denied"
        )

      {{:error, :only_one_owner}, _} ->
        socket
        |> put_live_flash(
          :error,
          "The team has to have at least one owner"
        )

      {{:error, :disabled_2fa}, _} ->
        socket
        |> put_live_flash(
          :error,
          "User must have 2FA enabled to become an owner"
        )

      {{:error, {:over_limit, limit}}, _} ->
        socket
        |> put_live_flash(
          :error,
          "Your account is limited to #{limit} team members. You can upgrade your plan to increase this limit"
        )
    end
  end

  defp entry_label(%Layout.Entry{role: :guest, type: :membership}, _), do: nil
  defp entry_label(%Layout.Entry{type: :invitation_pending}, _), do: "Invitation Pending"
  defp entry_label(%Layout.Entry{type: :invitation_sent}, _), do: "Invitation Sent"

  defp entry_label(%Layout.Entry{meta: %{user: %{id: id, type: :sso}}}, %{id: id}),
    do: "You (SSO)"

  defp entry_label(%Layout.Entry{meta: %{user: %{id: id}}}, %{id: id}), do: "You"
  defp entry_label(%Layout.Entry{meta: %{user: %{type: :sso}}}, _), do: "SSO Member"
  defp entry_label(_, _), do: "Team Member"

  def at_limit?(layout, limit) do
    not Plausible.Billing.Quota.below_limit?(
      Layout.active_count(layout) - 1,
      limit
    )
  end
end
```

## File: `lib/plausible_web/live/team_setup.ex`
```
defmodule PlausibleWeb.Live.TeamSetup do
  @moduledoc """
  LiveView for Team setup
  """

  use PlausibleWeb, :live_view

  alias Plausible.Repo
  alias Plausible.Teams
  alias Plausible.Teams.Management.Layout
  alias PlausibleWeb.Router.Helpers, as: Routes

  def mount(_params, _session, socket) do
    current_user = socket.assigns.current_user
    current_team = socket.assigns.current_team

    socket =
      case current_team do
        %Teams.Team{setup_complete: true} ->
          socket
          |> put_flash(:success, "Your team is now created")
          |> redirect(to: Routes.settings_path(socket, :team_general))

        %Teams.Team{} ->
          team_name_form =
            current_team
            |> Teams.Team.name_changeset(%{name: "#{current_user.name}'s Team"})
            |> Repo.update!()
            |> Teams.Team.name_changeset(%{})
            |> to_form()

          layout = Layout.init(current_team)

          assign(socket,
            team_name_form: team_name_form,
            team_layout: layout,
            current_team: current_team
          )

        _ ->
          socket
          |> put_flash(:error, "You cannot create any team just yet")
          |> redirect(to: Routes.site_path(socket, :index))
      end

    socket =
      if current_team do
        {:ok, my_role} = Teams.Memberships.team_role(current_team, current_user)
        assign(socket, my_role: my_role)
      else
        socket
      end

    {:ok, socket}
  end

  def render(assigns) do
    assigns = assign(assigns, :locked?, Plausible.Teams.Billing.solo?(assigns.current_team))

    ~H"""
    <.focus_box padding?={false}>
      <:title>
        <div class="pt-8 px-8 flex justify-between">
          <div>Create a new team</div>
          <div class="ml-auto">
            <.docs_info slug="users-roles" />
          </div>
        </div>
      </:title>
      <:subtitle>
        <p class="px-8">
          Name your team, add team members and assign roles. When ready, click "Create Team" to send invitations
        </p>
      </:subtitle>

      <div class="relative -mt-8 pt-4 pb-8 px-8">
        <PlausibleWeb.Components.Billing.feature_gate
          current_role={@current_team_role}
          current_team={@current_team}
          locked?={@locked?}
        >
          <.form
            :let={f}
            for={@team_name_form}
            method="post"
            phx-change="update-team"
            phx-blur="update-team"
            id="update-team-form"
            class="mt-4 mb-8"
          >
            <.input
              type="text"
              placeholder={"#{@current_user.name}'s Team"}
              autofocus={not @locked?}
              field={f[:name]}
              label="Name"
              width="w-full"
              phx-debounce="500"
            />
          </.form>

          <.label class="mb-2">
            Team Members
          </.label>
          {live_render(@socket, PlausibleWeb.Live.TeamManagement,
            id: "team-management-setup",
            container: {:div, id: "team-setup"},
            session: %{
              "mode" => "team-setup"
            }
          )}
        </PlausibleWeb.Components.Billing.feature_gate>
      </div>
    </.focus_box>
    """
  end

  def handle_event("update-team", %{"team" => %{"name" => name}}, socket) do
    changeset = Teams.Team.name_changeset(socket.assigns.current_team, %{name: name})

    socket =
      case Repo.update(changeset) do
        {:ok, team} ->
          assign(socket, team_name_form: to_form(changeset), current_team: team)

        {:error, changeset} ->
          assign(socket, team_name_form: to_form(changeset))
      end

    {:noreply, socket}
  end
end
```

## File: `lib/plausible_web/live/verification.ex`
```
defmodule PlausibleWeb.Live.Verification do
  @moduledoc """
  LiveView coordinating the site verification process.
  Onboarding new sites, renders a standalone component.
  Embedded modal variant is available for general site settings.
  """
  use Plausible
  use PlausibleWeb, :live_view

  alias Plausible.InstallationSupport.{State, LegacyVerification, Verification}

  @component PlausibleWeb.Live.Components.Verification
  @slowdown_for_frequent_checking :timer.seconds(5)

  def mount(
        %{"domain" => domain} = params,
        _session,
        socket
      ) do
    site =
      Plausible.Sites.get_for_user!(socket.assigns.current_user, domain, [
        :owner,
        :admin,
        :editor,
        :super_admin,
        :viewer
      ])

    private = Map.get(socket.private.connect_info, :private, %{})

    super_admin? = Plausible.Auth.is_super_admin?(socket.assigns.current_user)
    has_pageviews? = has_pageviews?(site)

    socket =
      assign(socket,
        site: site,
        super_admin?: super_admin?,
        domain: domain,
        has_pageviews?: has_pageviews?,
        component: @component,
        installation_type: params["installation_type"],
        report_to: self(),
        delay: private[:delay] || 500,
        slowdown: private[:slowdown] || 500,
        flow: params["flow"] || "",
        checks_pid: nil,
        attempts: 0
      )

    on_ee do
      if connected?(socket) do
        launch_delayed(socket)
      end
    end

    on_ee do
      {:ok, socket}
    else
      # on CE we skip the verification process and instead,
      # we just wait for the first pageview to be recorded
      socket =
        if has_pageviews? do
          redirect_to_stats(socket)
        else
          schedule_pageviews_check(socket)
        end

      {:ok, socket}
    end
  end

  on_ee do
    def render(assigns) do
      ~H"""
      <PlausibleWeb.Components.FlowProgress.render flow={@flow} current_step="Verify installation" />

      <.live_component
        module={@component}
        installation_type={@installation_type}
        domain={@domain}
        id="verification-standalone"
        attempts={@attempts}
        flow={@flow}
        awaiting_first_pageview?={not @has_pageviews?}
        super_admin?={@super_admin?}
      />
      """
    end
  else
    def render(assigns) do
      ~H"""
      <PlausibleWeb.Components.FlowProgress.render flow={@flow} current_step="Verify installation" />
      <.awaiting_pageviews />
      """
    end
  end

  on_ce do
    defp awaiting_pageviews(assigns) do
      ~H"""
      <.focus_box>
        <div class="flex items-center">
          <div class="block pulsating-circle"></div>
          <p class="ml-8">Awaiting your first pageview …</p>
        </div>
      </.focus_box>
      """
    end
  end

  def handle_event("launch-verification", _, socket) do
    launch_delayed(socket)
    {:noreply, reset_component(socket)}
  end

  def handle_event("retry", _, socket) do
    launch_delayed(socket)
    {:noreply, reset_component(socket)}
  end

  def handle_info({:start, report_to}, socket) do
    if is_pid(socket.assigns.checks_pid) and Process.alive?(socket.assigns.checks_pid) do
      {:noreply, socket}
    else
      case Plausible.RateLimit.check_rate(
             "site_verification_#{socket.assigns.domain}",
             :timer.minutes(60),
             3
           ) do
        {:allow, _} -> :ok
        {:deny, _} -> :timer.sleep(@slowdown_for_frequent_checking)
      end

      url_to_verify = "https://#{socket.assigns.domain}"
      domain = socket.assigns.domain
      installation_type = socket.assigns.installation_type

      {:ok, pid} =
        if(FunWithFlags.enabled?(:scriptv2, for: socket.assigns.site),
          do:
            Verification.Checks.run(url_to_verify, domain, installation_type,
              report_to: report_to,
              slowdown: socket.assigns.slowdown
            ),
          else:
            LegacyVerification.Checks.run(
              url_to_verify,
              domain,
              report_to: report_to,
              slowdown: socket.assigns.slowdown
            )
        )

      {:noreply, assign(socket, checks_pid: pid, attempts: socket.assigns.attempts + 1)}
    end
  end

  def handle_info({:check_start, {check, _state}}, socket) do
    update_component(socket,
      message: check.report_progress_as()
    )

    {:noreply, socket}
  end

  def handle_info({:all_checks_done, %State{} = state}, socket) do
    interpretation =
      if(FunWithFlags.enabled?(:scriptv2, for: socket.assigns.site),
        do: Verification.Checks.interpret_diagnostics(state),
        else: LegacyVerification.Checks.interpret_diagnostics(state)
      )

    if not socket.assigns.has_pageviews? do
      schedule_pageviews_check(socket)
    end

    update_component(socket,
      finished?: true,
      success?: interpretation.ok?,
      interpretation: interpretation,
      verification_state: state
    )

    {:noreply, assign(socket, checks_pid: nil)}
  end

  def handle_info(:check_pageviews, socket) do
    socket =
      if has_pageviews?(socket.assigns.site) do
        redirect_to_stats(socket)
      else
        schedule_pageviews_check(socket)
      end

    {:noreply, socket}
  end

  defp schedule_pageviews_check(socket) do
    Process.send_after(self(), :check_pageviews, socket.assigns.delay * 2)
    socket
  end

  defp redirect_to_stats(socket) do
    stats_url = Routes.stats_path(PlausibleWeb.Endpoint, :stats, socket.assigns.domain, [])
    redirect(socket, to: stats_url)
  end

  defp reset_component(socket) do
    update_component(socket,
      message: "We're visiting your site to ensure that everything is working",
      finished?: false,
      success?: false,
      diagnostics: nil
    )

    socket
  end

  defp update_component(_socket, updates) do
    send_update(
      @component,
      Keyword.merge(updates, id: "verification-standalone")
    )
  end

  defp launch_delayed(socket) do
    Process.send_after(self(), {:start, socket.assigns.report_to}, socket.assigns.delay)
  end

  defp has_pageviews?(site) do
    Plausible.Stats.Clickhouse.has_pageviews?(site)
  end
end
```

## File: `lib/plausible_web/login_preference.ex`
```
defmodule PlausibleWeb.LoginPreference do
  @moduledoc """
  Functions for managing user login preference cookies.

  This module handles storing and retrieving the user's preferred login method
  (standard or SSO) to provide a better user experience by showing their
  preferred option first.
  """

  @cookie_name "login_preference"
  @cookie_max_age 60 * 60 * 24 * 365

  @spec set_sso(Plug.Conn.t()) :: Plug.Conn.t()
  def set_sso(conn) do
    secure_cookie = PlausibleWeb.Endpoint.secure_cookie?()

    Plug.Conn.put_resp_cookie(conn, @cookie_name, "sso",
      http_only: true,
      secure: secure_cookie,
      max_age: @cookie_max_age,
      same_site: "Lax"
    )
  end

  @spec clear(Plug.Conn.t()) :: Plug.Conn.t()
  def clear(conn) do
    Plug.Conn.delete_resp_cookie(conn, @cookie_name)
  end

  @spec get(Plug.Conn.t()) :: String.t() | nil
  def get(conn) do
    case Plug.Conn.fetch_cookies(conn) do
      %{cookies: %{@cookie_name => "sso"}} ->
        "sso"

      _ ->
        nil
    end
  end
end
```

## File: `lib/plausible_web/mjml/stats_report.ex`
```
defmodule PlausibleWeb.MJML.StatsReport do
  @moduledoc """
  MJML rendered for the weekly or monthly report e-mail
  """

  use MjmlEEx, mjml_template: "templates/stats_report.mjml.eex"
end
```

## File: `lib/plausible_web/mjml/templates/stats_report.mjml.eex`
```
<% use Plausible %>
<mjml>
  <mj-head>
    <mj-attributes>
      <mj-text
        color="#3d4852"
        font-family="'Helvetica Neue', Helvetica, Arial, sans-serif"
        font-size="14px"
      />
      <mj-button
        background-color="#4338ca"
        font-family="'Helvetica Neue', Helvetica, Arial, sans-serif"
        color="#ffffff"
        font-size="14px"
      />
      <mj-class name="text-lg" font-size="24px" font-weight="bold" />
      <mj-class name="text-sm" font-size="14px" font-weight="normal" />
      <mj-class name="text-label" font-size="14px" font-weight="bold" color="#666666" />
      <mj-class name="trend-good" font-size="14px" font-weight="bold" color="#15803d" />
      <mj-class name="trend-bad" font-size="14px" font-weight="bold" color="#b91c1c" />
      <mj-column vertical-align="middle" />
      <mj-divider border-width="1px" border-color="#aaaaaa" />
    </mj-attributes>
  </mj-head>
  <mj-body>
    <mj-section padding="25px 0 0 0">
      <mj-column>
        <%= if ee?() do %>
        <mj-text mj-class="text-sm" height="40px">
          <%= Plausible.product_name() %>
        </mj-text>
        <% else %>
        <mj-text mj-class="text-sm">
          <%= Plausible.product_name() %>
        </mj-text>
        <mj-divider />
        <mj-text mj-class="text-sm" line-height="1.5">
        Plausible CE is funded by our cloud subscribers. If you <a href="https://plausible.io/?utm_medium=email&utm_source=CE">enjoy using Plausible</a>
        and know someone who might benefit from it, please spread the word.
        </mj-text>
        <mj-divider />
        <% end %>
        <mj-text mj-class="text-lg">
          <%= @site.domain %>
        </mj-text>
        <mj-text mj-class="text-sm" padding="0 25px 0 25px">
          <%= @name %> Report (<%= @date %>)
        </mj-text>
      </mj-column>
    </mj-section>

    <mj-section>
      <mj-column>
        <mj-divider />
      </mj-column>
    </mj-section>

    <mj-section padding="0">
      <mj-column>
        <mj-text mj-class="text-label">UNIQUE VISITORS</mj-text>
        <mj-text mj-class="text-lg" css-class="visitors">
          <%= PlausibleWeb.StatsView.large_number_format(@stats.visitors.value) %>
        </mj-text>
        <%= cond do %>
          <% @stats.visitors.change == nil -> %>
            <mj-text css-class="change-visitors" mj-class="text-sm">N/A</mj-text>
          <% @stats.visitors.change >= 0 -> %>
            <mj-text css-class="change-visitors" mj-class="text-sm trend-good">
              <%= "#{if @stats.visitors.change != 0, do: "+"}#{@stats.visitors.change}%" %>
            </mj-text>
          <% @stats.visitors.change < 0 -> %>
            <mj-text css-class="change-visitors" mj-class="text-sm trend-bad">
              <%= @stats.visitors.change %>%
            </mj-text>
        <% end %>
        <mj-spacer height="30px" />
      </mj-column>
      <mj-column>
        <mj-text mj-class="text-label">PAGEVIEWS</mj-text>
        <mj-text mj-class="text-lg" css-class="pageviews">
          <%= PlausibleWeb.StatsView.large_number_format(@stats.pageviews.value) %>
        </mj-text>
        <%= cond do %>
          <% is_nil(@stats.pageviews.change) -> %>
            <mj-text css-class="change-pageviews" mj-class="text-sm">N/A</mj-text>
          <% @stats.pageviews.change >= 0 -> %>
            <mj-text css-class="change-pageviews" mj-class="text-sm trend-good">
              <%= "#{if @stats.pageviews.change != 0, do: "+"}#{@stats.pageviews.change}%" %>
            </mj-text>
          <% @stats.pageviews.change < 0 -> %>
            <mj-text css-class="change-pageviews" mj-class="text-sm trend-bad">
              <%= @stats.pageviews.change %>%
            </mj-text>
        <% end %>
        <mj-spacer height="30px" />
      </mj-column>

      <mj-column>
        <mj-text mj-class="text-label">BOUNCE RATE</mj-text>
        <mj-text mj-class="text-lg">
          <%= @stats.bounce_rate.value %>
        </mj-text>

        <%= cond do %>
          <% @stats.bounce_rate.change == nil -> %>
            <mj-text css-class="change-bounce-rate" mj-class="text-sm">N/A</mj-text>
          <% @stats.bounce_rate.change <= 0 -> %>
            <mj-text css-class="change-bounce-rate" mj-class="text-sm trend-good">
              <%= @stats.bounce_rate.change %>%
            </mj-text>
          <% @stats.bounce_rate.change > 0 -> %>
            <mj-text css-class="change-bounce-rate" mj-class="text-sm trend-bad">
              +<%= @stats.bounce_rate.change %>%
            </mj-text>
        <% end %>
        <mj-spacer height="30px" />
      </mj-column>
    </mj-section>

    <mj-section padding="0">
      <mj-column>
        <mj-divider />
      </mj-column>
    </mj-section>

    <mj-section>
      <mj-group>
        <mj-column>
          <mj-text font-weight="bold">Referrer</mj-text>

          <%= for source <- @stats.sources do %>
            <mj-text css-class="referrer-name">
              <%= source[:source] %>
            </mj-text>
          <% end %>
        </mj-column>
        <mj-column>
          <mj-text font-weight="bold" align="right">Visitors</mj-text>

          <%= for source <- @stats.sources do %>
            <mj-text align="right" css-class="referrer-count">
              <%= PlausibleWeb.StatsView.large_number_format(source[:visitors]) %>
            </mj-text>
          <% end %>
        </mj-column>
      </mj-group>
    </mj-section>

    <mj-section padding="0">
      <mj-column>
        <mj-divider />
      </mj-column>
    </mj-section>

    <mj-section>
      <mj-group>
        <mj-column>
          <mj-text font-weight="bold">
            Page
          </mj-text>

          <%= for page <- @stats.pages do %>
            <mj-text css-class="page-name">
              <%= page[:page] %>
            </mj-text>
          <% end %>
        </mj-column>
        <mj-column>
          <mj-text font-weight="bold" align="right">
            Visitors
          </mj-text>

          <%= for page <- @stats.pages do %>
            <mj-text align="right" css-class="page-count">
              <%= PlausibleWeb.StatsView.large_number_format(page[:visitors]) %>
            </mj-text>
          <% end %>
        </mj-column>
      </mj-group>
    </mj-section>

    <%= if @login_link do %>
      <mj-section>
        <mj-column>
        <mj-button href="<%= PlausibleWeb.Router.Helpers.auth_url(PlausibleWeb.Endpoint, :login_form) %>">
            Login to view your dashboard
          </mj-button>
        </mj-column>
      </mj-section>
    <% end %>

    <mj-section>
      <mj-column>
        <mj-divider />
      </mj-column>
    </mj-section>
    <mj-section padding="0">
      <mj-column>
        <mj-text mj-class="text-sm" padding="0 25px 25px 25px">
        Don't want to receive these e-mails? <a href="<%= @unsubscribe_link %>">Click here</a>
          to unsubscribe.
        </mj-text>
      </mj-column>
    </mj-section>
  </mj-body>
</mjml>
```

## File: `lib/plausible_web/plugins/api/controllers/capabilities.ex`
```
defmodule PlausibleWeb.Plugins.API.Controllers.Capabilities do
  @moduledoc """
  Controller for Plugins API Capabilities - doesn't enforce authentication,
  serves as a comprehensive health check
  """
  use PlausibleWeb, :plugins_api_controller

  operation(:index,
    summary: "Retrieve Capabilities",
    parameters: [],
    responses: %{
      ok: {"Capabilities response", "application/json", Schemas.Capabilities}
    }
  )

  @spec index(Plug.Conn.t(), %{}) :: Plug.Conn.t()
  def index(conn, _params) do
    {:ok, capabilities} = API.Capabilities.get(conn)

    conn
    |> put_view(Views.Capabilities)
    |> render("index.json", capabilities: capabilities)
  end
end
```

## File: `lib/plausible_web/plugins/api/controllers/custom_props.ex`
```
defmodule PlausibleWeb.Plugins.API.Controllers.CustomProps do
  @moduledoc """
  Controller for the CustomProp resource under Plugins API
  """
  use PlausibleWeb, :plugins_api_controller

  operation(:enable,
    id: "CustomProp.GetOrEnable",
    summary: "Get or enable CustomProp(s)",
    request_body:
      {"CustomProp enable params", "application/json", Schemas.CustomProp.EnableRequest},
    responses: %{
      created: {"CustomProp", "application/json", Schemas.CustomProp.ListResponse},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized},
      payment_required: {"Payment required", "application/json", Schemas.PaymentRequired},
      unprocessable_entity:
        {"Unprocessable entity", "application/json", Schemas.UnprocessableEntity}
    }
  )

  @spec enable(Plug.Conn.t(), map()) :: Plug.Conn.t()
  def enable(
        %{private: %{open_api_spex: %{body_params: body_params}}} = conn,
        _params
      ) do
    site = conn.assigns.authorized_site

    prop_or_props =
      case body_params do
        %{custom_props: props} ->
          Enum.map(props, & &1.custom_prop.key)

        %{custom_prop: %{key: prop}} ->
          prop
      end

    case API.CustomProps.enable(site, prop_or_props) do
      {:ok, enabled_props} ->
        conn
        |> put_view(Views.CustomProp)
        |> put_status(:created)
        |> render("index.json", props: enabled_props, authorized_site: site)

      {:error, :upgrade_required} ->
        payment_required(conn)

      {:error, changeset} ->
        Errors.error(conn, 422, changeset)
    end
  end

  operation(:disable,
    id: "CustomProp.DisableBulk",
    summary: "Disable CustomProp(s)",
    request_body:
      {"CustomProp disable params", "application/json", Schemas.CustomProp.DisableRequest},
    responses: %{
      no_content: {"NoContent", nil, nil},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized},
      payment_required: {"Payment required", "application/json", Schemas.PaymentRequired},
      unprocessable_entity:
        {"Unprocessable entity", "application/json", Schemas.UnprocessableEntity}
    }
  )

  @spec disable(Plug.Conn.t(), map()) :: Plug.Conn.t()
  def disable(
        %{private: %{open_api_spex: %{body_params: body_params}}} = conn,
        _params
      ) do
    site = conn.assigns.authorized_site

    prop_or_props =
      case body_params do
        %{custom_props: props} ->
          Enum.map(props, & &1.custom_prop.key)

        %{custom_prop: %{key: prop}} ->
          prop
      end

    case API.CustomProps.disable(site, prop_or_props) do
      :ok ->
        send_resp(conn, :no_content, "")

      {:error, changeset} ->
        Errors.error(conn, 422, changeset)
    end
  end

  defp payment_required(conn) do
    Errors.error(
      conn,
      402,
      "#{Plausible.Billing.Feature.Props.display_name()} is part of the Plausible Business plan. To get access to this feature, please upgrade your account."
    )
  end
end
```

## File: `lib/plausible_web/plugins/api/controllers/goals.ex`
```
defmodule PlausibleWeb.Plugins.API.Controllers.Goals do
  @moduledoc """
  Controller for the Goal resource under Plugins API
  """
  use PlausibleWeb, :plugins_api_controller

  operation(:create,
    id: "Goal.GetOrCreate",
    summary: "Get or create Goal",
    request_body: {"Goal params", "application/json", Schemas.Goal.CreateRequest},
    responses: %{
      created: {"Goal", "application/json", Schemas.Goal.ListResponse},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized},
      payment_required: {"Payment required", "application/json", Schemas.PaymentRequired},
      unprocessable_entity:
        {"Unprocessable entity", "application/json", Schemas.UnprocessableEntity}
    }
  )

  def create(
        %{private: %{open_api_spex: %{body_params: body_params}}} = conn,
        _params
      ) do
    site = conn.assigns.authorized_site

    goal_or_goals =
      case body_params do
        %{goals: goals} -> goals
        %{goal: _} = single_goal -> single_goal
      end

    case API.Goals.create(site, goal_or_goals) do
      {:ok, goals} ->
        location_headers =
          Enum.map(goals, &{"location", plugins_api_goals_url(conn, :get, &1.id)})

        conn
        |> prepend_resp_headers(location_headers)
        |> put_view(Views.Goal)
        |> put_status(:created)
        |> render("index.json", goals: goals, authorized_site: site)

      {:error, :upgrade_required} ->
        payment_required(conn)

      {:error, changeset} ->
        Errors.error(conn, 422, changeset)
    end
  end

  operation(:index,
    summary: "Retrieve Goals",
    parameters: [
      limit: [in: :query, type: :integer, description: "Maximum entries per page", example: 10],
      after: [
        in: :query,
        type: :string,
        description: "Cursor value to seek after - generated internally"
      ],
      before: [
        in: :query,
        type: :string,
        description: "Cursor value to seek before - generated internally"
      ]
    ],
    responses: %{
      ok: {"Goals response", "application/json", Schemas.Goal.ListResponse},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized}
    }
  )

  @spec index(Plug.Conn.t(), %{}) :: Plug.Conn.t()
  def index(conn, _params) do
    {:ok, pagination} = API.Goals.get_goals(conn.assigns.authorized_site, conn.query_params)

    conn
    |> put_view(Views.Goal)
    |> render("index.json", %{pagination: pagination})
  end

  operation(:get,
    summary: "Retrieve Goal by ID",
    parameters: [
      id: [
        in: :path,
        type: :integer,
        description: "Goal ID",
        example: 123,
        required: true
      ]
    ],
    responses: %{
      ok: {"Goal", "application/json", Schemas.Goal},
      not_found: {"NotFound", "application/json", Schemas.NotFound},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized},
      unprocessable_entity:
        {"Unprocessable entity", "application/json", Schemas.UnprocessableEntity}
    }
  )

  @spec get(Plug.Conn.t(), map()) :: Plug.Conn.t()
  def get(%{private: %{open_api_spex: %{params: %{id: id}}}} = conn, _params) do
    site = conn.assigns.authorized_site

    case API.Goals.get(site, id) do
      nil ->
        conn
        |> put_view(Views.Error)
        |> put_status(:not_found)
        |> render("404.json")

      goal ->
        conn
        |> put_view(Views.Goal)
        |> put_status(:ok)
        |> render("goal.json", goal: goal, authorized_site: site)
    end
  end

  operation(:delete,
    summary: "Delete Goal by ID",
    parameters: [
      id: [
        in: :path,
        type: :integer,
        description: "Goal ID",
        example: 123,
        required: true
      ]
    ],
    responses: %{
      no_content: {"NoContent", nil, nil},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized}
    }
  )

  @spec delete(Plug.Conn.t(), map()) :: Plug.Conn.t()
  def delete(%{private: %{open_api_spex: %{params: %{id: id}}}} = conn, _params) do
    :ok = API.Goals.delete(conn.assigns.authorized_site, id)
    send_resp(conn, :no_content, "")
  end

  operation(:delete_bulk,
    id: "Goal.DeleteBulk",
    summary: "Delete Goals in bulk",
    request_body: {"Goal params", "application/json", Schemas.Goal.DeleteBulkRequest},
    responses: %{
      no_content: {"NoContent", nil, nil},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized}
    }
  )

  @spec delete_bulk(Plug.Conn.t(), map()) :: Plug.Conn.t()
  def delete_bulk(
        %{private: %{open_api_spex: %{body_params: %{goal_ids: goal_ids}}}} = conn,
        _params
      ) do
    :ok = API.Goals.delete(conn.assigns.authorized_site, goal_ids)
    send_resp(conn, :no_content, "")
  end

  defp payment_required(conn) do
    Errors.error(
      conn,
      402,
      "#{Plausible.Billing.Feature.RevenueGoals.display_name()} is part of the Plausible Business plan. To get access to this feature, please upgrade your account."
    )
  end
end
```

## File: `lib/plausible_web/plugins/api/controllers/shared_links.ex`
```
defmodule PlausibleWeb.Plugins.API.Controllers.SharedLinks do
  @moduledoc """
  Controller for the Shared Link resource under Plugins API
  """
  use PlausibleWeb, :plugins_api_controller

  operation(:index,
    summary: "Retrieve Shared Links",
    parameters: [
      limit: [in: :query, type: :integer, description: "Maximum entries per page", example: 10],
      after: [
        in: :query,
        type: :string,
        description: "Cursor value to seek after - generated internally"
      ],
      before: [
        in: :query,
        type: :string,
        description: "Cursor value to seek before - generated internally"
      ]
    ],
    responses: %{
      ok: {"Shared Links response", "application/json", Schemas.SharedLink.ListResponse},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized}
    }
  )

  @spec index(Plug.Conn.t(), %{}) :: Plug.Conn.t()
  def index(conn, _params) do
    {:ok, pagination} =
      API.SharedLinks.get_shared_links(conn.assigns.authorized_site, conn.query_params)

    conn
    |> put_view(Views.SharedLink)
    |> render("index.json", %{pagination: pagination})
  end

  operation(:create,
    summary: "Get or create Shared Link",
    request_body: {"Shared Link params", "application/json", Schemas.SharedLink.CreateRequest},
    responses: %{
      created: {"Shared Link", "application/json", Schemas.SharedLink},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized},
      unprocessable_entity:
        {"Unprocessable entity", "application/json", Schemas.UnprocessableEntity}
    }
  )

  @spec create(Plug.Conn.t(), map()) :: Plug.Conn.t()
  def create(
        %{
          private: %{
            open_api_spex: %{
              body_params: %Schemas.SharedLink.CreateRequest{
                shared_link: %{name: name} = shared_link
              }
            }
          }
        } = conn,
        _params
      ) do
    site = conn.assigns.authorized_site

    {:ok, shared_link} = API.SharedLinks.get_or_create(site, name, shared_link[:password])

    conn
    |> put_view(Views.SharedLink)
    |> put_status(:created)
    |> put_resp_header("location", plugins_api_shared_links_url(conn, :get, shared_link.id))
    |> render("shared_link.json", shared_link: shared_link, authorized_site: site)
  end

  operation(:get,
    summary: "Retrieve Shared Link by ID",
    parameters: [
      id: [
        in: :path,
        type: :integer,
        description: "Shared Link ID",
        example: 123,
        required: true
      ]
    ],
    responses: %{
      created: {"Shared Link", "application/json", Schemas.SharedLink},
      not_found: {"NotFound", "application/json", Schemas.NotFound},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized},
      unprocessable_entity:
        {"Unprocessable entity", "application/json", Schemas.UnprocessableEntity}
    }
  )

  @spec get(Plug.Conn.t(), map()) :: Plug.Conn.t()
  def get(%{private: %{open_api_spex: %{params: %{id: id}}}} = conn, _params) do
    site = conn.assigns.authorized_site

    case API.SharedLinks.get(site, id) do
      nil ->
        conn
        |> put_view(Views.Error)
        |> put_status(:not_found)
        |> render("404.json")

      shared_link ->
        conn
        |> put_view(Views.SharedLink)
        |> put_status(:ok)
        |> render("shared_link.json", shared_link: shared_link, authorized_site: site)
    end
  end
end
```

## File: `lib/plausible_web/plugins/api/controllers/tracker_script_configuration.ex`
```
defmodule PlausibleWeb.Plugins.API.Controllers.TrackerScriptConfiguration do
  @moduledoc """
  Controller for the Tracker Script Configuration resource under Plugins API
  """
  use PlausibleWeb, :plugins_api_controller

  operation(:get,
    summary: "Retrieve Tracker Script Configuration",
    parameters: [],
    responses: %{
      ok:
        {"Tracker Script Configuration response", "application/json",
         Schemas.TrackerScriptConfiguration},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized}
    }
  )

  @spec get(Plug.Conn.t(), %{}) :: Plug.Conn.t()
  def get(conn, _params) do
    site = conn.assigns.authorized_site
    configuration = PlausibleWeb.Tracker.get_or_create_tracker_script_configuration!(site)

    conn
    |> put_view(Views.TrackerScriptConfiguration)
    |> render("tracker_script_configuration.json", tracker_script_configuration: configuration)
  end

  operation(:update,
    summary: "Update Tracker Script Configuration",
    request_body:
      {"Tracker Script Configuration params", "application/json",
       Schemas.TrackerScriptConfiguration.UpdateRequest},
    responses: %{
      ok:
        {"Tracker Script Configuration", "application/json", Schemas.TrackerScriptConfiguration},
      unauthorized: {"Unauthorized", "application/json", Schemas.Unauthorized}
    }
  )

  @spec update(Plug.Conn.t(), map()) :: Plug.Conn.t()
  def update(conn, %{"tracker_script_configuration" => update_params}) do
    site = conn.assigns.authorized_site

    update_params = Map.put(update_params, "site_id", site.id)

    updated_config =
      PlausibleWeb.Tracker.update_script_configuration(site, update_params, :plugins_api)

    conn
    |> put_view(Views.TrackerScriptConfiguration)
    |> render("tracker_script_configuration.json", tracker_script_configuration: updated_config)
  end
end
```

## File: `lib/plausible_web/plugins/api/errors.ex`
```
defmodule PlausibleWeb.Plugins.API.Errors do
  @moduledoc """
  Common responses for Plugins API
  """

  import Plug.Conn
  import Plausible.ChangesetHelpers

  @spec unauthorized(Plug.Conn.t()) :: Plug.Conn.t()
  def unauthorized(conn) do
    conn
    |> put_resp_header("www-authenticate", ~s[Basic realm="Plugins API Access"])
    |> error(:unauthorized, "Plugins API: unauthorized")
  end

  @spec error(
          Plug.Conn.t(),
          Plug.Conn.status(),
          String.t() | [String.t()] | Ecto.Changeset.t() | [Ecto.Changeset.t()]
        ) ::
          Plug.Conn.t()
  def error(conn, status, message) when is_binary(message) do
    error(conn, status, [message])
  end

  def error(conn, status, message) when is_map(message) do
    error(conn, status, [message])
  end

  def error(conn, status, messages) when is_list(messages) do
    response =
      Jason.encode!(%{
        errors:
          Enum.map(messages, fn
            message when is_binary(message) ->
              %{detail: message}

            %Ecto.Changeset{} = changeset ->
              changeset
              |> traverse_errors()
              |> Enum.map(fn {key, message} ->
                %{detail: "#{key}: #{message}"}
              end)
          end)
          |> List.flatten()
      })

    conn
    |> put_resp_content_type("application/json")
    |> send_resp(status, response)
    |> halt()
  end
end
```

## File: `lib/plausible_web/plugins/api/schemas/capabilities.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Capabilities do
  @moduledoc """
  OpenAPI schema for Capabilities
  """
  use PlausibleWeb, :open_api_schema
  require Plausible.Billing.Feature

  @features Plausible.Billing.Feature.list_short_names()
  @features_schema Enum.reduce(@features, %{}, fn feature, acc ->
                     Map.put(acc, feature, %Schema{type: :boolean})
                   end)

  OpenApiSpex.schema(%{
    title: "Capabilities",
    description: "Capabilities object",
    type: :object,
    required: [:authorized, :data_domain, :features],
    properties: %{
      authorized: %Schema{type: :boolean},
      data_domain: %Schema{type: :string, nullable: true},
      features: %Schema{
        type: :object,
        required: @features,
        properties: @features_schema
      }
    },
    example: %{
      authorized: true,
      data_domain: "example.com",
      features: %{
        Funnels: false,
        Goals: true,
        Props: false,
        RevenueGoals: false,
        StatsAPI: false,
        SitesAPI: false,
        SiteSegments: false,
        Teams: false,
        SharedLinks: false,
        SSO: false
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/custom_prop.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.CustomProp do
  @moduledoc """
  OpenAPI schema for Goal
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "CustomProp",
    description: "Custom Property object",
    type: :object,
    required: [:custom_prop],
    properties: %{
      custom_prop: %Schema{
        type: :object,
        required: [:key],
        properties: %{
          key: %Schema{type: :string, description: "Custom Property Key"}
        }
      }
    },
    example: %{
      custom_prop: %{
        key: "author"
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/custom_prop/disable_request.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.CustomProp.DisableRequest do
  @moduledoc """
  OpenAPI schema for Custom Property disable request
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "CustomProp.DisableRequest",
    description: "Custom Property disable params",
    type: :object,
    oneOf: [
      %Schema{
        title: "CustomProp.DisableRequest.BulkDisable",
        type: :object,
        description: "Bulk Custom Property disable request",
        required: [:custom_props],
        properties: %{
          custom_props: %Schema{
            type: :array,
            minItems: 1,
            items: Schemas.CustomProp
          }
        }
      },
      Schemas.CustomProp
    ],
    example: %{custom_props: [%{custom_prop: %{key: "author"}}]}
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/custom_prop/enable_request.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.CustomProp.EnableRequest do
  @moduledoc """
  OpenAPI schema for Custom Property creation request
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "CustomProp.EnableRequest",
    description: "Custom Property enable params",
    type: :object,
    oneOf: [
      %Schema{
        title: "CustomProp.EnableRequest.BulkEnable",
        type: :object,
        description: "Bulk Custom Property enable request",
        required: [:custom_props],
        properties: %{
          custom_props: %Schema{
            type: :array,
            minItems: 1,
            items: Schemas.CustomProp
          }
        }
      },
      Schemas.CustomProp
    ],
    example: %{custom_props: [%{custom_prop: %{key: "author"}}]}
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/custom_prop/list_response.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.CustomProp.ListResponse do
  @moduledoc """
  OpenAPI schema for SharedLink list response
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "CustomProp.ListResponse",
    description: "Custom Props list response",
    type: :object,
    required: [:custom_props],
    properties: %{
      custom_props: %Schema{
        items: Schemas.CustomProp,
        type: :array
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/error.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Error do
  @moduledoc """
  OpenAPI schema for an error included in a response
  """

  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: """
    An explanation of an error that occurred within the Plugins API
    """,
    type: :object,
    required: [:detail],
    properties: %{detail: %Schema{type: :string}}
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal do
  @moduledoc """
  OpenAPI schema for Goal
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "Goal",
    description: "Goal object",
    type: :object,
    discriminator: %OpenApiSpex.Discriminator{
      propertyName: "goal_type",
      mapping: %{
        "Goal.CustomEvent" => Schemas.Goal.CustomEvent,
        "Goal.Pageview" => Schemas.Goal.Pageview,
        "Goal.Revenue" => Schemas.Goal.Revenue
      }
    },
    oneOf: [
      Schemas.Goal.CustomEvent,
      Schemas.Goal.Revenue,
      Schemas.Goal.Pageview
    ],
    example: %{
      goal_type: "Goal.Revenue",
      goal: %{
        currency: "EUR",
        event_name: "Purchase"
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/create_request.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.CreateRequest do
  @moduledoc """
  OpenAPI schema for Goal creation request
  """
  use Plausible.Funnel.Const
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "Goal.CreateRequest",
    description: "Goal creation params",
    type: :object,
    oneOf: [
      %Schema{
        title: "Goal.CreateRequest.BulkGetOrCreate",
        type: :object,
        description: "Bulk goal creation request",
        required: [:goals],
        properties: %{
          goals: %Schema{
            type: :array,
            minItems: 1,
            maxItems: Funnel.Const.max_steps(),
            items: %Schema{
              oneOf: [
                Schemas.Goal.CreateRequest.CustomEvent,
                Schemas.Goal.CreateRequest.Revenue,
                Schemas.Goal.CreateRequest.Pageview
              ]
            }
          }
        }
      },
      Schemas.Goal.CreateRequest.CustomEvent,
      Schemas.Goal.CreateRequest.Revenue,
      Schemas.Goal.CreateRequest.Pageview
    ]
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/create_request/custom_event.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.CreateRequest.CustomEvent do
  @moduledoc """
  OpenAPI schema for Custom Event Goal creation request
  """

  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "Goal.CreateRequest.CustomEvent",
    description: "Custom Event Goal creation params",
    type: :object,
    required: [:goal, :goal_type],
    properties: %{
      goal_type: %Schema{
        type: :string,
        enum: ["Goal.CustomEvent"],
        default: "Goal.CustomEvent"
      },
      goal: %Schema{
        type: :object,
        required: [:event_name],
        properties: %{
          event_name: %Schema{type: :string}
        }
      }
    },
    example: %{
      goal_type: "Goal.CustomEvent",
      goal: %{
        event_name: "Signup"
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/create_request/pageview.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.CreateRequest.Pageview do
  @moduledoc """
  OpenAPI schema for Pageview Goal creation request
  """

  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "Goal.CreateRequest.Pageview",
    description: "Pageview Goal creation params",
    type: :object,
    required: [:goal, :goal_type],
    properties: %{
      goal_type: %Schema{
        type: :string,
        enum: ["Goal.Pageview"],
        default: "Goal.Pageview"
      },
      goal: %Schema{
        type: :object,
        required: [:path],
        properties: %{
          path: %Schema{type: :string}
        }
      }
    },
    example: %{
      goal_type: "Goal.Pageview",
      goal: %{
        path: "/checkout"
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/create_request/revenue.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.CreateRequest.Revenue do
  @moduledoc """
  OpenAPI schema for Custom Event Goal creation request
  """

  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "Goal.CreateRequest.Revenue",
    description: "Revenue Goal creation params",
    type: :object,
    required: [:goal, :goal_type],
    properties: %{
      goal_type: %Schema{
        type: :string,
        enum: ["Goal.Revenue"],
        default: "Goal.Revenue"
      },
      goal: %Schema{
        type: :object,
        required: [:event_name, :currency],
        properties: %{
          event_name: %Schema{type: :string},
          currency: %Schema{type: :string}
        }
      }
    },
    example: %{
      goal_type: "Goal.Revenue",
      goal: %{
        event_name: "Purchase",
        currency: "EUR"
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/custom_event.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.CustomEvent do
  @moduledoc """
  OpenAPI schema for Custom Event Goal object
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: "Custom Event Goal object",
    title: "Goal.CustomEvent",
    type: :object,
    allOf: [
      Schemas.Goal.Type,
      %Schema{
        type: :object,
        required: [:goal],
        properties: %{
          goal: %Schema{
            type: :object,
            required: [:id, :display_name, :event_name],
            properties: %{
              id: %Schema{type: :integer, description: "Goal ID", readOnly: true},
              display_name: %Schema{type: :string, description: "Display name", readOnly: true},
              event_name: %Schema{type: :string, description: "Event Name"}
            }
          }
        }
      }
    ]
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/delete_bulk_request.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.DeleteBulkRequest do
  @moduledoc """
  OpenAPI schema for bulk Goal deletion request
  """
  use Plausible.Funnel.Const
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "Goal.DeleteBulkRequest",
    description: "Goal deletion params",
    type: :object,
    required: [:goal_ids],
    properties: %{
      goal_ids: %Schema{
        type: :array,
        minItems: 1,
        maxItems: Funnel.Const.max_steps(),
        items: %Schema{type: :integer, description: "Goal ID"}
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/list_response.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.ListResponse do
  @moduledoc """
  OpenAPI schema for Goals list response
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "Goal.ListResponse",
    description: "Goals list response",
    type: :object,
    required: [:goals, :meta],
    properties: %{
      goals: %Schema{
        items: Schemas.Goal,
        type: :array
      },
      meta: %Schema{
        required: [:pagination],
        type: :object,
        properties: %{
          pagination: Schemas.PaginationMetadata
        }
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/pageview.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.Pageview do
  @moduledoc """
  OpenAPI schema for Pageview Goal object
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: "Pageview Goal object",
    title: "Goal.Pageview",
    type: :object,
    allOf: [
      Schemas.Goal.Type,
      %Schema{
        type: :object,
        required: [:goal],
        properties: %{
          goal: %Schema{
            type: :object,
            required: [:id, :display_name, :path],
            properties: %{
              id: %Schema{type: :integer, description: "Goal ID", readOnly: true},
              display_name: %Schema{type: :string, description: "Display name", readOnly: true},
              path: %Schema{type: :string, description: "Page Path"}
            }
          }
        }
      }
    ]
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/revenue.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.Revenue do
  @moduledoc """
  OpenAPI schema for Revenue Goal object
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: "Revenue Goal object",
    title: "Goal.Revenue",
    type: :object,
    allOf: [
      Schemas.Goal.Type,
      %Schema{
        type: :object,
        required: [:goal],
        properties: %{
          goal: %Schema{
            type: :object,
            required: [:id, :display_name, :event_name, :currency],
            properties: %{
              id: %Schema{type: :integer, description: "Goal ID", readOnly: true},
              display_name: %Schema{type: :string, description: "Display name", readOnly: true},
              event_name: %Schema{type: :string, description: "Event Name"},
              currency: %Schema{type: :string, description: "Currency"}
            }
          }
        }
      }
    ]
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/goal/type.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Goal.Type do
  @moduledoc """
  OpenAPI schema for common Goal Type

  Future-proof: funnels etc.
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "Goal.Type",
    description: "Properties common to all Goals",
    type: :object,
    properties: %{
      goal_type: %Schema{type: :string}
    },
    required: [:goal_type]
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/link.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Link do
  @moduledoc """
  OpenAPI Link schema
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "Link",
    type: :object,
    required: [:url],
    properties: %{url: %Schema{type: :string}}
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/not_found.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.NotFound do
  @moduledoc """
  OpenAPI schema for a generic 404 response
  """

  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: """
    The response that is returned when the user makes a request to a non-existing resource
    """,
    type: :object,
    title: "NotFoundError",
    required: [:errors],
    properties: %{
      errors: %Schema{
        items: Schemas.Error,
        type: :array
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/pagination_metadata.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.PaginationMetadata do
  @moduledoc """
  Pagination metadata OpenAPI schema
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "PaginationMetadata",
    description: "Pagination meta data",
    type: :object,
    required: [:has_next_page, :has_prev_page],
    properties: %{
      has_next_page: %Schema{type: :boolean},
      has_prev_page: %Schema{type: :boolean},
      links: %Schema{
        properties: %{
          next: Schemas.Link,
          prev: Schemas.Link
        },
        type: :object
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/payment_required.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.PaymentRequired do
  @moduledoc """
  OpenAPI schema for a generic 402 response
  """

  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: """
    The response that is returned when the user makes a request that cannot be
    processed due to their subscription limitations.
    """,
    type: :object,
    title: "PaymentRequiredError",
    required: [:errors],
    properties: %{
      errors: %Schema{
        items: Schemas.Error,
        type: :array
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/shared_link.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.SharedLink do
  @moduledoc """
  OpenAPI schema for SharedLink object
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: "Shared Link object",
    type: :object,
    required: [:shared_link],
    properties: %{
      shared_link: %Schema{
        type: :object,
        required: [:id, :name, :password_protected, :href],
        properties: %{
          id: %Schema{type: :integer, description: "Shared Link ID"},
          name: %Schema{type: :string, description: "Shared Link Name"},
          password_protected: %Schema{
            type: :boolean,
            description: "Shared Link Has Password"
          },
          href: %Schema{type: :string, description: "Shared Link URL"}
        }
      }
    },
    example: %{
      shared_link: %{
        id: 1024,
        name: "Public Dashboard",
        password_protected: false,
        href: "https://example.com"
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/shared_link/create_request.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.SharedLink.CreateRequest do
  @moduledoc """
  OpenAPI schema for SharedLink creation request
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "SharedLink.CreateRequest",
    description: "Shared Links creation params",
    type: :object,
    required: [:shared_link],
    properties: %{
      shared_link: %Schema{
        type: :object,
        required: [:name],
        properties: %{
          name: %Schema{description: "Shared Link Name", type: :string},
          password: %Schema{description: "Shared Link Password", type: :string}
        }
      }
    },
    example: %{
      shared_link: %{name: "My Shared Dashboard"}
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/shared_link/list_response.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.SharedLink.ListResponse do
  @moduledoc """
  OpenAPI schema for SharedLink list response
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "SharedLink.ListResponse",
    description: "Shared Links list response",
    type: :object,
    required: [:shared_links, :meta],
    properties: %{
      shared_links: %Schema{
        items: Schemas.SharedLink,
        type: :array
      },
      meta: %Schema{
        required: [:pagination],
        type: :object,
        properties: %{
          pagination: Schemas.PaginationMetadata
        }
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/tracker_script_configuration.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.TrackerScriptConfiguration do
  @moduledoc """
  OpenAPI schema for TrackerScriptConfiguration object
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: "Tracker Script Configuration object",
    type: :object,
    required: [:tracker_script_configuration],
    properties: %{
      tracker_script_configuration: %Schema{
        type: :object,
        required: [
          :id,
          :installation_type,
          :hash_based_routing,
          :outbound_links,
          :file_downloads,
          :form_submissions
        ],
        properties: %{
          id: %Schema{type: :string, description: "Tracker Script Configuration ID"},
          installation_type: %Schema{
            type: :string,
            description: "Tracker Script Installation Type",
            enum: ["manual", "wordpress", "gtm"]
          },
          hash_based_routing: %Schema{type: :boolean, description: "Hash Based Routing"},
          outbound_links: %Schema{type: :boolean, description: "Track Outbound Links"},
          file_downloads: %Schema{type: :boolean, description: "Track File Downloads"},
          form_submissions: %Schema{type: :boolean, description: "Track Form Submissions"}
        }
      }
    },
    example: %{
      tracker_script_configuration: %{
        id: "qyhkWtOWaTN0YPkhrcJgy",
        installation_type: "wordpress",
        hash_based_routing: true,
        outbound_links: false,
        file_downloads: true,
        form_submissions: false
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/tracker_script_configuration/update_request.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.TrackerScriptConfiguration.UpdateRequest do
  @moduledoc """
  OpenAPI schema for TrackerScriptConfiguration update request
  """
  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    title: "TrackerScriptConfiguration.UpdateRequest",
    description: "Tracker Script Configuration update params",
    type: :object,
    required: [:tracker_script_configuration],
    properties: %{
      tracker_script_configuration: %Schema{
        type: :object,
        required: [:installation_type],
        properties: %{
          installation_type: %Schema{
            type: :string,
            description: "Tracker Script Installation Type",
            enum: ["manual", "wordpress", "gtm"]
          },
          hash_based_routing: %Schema{type: :boolean, description: "Hash Based Routing"},
          outbound_links: %Schema{type: :boolean, description: "Track Outbound Links"},
          file_downloads: %Schema{type: :boolean, description: "Track File Downloads"},
          form_submissions: %Schema{type: :boolean, description: "Track Form Submissions"}
        }
      }
    },
    example: %{
      tracker_script_configuration: %{installation_type: "wordpress", hash_based_routing: true}
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/unauthorized.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.Unauthorized do
  @moduledoc """
  OpenAPI schema for a generic 401 response
  """

  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: """
    The response that is returned when the user makes an unauthorized request.
    """,
    type: :object,
    title: "UnauthorizedError",
    required: [:errors],
    properties: %{
      errors: %Schema{
        items: Schemas.Error,
        type: :array
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/schemas/unprocessable_entity.ex`
```
defmodule PlausibleWeb.Plugins.API.Schemas.UnprocessableEntity do
  @moduledoc """
  OpenAPI schema for a generic 422 response
  """

  use PlausibleWeb, :open_api_schema

  OpenApiSpex.schema(%{
    description: """
    The response that is returned when the user makes a request that cannot be
    processed.
    """,
    type: :object,
    title: "UnprocessableEntityError",
    required: [:errors],
    properties: %{
      errors: %Schema{
        items: Schemas.Error,
        type: :array
      }
    }
  })
end
```

## File: `lib/plausible_web/plugins/api/spec.ex`
```
defmodule PlausibleWeb.Plugins.API.Spec do
  @moduledoc """
  OpenAPI specification for the Plugins API
  """
  alias OpenApiSpex.{Components, Info, OpenApi, Paths, Server}
  alias PlausibleWeb.Router
  @behaviour OpenApi

  @impl OpenApi
  def spec do
    %OpenApi{
      servers: [
        %Server{
          description: "This server",
          url: PlausibleWeb.Endpoint.url(),
          variables: %{}
        }
      ],
      info: %Info{
        title: "Plausible Plugins API",
        version: "1.0-rc"
      },
      # Populate the paths from a phoenix router
      paths: Paths.from_router(Router),
      components: %Components{
        securitySchemes: %{
          "basic_auth" => %OpenApiSpex.SecurityScheme{
            type: "http",
            scheme: "basic",
            description: """
            HTTP basic access authentication using your Site Domain as the
            username and the Plugin Token contents as the password.
            Note that Site Domain is optional, a password alone suffices.

            For more information see
            https://en.wikipedia.org/wiki/Basic_access_authentication
            """
          }
        }
      },
      security: [%{"basic_auth" => []}]
    }
    # Discover request/response schemas from path specs
    |> OpenApiSpex.resolve_schema_modules()
  end
end
```

## File: `lib/plausible_web/plugins/api/views/capabilities.ex`
```
defmodule PlausibleWeb.Plugins.API.Views.Capabilities do
  @moduledoc """
  View for rendering Capabilities on the Plugins API
  """
  use PlausibleWeb, :plugins_api_view

  def render("index.json", %{capabilities: capabilities}) when is_map(capabilities) do
    capabilities
  end
end
```

## File: `lib/plausible_web/plugins/api/views/custom_props.ex`
```
defmodule PlausibleWeb.Plugins.API.Views.CustomProp do
  @moduledoc """
  View for rendering Custom Props in the Plugins API
  """

  use PlausibleWeb, :plugins_api_view

  def render("index.json", %{props: props}) do
    %{
      custom_props: render_many(props, __MODULE__, "custom_prop.json", as: :custom_prop)
    }
  end

  def render("custom_prop.json", %{
        custom_prop: custom_prop
      }) do
    %{
      custom_prop: %{
        key: custom_prop
      }
    }
  end
end
```

## File: `lib/plausible_web/plugins/api/views/error.ex`
```
defmodule PlausibleWeb.Plugins.API.Views.Error do
  @moduledoc """
  View for rendering Plugins REST API errors
  """
  use PlausibleWeb, :plugins_api_view

  def template_not_found(_template, assigns) do
    render("500.json", assigns)
  end

  @spec render(String.t(), map) :: map | binary()
  def render("400.json", _assigns) do
    %{errors: [%{detail: "Bad request"}]}
  end

  def render("404.json", _assigns) do
    %{errors: [%{detail: "Plugins API: resource not found"}]}
  end

  def render("500.json", _assigns) do
    %{errors: [%{detail: "Plugins API: Internal server error"}]}
  end
end
```

## File: `lib/plausible_web/plugins/api/views/goal.ex`
```
defmodule PlausibleWeb.Plugins.API.Views.Goal do
  @moduledoc """
  View for rendering Goals in the Plugins API
  """

  use PlausibleWeb, :plugins_api_view

  def render("index.json", %{
        pagination: %{entries: goals, metadata: metadata},
        authorized_site: site,
        conn: conn
      }) do
    %{
      goals: render_many(goals, __MODULE__, "goal.json", authorized_site: site, as: :goal),
      meta: render_metadata_links(metadata, :plugins_api_goals_url, :index, conn.query_params)
    }
  end

  def render("index.json", %{
        goals: goals,
        authorized_site: site,
        conn: conn
      }) do
    %{
      goals: render_many(goals, __MODULE__, "goal.json", authorized_site: site, as: :goal),
      meta: render_metadata_links(%{}, :plugins_api_goals_url, :index, conn.query_params)
    }
  end

  def render("goal.json", %{
        goal: %{event_name: nil} = pageview
      }) do
    %{
      goal_type: "Goal.Pageview",
      goal: %{
        id: pageview.id,
        display_name: pageview.display_name,
        path: pageview.page_path
      }
    }
  end

  def render("goal.json", %{
        goal: %{page_path: nil, currency: nil} = custom_event
      }) do
    %{
      goal_type: "Goal.CustomEvent",
      goal: %{
        id: custom_event.id,
        display_name: custom_event.display_name,
        event_name: custom_event.event_name
      }
    }
  end

  def render("goal.json", %{
        goal: %{page_path: nil, currency: currency} = revenue_goal
      })
      when is_atom(currency) do
    %{
      goal_type: "Goal.Revenue",
      goal: %{
        id: revenue_goal.id,
        display_name: revenue_goal.display_name,
        event_name: revenue_goal.event_name,
        currency: revenue_goal.currency
      }
    }
  end
end
```

## File: `lib/plausible_web/plugins/api/views/pagination.ex`
```
defmodule PlausibleWeb.Plugins.API.Views.Pagination do
  @moduledoc """
  A view capable of rendering pagination metadata included
  in responses containing lists of objects.
  """
  use Phoenix.View,
    namespace: PlausibleWeb.Plugins.API,
    root: ""

  alias PlausibleWeb.Router.Helpers

  def render_metadata_links(meta, helper_fn, helper_fn_args, existing_params \\ %{}) do
    render(__MODULE__, "pagination.json", %{
      meta: meta,
      url_helper: fn query_params ->
        existing_params = Map.drop(existing_params, ["before", "after"])

        query_params =
          query_params
          |> Enum.into(%{})
          |> Map.merge(existing_params)

        args = [
          PlausibleWeb.Endpoint
          | List.wrap(helper_fn_args) ++ [query_params]
        ]

        apply(Helpers, helper_fn, args)
      end
    })
  end

  @spec render(binary(), map()) ::
          binary()
  def render("pagination.json", %{meta: meta, url_helper: url_helper_fn}) do
    pagination =
      [
        {:after, :next, :has_next_page},
        {:before, :prev, :has_prev_page}
      ]
      |> Enum.reduce(%{}, fn
        {meta_key, url_key, sibling_key}, acc ->
          meta_value = Map.get(meta, meta_key)

          if meta_value do
            url = url_helper_fn.([{meta_key, meta_value}])

            acc
            |> Map.update(
              :links,
              %{url_key => %{url: url}},
              &Map.put(&1, url_key, %{url: url})
            )
            |> Map.put(sibling_key, true)
          else
            acc
            |> Map.update(:links, %{}, & &1)
            |> Map.put(sibling_key, false)
          end
      end)

    %{
      pagination: pagination
    }
  end
end
```

## File: `lib/plausible_web/plugins/api/views/shared_link.ex`
```
defmodule PlausibleWeb.Plugins.API.Views.SharedLink do
  @moduledoc """
  View for rendering Shared Links in the Plugins API
  """

  use PlausibleWeb, :plugins_api_view

  def render("index.json", %{
        pagination: %{entries: shared_links, metadata: metadata},
        authorized_site: site,
        conn: conn
      }) do
    %{
      shared_links:
        render_many(shared_links, __MODULE__, "shared_link.json",
          authorized_site: site,
          as: :shared_link
        ),
      meta:
        render_metadata_links(metadata, :plugins_api_shared_links_url, :index, conn.query_params)
    }
  end

  def render("shared_link.json", %{
        shared_link: shared_link,
        authorized_site: site
      }) do
    %{
      shared_link: %{
        id: shared_link.id,
        name: shared_link.name,
        password_protected: is_binary(shared_link.password_hash),
        href: Plausible.Sites.shared_link_url(site, shared_link)
      }
    }
  end
end
```

## File: `lib/plausible_web/plugins/api/views/tracker_script_configuration.ex`
```
defmodule PlausibleWeb.Plugins.API.Views.TrackerScriptConfiguration do
  @moduledoc """
  View for rendering Tracker Script Configuration in the Plugins API
  """

  use PlausibleWeb, :plugins_api_view

  def render("tracker_script_configuration.json", %{
        tracker_script_configuration: tracker_script_configuration
      }) do
    %{
      tracker_script_configuration: %{
        id: tracker_script_configuration.id,
        installation_type: tracker_script_configuration.installation_type || :manual,
        hash_based_routing: tracker_script_configuration.hash_based_routing,
        outbound_links: tracker_script_configuration.outbound_links,
        file_downloads: tracker_script_configuration.file_downloads,
        form_submissions: tracker_script_configuration.form_submissions
      }
    }
  end
end
```

## File: `lib/plausible_web/plugs/auth_plug.ex`
```
defmodule PlausibleWeb.AuthPlug do
  @moduledoc """
  Plug for populating conn assigns with user data
  on the basis of authenticated session token.

  Must be kept in sync with `PlausibleWeb.Live.AuthContext`.
  """

  use Plausible
  import Plug.Conn

  alias PlausibleWeb.UserAuth

  def init(options) do
    options
  end

  def call(conn, _opts) do
    case UserAuth.get_user_session(conn) do
      {:ok, user_session} ->
        user = user_session.user

        current_team_id_from_session = Plug.Conn.get_session(conn, "current_team_id")

        current_team_id =
          conn.params["__team"] || current_team_id_from_session || user.last_team_identifier

        {current_team, current_team_role} =
          if current_team_id do
            team_membership =
              Enum.find(user.team_memberships, %{}, &(&1.team.identifier == current_team_id))

            {Map.get(team_membership, :team), Map.get(team_membership, :role)}
          else
            {nil, nil}
          end

        conn =
          cond do
            current_team && current_team_id != current_team_id_from_session ->
              Plausible.Users.remember_last_team(user, current_team_id)
              Plug.Conn.put_session(conn, "current_team_id", current_team_id)

            is_nil(current_team) && not is_nil(current_team_id_from_session) ->
              Plausible.Users.remember_last_team(user, nil)
              Plug.Conn.delete_session(conn, "current_team_id")

            true ->
              conn
          end

        my_team =
          user.team_memberships
          |> Enum.find(%{}, &(&1.role == :owner and &1.team.setup_complete == false))
          |> Map.get(:team)

        teams_count = length(user.team_memberships)

        teams =
          user.team_memberships
          |> Enum.filter(& &1.team.setup_complete)
          |> Enum.sort_by(fn tm -> [tm.role != :owner, tm.team_id] end)
          |> Enum.map(&Map.fetch!(&1, :team))
          |> Enum.take(3)

        Plausible.OpenTelemetry.add_user_attributes(user)

        Sentry.Context.set_user_context(%{id: user.id, name: user.name, email: user.email})

        on_ee do
          Plausible.Audit.set_context(%{
            current_user: user,
            current_team: current_team
          })
        end

        conn
        |> assign(:current_user, user)
        |> assign(:current_user_session, user_session)
        |> assign(:my_team, my_team)
        |> assign(:current_team, current_team || my_team)
        |> assign(:current_team_role, current_team_role || (my_team && :owner))
        |> assign(:teams_count, teams_count)
        |> assign(:teams, teams)
        |> assign(:more_teams?, teams_count > 3)

      {:error, :session_expired, user_session} ->
        assign(conn, :expired_session, user_session)

      _ ->
        conn
    end
  end
end
```

## File: `lib/plausible_web/plugs/authorize_plugins_api.ex`
```
defmodule PlausibleWeb.Plugs.AuthorizePluginsAPI do
  @moduledoc """
  Plug for Basic HTTP Authentication using
  Plugins API Tokens lookup.
  """

  alias PlausibleWeb.Plugins.API.Errors
  alias Plausible.Plugins.API.Tokens
  import Plug.Conn

  def init(opts), do: opts

  def call(conn, opts \\ []) do
    send_error? =
      Keyword.get(opts, :send_error?, true)

    with {:ok, token} <- extract_token(conn),
         {:ok, conn} <- authorize(conn, token) do
      conn
    else
      {:unauthorized, conn} ->
        if send_error? do
          Errors.unauthorized(conn)
        else
          conn
        end
    end
  end

  defp authorize(conn, token_value) do
    case Tokens.find(token_value) do
      {:ok, token} ->
        {:ok, token} = Tokens.update_last_seen(token)
        {:ok, Plug.Conn.assign(conn, :authorized_site, token.site)}

      {:error, :not_found} ->
        {:unauthorized, conn}
    end
  end

  defp extract_token(conn) do
    with ["Basic " <> encoded_user_and_pass] <- get_req_header(conn, "authorization"),
         {:ok, decoded_user_and_pass} <- Base.decode64(encoded_user_and_pass) do
      case :binary.split(decoded_user_and_pass, ":") do
        [_user, token_value] -> {:ok, token_value}
        [token_value] -> {:ok, token_value}
      end
    else
      _ ->
        {:unauthorized, conn}
    end
  end
end
```

## File: `lib/plausible_web/plugs/authorize_public_api.ex`
```
defmodule PlausibleWeb.Plugs.AuthorizePublicAPI do
  @moduledoc """
  Plug for authorizing access to Stats and Sites APIs.

  The plug expects `:api_scope` to be provided in the assigns. The scope
  will then be used to check for API key validity. The assign can be
  provided in the router configuration in a following way:

      scope "/api/v1/stats", PlausibleWeb.Api, assigns: %{api_scope: "some:scope:*"} do
        pipe_through [:public_api, #{inspect(__MODULE__)}]

        # route definitions follow
        # ...
      end

  The scope from `:api_scope` is checked for match against all scopes from API key's
  `scopes` field. If the scope is among `@implicit_scopes`, it's considered to be
  present for any valid API key. Scopes are checked for match by prefix, so if we have
  `some:scope:*` in matching route `:api_scope` and the API key has `some:*` in its
  `scopes` field, they will match.

  After a match is found, additional verification can be conducted, like in case of
  `stats:read:*`, where valid site ID is expected among parameters too.

  All API requests are rate limited per API key, enforcing a given hourly request limit.
  """

  use Plausible.Repo

  import Plug.Conn

  alias Plausible.Auth
  alias Plausible.RateLimit
  alias Plausible.Teams
  alias PlausibleWeb.Api.Helpers, as: H

  require Logger

  # Scopes permitted implicitly for every API key. Existing API keys
  # have _either_ `["stats:read:*"]` (the default) or `["sites:provision:*"]`
  # set as their valid scopes. We always consider implicit scopes as
  # present in addition to whatever else is provided for a particular
  # API key.
  @implicit_scopes ["stats:read:*", "sites:read:*"]

  def init(opts) do
    opts
  end

  def call(conn, _opts) do
    requested_scope = Map.fetch!(conn.assigns, :api_scope)
    context = conn.assigns[:api_context]

    with {:ok, token} <- get_bearer_token(conn),
         {:ok, api_key, limit_key, hourly_limit} <- find_api_key(conn, token, context),
         :ok <- check_api_key_rate_limit(limit_key, hourly_limit),
         {:ok, conn} <- verify_by_scope(conn, api_key, requested_scope) do
      conn
      |> assign(:current_user, api_key.user)
      |> assign(:current_team, api_key.team)
    else
      error -> send_error(conn, requested_scope, error)
    end
  end

  ### Verification dispatched by scope

  defp find_api_key(conn, token, :site) do
    case Auth.find_api_key(token, team_by: {:site, conn.params["site_id"]}) do
      {:ok, %{api_key: api_key, team: nil}} ->
        {:ok, api_key, limit_key(api_key, nil), Auth.ApiKey.hourly_request_limit()}

      {:ok, %{api_key: api_key, team: team}} ->
        team_role_result = Plausible.Teams.Memberships.team_role(team, api_key.user)

        cond do
          Auth.is_super_admin?(api_key.user) ->
            :pass

          team_role_result == {:ok, :guest} ->
            Logger.warning(
              "[#{inspect(__MODULE__)}] API key #{api_key.id} user accessing #{conn.params["site_id"]} as a guest"
            )

          team_role_result == {:error, :not_a_member} ->
            Logger.warning(
              "[#{inspect(__MODULE__)}] API key #{api_key.id} user trying to access #{conn.params["site_id"]} as a non-member"
            )

          true ->
            :pass
        end

        {:ok, api_key, limit_key(api_key, team.identifier), team.hourly_api_request_limit}

      {:error, _} = error ->
        error
    end
  end

  defp find_api_key(_conn, token, _) do
    case Auth.find_api_key(token) do
      {:ok, %{api_key: api_key, team: nil}} ->
        {:ok, api_key, limit_key(api_key, nil), Auth.ApiKey.hourly_request_limit()}

      {:ok, %{api_key: api_key, team: team}} ->
        {:ok, api_key, limit_key(api_key, team.identifier), team.hourly_api_request_limit}

      {:error, _} = error ->
        error
    end
  end

  defp limit_key(api_key, nil) do
    "api_request:#{api_key.id}"
  end

  defp limit_key(api_key, team_id) do
    "api_request:#{api_key.id}:#{team_id}"
  end

  defp verify_by_scope(conn, api_key, "stats:read:" <> _ = scope) do
    with :ok <- check_scope(api_key, scope),
         {:ok, site} <- find_site(conn.params["site_id"]),
         :ok <- verify_site_access(api_key, site) do
      Plausible.OpenTelemetry.add_site_attributes(site)
      site = Plausible.Repo.preload(site, :completed_imports)
      {:ok, assign(conn, :site, site)}
    end
  end

  defp verify_by_scope(conn, api_key, scope) do
    with :ok <- check_scope(api_key, scope) do
      {:ok, conn}
    end
  end

  defp check_scope(_api_key, required_scope) when required_scope in @implicit_scopes do
    :ok
  end

  defp check_scope(api_key, required_scope) do
    found? =
      Enum.any?(api_key.scopes, fn scope ->
        scope = String.trim_trailing(scope, "*")

        String.starts_with?(required_scope, scope)
      end)

    if found? do
      :ok
    else
      {:error, :invalid_api_key}
    end
  end

  defp get_bearer_token(conn) do
    authorization_header =
      conn
      |> Plug.Conn.get_req_header("authorization")
      |> List.first()

    case authorization_header do
      "Bearer " <> token -> {:ok, String.trim(token)}
      _ -> {:error, :missing_api_key}
    end
  end

  defp check_api_key_rate_limit(limit_key, hourly_limit) do
    case RateLimit.check_rate(limit_key, to_timeout(hour: 1), hourly_limit) do
      {:allow, _} -> :ok
      {:deny, _} -> {:error, :rate_limit, hourly_limit}
    end
  end

  defp find_site(nil), do: {:error, :missing_site_id}

  defp find_site(site_id) do
    domain_based_search =
      from s in Plausible.Site, where: s.domain == ^site_id or s.domain_changed_from == ^site_id

    case Repo.one(domain_based_search) do
      %Plausible.Site{} = site ->
        {:ok, site}

      nil ->
        {:error, :invalid_api_key}
    end
  end

  defp verify_site_access(api_key, site) do
    team = Repo.preload(site, :team).team

    is_member? = Plausible.Teams.Memberships.site_member?(site, api_key.user)
    is_super_admin? = Auth.is_super_admin?(api_key.user_id)

    cond do
      is_super_admin? ->
        :ok

      api_key.team_id && api_key.team_id != site.team_id ->
        {:error, :invalid_api_key}

      Teams.locked?(team) ->
        {:error, :site_locked}

      Plausible.Billing.Feature.StatsAPI.check_availability(team) !== :ok ->
        {:error, :upgrade_required}

      is_member? ->
        :ok

      true ->
        {:error, :invalid_api_key}
    end
  end

  defp send_error(conn, _, {:error, :missing_api_key}) do
    H.unauthorized(
      conn,
      "Missing API key. Please use a valid Plausible API key as a Bearer Token."
    )
  end

  defp send_error(conn, "stats:read:" <> _, {:error, :invalid_api_key}) do
    H.unauthorized(
      conn,
      "Invalid API key or site ID. Please make sure you're using a valid API key with access to the site you've requested."
    )
  end

  defp send_error(conn, _, {:error, :invalid_api_key}) do
    H.unauthorized(
      conn,
      "Invalid API key. Please make sure you're using a valid API key with access to the resource you've requested."
    )
  end

  defp send_error(conn, _, {:error, :rate_limit, limit}) do
    H.too_many_requests(
      conn,
      "Too many API requests. Your API key is limited to #{limit} requests per hour. Please contact us to request more capacity."
    )
  end

  defp send_error(conn, _, {:error, :missing_site_id}) do
    H.bad_request(
      conn,
      "Missing site ID. Please provide the required site_id parameter with your request."
    )
  end

  defp send_error(conn, _, {:error, :upgrade_required}) do
    H.payment_required(
      conn,
      "The account that owns this API key does not have access to Stats API. Please make sure you're using the API key of a subscriber account and that the subscription plan includes Stats API"
    )
  end

  defp send_error(conn, _, {:error, :site_locked}) do
    H.payment_required(
      conn,
      "This Plausible site is locked due to missing active subscription. In order to access it, the site owner should subscribe to a suitable plan"
    )
  end
end
```

## File: `lib/plausible_web/plugs/authorize_site_access.ex`
```
defmodule PlausibleWeb.Plugs.AuthorizeSiteAccess do
  @moduledoc """
  Plug restricting access to site and shared link, when present.

  In order to permit access to site regardless of role:

  ```elixir
  plug AuthorizeSiteAccess
  ```

  or

  ```elixir
  plug AuthorizeSiteAccess, :all_roles
  ```

  Permit access for a subset of roles only:

  ```elixir
  plug AuthorizeSiteAccess, [:admin, :owner, :super_admin]
  ```

  Permit access using a custom site param:

  ```elixir
  plug AuthorizeSiteAccess, {[:admin, :owner, :super_admin], "site_id"}
  ```

  or in case where any role is allowed:

  ```elixir
  plug AuthorizeSiteAccess, {:all_roles, "site_id"}
  ```
  """

  use Plausible.Repo

  import Plug.Conn
  import Phoenix.Controller, only: [get_format: 1]

  alias Plausible.Teams

  @all_roles [:public, :viewer, :admin, :editor, :super_admin, :owner, :billing]

  def init([]), do: {@all_roles, nil}

  def init(:all_roles), do: {@all_roles, nil}

  def init(allowed_roles) when is_list(allowed_roles) do
    init({allowed_roles, nil})
  end

  def init({:all_roles, site_param}) do
    init({@all_roles, site_param})
  end

  def init({allowed_roles, site_param}) when is_list(allowed_roles) do
    allowed_roles =
      if allowed_roles == [] do
        @all_roles
      else
        allowed_roles
      end

    unknown_roles = allowed_roles -- @all_roles

    if unknown_roles != [] do
      raise ArgumentError, "Unknown allowed roles configured: #{inspect(unknown_roles)}"
    end

    if !is_binary(site_param) && !is_nil(site_param) do
      raise ArgumentError, "Invalid site param configured: #{inspect(site_param)}"
    end

    {allowed_roles, site_param}
  end

  def call(conn, {allowed_roles, site_param}) do
    current_user = conn.assigns[:current_user]

    with {:ok, domain} <- get_domain(conn, site_param),
         {:ok, %{site: site, role: membership_role, member_type: member_type}} <-
           get_site_with_role(conn, current_user, domain),
         {:ok, shared_link} <- maybe_get_shared_link(conn, site) do
      role =
        cond do
          membership_role ->
            membership_role

          Plausible.Auth.is_super_admin?(current_user) ->
            :super_admin

          site.public ->
            :public

          shared_link ->
            :public

          true ->
            nil
        end

      if role in allowed_roles do
        if current_user do
          Sentry.Context.set_user_context(%{id: current_user.id})
          Plausible.OpenTelemetry.add_user_attributes(current_user.id)
        end

        Sentry.Context.set_extra_context(%{site_id: site.id, domain: site.domain})
        Plausible.OpenTelemetry.add_site_attributes(site)

        site =
          site
          |> Repo.preload([
            :owners,
            :completed_imports,
            team: [:owners, subscription: Teams.last_subscription_query()]
          ])

        conn = merge_assigns(conn, site: site, site_role: role)

        # Switch current team if user is a team member in it
        conn =
          if member_type == :team_member do
            set_current_team(conn, site.team)
          else
            conn
          end

        if not is_nil(current_user) and role not in [:public, nil] do
          assign(conn, :site_team, site.team)
        else
          conn
        end
      else
        error_not_found(conn)
      end
    end
  end

  defp set_current_team(conn, team) do
    current_team = conn.assigns[:current_team]

    if !current_team || team.id != current_team.id do
      conn
      |> assign(:current_team, team)
      |> Plug.Conn.put_session("current_team_id", team.identifier)
    else
      conn
    end
  end

  defp valid_path_fragment?(fragment), do: is_binary(fragment) and String.valid?(fragment)

  defp get_domain(conn, nil) do
    domain = conn.path_params["domain"]

    if valid_path_fragment?(domain) do
      {:ok, domain}
    else
      error_not_found(conn)
    end
  end

  defp get_domain(conn, site_param) do
    domain = conn.params[site_param]

    if valid_path_fragment?(domain) do
      {:ok, domain}
    else
      error_not_found(conn)
    end
  end

  defp get_site_with_role(conn, current_user, domain) do
    site = Repo.get_by(Plausible.Site, domain: domain)

    if site do
      {member_type, site_role} =
        case Teams.Memberships.site_role(site, current_user) do
          {:ok, {member_type, role}} -> {member_type, role}
          _ -> {nil, nil}
        end

      {:ok, %{site: site, role: site_role, member_type: member_type}}
    else
      error_not_found(conn)
    end
  end

  defp maybe_get_shared_link(conn, site) do
    slug = conn.path_params["slug"] || conn.params["auth"]

    if valid_path_fragment?(slug) do
      if shared_link = Repo.get_by(Plausible.Site.SharedLink, slug: slug, site_id: site.id) do
        {:ok, shared_link}
      else
        error_not_found(conn)
      end
    else
      {:ok, nil}
    end
  end

  defp error_not_found(conn) do
    case get_format(conn) do
      "json" ->
        conn
        |> PlausibleWeb.Api.Helpers.not_found(
          "Site does not exist or user does not have sufficient access."
        )
        |> halt()

      _ ->
        conn
        |> PlausibleWeb.ControllerHelpers.render_error(404)
        |> halt()
    end
  end
end
```

## File: `lib/plausible_web/plugs/authorize_team_access.ex`
```
defmodule Plausible.Plugs.AuthorizeTeamAccess do
  @moduledoc """
  Enforce team role to be within the declared set.
  `:current_team_role` is assumed to be populated by `PlausibleWeb.AuthPlug`.

  For cases where no `:current_team` exists, the plug is permissive,
  so that existing notices can be displayed still.
  """

  alias PlausibleWeb.Router.Helpers, as: Routes

  import Plug.Conn

  @all_roles Plausible.Teams.Membership.roles() -- [:guest]

  def init([]), do: @all_roles

  def init(roles) when is_list(roles) do
    true = Enum.all?(roles, &(&1 in @all_roles))
    roles
  end

  def call(conn, roles \\ @all_roles) do
    current_team = conn.assigns[:current_team]

    if current_team do
      current_team_role = conn.assigns[:current_team_role]

      if current_team_role in roles do
        conn
      else
        conn
        |> Phoenix.Controller.redirect(to: Routes.site_path(conn, :index))
        |> halt()
      end
    else
      conn
    end
  end
end
```

## File: `lib/plausible_web/plugs/error_handler.ex`
```
defmodule PlausibleWeb.Plugs.ErrorHandler do
  @moduledoc """
    A thin macro wrapper around Plug.ErrorHandler that adds Sentry context
    containing a readable support hash presented to the users.
    To be used in the user-facing APIs, so that we don't leak internal
    server errors.

    Usage: `use PlausibleWeb.Plugs.ErrorHandler`
  """
  defmacro __using__(_) do
    quote do
      use Plug.ErrorHandler

      @impl Plug.ErrorHandler
      def handle_errors(conn, %{kind: kind, reason: reason}) do
        json(conn, %{error: "internal server error"})
      end
    end
  end
end
```

## File: `lib/plausible_web/plugs/favicon.ex`
```
defmodule PlausibleWeb.Favicon do
  @referer_domains_file "priv/referer_favicon_domains.json"
  @moduledoc """
  A Plug that fetches favicon images from DuckDuckGo and returns them
  to the Plausible frontend.

  The proxying is there so we can reduce the number of third-party domains that
  the browser clients need to connect to. Our goal is to have 0 third-party domain
  connections on the website for privacy reasons.

  This module also maps between categorized sources and their respective URLs for favicons.
  What does that mean exactly? During ingestion we use `PlausibleWeb.RefInspector.parse/1` to
  categorize our referrer sources like so:

  google.com -> Google
  google.co.uk -> Google
  google.com.au -> Google

  So when we show Google as a source in the dashboard, the request to this plug will come as:
  https://plausible/io/favicon/sources/Google

  Now, when we want to show a favicon for Google, we need to convert Google -> google.com or
  some other hostname owned by Google:
  https://icons.duckduckgo.com/ip3/google.com.ico

  The mapping from source category -> source hostname is stored in "#{@referer_domains_file}" and
  managed by `Mix.Tasks.GenerateReferrerFavicons.run/1`
  """
  import Plug.Conn
  alias Plausible.HTTPClient

  @placeholder_icon_location "priv/placeholder_favicon.svg"
  @placeholder_icon File.read!(@placeholder_icon_location)
  @custom_icons %{
    "Brave" => "search.brave.com",
    "Sogou" => "sogou.com",
    "Wikipedia" => "en.wikipedia.org",
    "Discord" => "discord.com",
    "Perplexity" => "perplexity.ai",
    "Microsoft Teams" => "microsoft.com",
    "LinkedIn" => "linkedin.com"
  }

  def init(_) do
    domains =
      File.read!(Application.app_dir(:plausible, @referer_domains_file))
      |> Jason.decode!()
      |> Map.merge(@custom_icons)

    [favicon_domains: domains]
  end

  @ddg_broken_icon <<137, 80, 78, 71, 13, 10, 26, 10>>
  @doc """
  Proxies HTTP request to DuckDuckGo favicon service. Swallows hop-by-hop HTTP
  headers that should not be forwarded as defined in [RFC 2616](https://www.rfc-editor.org/rfc/rfc2616#section-13.5.1)

  ## Placeholder

  Cases where we show a placeholder icon instead:

  1. In case of network error to DuckDuckGo
  2. In case of non-2xx status code from DuckDuckGo
  3. In case of broken image response body from DuckDuckGo

  I'm not sure why DDG sometimes returns a broken PNG image in their response
  but we filter that out.  When the icon request fails, we show a placeholder
  favicon instead. The placeholder is an svg from [https://heroicons.com/](https://heroicons.com/).

  DuckDuckGo favicon service has some issues with [SVG favicons](https://css-tricks.com/svg-favicons-and-all-the-fun-things-we-can-do-with-them/).
  For some reason, they return them with `content-type=image/x-icon` whereas SVG
  icons should be returned with `content-type=image/svg+xml`. This Plug detects
  when the response body starts with `<svg` and will override the `Content-Type`
  to correct it.

  ## Preventing XSS vulnerabilities

  SVGs may contain `<script>` tags, and as these SVGs come from external
  sources, we need to prevent untrusted code from running on the browser.

  - This Plug sets a strict `Content-Security-Policy` header telling the browser
    not to run scripts.

  - This Plug sets `Content-Disposition=attachment` to prevent the SVG from
    rendering when navigating to `/favicon/sources/:domain` directly.

  - Browsers do not execute scripts from `<img>` tags, therefore it is safe to
    use `<img src="https://plausible.io/favicon/sources/dummy.site"></img>`

  """
  def call(conn, favicon_domains: favicon_domains) do
    case conn.request_path do
      "/favicon/sources/placeholder" ->
        send_placeholder(conn)

      "/favicon/sources/" <> domain ->
        domain = URI.decode_www_form(domain)

        domain =
          Map.get(favicon_domains, domain, domain)
          |> String.split("/", parts: 2)
          |> hd()

        case HTTPClient.impl().get("https://icons.duckduckgo.com/ip3/#{domain}.ico") do
          {:ok, %Finch.Response{status: 200, body: body, headers: headers}}
          when body != @ddg_broken_icon ->
            conn
            |> forward_headers(headers)
            |> maybe_override_content_type(body)
            |> prevent_javascript_execution()
            |> send_resp(200, body)
            |> halt()

          _ ->
            send_placeholder(conn)
        end

      _ ->
        conn
    end
  end

  defp send_placeholder(conn) do
    conn
    |> put_resp_content_type("image/svg+xml")
    |> put_resp_header("cache-control", "public, max-age=2592000")
    |> send_resp(200, @placeholder_icon)
    |> halt
  end

  @forwarded_headers ["content-type", "cache-control", "expires"]
  defp forward_headers(conn, headers) do
    headers_to_forward = Enum.filter(headers, fn {k, _} -> k in @forwarded_headers end)
    %Plug.Conn{conn | resp_headers: headers_to_forward}
  end

  defp maybe_override_content_type(conn, "<svg" <> _rest) do
    conn |> put_resp_content_type("image/svg+xml")
  end

  defp maybe_override_content_type(conn, _), do: conn

  defp prevent_javascript_execution(conn) do
    conn
    |> put_resp_header("content-security-policy", "script-src 'none'")
    |> put_resp_header("content-disposition", "attachment")
  end
end
```

## File: `lib/plausible_web/plugs/first_launch_plug.ex`
```
defmodule PlausibleWeb.FirstLaunchPlug do
  @moduledoc """
  Redirects first-launch users to registration page.
  """

  defmodule Test do
    @moduledoc """
    Test helper for setup blocks allowing to skip the plug processing
    """
    @spec skip(map()) :: {:ok, map()}
    def skip(context) do
      conn = Plug.Conn.put_private(context.conn, PlausibleWeb.FirstLaunchPlug, :skip)
      {:ok, Map.put(context, :conn, conn)}
    end
  end

  @behaviour Plug
  alias Plausible.Release

  @impl true
  def init(opts) do
    _path = Keyword.fetch!(opts, :redirect_to)
  end

  @impl true
  def call(%Plug.Conn{private: %{__MODULE__ => :skip}} = conn, _), do: conn
  def call(%Plug.Conn{request_path: path} = conn, path), do: conn

  def call(conn, redirect_to) do
    if Release.should_be_first_launch?() do
      conn
      |> Phoenix.Controller.redirect(to: redirect_to)
      |> Plug.Conn.halt()
    else
      conn
    end
  end
end
```

## File: `lib/plausible_web/plugs/maybe_disable_registration.ex`
```
defmodule PlausibleWeb.Plugs.MaybeDisableRegistration do
  @moduledoc """
  Plug toggling registration according to selfhosted state.
  """

  import Phoenix.Controller
  import Plug.Conn

  alias Plausible.Release
  alias PlausibleWeb.Router.Helpers, as: Routes

  def init(opts) do
    opts
  end

  def call(conn, _opts) do
    disabled_for = List.wrap(conn.assigns.disable_registration_for)

    selfhost_config = Application.get_env(:plausible, :selfhost)
    disable_registration = Keyword.fetch!(selfhost_config, :disable_registration)
    first_launch? = Release.should_be_first_launch?()

    if not first_launch? and disable_registration in disabled_for do
      conn
      |> put_flash(:error, "Registration is disabled on this instance")
      |> redirect(to: Routes.auth_path(conn, :login_form))
      |> halt()
    else
      conn
    end
  end
end
```

## File: `lib/plausible_web/plugs/no_robots.ex`
```
defmodule PlausibleWeb.Plugs.NoRobots do
  @moduledoc """
  Rejects bot requests by any means available.

  We're adding `x-robots-tag` to the response header and annotate the conn
  with "noindex, nofollow" under `private.robots` key.

  The only exception is, if the request is trying to access our live demo
  at plausible.io/plausible.io - in which case we'll allow indexing, but deny
  following links and skip the bot detection, in kind robots we trust.
  """
  @behaviour Plug
  import Plug.Conn

  @impl true
  def init(opts), do: opts

  @impl true
  def call(conn, _opts \\ nil) do
    conn =
      if conn.path_info == ["plausible.io"] do
        put_private(conn, :robots, "index, nofollow")
      else
        put_private(conn, :robots, "noindex, nofollow")
      end

    put_resp_header(conn, "x-robots-tag", conn.private.robots)
  end
end
```

## File: `lib/plausible_web/plugs/require_account.ex`
```
defmodule PlausibleWeb.RequireAccountPlug do
  alias PlausibleWeb.Router.Helpers, as: Routes
  import Plug.Conn

  @unverified_email_exceptions [
    ["settings", "security", "email", "cancel"],
    ["activate"],
    ["activate", "request-code"],
    ["me"]
  ]

  def init(options) do
    options
  end

  def call(conn, _opts) do
    user = conn.assigns[:current_user]

    cond do
      is_nil(user) ->
        conn
        |> Phoenix.Controller.redirect(to: redirect_to(conn))
        |> halt

      not user.email_verified and
          conn.path_info not in @unverified_email_exceptions ->
        conn
        |> Phoenix.Controller.redirect(to: "/activate")
        |> halt

      true ->
        conn
    end
  end

  defp redirect_to(%Plug.Conn{method: "GET"} = conn) do
    return_to =
      if conn.query_string && String.length(conn.query_string) > 0 do
        conn.request_path <> "?" <> conn.query_string
      else
        conn.request_path
      end

    Routes.auth_path(conn, :login_form, return_to: return_to)
  end

  defp redirect_to(conn), do: Routes.auth_path(conn, :login_form)
end
```

## File: `lib/plausible_web/plugs/require_logged_out.ex`
```
defmodule PlausibleWeb.RequireLoggedOutPlug do
  import Plug.Conn

  def init(opts \\ []) do
    opts
  end

  def call(conn, _opts) do
    if conn.assigns[:current_user] do
      conn
      |> PlausibleWeb.UserAuth.set_logged_in_cookie()
      |> Phoenix.Controller.redirect(to: "/sites")
      |> halt()
    else
      conn
    end
  end
end
```

## File: `lib/plausible_web/plugs/restrict_user_type.ex`
```
defmodule Plausible.Plugs.RestrictUserType do
  @moduledoc """
  Plug for restricting user access by type.
  """

  import Plug.Conn

  alias PlausibleWeb.Router.Helpers, as: Routes

  def init(opts) do
    Keyword.fetch!(opts, :deny)
  end

  def call(conn, deny_type) do
    user = conn.assigns[:current_user]

    if user && Plausible.Users.type(user) == deny_type do
      conn
      |> Phoenix.Controller.redirect(to: Routes.site_path(conn, :index))
      |> halt()
    else
      conn
    end
  end
end
```

## File: `lib/plausible_web/plugs/sso_team_access.ex`
```
defmodule Plausible.Plugs.SSOTeamAccess do
  @moduledoc """
  Plug ensuring user is permitted to access the team
  if it has SSO setup with Force SSO policy.  
  """

  use Plausible

  def init(_) do
    []
  end

  on_ee do
    import Phoenix.Controller, only: [redirect: 2]
    import Plug.Conn

    alias PlausibleWeb.Router.Helpers, as: Routes

    def call(conn, _opts) do
      current_user = conn.assigns[:current_user]
      current_team = conn.assigns[:current_team]

      eligible_for_check? =
        not is_nil(current_user) and
          not is_nil(current_team) and
          current_team.policy.force_sso == :all_but_owners and
          Plausible.Users.type(current_user) == :standard

      if eligible_for_check? do
        check_user(conn, current_user, current_team)
      else
        conn
      end
    end

    defp check_user(conn, user, team) do
      conn =
        case Plausible.Auth.SSO.check_ready_to_provision(user, team) do
          :ok ->
            redirect(conn, to: Routes.sso_path(conn, :provision_notice))

          {:error, issue} ->
            redirect(conn, to: Routes.sso_path(conn, :provision_issue, issue: issue))
        end

      halt(conn)
    end
  else
    def call(conn, _opts) do
      conn
    end
  end
end
```

## File: `lib/plausible_web/plugs/super_admin_only_plug.ex`
```
defmodule PlausibleWeb.SuperAdminOnlyPlug do
  @moduledoc false

  use Plausible.Repo

  import Plug.Conn

  def init(options) do
    options
  end

  def call(conn, _opts) do
    current_user = conn.assigns[:current_user]

    if current_user && Plausible.Auth.is_super_admin?(current_user) do
      conn
    else
      conn
      |> PlausibleWeb.UserAuth.log_out_user()
      |> send_resp(403, "Not allowed")
      |> halt()
    end
  end
end
```

## File: `lib/plausible_web/plugs/tracker_plug.ex`
```
defmodule PlausibleWeb.TrackerPlug do
  @moduledoc """
  Plug to serve the Plausible tracker script.
  """

  import Plug.Conn
  use Agent
  use Plausible

  base_variants = [
    "hash",
    "outbound-links",
    "exclusions",
    "compat",
    "local",
    "manual",
    "file-downloads",
    "pageview-props",
    "tagged-events",
    "revenue",
    "pageleave"
  ]

  # Generates Power Set of all variants
  legacy_variants =
    1..Enum.count(base_variants)
    |> Enum.map(fn x ->
      Combination.combine(base_variants, x)
      |> Enum.map(fn y -> Enum.sort(y) |> Enum.join(".") end)
    end)
    |> List.flatten()

  @base_legacy_filenames ["plausible", "script", "analytics"]
  @files_available ["plausible.js", "p.js"] ++
                     Enum.map(legacy_variants, fn v -> "plausible.#{v}.js" end)

  def init(opts) do
    Keyword.merge(opts, files_available: MapSet.new(@files_available))
  end

  def call(conn, files_available: files_available) do
    case conn.request_path do
      "/js/s-" <> path ->
        if String.ends_with?(path, ".js") do
          tag = String.replace_trailing(path, ".js", "")
          request_tracker_script(tag, conn)
        else
          conn
        end

      "/js/p.js" ->
        legacy_request_file("p.js", files_available, conn)

      "/js/" <> requested_filename ->
        sorted_script_variant(requested_filename) |> legacy_request_file(files_available, conn)

      _ ->
        conn
    end
  end

  def telemetry_event(name), do: [:plausible, :tracker_script, :request, name]

  defp request_tracker_script(tag, conn) do
    script_tag = get_plausible_web_script_tag(tag)

    if script_tag do
      :telemetry.execute(
        telemetry_event(:v2),
        %{},
        %{status: 200}
      )

      conn
      |> put_resp_header("content-type", "application/javascript")
      |> put_resp_header("x-content-type-options", "nosniff")
      |> put_resp_header("cross-origin-resource-policy", "cross-origin")
      |> put_resp_header("access-control-allow-origin", "*")
      |> put_resp_header("cache-control", "public, max-age=60, no-transform")
      # CDN-Tag is used by BunnyCDN to tag cached resources. This allows us to purge
      # specific tracker scripts from the CDN cache.
      |> put_resp_header("cdn-tag", "tracker_script::#{tag}")
      |> send_resp(200, script_tag)
      |> halt()
    else
      :telemetry.execute(
        telemetry_event(:v2),
        %{},
        %{status: 404}
      )

      conn
      |> send_resp(404, "Not found")
      |> halt()
    end
  end

  defp get_plausible_web_script_tag(tag) do
    on_ee do
      # On cloud, we generate the script always on the fly relying on CDN caching
      PlausibleWeb.TrackerScriptCache.get_from_source(tag)
    else
      # On self-hosted, we have a pre-warmed cache for the script
      PlausibleWeb.TrackerScriptCache.get(tag)
    end
  end

  defp legacy_request_file(filename, files_available, conn) do
    if filename && MapSet.member?(files_available, filename) do
      location = Application.app_dir(:plausible, "priv/tracker/js/" <> filename)

      :telemetry.execute(
        telemetry_event(:legacy),
        %{},
        %{status: 200}
      )

      conn
      |> put_resp_header("content-type", "application/javascript")
      |> put_resp_header("x-content-type-options", "nosniff")
      |> put_resp_header("cross-origin-resource-policy", "cross-origin")
      |> put_resp_header("access-control-allow-origin", "*")
      |> put_resp_header("cache-control", "public, max-age=86400, must-revalidate")
      |> send_file(200, location)
      |> halt()
    else
      conn
    end
  end

  # Variants which do not factor into output
  @ignore_variants ["js", "pageleave"]

  defp sorted_script_variant(requested_filename) do
    case String.split(requested_filename, ".") do
      [base_filename | rest] when base_filename in @base_legacy_filenames ->
        sorted_variants =
          rest
          |> Enum.reject(&(&1 in @ignore_variants))
          |> Enum.sort()

        Enum.join(["plausible"] ++ sorted_variants ++ ["js"], ".")

      _ ->
        nil
    end
  end
end
```

## File: `lib/plausible_web/plugs/user_session_touch.ex`
```
defmodule PlausibleWeb.Plugs.UserSessionTouch do
  @moduledoc """
  Plug for bumping timeout on user session on every dashboard request.
  """

  import Plug.Conn

  alias Plausible.Auth

  def init(opts \\ []) do
    opts
  end

  def call(conn, _opts) do
    if user_session = conn.assigns[:current_user_session] do
      assign(
        conn,
        :current_user_session,
        Auth.UserSessions.touch(user_session)
      )
    else
      conn
    end
  end
end
```

## File: `lib/plausible_web/remote_ip.ex`
```
defmodule PlausibleWeb.RemoteIP do
  @moduledoc """
  Implements the strategy of retrieving client's remote IP
  """

  def get(conn) do
    x_plausible_ip = List.first(Plug.Conn.get_req_header(conn, "x-plausible-ip")) || ""
    cf_connecting_ip = List.first(Plug.Conn.get_req_header(conn, "cf-connecting-ip")) || ""
    x_forwarded_for = List.first(Plug.Conn.get_req_header(conn, "x-forwarded-for")) || ""
    b_forwarded_for = List.first(Plug.Conn.get_req_header(conn, "b-forwarded-for")) || ""
    forwarded = List.first(Plug.Conn.get_req_header(conn, "forwarded")) || ""

    cond do
      byte_size(x_plausible_ip) > 0 ->
        clean_ip(x_plausible_ip)

      byte_size(cf_connecting_ip) > 0 ->
        clean_ip(cf_connecting_ip)

      byte_size(b_forwarded_for) > 0 ->
        parse_forwarded_for(b_forwarded_for)

      byte_size(x_forwarded_for) > 0 ->
        parse_forwarded_for(x_forwarded_for)

      byte_size(forwarded) > 0 ->
        Regex.named_captures(~r/for=(?<for>[^;,]+).*$/, forwarded)
        |> Map.get("for")
        # IPv6 addresses are enclosed in quote marks and square brackets: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded
        |> String.trim("\"")
        |> clean_ip()

      true ->
        to_string(:inet_parse.ntoa(conn.remote_ip))
    end
  end

  # Removes port from both IPv4 and IPv6 addresses. From https://regexr.com/3hpvt
  # Removes surrounding [] of an IPv6 address
  @port_regex ~r/((\.\d+)|(\]))(?<port>:[0-9]+)$/
  defp clean_ip(ip_and_port) do
    ip =
      case Regex.named_captures(@port_regex, ip_and_port) do
        %{"port" => port} -> String.trim_trailing(ip_and_port, port)
        _ -> ip_and_port
      end

    ip
    |> String.trim_leading("[")
    |> String.trim_trailing("]")
  end

  defp parse_forwarded_for(header) do
    String.split(header, ",")
    |> Enum.map(&String.trim/1)
    |> List.first()
    |> clean_ip()
  end
end
```

## File: `lib/plausible_web/router.ex`
```
defmodule PlausibleWeb.Router do
  use PlausibleWeb, :router
  use Plausible
  import Phoenix.LiveView.Router
  import PhoenixStorybook.Router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_secure_browser_headers
    plug PlausibleWeb.Plugs.NoRobots
    on_ee(do: nil, else: plug(PlausibleWeb.FirstLaunchPlug, redirect_to: "/register"))
    plug PlausibleWeb.AuthPlug
    on_ee(do: plug(Plausible.Plugs.HandleExpiredSession))
    on_ee(do: plug(Plausible.Plugs.SSOTeamAccess))
    plug PlausibleWeb.Plugs.UserSessionTouch
  end

  on_ee do
    pipeline :browser_sso_notice do
      plug :accepts, ["html"]
      plug :fetch_session
      plug :fetch_live_flash
      plug :put_secure_browser_headers
      plug PlausibleWeb.Plugs.NoRobots
      on_ee(do: nil, else: plug(PlausibleWeb.FirstLaunchPlug, redirect_to: "/register"))
      plug PlausibleWeb.AuthPlug
      on_ee(do: plug(Plausible.Plugs.HandleExpiredSession))
      plug PlausibleWeb.Plugs.UserSessionTouch
    end
  end

  pipeline :shared_link do
    plug :accepts, ["html"]
    plug :put_secure_browser_headers
    plug PlausibleWeb.Plugs.NoRobots
  end

  pipeline :csrf do
    plug :protect_from_forgery
  end

  pipeline :app_layout do
    plug :put_root_layout, html: {PlausibleWeb.LayoutView, :app}
  end

  pipeline :external_api do
    plug :accepts, ["json"]
  end

  pipeline :api do
    plug :accepts, ["json"]
    plug :fetch_session
    plug PlausibleWeb.AuthPlug
  end

  pipeline :internal_stats_api do
    plug :accepts, ["json"]
    plug :fetch_session
    plug PlausibleWeb.AuthPlug
    plug PlausibleWeb.Plugs.AuthorizeSiteAccess
    plug PlausibleWeb.Plugs.NoRobots
  end

  pipeline :docs_stats_api do
    plug :accepts, ["json"]
    plug :fetch_session
    plug PlausibleWeb.AuthPlug

    plug PlausibleWeb.Plugs.AuthorizeSiteAccess,
         {[:admin, :editor, :super_admin, :owner], "site_id"}

    plug PlausibleWeb.Plugs.NoRobots
  end

  pipeline :public_api do
    plug :accepts, ["json"]
  end

  on_ee do
    pipeline :flags do
      plug :accepts, ["html"]
      plug :put_secure_browser_headers
      plug PlausibleWeb.Plugs.NoRobots
      plug :fetch_session

      plug PlausibleWeb.AuthPlug
      plug PlausibleWeb.SuperAdminOnlyPlug
    end
  end

  if Mix.env() in [:dev, :ce_dev] do
    forward "/sent-emails", Bamboo.SentEmailViewerPlug
  end

  scope "/" do
    storybook_assets()
  end

  scope "/", PlausibleWeb do
    pipe_through :browser
    live_storybook("/storybook", backend_module: PlausibleWeb.Storybook)
  end

  on_ee do
    scope alias: PlausibleWeb.Live,
          assigns: %{connect_live_socket: true, skip_plausible_tracking: true} do
      pipe_through [:browser, :csrf, :app_layout, :flags]

      live "/cs", CustomerSupport, :index, as: :customer_support

      live "/cs/:any/:resource/:id", CustomerSupport, :details, as: :customer_support_resource
    end
  end

  on_ee do
    scope path: "/flags" do
      pipe_through :flags
      forward "/", FunWithFlags.UI.Router, namespace: "flags"
    end
  end

  on_ee do
    if Mix.env() in [:dev, :test] do
      scope "/dev", PlausibleWeb do
        pipe_through :browser

        get "/billing/create-subscription-form/:plan_id", DevSubscriptionController, :create_form
        get "/billing/update-subscription-form", DevSubscriptionController, :update_form
        get "/billing/cancel-subscription-form", DevSubscriptionController, :cancel_form

        post "/billing/create-subscription/:plan_id", DevSubscriptionController, :create
        post "/billing/update-subscription", DevSubscriptionController, :update
        post "/billing/cancel-subscription", DevSubscriptionController, :cancel
      end
    end
  end

  # Routes for plug integration testing
  if Mix.env() in [:test, :ce_test] do
    scope "/plug-tests", PlausibleWeb do
      scope [] do
        pipe_through :browser

        get("/basic", TestController, :browser_basic)
        get("/:domain/shared-link/:slug", TestController, :browser_basic)
        get("/:domain/with-domain", TestController, :browser_basic)
      end

      scope [] do
        pipe_through :api

        get("/api-basic", TestController, :api_basic)
        get("/:domain/api-with-domain", TestController, :api_basic)
      end
    end
  end

  # SSO routes
  on_ee do
    pipeline :sso_saml do
      plug :accepts, ["html"]

      plug PlausibleWeb.Plugs.SecureSSO

      plug PlausibleWeb.Plugs.NoRobots

      plug :fetch_session
      plug :fetch_live_flash
    end

    pipeline :sso_saml_auth do
      plug :protect_from_forgery, with: :clear_session
    end

    scope "/sso", PlausibleWeb do
      pipe_through [PlausibleWeb.Plugs.GateSSO, :browser, :csrf]

      get "/login", SSOController, :login_form
      post "/login", SSOController, :login
    end

    scope "/sso/saml", PlausibleWeb do
      pipe_through [PlausibleWeb.Plugs.GateSSO, :sso_saml]

      scope [] do
        pipe_through :sso_saml_auth

        get "/signin/:integration_id", SSOController, :saml_signin
      end

      post "/consume/:integration_id", SSOController, :saml_consume
      post "/csp-report", SSOController, :csp_report
    end
  end

  scope path: "/api/plugins", as: :plugins_api do
    pipeline :plugins_api_auth do
      plug(PlausibleWeb.Plugs.AuthorizePluginsAPI)
    end

    pipeline :plugins_api do
      plug(:accepts, ["json"])
      plug(OpenApiSpex.Plug.PutApiSpec, module: PlausibleWeb.Plugins.API.Spec)
    end

    scope "/spec" do
      pipe_through(:plugins_api)
      get("/openapi", OpenApiSpex.Plug.RenderSpec, [])
      get("/swagger-ui", OpenApiSpex.Plug.SwaggerUI, path: "/api/plugins/spec/openapi")
    end

    scope "/v1/capabilities", PlausibleWeb.Plugins.API.Controllers,
      assigns: %{plugins_api: true} do
      pipe_through([:plugins_api])
      get("/", Capabilities, :index)
    end

    scope "/v1", PlausibleWeb.Plugins.API.Controllers, assigns: %{plugins_api: true} do
      pipe_through([:plugins_api, :plugins_api_auth])

      get("/shared_links", SharedLinks, :index)
      get("/shared_links/:id", SharedLinks, :get)
      put("/shared_links", SharedLinks, :create)

      get("/goals", Goals, :index)
      get("/goals/:id", Goals, :get)
      put("/goals", Goals, :create)

      on_ee do
        get("/funnels/:id", Funnels, :get)
        get("/funnels", Funnels, :index)
        put("/funnels", Funnels, :create)
      end

      delete("/goals/:id", Goals, :delete)
      delete("/goals", Goals, :delete_bulk)

      put("/custom_props", CustomProps, :enable)
      delete("/custom_props", CustomProps, :disable)

      get("/tracker_script_configuration", TrackerScriptConfiguration, :get)
      put("/tracker_script_configuration", TrackerScriptConfiguration, :update)
    end
  end

  scope "/api" do
    pipe_through :internal_stats_api

    scope "/stats", PlausibleWeb.Api do
      on_ee do
        get "/:domain/funnels/:id", StatsController, :funnel
      end

      get "/:domain/current-visitors", StatsController, :current_visitors
      get "/:domain/main-graph", StatsController, :main_graph
      get "/:domain/top-stats", StatsController, :top_stats
      get "/:domain/sources", StatsController, :sources
      get "/:domain/channels", StatsController, :channels
      get "/:domain/utm_mediums", StatsController, :utm_mediums
      get "/:domain/utm_sources", StatsController, :utm_sources
      get "/:domain/utm_campaigns", StatsController, :utm_campaigns
      get "/:domain/utm_contents", StatsController, :utm_contents
      get "/:domain/utm_terms", StatsController, :utm_terms
      get "/:domain/referrers/:referrer", StatsController, :referrer_drilldown
      get "/:domain/pages", StatsController, :pages
      get "/:domain/entry-pages", StatsController, :entry_pages
      get "/:domain/exit-pages", StatsController, :exit_pages
      get "/:domain/countries", StatsController, :countries
      get "/:domain/regions", StatsController, :regions
      get "/:domain/cities", StatsController, :cities
      get "/:domain/browsers", StatsController, :browsers
      get "/:domain/browser-versions", StatsController, :browser_versions
      get "/:domain/operating-systems", StatsController, :operating_systems
      get "/:domain/operating-system-versions", StatsController, :operating_system_versions
      get "/:domain/screen-sizes", StatsController, :screen_sizes
      get "/:domain/conversions", StatsController, :conversions
      get "/:domain/custom-prop-values/:prop_key", StatsController, :custom_prop_values
      get "/:domain/suggestions/:filter_name", StatsController, :filter_suggestions

      get "/:domain/suggestions/custom-prop-values/:prop_key",
          StatsController,
          :custom_prop_value_filter_suggestions
    end

    scope "/:domain/segments", PlausibleWeb.Api.Internal do
      post "/", SegmentsController, :create
      patch "/:segment_id", SegmentsController, :update
      delete "/:segment_id", SegmentsController, :delete
    end
  end

  scope "/api/v1/stats", PlausibleWeb.Api,
    assigns: %{api_scope: "stats:read:*", api_context: :site} do
    pipe_through [:public_api, PlausibleWeb.Plugs.AuthorizePublicAPI]

    get "/realtime/visitors", ExternalStatsController, :realtime_visitors
    get "/aggregate", ExternalStatsController, :aggregate
    get "/breakdown", ExternalStatsController, :breakdown
    get "/timeseries", ExternalStatsController, :timeseries
  end

  scope "/api/v2", PlausibleWeb.Api,
    assigns: %{api_scope: "stats:read:*", api_context: :site, schema_type: :public} do
    pipe_through [:public_api, PlausibleWeb.Plugs.AuthorizePublicAPI]

    post "/query", ExternalQueryApiController, :query

    if Mix.env() in [:test, :ce_test] do
      scope assigns: %{schema_type: :internal} do
        post "/query-internal-test", ExternalQueryApiController, :query
      end
    end
  end

  scope "/api/docs", PlausibleWeb.Api do
    get "/query/schema.json", ExternalQueryApiController, :schema

    scope assigns: %{schema_type: :public} do
      pipe_through :docs_stats_api

      post "/query", ExternalQueryApiController, :query
    end
  end

  on_ee do
    scope "/api/v1/sites", PlausibleWeb.Api do
      pipe_through :public_api

      scope assigns: %{api_scope: "sites:read:*"} do
        pipe_through PlausibleWeb.Plugs.AuthorizePublicAPI

        get "/", ExternalSitesController, :index
        get "/teams", ExternalSitesController, :teams_index

        scope assigns: %{api_context: :site} do
          get "/goals", ExternalSitesController, :goals_index
          get "/guests", ExternalSitesController, :guests_index
          get "/:site_id", ExternalSitesController, :get_site
        end
      end

      scope assigns: %{api_scope: "sites:provision:*"} do
        pipe_through PlausibleWeb.Plugs.AuthorizePublicAPI

        post "/", ExternalSitesController, :create_site

        scope assigns: %{api_context: :site} do
          put "/shared-links", ExternalSitesController, :find_or_create_shared_link

          put "/goals", ExternalSitesController, :find_or_create_goal
          delete "/goals/:goal_id", ExternalSitesController, :delete_goal

          put "/guests", ExternalSitesController, :find_or_create_guest
          delete "/guests/:email", ExternalSitesController, :delete_guest

          put "/:site_id", ExternalSitesController, :update_site
          delete "/:site_id", ExternalSitesController, :delete_site
        end
      end
    end
  end

  scope "/api", PlausibleWeb do
    scope [] do
      pipe_through :external_api

      post "/event", Api.ExternalController, :event
      get "/error", Api.ExternalController, :error
      # Remove this once all external checks are migration to new /system/health/* checks
      get "/health", Api.SystemController, :readiness
    end

    scope "/system" do
      get "/", Api.SystemController, :info
      get "/health/live", Api.SystemController, :liveness
      get "/health/ready", Api.SystemController, :readiness
    end

    scope [] do
      pipe_through :api
      post "/paddle/webhook", Api.PaddleController, :webhook
      get "/paddle/currency", Api.PaddleController, :currency

      put "/:domain/disable-feature", Api.InternalController, :disable_feature

      get "/sites", Api.InternalController, :sites
    end
  end

  scope "/", PlausibleWeb do
    pipe_through [:browser, :csrf]

    scope alias: Live, assigns: %{connect_live_socket: true} do
      pipe_through [PlausibleWeb.RequireLoggedOutPlug, :app_layout]

      scope assigns: %{disable_registration_for: [:invite_only, true]} do
        pipe_through PlausibleWeb.Plugs.MaybeDisableRegistration

        live "/register", RegisterForm, :register_form, as: :auth
      end

      scope assigns: %{
              disable_registration_for: true,
              dogfood_page_path: "/register/invitation/:invitation_id"
            } do
        pipe_through PlausibleWeb.Plugs.MaybeDisableRegistration

        live "/register/invitation/:invitation_id", RegisterForm, :register_from_invitation_form,
          as: :auth
      end
    end

    get "/activate", AuthController, :activate_form
    post "/activate/request-code", AuthController, :request_activation_code
    post "/activate", AuthController, :activate
    get "/login", AuthController, :login_form
    post "/login", AuthController, :login
    get "/password/request-reset", AuthController, :password_reset_request_form
    post "/password/request-reset", AuthController, :password_reset_request
    post "/2fa/setup/initiate", AuthController, :initiate_2fa_setup
    get "/2fa/setup/verify", AuthController, :verify_2fa_setup_form
    post "/2fa/setup/verify", AuthController, :verify_2fa_setup
    post "/2fa/disable", AuthController, :disable_2fa
    post "/2fa/recovery_codes", AuthController, :generate_2fa_recovery_codes
    get "/2fa/verify", AuthController, :verify_2fa_form
    post "/2fa/verify", AuthController, :verify_2fa
    get "/2fa/use_recovery_code", AuthController, :verify_2fa_recovery_code_form
    post "/2fa/use_recovery_code", AuthController, :verify_2fa_recovery_code
    get "/password/reset", AuthController, :password_reset_form
    post "/password/reset", AuthController, :password_reset
    get "/avatar/:hash", AvatarController, :avatar
    post "/error_report", ErrorReportController, :submit_error_report
  end

  scope "/", PlausibleWeb do
    pipe_through [:shared_link]

    get "/share/:domain", StatsController, :shared_link
    post "/share/:slug/authenticate", StatsController, :authenticate_shared_link
  end

  scope "/settings", PlausibleWeb do
    pipe_through [:browser, :csrf, PlausibleWeb.RequireAccountPlug]

    get "/", SettingsController, :index
    get "/preferences", SettingsController, :preferences

    post "/preferences/name", SettingsController, :update_name
    post "/preferences/theme", SettingsController, :update_theme

    get "/security", SettingsController, :security
    delete "/security/user-sessions/:id", SettingsController, :delete_session

    post "/security/email/cancel", SettingsController, :cancel_update_email
    post "/security/email", SettingsController, :update_email
    post "/security/password", SettingsController, :update_password

    get "/billing/subscription", SettingsController, :subscription
    get "/billing/invoices", SettingsController, :invoices
    get "/api-keys", SettingsController, :api_keys

    get "/api-keys/new", SettingsController, :new_api_key
    post "/api-keys", SettingsController, :create_api_key
    delete "/api-keys/:id", SettingsController, :delete_api_key

    get "/danger-zone", SettingsController, :danger_zone

    get "/team/general", SettingsController, :team_general
    post "/team/general/name", SettingsController, :update_team_name
    post "/team/leave", SettingsController, :leave_team

    on_ee do
      get "/sso/info", SSOController, :cta
      get "/sso/general", SSOController, :sso_settings
      get "/sso/sessions", SSOController, :team_sessions
      delete "/sso/sessions/:session_id", SSOController, :delete_session
    end

    post "/team/invitations/:invitation_id/accept", InvitationController, :accept_invitation
    post "/team/invitations/:invitation_id/reject", InvitationController, :reject_invitation
    delete "/team/invitations/:invitation_id", InvitationController, :remove_team_invitation
    get "/team/delete", SettingsController, :team_danger_zone
    delete "/team/delete", SettingsController, :delete_team
  end

  on_ee do
    scope "/", PlausibleWeb do
      pipe_through [:browser_sso_notice, :csrf]

      get "/sso/notice", SSOController, :provision_notice
      get "/sso/issue", SSOController, :provision_issue
      get "/logout", AuthController, :logout
      get "/team/select", AuthController, :select_team
    end
  end

  scope "/", PlausibleWeb do
    pipe_through [:browser, :csrf]

    on_ce do
      get "/logout", AuthController, :logout
      get "/team/select", AuthController, :select_team
    end

    delete "/me", AuthController, :delete_me

    get "/auth/google/callback", AuthController, :google_auth_callback

    on_ee do
      get "/helpscout/callback", HelpScoutController, :callback
      get "/helpscout/show", HelpScoutController, :show
      get "/helpscout/search", HelpScoutController, :search
    end

    get "/", PageController, :index

    get "/billing/change-plan/preview/:plan_id", BillingController, :change_plan_preview
    post "/billing/change-plan/:new_plan_id", BillingController, :change_plan
    get "/billing/choose-plan", BillingController, :choose_plan
    get "/billing/upgrade-to-enterprise-plan", BillingController, :upgrade_to_enterprise_plan
    get "/billing/upgrade-success", BillingController, :upgrade_success
    get "/billing/subscription/ping", BillingController, :ping_subscription

    scope alias: Live, assigns: %{connect_live_socket: true} do
      pipe_through [:app_layout, PlausibleWeb.RequireAccountPlug]

      live "/sites", Sites, :index, as: :site
      live "/team/setup", TeamSetup, :setup, as: :team_setup
    end

    get "/sites/new", SiteController, :new
    post "/sites", SiteController, :create_site
    get "/sites/:domain/change-domain", SiteController, :change_domain
    put "/sites/:domain/change-domain", SiteController, :change_domain_submit
    post "/sites/:domain/make-public", SiteController, :make_public
    post "/sites/:domain/make-private", SiteController, :make_private
    post "/sites/:domain/weekly-report/enable", SiteController, :enable_weekly_report
    post "/sites/:domain/weekly-report/disable", SiteController, :disable_weekly_report
    post "/sites/:domain/weekly-report/recipients", SiteController, :add_weekly_report_recipient

    delete "/sites/:domain/weekly-report/recipients/:recipient",
           SiteController,
           :remove_weekly_report_recipient

    post "/sites/:domain/monthly-report/enable", SiteController, :enable_monthly_report
    post "/sites/:domain/monthly-report/disable", SiteController, :disable_monthly_report

    post "/sites/:domain/monthly-report/recipients",
         SiteController,
         :add_monthly_report_recipient

    delete "/sites/:domain/monthly-report/recipients/:recipient",
           SiteController,
           :remove_monthly_report_recipient

    post "/sites/:domain/traffic-change-notification/:type/enable",
         SiteController,
         :enable_traffic_change_notification

    post "/sites/:domain/traffic-change-notification/:type/disable",
         SiteController,
         :disable_traffic_change_notification

    put "/sites/:domain/traffic-change-notification/:type",
        SiteController,
        :update_traffic_change_notification

    post "/sites/:domain/traffic-change-notification/:type/recipients",
         SiteController,
         :add_traffic_change_notification_recipient

    delete "/sites/:domain/traffic-change-notification/:type/recipients/:recipient",
           SiteController,
           :remove_traffic_change_notification_recipient

    get "/sites/:domain/shared-links/new", SiteController, :new_shared_link
    post "/sites/:domain/shared-links", SiteController, :create_shared_link
    get "/sites/:domain/shared-links/:slug/edit", SiteController, :edit_shared_link
    put "/sites/:domain/shared-links/:slug", SiteController, :update_shared_link
    delete "/sites/:domain/shared-links/:slug", SiteController, :delete_shared_link

    get "/sites/:domain/memberships/invite", Site.MembershipController, :invite_member_form
    post "/sites/:domain/memberships/invite", Site.MembershipController, :invite_member

    post "/sites/invitations/:invitation_id/accept", InvitationController, :accept_invitation

    post "/sites/invitations/:invitation_id/reject", InvitationController, :reject_invitation

    delete "/sites/:domain/invitations/:invitation_id", InvitationController, :remove_invitation

    get "/sites/:domain/transfer-ownership", Site.MembershipController, :transfer_ownership_form
    post "/sites/:domain/transfer-ownership", Site.MembershipController, :transfer_ownership

    get "/sites/:domain/change-team", Site.MembershipController, :change_team_form
    post "/sites/:domain/change-team", Site.MembershipController, :change_team

    put "/sites/:domain/memberships/u/:id/role/:new_role",
        Site.MembershipController,
        :update_role_by_user

    delete "/sites/:domain/memberships/u/:id", Site.MembershipController, :remove_member_by_user

    get "/sites/:domain/weekly-report/unsubscribe", UnsubscribeController, :weekly_report
    get "/sites/:domain/monthly-report/unsubscribe", UnsubscribeController, :monthly_report

    scope alias: Live, assigns: %{connect_live_socket: true} do
      pipe_through [:app_layout, PlausibleWeb.RequireAccountPlug]

      scope assigns: %{
              dogfood_page_path: "/:website/installation"
            } do
        live "/:domain/installation", Installation, :installation, as: :site
      end

      scope assigns: %{
              dogfood_page_path: "/:website/installationv2"
            } do
        live "/:domain/installationv2", InstallationV2, :installation_v2, as: :site
      end

      scope assigns: %{
              dogfood_page_path: "/:website/verification"
            } do
        live "/:domain/verification", Verification, :verification, as: :site
      end

      scope assigns: %{
              dogfood_page_path: "/:website/change-domain-v2"
            } do
        live "/:domain/change-domain-v2", ChangeDomainV2, :change_domain_v2, as: :site
      end
    end

    get "/:domain/settings", SiteController, :settings
    get "/:domain/settings/general", SiteController, :settings_general
    get "/:domain/settings/people", SiteController, :settings_people
    get "/:domain/settings/visibility", SiteController, :settings_visibility
    get "/:domain/settings/goals", SiteController, :settings_goals
    get "/:domain/settings/properties", SiteController, :settings_props

    on_ee do
      get "/:domain/settings/funnels", SiteController, :settings_funnels
    end

    get "/:domain/settings/email-reports", SiteController, :settings_email_reports
    get "/:domain/settings/danger-zone", SiteController, :settings_danger_zone
    get "/:domain/settings/integrations", SiteController, :settings_integrations
    get "/:domain/settings/shields/:shield", SiteController, :settings_shields
    get "/:domain/settings/imports-exports", SiteController, :settings_imports_exports

    put "/:domain/settings/features/visibility/:setting",
        SiteController,
        :update_feature_visibility

    put "/:domain/settings", SiteController, :update_settings
    put "/:domain/settings/google", SiteController, :update_google_auth
    delete "/:domain/settings/google-search", SiteController, :delete_google_auth
    delete "/:domain/settings/google-import", SiteController, :delete_google_auth
    delete "/:domain", SiteController, :delete_site
    delete "/:domain/stats", SiteController, :reset_stats

    get "/:domain/import/google-analytics/property",
        GoogleAnalyticsController,
        :property_form

    post "/:domain/import/google-analytics/property",
         GoogleAnalyticsController,
         :property

    get "/:domain/import/google-analytics/confirm", GoogleAnalyticsController, :confirm
    post "/:domain/settings/google-import", GoogleAnalyticsController, :import

    delete "/:domain/settings/forget-imported", SiteController, :forget_imported
    delete "/:domain/settings/forget-import/:import_id", SiteController, :forget_import

    get "/:domain/download/export", SiteController, :download_export
    get "/:domain/settings/import", SiteController, :csv_import

    get "/debug/clickhouse", DebugController, :clickhouse

    get "/:domain/export", StatsController, :csv_export
    get "/:domain/*path", StatsController, :stats
  end
end
```

## File: `lib/plausible_web/storybook.ex`
```
defmodule PlausibleWeb.Storybook do
  @moduledoc false

  use PhoenixStorybook,
    otp_app: :plausible_web,
    title: "Plausible Storybook",
    content_path: Path.expand("../../storybook", __DIR__),
    # assets path are remote path, not local file-system paths
    css_path: "/css/storybook.css",
    js_path: "/js/storybook.js",
    sandbox_class: "plausible",
    color_mode: true
end
```

## File: `lib/plausible_web/templates/auth/activate.html.heex`
```
<PlausibleWeb.Components.FlowProgress.render
  flow={@conn.params["flow"]}
  current_step="Activate account"
/>

<.focus_box>
  <:title>
    <%= if @has_email_code? do %>
      <%= if @has_any_memberships? do %>
        Verify your email address
      <% else %>
        Activate your account
      <% end %>
    <% else %>
      Activate your account
    <% end %>
  </:title>

  <:subtitle :if={@has_email_code?}>
    <p class="truncate">
      Please enter the 4-digit code we sent to <b>{@conn.assigns[:current_user].email}</b>
    </p>
  </:subtitle>

  <:subtitle :if={!@has_email_code?}>
    <p class="truncate">
      A 4-digit activation code will be sent to <b>{@conn.assigns[:current_user].email}</b>
    </p>
  </:subtitle>

  <div :if={@has_email_code?}>
    <.form :let={f} for={@conn} action={@form_submit_url}>
      <.input type="hidden" field={f[:team_identifier]} />
      <.input
        field={f[:code]}
        class="tracking-widest font-medium shadow-sm focus:ring-indigo-500 focus:border-indigo-500 block w-36 px-8 border-gray-300 dark:border-gray-500 rounded-md dark:text-gray-200 dark:bg-gray-900 text-center"
        oninput="this.value=this.value.replace(/[^0-9]/g, ''); if (this.value.length >= 4) document.getElementById('submit').focus()"
        onclick="this.select();"
        maxlength="4"
        placeholder="••••"
        style="letter-spacing: 10px;"
        required={true}
      />
      <.button id="submit" type="submit" class="w-full mt-8">
        Activate
      </.button>
    </.form>
  </div>

  <.error>{@error}</.error>

  <div :if={!@has_email_code?}>
    <.button_link method="post" class="w-full" href="/activate/request-code">
      Request activation code
    </.button_link>
  </div>

  <:footer :if={@has_email_code?}>
    <b>Didn't receive an email?</b>

    <.focus_list>
      <:item>
        Check your spam folder
      </:item>
      <:item>
        <.styled_link href="/activate/request-code" method="post">
          Send a new code
        </.styled_link>
        to {@conn.assigns[:current_user].email}
      </:item>
      <:item :if={ee?()}>
        <.styled_link href="https://plausible.io/contact" new_tab={true}>
          Contact us
        </.styled_link>
        if the problem persists
      </:item>
      <:item :if={ce?()}>
        Ask on our
        <.styled_link href="https://github.com/plausible/analytics/discussions" new_tab={true}>
          community-supported forum
        </.styled_link>
      </:item>
    </.focus_list>

    <b>Entered the wrong email address?</b>

    <.focus_list>
      <:item :if={@has_any_memberships?}>
        <.styled_link method="post" href={Routes.settings_path(@conn, :cancel_update_email)}>
          Change email back to
        </.styled_link>
        {@conn.assigns[:current_user].previous_email}
      </:item>

      <:item :if={not @has_any_memberships?}>
        <.styled_link
          method="delete"
          href="/me?redirect=/register"
          data-confim="Deleting your account cannot be reversed. Are you sure?"
        >
          Delete this account
        </.styled_link>
        and start over
      </:item>
    </.focus_list>
  </:footer>
</.focus_box>
```

## File: `lib/plausible_web/templates/auth/generate_2fa_recovery_codes.html.heex`
```
<.focus_box>
  <:title>
    <%= if @from_setup do %>
      Setup Two-Factor Authentication
    <% else %>
      Your New Recovery Codes
    <% end %>
  </:title>

  <:subtitle>
    Use these recovery codes to log in if you lose access to the authenticator application. Store them somewhere safe!
  </:subtitle>

  <div
    id="recovery-codes-list"
    class="font-mono border-2 border-dotted border-gray-200 dark:border-gray-700 rounded-md text-gray-600 dark:text-gray-200 text-lg bg-gray-100 dark:bg-gray-900 p-2 mt-6 flex flex-wrap"
  >
    <%= for code <- @recovery_codes do %>
      <div class="basis-1/2 text-center">{code}</div>
    <% end %>
  </div>

  <div class="mt-6">
    <button onclick="print(); event.stopPropagation();" id="print" class="button w-full">
      Print Codes <Heroicons.printer class="h-4 w-4 ml-2 mt-1" />
    </button>
    <button
      onclick="var list = document.getElementById('recovery-codes-list'); var selection = getSelection(); selection.removeAllRanges(); var range = createRange(); range.selectNodeContents(list); selection.addRange(range); document.execCommand('copy'); selection.removeAllRanges(); event.stopPropagation(); document.getElementById('copy-base-icon').classList.add('hidden'); document.getElementById('copy-done-icon').classList.remove('hidden'); setTimeout(function() { document.getElementById('copy-done-icon').classList.add('hidden'); document.getElementById('copy-base-icon').classList.remove('hidden'); }, 2000)"
      id="copy"
      class="button w-full mt-4"
    >
      Copy to Clipboard
      <span id="copy-base-icon">
        <Heroicons.document_duplicate class="h-4 w-4 ml-2 mt-1" />
      </span>
      <span id="copy-done-icon" class="hidden">
        <Heroicons.check class="h-4 w-4 ml-2 mt-1" />
      </span>
    </button>
    <button
      id="finish"
      class="button w-full mt-4"
      onclick={"location.replace('#{Routes.settings_path(@conn, :security) <> "#update-2fa"}')"}
    >
      Finish
    </button>
  </div>
</.focus_box>
```

## File: `lib/plausible_web/templates/auth/initiate_2fa_setup.html.heex`
```
<.focus_box>
  <:title>
    Setup Two-Factor Authentication
  </:title>

  <:subtitle>
    Link your Plausible account to the authenticator app you have installed either on your phone or computer.
  </:subtitle>

  <:footer>
    <.focus_list>
      <:item>
        Changed your mind?
        <.styled_link href={Routes.settings_path(@conn, :security) <> "#update-2fa"}>
          Go back to Settings
        </.styled_link>
      </:item>
    </.focus_list>
  </:footer>

  <div class="flex flex-col sm:flex-row items-center sm:items-start">
    <div class="mt-8">
      <div class="border-2 border-gray-300 inline-block p-2 dark:bg-white">
        <PlausibleWeb.Components.TwoFactor.qr_code text={@totp_uri} />
      </div>
    </div>

    <div class="mt-8 sm:ml-4">
      <.focus_list>
        <:item>
          Open the authenticator application
        </:item>
        <:item>
          Tap Scan a QR Code
        </:item>
        <:item>
          Scan this code with your phone camera or paste the code manually
        </:item>
      </.focus_list>
      <div class="sm:ml-2">
        <PlausibleWeb.Live.Components.Form.input_with_clipboard
          id="secret"
          name="secret_clipboard"
          label="Code"
          value={@secret}
          onfocus="this.value = this.value;"
          class="focus:ring-indigo-500 focus:border-indigo-500 bg-gray-50 dark:bg-gray-850 dark:text-gray-300 block w-7/12 rounded-md sm:text-sm border-gray-300 dark:border-gray-500 w-full p-2 mt-2"
        />
      </div>
    </div>
  </div>

  <div class="mt-6 flex flex-col-reverse sm:flex-row justify-between items-center">
    <.unstyled_link
      id="proceed"
      class="button w-full"
      href={Routes.auth_path(@conn, :verify_2fa_setup_form)}
    >
      Proceed
    </.unstyled_link>
  </div>
</.focus_box>
```

## File: `lib/plausible_web/templates/auth/login_form.html.heex`
```
<.focus_box>
  <:title>
    {Phoenix.Flash.get(@flash, :login_title) || "Enter your account credentials"}
  </:title>
  <:subtitle>
    <%= if Phoenix.Flash.get(@flash, :login_instructions) do %>
      <p class="text-gray-500 mt-1 mb-2">
        {Phoenix.Flash.get(@flash, :login_instructions)}
      </p>
    <% end %>
  </:subtitle>
  <.form :let={f} for={@conn} action="/login">
    <div class="my-4 mt-8">
      <.input
        type="email"
        autocomplete="username"
        placeholder="user@example.com"
        field={f[:email]}
        label="Email"
      />
    </div>
    <div class="my-4">
      <.input
        type="password"
        autocomplete="current-password"
        id="current-password"
        field={f[:password]}
        label="Password"
      />
    </div>

    <%= if login_error = Phoenix.Flash.get(@flash, :login_error) do %>
      <div class="text-red-500 mt-4">{login_error}</div>
    <% end %>

    <.input type="hidden" field={f[:return_to]} />

    <.button class="w-full" type="submit">Log in</.button>
  </.form>

  <:footer>
    <.focus_list>
      <:item :if={
        Keyword.fetch!(Application.get_env(:plausible, :selfhost), :disable_registration) == false
      }>
        Don't have an account?
        <.styled_link href="/register">
          Register
        </.styled_link>
        instead.
      </:item>
      <:item :if={ee?() and Plausible.sso_enabled?()}>
        <%= on_ee do %>
          Have a Single Sign-on account?
          <.styled_link href={
            Routes.sso_path(@conn, :login_form,
              return_to: @conn.params["return_to"],
              prefer: "manual"
            )
          }>
            Sign in here
          </.styled_link>
          instead.
        <% end %>
      </:item>
      <:item>
        Forgot password?
        <.styled_link href="/password/request-reset">
          Click here
        </.styled_link>
        to reset it.
      </:item>
    </.focus_list>
  </:footer>
</.focus_box>
```

## File: `lib/plausible_web/templates/auth/password_reset_form.html.heex`
```
{live_render(@conn, PlausibleWeb.Live.ResetPasswordForm,
  container: {:div, class: "contents"},
  session: %{"email" => @email}
)}
```

## File: `lib/plausible_web/templates/auth/password_reset_request_form.html.heex`
```
<.focus_box>
  <:title>
    Reset your password
  </:title>

  <:subtitle>
    Enter your email so we can send a password reset link
  </:subtitle>

  <.form :let={f} for={@conn} action={Routes.auth_path(@conn, :password_reset_request)}>
    <div class="my-4 mt-8">
      <.input type="email" field={f[:email]} placeholder="user@example.com" />
    </div>
    <%= if @conn.assigns[:error] do %>
      <div class="text-red-500 my-2">{@conn.assigns[:error]}</div>
    <% end %>

    <%= if PlausibleWeb.Captcha.enabled?() do %>
      <div class="mt-4">
        <div class="h-captcha" data-sitekey={PlausibleWeb.Captcha.sitekey()}></div>
        <%= if assigns[:captcha_error] do %>
          <div class="text-red-500 text-xs mt-3">{@captcha_error}</div>
        <% end %>
        <script src="https://hcaptcha.com/1/api.js" async defer>
        </script>
      </div>
    <% end %>

    <.button class="w-full" type="submit">Send reset link</.button>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/auth/password_reset_request_success.html.heex`
```
<div class="bg-white dark:bg-gray-800 max-w-md w-full mx-auto shadow-md rounded px-8 pt-6 pb-8 mb-4 mt-8">
  <h2 class="text-xl font-black dark:text-gray-100">Success!</h2>
  <div class="my-4 leading-tight dark:text-gray-100">
    We've sent an email containing password reset instructions to <b>{@email}</b>
    if it's registered in our system.
  </div>
  <div class="mt-8 text-sm dark:text-gray-100">
    Didn't receive the email within a few minutes?
  </div>
  <div class="mt-2 text-sm text-gray-600 dark:text-gray-400 leading-tight">
    You might have used an email address that's not registered in our database. Please verify the email address associated with your Plausible account and attempt the password reset once more.
  </div>
  <div class="mt-2 text-sm text-gray-600 dark:text-gray-400 leading-tight">
    <span :if={ce?()}>
      Certain that you're using the correct email address but still aren't receiving the password reset email? Please check your spam folder or ask on our <a
        href="https://github.com/plausible/analytics/discussions"
        class="text-indigo-500"
      >community-supported forum</a>.
    </span>
    <span :if={ee?()}>
      Certain that you're using the correct email address but still aren't receiving the password reset email? Please check your spam folder or <a
        href="https://plausible.io/contact"
        class="text-indigo-500"
      >contact us</a>.
    </span>
  </div>
</div>
```

## File: `lib/plausible_web/templates/auth/select_team.html.heex`
```
<.focus_box>
  <:title>Switch Team</:title>

  <:subtitle>Switch your current team.</:subtitle>

  <div>
    <ul>
      <li
        :for={team <- @teams_selection}
        class={if team.current?, do: ["border-indigo-400 border-r-4 m-2"], else: ["m-2"]}
      >
        <.unstyled_link href={
          if team.current?,
            do: "#",
            else: Routes.site_path(@conn, :index, __team: team.identifier)
        }>
          <div class="hover:bg-indigo-100 dark:hover:bg-gray-700 p-4">
            <p class="truncate font-medium text-gray-900 dark:text-gray-100" role="none">
              {team.name}
            </p>
            <p class="text-xs text-gray-500 dark:text-gray-400">
              Owner{if team.many_owners?, do: "s"}: {team.owners}
            </p>
          </div>
        </.unstyled_link>
      </li>
    </ul>
  </div>
</.focus_box>
```

## File: `lib/plausible_web/templates/auth/verify_2fa.html.heex`
```
<.focus_box>
  <:title>
    Enter Your 2FA Code
  </:title>

  <:subtitle>
    Enter the code from your authenticator application before it expires or wait for a new one.
  </:subtitle>

  <:footer>
    <.focus_list>
      <:item>
        Can't access your authenticator app?
        <.styled_link href={Routes.auth_path(@conn, :verify_2fa_recovery_code_form)}>
          Use recovery code
        </.styled_link>
      </:item>
      <:item :if={ee?()}>
        Lost your recovery codes?
        <.styled_link href="https://plausible.io/contact">
          Contact us
        </.styled_link>
      </:item>
    </.focus_list>
  </:footer>

  <.form
    :let={f}
    action={Routes.auth_path(@conn, :verify_2fa, Map.take(@conn.query_params, ["return_to"]))}
    for={@conn.params}
    onsubmit="document.getElementById('verify-button').disabled = true"
  >
    <div class="mt-2 text-gray-500 dark:text-gray-200 leading-tight">
      <PlausibleWeb.Components.TwoFactor.verify_2fa_input form={f} field={:code} class="mt-6" />

      <div>
        <.input
          type="checkbox"
          field={f[:remember_2fa]}
          value="true"
          label={"Trust this device for #{@remember_2fa_days} days"}
          class="block h-5 w-5 rounded dark:bg-gray-700 border-gray-300 text-indigo-600 focus:ring-indigo-600"
        />
      </div>

      <.input type="hidden" field={f[:return_to]} />
    </div>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/auth/verify_2fa_recovery_code.html.heex`
```
<.focus_box>
  <:title>
    Enter Recovery Code
  </:title>

  <:subtitle>
    Can't access your authenticator application? Enter a recovery code instead.
  </:subtitle>

  <:footer>
    Authenticator application working again?
    <.styled_link href={Routes.auth_path(@conn, :verify_2fa)}>
      Enter code
    </.styled_link>
    <%= if ee?() do %>
      <br /> Lost your recovery codes?
      <.styled_link href="https://plausible.io/contact">
        Contact us
      </.styled_link>
    <% end %>
  </:footer>

  <.form
    :let={f}
    for={@conn.params}
    action={Routes.auth_path(@conn, :verify_2fa_recovery_code)}
    onsubmit="document.getElementById('use-code-button').disabled = true"
  >
    <div class="mt-6">
      <div>
        <.input
          type="text"
          field={f[:recovery_code]}
          autocomplete="off"
          maxlength="10"
          oninvalid="document.getElementById('use-code-button').disabled = false"
          required="required"
          placeholder="Enter recovery code"
        />
      </div>
      <.button
        id="use-code-button"
        type="submit"
        class="w-full mt-4 [&>span.label-enabled]:block [&>span.label-disabled]:hidden [&[disabled]>span.label-enabled]:hidden [&[disabled]>span.label-disabled]:block"
      >
        <span class="label-enabled pointer-events-none">
          Use Code
        </span>

        <span class="label-disabled">
          <.spinner class="inline-block h-5 w-5 mr-2 text-white dark:text-gray-400" />
          Verifying...
        </span>
      </.button>
    </div>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/auth/verify_2fa_setup.html.heex`
```
<.focus_box>
  <:title>
    Setup Two-Factor Authentication
  </:title>

  <:subtitle>
    Enter the code from your authenticator application before it expires or wait for a new one.
  </:subtitle>

  <:footer>
    <.focus_list>
      <:item>
        Changed your mind?
        <.styled_link href={Routes.settings_path(@conn, :security) <> "#update-2fa"}>
          Go back to Settings
        </.styled_link>
      </:item>
      <:item>
        Having trouble?
        <.styled_link method="post" href={Routes.auth_path(@conn, :initiate_2fa_setup)}>
          Start over
        </.styled_link>
      </:item>
    </.focus_list>
  </:footer>

  <.form
    :let={f}
    for={@conn.params}
    action={Routes.auth_path(@conn, :verify_2fa_setup)}
    id="verify-2fa-form"
    onsubmit="document.getElementById('verify-button').disabled = true"
  >
    <PlausibleWeb.Components.TwoFactor.verify_2fa_input form={f} field={:code} class="mt-6" />
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/billing/change_enterprise_plan_contact_us.html.eex`
```
<div class="mx-auto mt-6 text-center">
  <h1 class="text-3xl font-black dark:text-gray-100">Change subscription plan</h1>
</div>

<div class="w-full max-w-lg px-4 mx-auto mt-4">
  <div class="flex-1 p-8 mt-8 bg-white rounded shadow-md dark:bg-gray-800">
    <div class="w-full pb-4 dark:text-gray-100">
      <span>Looking to adjust your plan?</span>
    </div>

    <ul class="w-full py-4 dark:text-gray-100">
      <span>You're currently on a custom plan. To modify your limits or unlock additional features, please contact us at <a href="mailto:hello@plausible.io" class="underline">hello@plausible.io</a>. We're here to help tailor your plan to your needs.</span>
    </ul>

  </div>
</div>
```

## File: `lib/plausible_web/templates/billing/change_plan_preview.html.heex`
```
<.focus_box>
  <:title>
    Confirm new subscription plan
  </:title>

  <div class="text-lg font-bold dark:text-gray-100">Due now</div>
  <div class="block text-gray-500 dark:text-gray-200 text-sm">
    Your card will be charged a pro-rated amount for the current billing period
  </div>

  <div class="flex flex-col mt-4">
    <div class="-my-2 py-2 overflow-x-auto sm:-mx-6 sm:px-6 lg:-mx-8 lg:px-8">
      <div class="align-middle inline-block min-w-full shadow overflow-hidden sm:rounded-lg border-b border-gray-200 dark:border-t dark:border-l dark:border-r dark:shadow-none">
        <table class="min-w-full">
          <thead>
            <tr>
              <th class="px-6 py-3 border-b border-gray-200 bg-gray-100 dark:bg-gray-900 text-left text-xs leading-4 font-medium text-gray-500 dark:text-gray-200 uppercase tracking-wider">
                Amount
              </th>
              <th class="px-6 py-3 border-b border-gray-200 bg-gray-100 dark:bg-gray-900 text-left text-xs leading-4 font-medium text-gray-500 dark:text-gray-200 uppercase tracking-wider">
                Date
              </th>
            </tr>
          </thead>
          <tbody class="bg-white dark:bg-gray-800">
            <tr class="border-b border-gray-200">
              <td class="px-6 py-4 text-sm leading-5 font-bold dark:text-gray-100">
                {present_currency(@preview_info["immediate_payment"]["currency"])}{@preview_info[
                  "immediate_payment"
                ]["amount"]}
              </td>
              <td class="px-6 py-4 text-sm leading-5 dark:text-gray-100">
                {present_date(@preview_info["immediate_payment"]["date"])}
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="pt-6"></div>

  <div class="py-4 dark:text-gray-100 text-lg font-bold">Next payment</div>

  <div class="flex flex-col">
    <div class="-my-2 py-2 overflow-x-auto sm:-mx-6 sm:px-6 lg:-mx-8 lg:px-8">
      <div class="align-middle inline-block min-w-full shadow overflow-hidden sm:rounded-lg border-b border-gray-200 dark:border-t dark:border-l dark:border-r dark:shadow-none">
        <table class="min-w-full">
          <thead>
            <tr>
              <th class="px-6 py-3 border-b border-gray-200 bg-gray-100 dark:bg-gray-900 text-left text-xs leading-4 font-medium text-gray-500 dark:text-gray-200 uppercase tracking-wider">
                Amount
              </th>
              <th class="px-6 py-3 border-b border-gray-200 bg-gray-100 dark:bg-gray-900 text-left text-xs leading-4 font-medium text-gray-500 dark:text-gray-200 uppercase tracking-wider">
                Date
              </th>
            </tr>
          </thead>
          <tbody class="bg-white dark:bg-gray-800">
            <tr class="border-b border-gray-200">
              <td class="px-6 py-4 text-sm leading-5 font-bold dark:text-gray-100">
                {present_currency(@preview_info["immediate_payment"]["currency"])}{@preview_info[
                  "next_payment"
                ]["amount"]}
              </td>
              <td class="px-6 py-4 text-sm leading-5 dark:text-gray-100">
                {present_date(@preview_info["next_payment"]["date"])}
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="flex items-center justify-between mt-10">
    <span class="flex rounded-md shadow-sm">
      <a
        href={@back_link}
        type="button"
        class="inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-500 text-sm leading-5 font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:text-gray-500 dark:hover:text-gray-200 focus:outline-none focus:border-blue-300 focus:ring active:text-gray-800 dark:active:text-gray-200 active:bg-gray-50 transition ease-in-out duration-150"
      >
        Back
      </a>
    </span>
    <span class="flex space-betwee rounded-md shadow-sm">
      <.button_link
        href={Routes.billing_path(@conn, :change_plan, @preview_info["plan_id"])}
        method="post"
      >
        Confirm plan change
      </.button_link>
    </span>
  </div>

  <div class="text-center mt-8 dark:text-gray-100">
    Questions?
    <.styled_link href="https://plausible.io/contact">Contact us</.styled_link>
  </div>
</.focus_box>
```

## File: `lib/plausible_web/templates/billing/choose_plan.html.heex`
```
{live_render(@conn, @live_module,
  id: "choose-plan",
  session: %{"remote_ip" => PlausibleWeb.RemoteIP.get(@conn)}
)}
```

## File: `lib/plausible_web/templates/billing/upgrade_success.html.heex`
```
<.focus_box>
  <:title>
    Your account is being upgraded...
  </:title>

  <:subtitle>
    Thank you for upgrading your subscription! We're still working on
    upgrading your account, and you'll be automatically redirected in a few
    seconds.
  </:subtitle>

  <p hidden id="timeout-notice" class="text-gray-500 dark:text-gray-200 text-sm">
    Your subscription is taking longer than usual to upgrade. If you're not
    redirected soon, please contact <a class="text-indigo-500" href="mailto:hello@plausible.io">hello@plausible.io</a>.
  </p>

  <div class="loading my-12 mx-auto">
    <div></div>
  </div>

  <script>
    const PING_SUBSCRIPTION_API = "<%= Routes.billing_path(@conn, :ping_subscription) %>"
    const REDIRECT_TO = "<%= Routes.settings_path(@conn, :subscription) %>"
    const PING_EVERY_MS = 2000
    const TIMEOUT_AFTER_MS = 15000

    const ping = async function(fun) {
      let result = {}

      while (!result.is_subscribed) {
        await wait();
        const response = await fetch(PING_SUBSCRIPTION_API)
        result = await response.json()
      }

      window.location = REDIRECT_TO
    }

    const wait = function() {
      return new Promise(resolve => { setTimeout(resolve, PING_EVERY_MS) })
    }

    setTimeout(() => {
      document.getElementById("timeout-notice").removeAttribute("hidden")
    }, TIMEOUT_AFTER_MS)

    // Pings pingSubscriptionUrl every 2 seconds until an active subscription
    // is created from Paddle webhooks.
    ping()
  </script>
</.focus_box>
```

## File: `lib/plausible_web/templates/billing/upgrade_to_enterprise_plan.html.heex`
```
<div class="mx-auto mt-6 text-center">
  <h1 class="text-3xl font-black text-black dark:text-gray-100">
    {if @subscription_resumable,
      do: "Change subscription plan",
      else: "Upgrade to Enterprise"}
  </h1>
</div>
<div class="w-full max-w-lg px-4 mx-auto mt-4 text-gray-900 dark:text-gray-100">
  <div class="flex-1 p-8 mt-8 rounded bg-white shadow-md dark:bg-gray-800 dark:shadow-none">
    <div class="w-full pb-4">
      <span>
        {if @subscription_resumable,
          do:
            "We've prepared your account for an upgrade to custom limits outside the listed plans:",
          else:
            "We've prepared a custom enterprise plan for your account with the following limits:"}
      </span>
    </div>
    <PlausibleWeb.Components.Billing.present_enterprise_plan plan={@latest_enterprise_plan} />
    <ul class="w-full py-4">
      <span>
        The plan is priced at
        <b>
          {case @price do
            %Money{} = money -> Plausible.Billing.format_price(money)
            nil -> "N/A"
          end}
        </b>
      </span>
      <span>
        per {if @latest_enterprise_plan.billing_interval == :yearly,
          do: "year",
          else: "month"} + VAT if applicable. {if @subscription_resumable,
          do:
            "On the next page, our payment provider will calculate the prorated amount that your card will be charged if you decide to upgrade now.",
          else: "Click the button below to upgrade."}
      </span>
    </ul>
    <div class="w-max">
      <%= if @subscription_resumable do %>
        <span class="inline-flex w-full rounded-md shadow-sm">
          <.link
            id="preview-changes"
            href={
              Routes.billing_path(
                @conn,
                :change_plan_preview,
                @latest_enterprise_plan.paddle_plan_id
              )
            }
            class="inline-flex items-center px-4 py-2 text-sm font-medium text-white bg-indigo-600 border border-transparent leading-5 rounded-md hover:bg-indigo-500 focus:outline-none focus:border-indigo-700 focus:ring active:bg-indigo-700 transition ease-in-out duration-150"
          >
            <svg fill="currentColor" viewBox="0 0 20 20" class="inline w-4 h-4 mr-2">
              <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"></path>
              <path
                fill-rule="evenodd"
                d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z"
                clip-rule="evenodd"
              >
              </path>
            </svg>
            Preview changes
          </.link>
        </span>
      <% else %>
        <PlausibleWeb.Components.Billing.paddle_button
          id="paddle-button"
          paddle_product_id={@latest_enterprise_plan.paddle_plan_id}
          user={@current_user}
          team={@current_team}
        >
          <svg fill="currentColor" viewBox="0 0 20 20" class="inline w-4 h-4 mr-2">
            <path
              fill-rule="evenodd"
              d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"
              clip-rule="evenodd"
            >
            </path>
          </svg>
          Pay securely via Paddle
        </PlausibleWeb.Components.Billing.paddle_button>
      <% end %>
    </div>
  </div>
</div>
<div class="mt-8 text-center text-gray-900 dark:text-gray-100">
  Questions? <a class="text-indigo-600" href={@contact_link}>Contact us</a>
</div>
<PlausibleWeb.Components.Billing.paddle_script />
```

## File: `lib/plausible_web/templates/debug/clickhouse.html.heex`
```
<div class="w-full max-w-4xl bg-white dark:bg-gray-800 shadow-md rounded p-8 mb-4 mt-8 mx-auto">
  <section class="grid grid-cols-1 gap-y-3 divide-y">
    <%= for log <- @queries do %>
      <details class="group py-1">
        <summary class="flex cursor-pointer flex-row items-center justify-between py-1 font-semibold text-gray-800 dark:text-gray-200 pt-4">
          {log["request_method"]} {controller_name(log["phoenix_controller"])}.{log[
            "phoenix_action"
          ]} ({log[:query_duration_ms]}ms)
          <svg
            class="h-6 w-6 rotate-0 transform text-gray-400 dark:text-gray-200 group-open:rotate-180"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke-width="2"
            stroke="currentColor"
            aria-hidden="true"
          >
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
          </svg>
        </summary>
        <table class="table table-striped table-auto text-gray-800 dark:text-gray-200">
          <tbody>
            <%= for {key, value} <- log do %>
              <tr class="table-row">
                <td class="table-cell p-2">{key}</td>
                <td class="table-cell p-2">
                  <%= case key do %>
                    <% :query -> %>
                      <pre class="whitespace-pre-wrap"><%= value %></pre>
                    <% "params" -> %>
                      <pre><%= Jason.encode!(value, pretty: true) %></pre>
                    <% _ -> %>
                      {value}
                  <% end %>
                </td>
              </tr>
            <% end %>
          </tbody>
        </table>
      </details>
    <% end %>
  </section>

  <%= if length(@queries) == 0 do %>
    <p class="text-gray-500">
      No queries run by user in the last few minutes. Try opening a dashboard
    </p>
  <% end %>
</div>
```

## File: `lib/plausible_web/templates/email/activation_email.html.heex`
```
Enter {@code} to verify your email address. This code will expire in 4 hours.
```

## File: `lib/plausible_web/templates/email/approaching_accept_traffic_until.html.heex`
```
You used to have an active account with {Plausible.product_name()}, a simple, lightweight, open source and privacy-first Google Analytics alternative.
<br /><br />
We've noticed that you're still sending us stats so we're writing to inform you that we'll stop accepting stats from your sites {@time}. We're an independent, bootstrapped service and we don't sell your data, so this will reduce our server costs and help keep us sustainable.
<br /><br /> If you'd like to continue counting your site stats in a privacy-friendly way, please
<a href={plausible_url() <> "?__team=#{@team.identifier}"}>login to your Plausible account</a> and start a subscription.
<br /><br />
Do you have any questions or need help with anything? Just reply to this email and we'll gladly help.
```

## File: `lib/plausible_web/templates/email/cancellation_email.html.heex`
```
This is Marko, one of the co-founders of Plausible. I’d love to understand the reasons behind your decision to cancel your subscription. We’re solely funded by our subscribers so we genuinely value your feedback. Even a few words would be beneficial in helping us improve our product. Please respond to this email with any insights you can share. Thank you for your time!
```

## File: `lib/plausible_web/templates/email/check_stats_email.html.heex`
```
Plausible is tracking your website stats without compromising the user experience and the privacy of your visitors.
<br /><br /> Here's how to get even more out of your Plausible experience: <br /><br /> *
<a href="https://plausible.io/docs/custom-event-goals">Set up custom events</a> and
<a href="https://plausible.io/docs/pageview-goals">pageview goals</a> to count actions you want your visitors to take<br />
* Running an ecommerce? Assign monetary values to custom events to track
<a href="https://plausible.io/docs/ecommerce-revenue-tracking">revenue attribution</a>
<br /> * Follow the journey from a landing page to conversion with
<a href="https://plausible.io/docs/funnel-analysis">funnel analysis</a>
<br /> *
<a href="https://plausible.io/docs/manual-link-tagging">
  Tag your social media, email and paid links
</a> to see which campaigns are responsible for most conversions<br />
* <a href="https://plausible.io/docs/custom-props/introduction">Send custom properties</a>
to collect data that we don't track automatically <br /> * Explore our
<a href="https://plausible.io/docs/stats-api">stats API</a> to retrieve your stats and our
<a href="https://plausible.io/docs/sites-api">sites API</a> to create and manage sites programmatically<br />
<br /><br />
<a href={plausible_url()}>View your Plausible dashboard now</a>
for the most valuable traffic insights at a glance. <br /><br />
Do reply back to this email if you have any questions or need some guidance.
```

## File: `lib/plausible_web/templates/email/create_site_email.html.heex`
```
You've activated
<%= if ee?() do %>
  your free 30-day trial of
<% end %>
{Plausible.product_name()}, a simple and privacy-friendly website analytics tool. <br /><br />
<a href={"#{plausible_url()}/sites/new"}>Click here</a>
to add your website URL, your timezone and install our one-line JavaScript snippet to start collecting visitor statistics.
<%= if ee?() do %>
  <br /><br />Do reply back to this email if you have any questions or need some guidance.
<% end %>
```

## File: `lib/plausible_web/templates/email/csv_import.html.heex`
```
<%= if @success do %>
  Your CSV import has completed successfully. The Plausible dashboard for {@site_import.site.domain} now contains historical imported data from {date_format(
    @site_import.start_date
  )} to {date_format(@site_import.end_date)}
  <br /><br />
  <a href={@link}>Click here</a>
  to view your dashboard.
<% else %>
  Unfortunately, your CSV import for {@site_import.site.domain} did not complete successfully. Sorry about that!
  <br /><br /> Please try to do the import once again.
  <%= if ee?() do %>
    <br /> <br />
    Please reply to this email to let us know if you're still experiencing issues with the import.
  <% end %>
<% end %>
```

## File: `lib/plausible_web/templates/email/dashboard_locked.html.heex`
```
Last week we sent a reminder that your site traffic has exceeded the limits of your {Plausible.product_name()} subscription tier for two consecutive months. Since we haven't received a response, we've had to temporarily lock access to your stats.
<br /><br />
Your subscription is still active, we're still counting your stats and haven't deleted any of your data but as you have outgrown your subscription tier, we kindly ask you to upgrade to match your new traffic levels. Upon upgrading to a suitable tier, your dashboard access will be immediately restored.
<br /><br />
During the last billing cycle ({PlausibleWeb.TextHelpers.format_date_range(
  @usage.last_cycle.date_range
)}), your account recorded {PlausibleWeb.AuthView.delimit_integer(@usage.last_cycle.total)} billable pageviews. In the billing cycle before that ({PlausibleWeb.TextHelpers.format_date_range(
  @usage.penultimate_cycle.date_range
)}), the usage was {PlausibleWeb.AuthView.delimit_integer(@usage.penultimate_cycle.total)} billable pageviews. Note that billable pageviews include both standard pageviews and custom events. In your
<a href={PlausibleWeb.Router.Helpers.settings_url(PlausibleWeb.Endpoint, :subscription) <> "?__team=#{@team.identifier}"}>account settings</a>, you'll find an overview of your usage and limits.
<br /><br />
<%= if @suggested_volume == :enterprise do %>
  Your usage exceeds our standard plans, so please reply back to this email for a tailored quote.
<% else %>
  <a href={PlausibleWeb.Router.Helpers.billing_url(PlausibleWeb.Endpoint, :choose_plan) <> "?__team=#{@team.identifier}"}>Click here to upgrade your subscription</a>. We recommend you upgrade to the {@suggested_volume} pageviews/month plan. The new charge will be prorated to reflect the amount you have already paid and the time until your current subscription is supposed to expire.
  <br /><br />
  If your usage decreases in the future, you can switch to a lower plan at any time. Any credit balance will automatically apply to future payments.
<% end %>
<br /><br />
Do you have questions or need help with anything? Just reply to this email. We're here to help!
<br /><br /> Thanks for understanding and for being a Plausible subscriber!
```

## File: `lib/plausible_web/templates/email/drop_notification.html.heex`
```
We've recorded {@current_visitors} visitors on
<a href={"https://" <> @site.domain}><%= @site.domain %></a> in the last 12 hours.
<%= if @dashboard_link do %>
  <br /><br /> View dashboard: <a href={@dashboard_link}>{@dashboard_link}</a>
  <br /><br /> Something looks off? Please
  <a href={@installation_link}>review your installation</a>
  to verify that Plausible has been integrated correctly.
<% end %>
```

## File: `lib/plausible_web/templates/email/enterprise_over_limit_internal.html.heex`
```
Automated notice about an enterprise account that has gone over their limits. <br /><br />
Customer email: {@user.email}<br />
Last billing cycle: {PlausibleWeb.TextHelpers.format_date_range(
  @pageview_usage.last_cycle.date_range
)}<br />
Last cycle pageview usage: {PlausibleWeb.AuthView.delimit_integer(
  @pageview_usage.last_cycle.total
)} billable pageviews<br />
Penultimate billing cycle: {PlausibleWeb.TextHelpers.format_date_range(
  @pageview_usage.penultimate_cycle.date_range
)}<br />
Penultimate cycle pageview usage: {PlausibleWeb.AuthView.delimit_integer(
  @pageview_usage.penultimate_cycle.total
)} billable pageviews<br /> Site usage: {@site_usage} / {@site_allowance} allowed sites<br />
```

## File: `lib/plausible_web/templates/email/error_report_email.html.heex`
```
<h1>Error report</h1>
<p>
  Reported by: {@reported_by}
  <br /> Sentry trace: <a href={sentry_link(@trace_id)}>{@trace_id}</a>
  <br />
</p>
<h2>User feedback:</h2>
<pre>
<%= @feedback %>
</pre>
<br />
```

## File: `lib/plausible_web/templates/email/existing_user_invitation.html.heex`
```
{@inviter.email} has invited you to the {@site.domain} site on {Plausible.product_name()}.
<a href={Routes.site_url(PlausibleWeb.Endpoint, :index) <> "?__team=none"}>Click here</a> to view and respond to the invitation. The invitation
will expire 48 hours after this email is sent.
```

## File: `lib/plausible_web/templates/email/existing_user_team_invitation.html.heex`
```
{@inviter.email} has invited you to the "{@team.name}" team on {Plausible.product_name()}.
<a href={Routes.site_url(PlausibleWeb.Endpoint, :index)}>Click here</a> to view and respond to the invitation. The invitation
will expire 48 hours after this email is sent.
```

## File: `lib/plausible_web/templates/email/export_failure.html.heex`
```
Your {Plausible.product_name()} export for {@site.domain} has encountered an error and was unsuccessful.
Sorry for the trouble this may have caused. <br /><br /> Please attempt to export your data again.
<%= if ee?() do %>
  Should the problem persist, do reply to this email so we can assist. Thanks!
<% end %>
```

## File: `lib/plausible_web/templates/email/export_success.html.heex`
```
Your {Plausible.product_name()} export for {@site.domain} is now ready for download.
Please click <a href={@download_url}>here</a>
to start the download process.
<%= if @expires_in do %>
  Note that this link will expire {@expires_in}.
<% end %>
```

## File: `lib/plausible_web/templates/email/google_analytics_import.html.heex`
```
<%= if @success do %>
  Your Google Analytics import has completed successfully. The Plausible dashboard for {@site_import.site.domain} now contains historical imported data from {date_format(
    @site_import.start_date
  )} to {date_format(@site_import.end_date)}
  <br /><br />
  <a href={@link}>Click here</a>
  to view your dashboard.
<% else %>
  Unfortunately, your Google Analytics import for {@site_import.site.domain} did not complete successfully. Sorry about that!
  <br /><br />
  Please try to do the import once again. Sometimes the Google Analytics API just randomly returns empty data. It's intermittent and random. Trying to do the import again may return what you need.
  <%= if ee?() do %>
    <br /> <br />
    Please reply to this email to let us know if you're still experiencing issues with the import.
  <% end %>
<% end %>
```

## File: `lib/plausible_web/templates/email/guest_invitation_accepted.html.heex`
```
{@invitee_email} has accepted your invitation to {@site.domain}.
<a href={Routes.site_url(PlausibleWeb.Endpoint, :settings_general, @site.domain) <> "?__team=#{@team.identifier}"}>Click here</a> to view site settings.
```

## File: `lib/plausible_web/templates/email/guest_invitation_rejected.html.heex`
```
{@guest_invitation.team_invitation.email} has rejected your invitation to {@guest_invitation.site.domain}.
<a href={Routes.site_url(PlausibleWeb.Endpoint, :settings_general, @guest_invitation.site.domain) <> "?__team=#{@team.identifier}"}>Click here</a> to view site settings.
```

## File: `lib/plausible_web/templates/email/guest_to_team_member_promotion.html.heex`
```
{@inviter.email} has promoted you to a team member in the "{@team.name}" team on {Plausible.product_name()}.
<a href={PlausibleWeb.Router.Helpers.site_url(PlausibleWeb.Endpoint, :index) <> "?__team=#{@team.identifier}"}>Click here</a> to view sites managed by the team.
```

## File: `lib/plausible_web/templates/email/new_user_invitation.html.heex`
```
{@inviter.email} has invited you to join the {@site.domain} site on {Plausible.product_name()}.
<a href={
  Routes.auth_url(
    PlausibleWeb.Endpoint,
    :register_from_invitation_form,
    @invitation_id
  )
}>Click here</a> to create your account. The link is valid for 48 hours after this email is sent.
<br /><br />
Plausible is a lightweight and open-source website analytics tool. We hope you like our simple and ethical approach to tracking website visitors.
```

## File: `lib/plausible_web/templates/email/new_user_team_invitation.html.heex`
```
{@inviter.email} has invited you to join the "{@team.name}" team on {Plausible.product_name()}.
<a href={
  Routes.auth_url(
    PlausibleWeb.Endpoint,
    :register_from_invitation_form,
    @invitation_id
  )
}>Click here</a> to create your account. The link is valid for 48 hours after this email is sent.
<br /><br />
Plausible is a lightweight and open-source website analytics tool. We hope you like our simple and ethical approach to tracking website visitors.
```

## File: `lib/plausible_web/templates/email/over_limit.html.heex`
```
Thanks for being a {Plausible.product_name()} subscriber! <br /><br />
This is a friendly reminder that your traffic has exceeded your subscription tier for two consecutive months. Congrats on all that traffic!
<br /><br />
To maintain uninterrupted access to your stats, we kindly ask you to upgrade your account to match your new traffic levels. Please note, if your account isn't upgraded within the next 7 days, access to your stats will be temporarily locked.
<br /><br />
During the last billing cycle ({PlausibleWeb.TextHelpers.format_date_range(
  @usage.last_cycle.date_range
)}), your account recorded {PlausibleWeb.AuthView.delimit_integer(@usage.last_cycle.total)} billable pageviews. In the billing cycle before that ({PlausibleWeb.TextHelpers.format_date_range(
  @usage.penultimate_cycle.date_range
)}), your account used {PlausibleWeb.AuthView.delimit_integer(@usage.penultimate_cycle.total)} billable pageviews. Note that billable pageviews include both standard pageviews and custom events. In your
<a href={plausible_url() <> PlausibleWeb.Router.Helpers.settings_path(PlausibleWeb.Endpoint, :subscription) <> "?__team=#{@team.identifier}"}>account settings</a>, you'll find an overview of your usage and limits.
<br /><br />
<%= if @suggested_volume == :enterprise do %>
  Your usage exceeds our standard plans, so please reply back to this email for a tailored quote.
<% else %>
  <a href={PlausibleWeb.Router.Helpers.billing_url(PlausibleWeb.Endpoint, :choose_plan) <> "?__team=#{@team.identifier}"}>Click here to upgrade your subscription</a>. We recommend you upgrade to the {@suggested_volume} pageviews/month plan. The new charge will be prorated to reflect the amount you have already paid and the time until your current subscription is supposed to expire.
  <br /><br />
  If your usage decreases in the future, you can switch to a lower plan at any time. Any credit balance will automatically apply to future payments.
<% end %>
<br /><br />
Do you have questions or need help with anything? Just reply to this email. We're here to help!
<br /><br /> Thanks again for using our product and for your support!
```

## File: `lib/plausible_web/templates/email/ownership_transfer_accepted.html.heex`
```
{@new_owner_email} has accepted the ownership transfer of {@site.domain}. They will be responsible for billing of it going
forward<%= if @initiator_as_guest_editor? do %>
  and your role has been changed to <b>guest editor</b>.
  <a href={Routes.site_url(PlausibleWeb.Endpoint, :settings_general, @site.domain) <> "?__team=none"}>
    Click here
  </a>
  to view site settings.
<% else %>
  <a href={Routes.site_url(PlausibleWeb.Endpoint, :settings_general, @site.domain) <> "?__team=#{@team.identifier}"}>
    Click here
  </a>
  to view site settings.
<% end %>
```

## File: `lib/plausible_web/templates/email/ownership_transfer_rejected.html.heex`
```
{@site_transfer.email} has rejected the ownership transfer of {@site_transfer.site.domain}.
<a href={Routes.site_url(PlausibleWeb.Endpoint, :settings_general, @site_transfer.site.domain) <> "?__team=#{@team.identifier}"}>Click here</a> to view site settings.
```

## File: `lib/plausible_web/templates/email/ownership_transfer_request.html.heex`
```
{@inviter.email} has requested to transfer the ownership of {@site.domain} site on {Plausible.product_name()} to you.
<%= if @new_owner_account do %>
  <a href={Routes.site_url(PlausibleWeb.Endpoint, :index)}>Click here</a>
  to view and respond to the invitation.
<% else %>
  <a
    phx-no-format
    href={Routes.auth_url(PlausibleWeb.Endpoint, :register_from_invitation_form, @invitation_id)}
  >Click here</a> to create your account. <br /><br />
  Plausible is a lightweight and open-source website analytics tool. We hope you like our simple and ethical approach to tracking website visitors.
<% end %>
```

## File: `lib/plausible_web/templates/email/password_reset_email.html.heex`
```
<a href={@reset_link}>Click here</a>
to reset your Plausible password.<br /><br />
This link will expire in 1 hour. If you don't use it by then, you can request another login link.
```

## File: `lib/plausible_web/templates/email/site_member_removed.html.heex`
```
An administrator of {@guest_membership.site.domain} has removed you as a member. You won't be able to see the stats anymore.
<br /><br />
<a href={Routes.site_url(PlausibleWeb.Endpoint, :index) <> "?__team=none"}>Click here</a>
to view your sites.
```

## File: `lib/plausible_web/templates/email/site_setup_help_email.html.heex`
```
<%= if ee?() and Plausible.Teams.on_trial?(@site_team) do %>
  You signed up for a free 30-day trial of Plausible, a simple and privacy-friendly website analytics tool.
  <br /><br />
<% end %>
To finish your setup for {@site.domain}, review
<a href={"#{plausible_url()}/#{URI.encode_www_form(@site.domain)}/installation?__team=#{@site_team.identifier}"}>your installation</a> and start collecting visitor statistics.
<br /><br />
This Plausible script is 45 times smaller than Google Analytics script so you’ll have a fast loading site while getting all the important traffic insights on one single page.
<br /><br /> On WordPress? We have a
<a href="https://plausible.io/wordpress-analytics-plugin">WordPress plugin</a> that makes the process simpler. We also have
<a href="https://plausible.io/docs/integration-guides">integration guides</a> for different site builders to help you start counting stats in no time.
<%= if ee?() do %>
  <br /><br /> Do reply back to this email if you have any questions or need some guidance.
<% end %>
```

## File: `lib/plausible_web/templates/email/site_setup_success_email.html.heex`
```
Congrats! We've recorded the first visitor on
<a href={"https://#{@site.domain}"}><%= @site.domain %></a>. Your traffic is now being counted without compromising the user experience and privacy of your visitors.
<br /><br />
Do check out your <a href={"#{plausible_url()}/#{URI.encode_www_form(@site.domain)}?__team=#{@site_team.identifier}"}>easy to use, fast-loading and privacy-friendly dashboard</a>.
<br /><br />
Something looks off? Take a look at our <a href="https://plausible.io/docs/troubleshoot-integration">installation troubleshooting guide</a>.
<br /><br />
<%= if (ee?() and Plausible.Teams.on_trial?(@site_team)) do %>
  You're on a 30-day free trial with no obligations so do take your time to explore Plausible.
  Here's how to get <a href="https://plausible.io/docs/your-plausible-experience">the most out of your Plausible experience</a>.
  <br /><br />
<% end %>
PS: You can import your historical Google Analytics stats into your Plausible dashboard.
<a href="https://plausible.io/docs/google-analytics-import">Learn how our GA importer works</a>.
<br /><br />
<%= unless Plausible.ce?() do %>
  Do reply back to this email if you have any questions. We're here to help.
<% end %>
```

## File: `lib/plausible_web/templates/email/spike_notification.html.heex`
```
There are currently <b>{@current_visitors}</b>
visitors on <a href={"https://" <> @site.domain}><%= @site.domain %></a>. <br />
<%= if Enum.count(@sources) > 0 do %>
  <br /> The top sources for current visitors:<br />
  <ul>
    <%= for %{dimensions: [source], metrics: [visitors]} <- @sources do %>
      <li>
        <b>{visitors}</b> visitor{if visitors > 1, do: "s"} from <b>{source}</b>
      </li>
    <% end %>
  </ul>
<% end %>

<br /> Your top pages being visited:<br />
<ul>
  <%= for %{dimensions: [page], metrics: [visitors]} <- @pages do %>
    <li>
      <b>{visitors}</b> visitor{if visitors > 1, do: "s"} on <b>{page}</b>
    </li>
  <% end %>
</ul>

<%= if @link do %>
  <br /> View dashboard: <a href={@link}>{@link}</a>
<% end %>
<br /><br /> Congrats on the spike in traffic!
<%= if ce?() do %>
  <br /><br /> Plausible CE is funded by our cloud subscribers. If you
  <a href="https://plausible.io/?utm_medium=email&utm_source=CE">enjoy using Plausible</a>
  and know someone who might benefit from it, please spread the word.
<% end %>
```

## File: `lib/plausible_web/templates/email/sso_domain_verification_failure.html.heex`
```
We were unable to verify the SSO domain '{@domain}' you attempted to set up. Despite multiple attempts, the validation process could not be completed and we have exhausted all automatic retries.<br />
Please review your domain configuration and follow our configuration guide to resolve common issues:
<a href="https://plausible.io/docs/sso" target="_blank">SSO Documentation</a>.
```

## File: `lib/plausible_web/templates/email/sso_domain_verification_success.html.heex`
```
We are pleased to inform you that your Single Sign-On (SSO) domain '{@domain}' has been successfully verified and is now ready for use.<br />
You can now enable SSO for your organization and allow users to sign in using their corporate credentials.
```

## File: `lib/plausible_web/templates/email/team_changed.html.heex`
```
{@user.email} has transferred {@site.domain} to the "{@team.name}" team on Plausible Analytics.
<a href={Routes.stats_url(PlausibleWeb.Endpoint, :stats, @site.domain, []) <> "?__team=#{@team.identifier}"}>Click here</a> to view the stats.
```

## File: `lib/plausible_web/templates/email/team_invitation_accepted.html.heex`
```
{@invitee_email} has accepted your invitation to "{@team.name}" team.
<a href={Routes.settings_url(PlausibleWeb.Endpoint, :team_general) <> "?__team=#{@team.identifier}"}>Click here</a> to view team settings.
```

## File: `lib/plausible_web/templates/email/team_invitation_rejected.html.heex`
```
{@team_invitation.email} has rejected your invitation to \"{@team.name}\" team.
<a href={Routes.settings_url(PlausibleWeb.Endpoint, :team_general) <> "?__team=#{@team.identifier}"}>Click here</a> to view team settings.
```

## File: `lib/plausible_web/templates/email/team_member_left.html.heex`
```
You are no longer a member of "{@team_membership.team.name}" team. <br /><br />
<a href={Routes.site_url(PlausibleWeb.Endpoint, :index) <> "?__team=none"}>Click here</a>
to view your sites.
```

## File: `lib/plausible_web/templates/email/team_member_removed.html.heex`
```
An administrator of "{@team_membership.team.name}" team has removed you as a member. <br /><br />
<a href={Routes.site_url(PlausibleWeb.Endpoint, :index) <> "?__team=none"}>Click here</a>
to view your sites.
```

## File: `lib/plausible_web/templates/email/trial_one_week_reminder.html.heex`
```
Time flies! Your 30-day free trial of Plausible will end next week. <br /><br />
Over the last three weeks, We hope you got to experience the potential benefits of having website stats in an easy to use dashboard while respecting the privacy of your visitors, not annoying them with the cookie and privacy notices and still having a fast loading site.
<br /><br />
In order to continue receiving valuable website traffic insights at a glance, you’ll need to
<a href={PlausibleWeb.Router.Helpers.billing_url(PlausibleWeb.Endpoint, :choose_plan) <> "?__team=#{@team.identifier}"}>upgrade your account</a>.
<br /><br /> If you have any questions or feedback for us, feel free to reply to this email.
```

## File: `lib/plausible_web/templates/email/trial_over_email.html.heex`
```
Your free Plausible trial has now expired. Upgrade your account to continue receiving valuable website traffic insights at a glance while respecting the privacy of your visitors and still having a fast loading site.
<br /><br />

<a href={PlausibleWeb.Router.Helpers.billing_url(PlausibleWeb.Endpoint, :choose_plan) <> "?__team=#{@team.identifier}"}>
  Upgrade now
</a>
<br /><br /> We will keep recording stats for {@extra_offset} days to give you time to upgrade.
```

## File: `lib/plausible_web/templates/email/trial_upgrade_email.html.heex`
```
Thanks for exploring Plausible, a simple and privacy-friendly alternative to Google Analytics. Your free 30-day trial is ending {@day}, but you can keep using Plausible by upgrading to a paid plan.
<br /><br />
In the last month, your account has used {PlausibleWeb.AuthView.delimit_integer(@usage)} billable pageviews{if @custom_events >
                                                                                                                 0,
                                                                                                               do:
                                                                                                                 " and custom events in total",
                                                                                                               else:
                                                                                                                 ""}.
<%= if @suggested_volume == :enterprise do %>
  This is more than our standard plans, so please reply back to this email to get a quote for your volume.
<% else %>
  Based on that we recommend you select a {@suggested_volume} pageviews/month plan. <br /><br />
  <a href={PlausibleWeb.Router.Helpers.billing_url(PlausibleWeb.Endpoint, :choose_plan) <> "?__team=#{@team.identifier}"}>
    Upgrade now
  </a>
  <br /><br />
  Have a question, feedback or need some guidance? Just reply to this email to get in touch!
<% end %>
```

## File: `lib/plausible_web/templates/email/two_factor_disabled_email.html.heex`
```
Two-Factor Authentication is now disabled on your account.
```

## File: `lib/plausible_web/templates/email/two_factor_enabled_email.html.heex`
```
Two-Factor Authentication is now enabled on your account.
```

## File: `lib/plausible_web/templates/email/welcome_email.html.heex`
```
We are building Plausible to provide a simple and ethical approach to tracking website visitors.
We're super excited to have you on board! <br /><br />
Here's how to get the most out of your Plausible experience: <br /><br /> *
<a href="https://plausible.io/docs/email-reports">Enable email reports</a> and notifications for
<a href="https://plausible.io/docs/traffic-spikes">traffic spikes</a>
<br /> *
<a href="https://plausible.io/docs/google-search-console-integration">Integrate with Search Console</a> to get keyword phrases people find your site with<br />
* <a href="https://plausible.io/docs/users-roles">Invite team members and other collaborators</a>
<br /> * Set up easy goals including
<a href="https://plausible.io/docs/error-pages-tracking-404">404 error pages</a>,
<a href="https://plausible.io/docs/file-downloads-tracking">file downloads</a> and
<a href="https://plausible.io/docs/outbound-link-click-tracking">outbound link clicks</a>
<br /> * <a href="https://plausible.io/docs/excluding">Opt out from counting your own visits</a>
<br /> * If you're concerned about adblockers,
<a href="https://plausible.io/docs/proxy/introduction">set up a proxy to bypass them</a>
<br />
<br /><br /> Then you're ready to start exploring your fast loading, ethical and actionable
<a href="https://plausible.io/sites">Plausible dashboard</a>. <br /><br />
Have a question, feedback or need some guidance? Do reply back to this email.
```

## File: `lib/plausible_web/templates/email/yearly_expiration_notification.html.heex`
```
Time flies! This is a reminder that your annual subscription for {Plausible.product_name()} will expire on {@next_bill_date}.
<br /><br /> You need to
<a href={PlausibleWeb.Router.Helpers.billing_url(PlausibleWeb.Endpoint, :choose_plan) <> "?__team=#{@team.identifier}"}>renew your subscription</a> if you want to continue using Plausible to count your website stats in a privacy-friendly way.
<br /><br />
If you don't want to continue your subscription, there's no action required. You will lose access to your dashboard on {@next_bill_date} and we'll stop accepting stats on {@accept_traffic_until}.
<br /><br />
Have a question, feedback or need some guidance? Just reply to this email to get in touch!
```

## File: `lib/plausible_web/templates/email/yearly_renewal_notification.html.heex`
```
Time flies! This is a reminder that your annual subscription for {Plausible.product_name()} is due to renew on {@date}. We will automatically charge {PlausibleWeb.BillingView.present_currency(
  @currency
)}{@next_bill_amount} from your preferred billing method. <br /><br />
There's no action required if you're happy to continue using Plausible to count your website stats in a privacy-friendly way.
<br /><br /> If you don't want to continue your subscription, you can cancel it on your
<a href={"#{plausible_url()}/settings?__team=#{@team.identifier}"}>account settings page</a>.
<br /><br />
BTW, most of our subscribers come from word of mouth, so if you love Plausible, and know someone else who might find it useful, we'd appreciate if you'd let them know. Thank you!
<br /><br /> Have a question, feedback or need some guidance? Do reply back to this email.
```

## File: `lib/plausible_web/templates/error/404_error.html.heex`
```
<div class="container flex flex-col items-center text-center mt-24">
  <h1 class="text-5xl font-black dark:text-gray-100">{@status}</h1>
  <div class="mt-4 text-xl dark:text-gray-100">Oops! There's nothing here</div>

  <div :if={!@conn.assigns[:current_user]} class="text-xl dark:text-gray-100">
    Trying to access your dashboard? You may need to log in again to see it
  </div>
  <div class="mt-4 flex">
    <.button_link
      :if={!@conn.assigns[:current_user]}
      href={Routes.auth_path(@conn, :login_form, return_to: url_path(@conn))}
      class="mr-4"
    >
      Log in
    </.button_link>
    <.button_link theme="bright" href={PlausibleWeb.LayoutView.home_dest(@conn)}>
      Go to homepage
    </.button_link>
  </div>
</div>
```

## File: `lib/plausible_web/templates/error/generic_error.html.heex`
```
<div class="container text-center mt-24">
  <h1 class="text-5xl font-black dark:text-gray-100">{@status}</h1>
  <div class="my-4 text-xl dark:text-gray-100">{@message}</div>
  <.button_link href={PlausibleWeb.LayoutView.home_dest(@conn)}>Go to homepage</.button_link>
</div>
```

## File: `lib/plausible_web/templates/error/server_error.html.heex`
```
<div class="w-full max-w-3xl mt-4 mx-auto flex">
  <div class="max-w-lg w-full mx-auto bg-white dark:bg-gray-800 shadow-lg rounded px-8 pt-6 pb-8 mb-4 mt-8">
    <h2 class="text-xl font-black dark:text-gray-100">Oops, sorry about that...</h2>

    <div class="rounded-md bg-yellow-50 dark:bg-transparent dark:border border-yellow-200 p-4 mt-4">
      <div class="flex">
        <div class="flex-shrink-0">
          <svg
            class="h-5 w-5 text-yellow-400 dark:text-yellow-300"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 20 20"
            fill="currentColor"
            aria-hidden="true"
          >
            <path
              fill-rule="evenodd"
              d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
              clip-rule="evenodd"
            />
          </svg>
        </div>
        <div class="ml-3">
          <h3 class="text-sm font-medium text-yellow-800 dark:text-yellow-400">
            There has been a server error.
            <%= if ee?() do %>
              But don't worry, we're on it!
            <% end %>
          </h3>

          <div class="mt-2 text-sm text-yellow-700 dark:text-yellow-300">
            <p>
              <%= if assigns[:trace_id] && ee?() do %>
                If you would like to help, tell us what you were trying to do. Our development team will receive your report.
              <% else %>
                We have been notified.
              <% end %>
            </p>
          </div>
        </div>
      </div>
    </div>

    <%= if ee?() do %>
      <%= if assigns[:trace_id] do %>
        <div class="my-6">
          <.form
            :let={f}
            for={%{}}
            as={:error}
            action={Routes.error_report_path(PlausibleWeb.Endpoint, :submit_error_report)}
          >
            <.input type="hidden" field={f[:trace_id]} value={@trace_id} />
            <PlausibleWeb.Live.Components.Form.label for="user_feedback">
              What happened?
            </PlausibleWeb.Live.Components.Form.label>
            <textarea
              name="user_feedback"
              id="user_feedback"
              rows="5"
              class="block w-full max-w-xl border-gray-300 dark:border-gray-700 resize-none shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md dark:bg-gray-900 dark:text-gray-300"
              placeholder="I clicked on 'X' and then hit 'Confirm'..."
            >
        </textarea>
            <.button class="w-full" type="submit">Send feedback</.button>
          </.form>
        </div>
      <% end %>

      <div class="mb-6 mt-12">
        <div class="flex gap-x-5 text-sm justify-center">
          <.styled_link href="/">
            Home page
          </.styled_link>
          <.styled_link href="https://status.plausible.io">
            Status page
          </.styled_link>
          <.styled_link href="https://plausible.io/contact">
            Contact us
          </.styled_link>
        </div>
      </div>
    <% end %>
  </div>
</div>
```

## File: `lib/plausible_web/templates/error/server_error_report_thanks.html.heex`
```
<div class="w-full max-w-3xl mt-4 mx-auto flex">
  <div class="max-w-lg w-full mx-auto bg-white dark:bg-gray-800 shadow-lg rounded px-8 pt-6 pb-8 mb-4 mt-8">
    <h2 class="text-xl font-black dark:text-gray-100">Thank you!</h2>

    <div class="rounded-md dark:bg-transparent mt-4">
      <div class="flex">
        <h3 class="text-sm font-medium dark:text-gray-100">
          Your report has been submitted.
        </h3>
      </div>
    </div>
    <div class="mb-6 mt-12">
      <div class="flex gap-x-5 text-sm justify-center">
        <.styled_link href={PlausibleWeb.LayoutView.home_dest(@conn)}>
          Home page
        </.styled_link>
        <.styled_link href="https://status.plausible.io">
          Status page
        </.styled_link>
        <.styled_link href="https://plausible.io/contact">
          Contact us
        </.styled_link>
      </div>
    </div>
  </div>
</div>
```

## File: `lib/plausible_web/templates/google_analytics/confirm.html.heex`
```
<.form
  :let={f}
  for={@conn}
  class="max-w-md w-full mx-auto bg-white dark:bg-gray-800 shadow-md rounded px-8 pt-6 pb-8 mb-4 mt-8"
  onsubmit="confirmButton.disabled = true; return true;"
  action={Routes.google_analytics_path(@conn, :import, @site.domain)}
>
  <h2 class="text-xl font-black dark:text-gray-100">Import from Google Analytics</h2>

  <.input type="hidden" field={f[:access_token]} />
  <.input type="hidden" field={f[:refresh_token]} />
  <.input type="hidden" field={f[:expires_at]} />

  <div class="mt-6 text-sm text-gray-500 dark:text-gray-200">
    Stats from this property and time period will be imported from
    your Google Analytics account to your Plausible dashboard
  </div>

  <div class="mt-6">
    <.label for={f[:property].id}>Google Analytics property</.label>
    <span class="block w-full text-base dark:text-gray-100 sm:text-sm dark:bg-gray-800">
      {@selected_property_name}
    </span>
    <.input type="hidden" value={@selected_property} field={f[:property]} readonly="true" />
  </div>
  <div class="flex justify-between mt-3">
    <div class="w-36">
      <.label for={f[:start_date].id}>From</.label>
      <span class="block w-full text-base dark:text-gray-100 sm:text-sm dark:bg-gray-800">
        {PlausibleWeb.EmailView.date_format(@start_date)}
      </span>
      <.input type="hidden" value={@start_date} field={f[:start_date]} readonly="true" />
    </div>
    <div class="align-middle pt-4 dark:text-gray-100">&rarr;</div>
    <div class="w-36">
      <.label for={f[:end_date].id}>To</.label>
      <span class="block w-full text-base dark:text-gray-100 sm:text-sm dark:bg-gray-800">
        {PlausibleWeb.EmailView.date_format(@end_date)}
      </span>
      <.input type="hidden" value={@end_date} field={f[:end_date]} readonly="true" />
    </div>
  </div>

  <div class="mt-6 flex flex-col-reverse sm:flex-row justify-between items-center">
    <p class="text-sm mt-4 sm:mt-0 dark:text-gray-100">
      <a
        href={
          Routes.google_analytics_path(@conn, :property, @site.domain,
            property: @selected_property,
            access_token: @access_token,
            refresh_token: @refresh_token,
            expires_at: @expires_at
          )
        }
        class="underline text-indigo-600"
      >
        Go back
      </a>
    </p>

    <.button
      type="submit"
      name="confirmButton"
      class="button sm:w-auto w-full [&>span.label-enabled]:block [&>span.label-disabled]:hidden [&[disabled]>span.label-enabled]:hidden [&[disabled]>span.label-disabled]:block"
    >
      <span class="label-enabled pointer-events-none">
        Confirm import
      </span>

      <span class="label-disabled">
        <.spinner class="inline-block h-5 w-5 mr-2 text-white dark:text-gray-400" />
        Starting import...
      </span>
    </.button>
  </div>
</.form>
```

## File: `lib/plausible_web/templates/google_analytics/property_form.html.heex`
```
<.focus_box>
  <:title>
    Import from Google Analytics
  </:title>

  <:subtitle>
    Choose the property in your Google Analytics account that will be imported to the {@site.domain} dashboard.
  </:subtitle>
  <.form
    :let={f}
    for={@conn}
    onsubmit="continueButton.disabled = true; return true;"
    action={Routes.google_analytics_path(@conn, :property, @site.domain)}
  >
    <.input type="hidden" field={f[:access_token]} />
    <.input type="hidden" field={f[:refresh_token]} />
    <.input type="hidden" field={f[:expires_at]} />

    <div class="mt-3">
      <.input
        type="select"
        field={f[:property]}
        prompt="(Choose property)"
        options={@properties}
        label="Google Analytics property"
        required="true"
      />

      <p class="text-red-600 dark:text-red-700">
        {@conn.assigns[:selected_property_error]}
      </p>
    </div>

    <div class="mt-6 flex flex-col-reverse sm:flex-row justify-between items-center">
      <p class="mt-4 sm:mt-0 dark:text-gray-100">
        <a
          href={Routes.site_path(@conn, :settings_imports_exports, @site.domain)}
          class="underline text-indigo-600"
        >
          Go back
        </a>
      </p>

      <.button
        type="submit"
        name="continueButton"
        class="button sm:w-auto w-full [&>span.label-enabled]:block [&>span.label-disabled]:hidden [&[disabled]>span.label-enabled]:hidden [&[disabled]>span.label-disabled]:block"
      >
        <span class="label-enabled pointer-events-none">
          Continue
        </span>

        <span class="label-disabled">
          <.spinner class="inline-block h-5 w-5 mr-2 text-white dark:text-gray-400" /> Checking...
        </span>
      </.button>
    </div>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/layout/_flash.html.heex`
```
<%= if Phoenix.Flash.get(@flash, :success) do %>
  <div class="z-50 fixed inset-0 flex items-end justify-center px-4 py-6 pointer-events-none sm:p-6 sm:items-start sm:justify-end">
    <div
      x-data={"{ show: true, ttl: #{Phoenix.Flash.get(@flash, :ttl) || 4000} }"}
      x-show="show"
      x-init="setTimeout(() => show = false, ttl)"
      x-transition:enter="transform ease-out duration-300 transition"
      x-transition:enter-start="translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2"
      x-transition:enter-end="translate-y-0 opacity-100 sm:translate-x-0"
      x-transition:leave="transition ease-in duration-100"
      x-transition:leave-start="opacity-100"
      x-transition:leave-end="opacity-0"
      class="max-w-sm w-full bg-white dark:bg-gray-800 shadow-lg rounded-lg pointer-events-auto"
    >
      <div class="rounded-lg ring-1 ring-black ring-opacity-5 overflow-hidden">
        <div class="p-4">
          <div class="flex items-start">
            <div class="flex-shrink-0">
              <svg
                class="h-6 w-6 text-green-400"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
                />
              </svg>
            </div>
            <div class="ml-3 w-0 flex-1 pt-0.5">
              <p class="text-sm leading-5 font-medium text-gray-900 dark:text-gray-100">
                {Phoenix.Flash.get(@flash, :success_title) || "Success!"}
              </p>
              <p class="mt-1 text-sm leading-5 text-gray-500 dark:text-gray-200">
                {Phoenix.Flash.get(@flash, :success)}
              </p>
            </div>
            <div class="ml-4 flex-shrink-0 flex">
              <button
                class="inline-flex text-gray-400 focus:outline-none focus:text-gray-500 dark:focus:text-gray-200 transition ease-in-out duration-150"
                @click="show = false"
              >
                <!-- Heroicon name: x -->
                <svg
                  class="h-5 w-5"
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                    clip-rule="evenodd"
                  />
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
<% end %>

<%= if Phoenix.Flash.get(@flash, :error) do %>
  <div class="z-50 fixed inset-0 flex items-end justify-center px-4 py-6 pointer-events-none sm:p-6 sm:items-start sm:justify-end">
    <div
      x-data={"{ show: true, ttl: #{Phoenix.Flash.get(@flash, :ttl) || 4000} }"}
      x-show="show"
      x-init="setTimeout(() => show = false, ttl)"
      x-transition:enter="transform ease-out duration-300 transition"
      x-transition:enter-start="translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2"
      x-transition:enter-end="translate-y-0 opacity-100 sm:translate-x-0"
      x-transition:leave="transition ease-in duration-100"
      x-transition:leave-start="opacity-100"
      x-transition:leave-end="opacity-0"
      class="max-w-sm w-full bg-white dark:bg-gray-800 shadow-lg rounded-lg pointer-events-auto"
    >
      <div class="rounded-lg ring-1 ring-black ring-opacity-5 overflow-hidden">
        <div class="p-4">
          <div class="flex items-start">
            <div class="flex-shrink-0">
              <svg
                class="w-6 h-6 text-red-400"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                >
                </path>
              </svg>
            </div>
            <div class="ml-3 w-0 flex-1 pt-0.5">
              <p class="text-sm leading-5 font-medium text-gray-900 dark:text-gray-100">
                {Phoenix.Flash.get(@flash, :error_title) || "Error"}
              </p>
              <p class="mt-1 text-sm leading-5 text-gray-500 dark:text-gray-200">
                {Phoenix.Flash.get(@flash, :error)}
              </p>
            </div>
            <div class="ml-4 flex-shrink-0 flex">
              <button
                class="inline-flex text-gray-400 focus:outline-none focus:text-gray-500 dark:focus:text-gray-200 transition ease-in-out duration-150"
                @click="show = false"
              >
                <!-- Heroicon name: x -->
                <svg
                  class="h-5 w-5"
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                    clip-rule="evenodd"
                  />
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
<% end %>
```

## File: `lib/plausible_web/templates/layout/_footer.html.heex`
```
<div class="mt-24 bg-gray-800 dark:bg-gray-800">
  <div class="container px-4 py-12 sm:px-6 lg:py-16 lg:px-8">
    <div class="xl:grid xl:grid-cols-3 xl:gap-8">
      <div class="my-8 xl:my-0">
        <h4 class="font-semibold tracking-wider text-gray-300 leading-5">
          <img
            src={
              PlausibleWeb.Router.Helpers.static_path(
                @conn,
                logo_path("logo_dark.svg")
              )
            }
            class="inline-block w-40 mr-1"
            alt="Plausible logo"
            loading="lazy"
          />
        </h4>
        <p class="mt-4 text-base text-gray-400 leading-6">
          <%= if ee?() do %>
            Made and hosted in the EU <span class="text-lg">🇪🇺</span> <br />
            Solely funded by our subscribers.
          <% end %>

          <%= if ce?() do %>
            This dashboard is running on self-managed infrastructure, not tested by Plausible Analytics. We cannot vouch for its performance or reliability. For official managed hosting, check out
            <.styled_link href="https://plausible.io">
              plausible.io
            </.styled_link>
          <% end %>
        </p>
      </div>
      <div class="grid grid-cols-2 gap-8 xl:col-span-2">
        <div class="md:grid md:grid-cols-2 md:gap-8 print:hidden">
          <div>
            <h4 class="text-sm font-semibold tracking-wider text-gray-400 uppercase leading-5">
              Getting started
            </h4>
            <ul class="mt-4">
              <li>
                <a
                  rel="noreferrer"
                  href="https://plausible.io/docs/integration-guides"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Integration guides
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noferrer"
                  href="https://plausible.io/wordpress-analytics-plugin"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  WordPress plugin
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/docs/troubleshoot-integration"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Troubleshooting
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/docs/script-extensions"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Script extensions
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/docs/google-analytics-import"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Import stats
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/docs/google-search-console-integration"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Search Console
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/docs/users-roles"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Invite team members
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/docs/excluding"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Exclude traffic
                </a>
              </li>
            </ul>
          </div>
          <div class="mt-32 md:mt-0">
            <h4 class="text-sm font-semibold tracking-wider text-gray-400 uppercase leading-5">
              Help guides
            </h4>
            <ul class="mt-4">
              <li>
                <a
                  rel="noferrer"
                  href="https://plausible.io/docs/compare-stats"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Compare stats
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noferrer"
                  href="https://plausible.io/docs/filters-segments"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Segment audience
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noferrer"
                  href="https://plausible.io/docs/manual-link-tagging"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Track campaigns
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noferrer"
                  href="https://plausible.io/docs/goal-conversions"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Event conversions
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noferrer"
                  href="https://plausible.io/docs/funnel-analysis"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Funnel analysis
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noferrer"
                  href="https://plausible.io/docs/ecommerce-revenue-tracking"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Revenue attribution
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noferrer"
                  href="https://plausible.io/docs/custom-props/introduction"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Custom properties
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noferrer"
                  href="https://plausible.io/docs/proxy/introduction"
                  class="text-base text-gray-300 leading-6 hover:text-white"
                >
                  Bypass adblockers
                </a>
              </li>
            </ul>
          </div>
        </div>
        <div class="md:grid md:grid-cols-2 md:gap-8 print:hidden">
          <div>
            <h4 class="text-sm leading-5 font-semibold tracking-wider text-gray-400 uppercase">
              Community
            </h4>
            <ul class="mt-4">
              <li>
                <a
                  rel="noreferrer"
                  href="https://plausible.io/changelog"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  What's new
                </a>
              </li>
              <li class="mt-4">
                <a
                  ref="noreferrer"
                  target="_blank"
                  href="https://plausible.io/status"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Status
                </a>
              </li>
              <li class="mt-4">
                <a
                  ref="noreferrer"
                  href="https://plausible.io/blog"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Blog
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/docs"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Documentation
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  target="_blank"
                  href="https://github.com/plausible/analytics"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  GitHub
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  target="_blank"
                  href="https://twitter.com/plausiblehq"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Twitter
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  target="_blank"
                  rel="me"
                  href="https://fosstodon.org/@plausible"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Mastodon
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  target="_blank"
                  href="https://www.linkedin.com/company/plausible-analytics/"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  LinkedIn
                </a>
              </li>
            </ul>
          </div>
          <div class="mt-12 md:mt-0">
            <h4 class="text-sm leading-5 font-semibold tracking-wider text-gray-400 uppercase">
              Company
            </h4>
            <ul class="mt-4">
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/about"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  About
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/contact"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Contact
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/privacy"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Privacy
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/data-policy"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Data policy
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/terms"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Terms
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/dpa"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  DPA
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/security"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Security
                </a>
              </li>
              <li class="mt-4">
                <a
                  rel="noreferrer"
                  href="https://plausible.io/imprint"
                  class="text-base leading-6 text-gray-300 hover:text-white"
                >
                  Imprint
                </a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
```

## File: `lib/plausible_web/templates/layout/_header.html.heex`
```
<nav class="relative z-20 py-8">
  <div class="container print:max-w-full">
    <nav class="relative flex items-center justify-between sm:h-10 md:justify-center">
      <div class="flex items-center flex-1 md:absolute md:inset-y-0 md:left-0">
        <a href={home_dest(@conn)}>
          <img
            src={
              PlausibleWeb.Router.Helpers.static_path(
                @conn,
                logo_path("logo_dark.svg")
              )
            }
            class="w-44 -mt-2 hidden dark:inline"
            alt="Plausible logo"
            loading="lazy"
          />
          <img
            src={
              PlausibleWeb.Router.Helpers.static_path(
                @conn,
                logo_path("logo_light.svg")
              )
            }
            class="w-44 -mt-2 inline dark:hidden"
            alt="Plausible logo"
            loading="lazy"
          />
        </a>
      </div>
      <div class="absolute inset-y-0 right-0 flex items-center justify-end">
        <%= cond do %>
          <% @conn.assigns[:current_user] -> %>
            <ul class="flex items-center w-full sm:w-auto">
              <li :if={
                ee?() && @conn.assigns[:site] &&
                  Plausible.Auth.is_super_admin?(@conn.assigns[:current_user])
              }>
                <.styled_link
                  class="text-sm mr-6"
                  href={"/cs/sites/site/#{@conn.assigns.site.id}"}
                  new_tab={true}
                >
                  CS
                </.styled_link>
              </li>
              <li
                :if={ee?() and Plausible.Teams.on_trial?(@conn.assigns[:current_team])}
                class="hidden mr-6 sm:block"
              >
                <.styled_link
                  class="text-sm text-yellow-900 dark:text-yellow-900 rounded px-3 py-2 rounded-md bg-yellow-100 dark:bg-yellow-100"
                  href={Routes.settings_path(@conn, :subscription)}
                >
                  {trial_notification(@conn.assigns[:current_team])}
                </.styled_link>
              </li>
              <li class="w-full sm:w-auto">
                <.dropdown>
                  <:button class="flex items-center gap-3 px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800">
                    <span class="font-medium truncate dark:text-gray-100 hidden md:block">
                      {@conn.assigns[:current_user].name}
                    </span>
                    <img
                      src={Plausible.Auth.User.profile_img_url(@conn.assigns[:current_user])}
                      class="w-7 rounded-full"
                    />
                  </:button>
                  <:menu>
                    <.dropdown_item>
                      <div class="text-xs text-gray-500 dark:text-gray-400">Signed in as</div>
                      <p class="truncate font-medium text-gray-900 dark:text-gray-100" role="none">
                        {@conn.assigns[:current_user].email}
                      </p>
                    </.dropdown_item>
                    <.team_switcher
                      conn={@conn}
                      teams={@teams}
                      my_team={@my_team}
                      current_team={@current_team}
                      more_teams?={@more_teams?}
                    />
                    <.dropdown_divider />
                    <.dropdown_item href={Routes.settings_path(@conn, :index)}>
                      Account Settings
                    </.dropdown_item>

                    <div :if={@my_team && @my_team.id == @current_team.id}>
                      <.dropdown_item class="flex" href={Routes.team_setup_path(@conn, :setup)}>
                        <span data-test="create-a-team-cta" class="flex-1">
                          Create a Team
                        </span>
                      </.dropdown_item>
                      <.dropdown_divider />
                    </div>

                    <div :if={Plausible.Teams.setup?(@current_team)}>
                      <.dropdown_item
                        class="flex"
                        href={Routes.settings_path(@conn, :team_general)}
                      >
                        <span class="flex-1">
                          Team Settings
                        </span>
                      </.dropdown_item>
                      <.dropdown_divider />
                    </div>
                    <.dropdown_item
                      class="!flex justify-between gap-x-12"
                      new_tab
                      href="https://plausible.io/docs"
                    >
                      Help Center
                    </.dropdown_item>
                    <.dropdown_item
                      :if={ee?()}
                      class="!flex justify-between gap-x-12"
                      new_tab
                      href="https://plausible.io/contact"
                    >
                      Contact Support
                    </.dropdown_item>
                    <.dropdown_item
                      :if={ee?()}
                      class="!flex justify-between gap-x-12"
                      new_tab
                      href={feedback_link(@conn.assigns[:current_user])}
                    >
                      Feature Requests
                    </.dropdown_item>
                    <.dropdown_item
                      :if={ce?()}
                      class="!flex justify-between gap-x-12"
                      new_tab
                      href="https://github.com/plausible/analytics"
                    >
                      Github Repo
                    </.dropdown_item>
                    <.dropdown_item href="/logout">Log Out</.dropdown_item>
                  </:menu>
                </.dropdown>
              </li>
              <%= if @conn.assigns[:current_user] && ee?() do %>
                <li id="changelog-notification" class="relative py-2"></li>
              <% end %>
            </ul>
          <% Keyword.fetch!(Application.get_env(:plausible, :selfhost), :disable_registration) != false -> %>
            <ul class="flex" x-show="!document.cookie.includes('logged_in=true')">
              <li>
                <div class="inline-flex">
                  <a
                    href="/login"
                    class="font-medium text-gray-500 dark:text-gray-200 hover:text-gray-900 focus:outline-none focus:text-gray-900 transition duration-150 ease-in-out"
                  >
                    Login
                  </a>
                </div>
              </li>
            </ul>
          <% true -> %>
            <ul class="flex" x-show="!document.cookie.includes('logged_in=true')">
              <li>
                <div class="inline-flex">
                  <a
                    href="/login"
                    class="font-medium text-gray-500 dark:text-gray-200 hover:text-gray-900 focus:outline-none focus:text-gray-900 transition duration-150 ease-in-out"
                  >
                    Login
                  </a>
                </div>
                <div class="inline-flex ml-6 rounded shadow">
                  <a
                    href="/register"
                    class="inline-flex items-center justify-center px-5 py-2 text-base font-medium text-white bg-indigo-600 border border-transparent leading-6 rounded-md hover:bg-indigo-500 focus:outline-none focus:ring transition duration-150 ease-in-out"
                  >
                    Sign up
                  </a>
                </div>
              </li>
            </ul>
        <% end %>
      </div>
    </nav>
  </div>
</nav>
```

## File: `lib/plausible_web/templates/layout/_notice.html.heex`
```
<%= if assigns[:flash] do %>
  {render("_flash.html", assigns)}
<% end %>

<div :if={assigns[:current_team]} class="flex flex-col gap-y-2">
  <Notice.active_grace_period
    :if={Plausible.Teams.GracePeriod.active?(@current_team)}
    enterprise?={Plausible.Teams.Billing.enterprise_configured?(@current_team)}
    grace_period_end={grace_period_end(@current_team)}
  />

  <Notice.dashboard_locked :if={Plausible.Teams.GracePeriod.expired?(@current_team)} />

  <Notice.subscription_cancelled subscription={@current_team.subscription} />

  <Notice.subscription_past_due subscription={@current_team.subscription} class="container" />

  <Notice.subscription_paused subscription={@current_team.subscription} class="container" />
</div>
```

## File: `lib/plausible_web/templates/layout/_tracking.html.heex`
```
<%= on_ee do %>
  <script
    :if={!@conn.assigns[:skip_plausible_tracking]}
    id="dogfood-script"
    data-script-params={JSON.encode!(PlausibleWeb.Dogfood.script_params(@conn.assigns))}
  >
    var scriptParams = JSON.parse(document.currentScript.dataset.scriptParams)

    window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)},window.plausible.init=function(i){window.plausible.o=i||{}};var script=document.createElement("script");script.type="text/javascript",script.defer=!0,script.src=scriptParams.script_url;var r=document.getElementsByTagName("script")[0];r.parentNode.insertBefore(script,r);

    plausible.init({
      captureOnLocalhost: scriptParams.capture_on_localhost,
      customProperties: {
        ...scriptParams.custom_properties,
        browser_language: navigator.language || navigator.userLanguage
      },
      transformRequest: function (payload) {
        if (scriptParams.location_override) {
          payload.u = scriptParams.location_override
        } else if (scriptParams.domain_to_replace) {
          payload.u = payload.u.replace(scriptParams.domain_to_replace, ':dashboard')
        }
        return payload
      }
    })
  </script>
<% end %>
```

## File: `lib/plausible_web/templates/layout/app.html.heex`
```
<!DOCTYPE html>
<html lang="en" class="h-full plausible">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Plausible is a lightweight and open-source web analytics tool. Your website data is 100% yours and the privacy of your visitors is respected."
    />
    <%= if assigns[:connect_live_socket] do %>
      <meta name="csrf-token" content={Plug.CSRFProtection.get_csrf_token()} />
      <meta name="websocket-url" content={websocket_url()} />
    <% end %>
    <meta name="robots" content={@conn.private.robots} />

    <PlausibleWeb.Components.Layout.favicon conn={@conn} />

    <title>
      {assigns[:title] ||
        "Plausible · Simple, privacy-friendly alternative to Google Analytics"}
    </title>
    <link rel="stylesheet" href={Routes.static_path(@conn, "/css/app.css")} />
    <PlausibleWeb.Components.Layout.theme_script {Map.take(assigns, [:current_user, :theme])} />
    {render("_tracking.html", assigns)}
  </head>
  <body
    class={[
      "flex flex-col bg-gray-50 dark:bg-gray-850",
      if !assigns[:embedded] do
        "h-full"
      end
    ]}
    style={if assigns[:background], do: "background-color: #{assigns[:background]}"}
  >
    <%= if !assigns[:embedded] && !assigns[:hide_header?] do %>
      {render("_header.html", assigns)}

      <%= if !assigns[:disable_global_notices?] do %>
        {render("_notice.html", assigns)}
      <% end %>
    <% end %>

    <main class="flex-1">
      {Map.get(assigns, :inner_layout) || @inner_content}
    </main>

    <%= if assigns[:embedded] do %>
      <div data-iframe-height></div>
      <script type="text/javascript" src={Routes.static_path(@conn, "/js/embed.content.js")}>
      </script>
    <% end %>
    <%= if !assigns[:hide_footer?] do %>
      {render("_footer.html", assigns)}
    <% end %>
    <script type="text/javascript" src={Routes.static_path(@conn, "/js/app.js")}>
    </script>
    <%= if assigns[:load_dashboard_js] do %>
      <script type="text/javascript" src={Routes.static_path(@conn, "/js/dashboard.js")}>
      </script>
    <% end %>
  </body>
</html>
```

## File: `lib/plausible_web/templates/layout/base_email.html.heex`
```
{PlausibleWeb.EmailView.greet_recipient(assigns)}
<br /><br />

{@inner_content}
<br /><br />

<%= if ee?() do %>
  Regards,<br /> The Plausible Team 💌 <br /><br />
<% end %>
-- <br /><br />
<a href={plausible_url()}>{plausible_url()}</a>
<br />

<p :if={ee?()} phx-no-curly-interpolation>{{{ pm:unsubscribe }}}</p>
```

## File: `lib/plausible_web/templates/layout/base_error.html.heex`
```
<!DOCTYPE html>
<html lang="en" class="h-full plausible">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <PlausibleWeb.Components.Layout.favicon conn={@conn} />
    <title>Plausible · Web analytics</title>
    <link rel="stylesheet" href={Routes.static_path(PlausibleWeb.Endpoint, "/css/app.css")} />
  </head>
  <body class="flex flex-col h-full bg-gray-100 dark:bg-gray-900">
    <div class="w-full my-8 text-center">
      <a href={home_dest(@conn)}>
        <img
          src={
            PlausibleWeb.Router.Helpers.static_path(
              @conn,
              logo_path("logo_dark.svg")
            )
          }
          class="w-44 hidden dark:inline"
          alt="Plausible logo"
          loading="lazy"
        />
        <img
          src={
            PlausibleWeb.Router.Helpers.static_path(
              @conn,
              logo_path("logo_light.svg")
            )
          }
          class="w-44 inline dark:hidden"
          alt="Plausible logo"
          loading="lazy"
        />
      </a>
    </div>

    {@inner_content}

    <script type="text/javascript" src={Routes.static_path(PlausibleWeb.Endpoint, "/js/app.js")}>
    </script>
  </body>
</html>
```

## File: `lib/plausible_web/templates/layout/embedded.html.heex`
```
Content omitted due to reason: BINARY
```

## File: `lib/plausible_web/templates/layout/priority_email.html.heex`
```
{PlausibleWeb.EmailView.greet_recipient(assigns)}
<br /><br />

{@inner_content}
<br /><br />

<%= if ee?() do %>
  Regards,<br /> The Plausible Team 💌 <br /><br />
<% end %>
-- <br /><br />
<a href={plausible_url()}>{plausible_url()}</a>
<br />
```

## File: `lib/plausible_web/templates/layout/settings.html.heex`
```
<%= render_layout "app.html", assigns do %>
  <% options = account_settings_sidebar(@conn) %>
  <div class="container pt-6">
    <.styled_link class="text-indigo-600 font-bold text-sm" href="/sites">
      ← Back to Sites
    </.styled_link>
    <div class="pb-5 border-b border-gray-200 dark:border-gray-500">
      <h2 class="text-2xl font-bold leading-7 text-gray-900 dark:text-gray-100 sm:text-3xl sm:leading-9 sm:truncate">
        Settings
      </h2>
    </div>
    <div class="lg:grid lg:grid-cols-12 lg:gap-x-5 lg:mt-4">
      <div class="lg:col-span-3">
        <.mobile_nav_dropdown
          name="settings"
          options={options}
          selected_fn={&is_current_tab(@conn, &1)}
          conn={@conn}
          href_base="/settings/"
        />

        <div class="hidden lg:block py-4 top-0 sticky">
          <h3 class="uppercase text-sm text-indigo-600 font-semibold">Account Settings</h3>
          <p class="text-xs dark:text-gray-400 truncate">{@current_user.email}</p>
          <Layout.settings_sidebar
            selected_fn={&is_current_tab(@conn, &1)}
            options={options["Account Settings"]}
          />

          <div :if={Plausible.Teams.setup?(@current_team)}>
            <h3 class="uppercase text-sm text-indigo-600 font-semibold mt-6">Team Settings</h3>
            <p class="text-xs dark:text-gray-400 truncate mb-4">
              {Plausible.Teams.name(@current_team)}
            </p>

            <Layout.settings_sidebar
              selected_fn={&is_current_tab(@conn, &1)}
              options={options["Team Settings"]}
            />
          </div>
        </div>
      </div>

      <div class="space-y-6 lg:col-span-9 lg:mt-4">
        {@inner_content}
      </div>
    </div>
  </div>
<% end %>
```

## File: `lib/plausible_web/templates/layout/site_settings.html.heex`
```
<%= render_layout "app.html", assigns do %>
  <% options = site_settings_sidebar(@conn) %>
  <div class="container pt-6">
    <.styled_link
      class="text-indigo-600 font-bold text-sm"
      href={"/#{URI.encode_www_form(@site.domain)}"}
    >
      ← Back to Stats
    </.styled_link>
    <div class="pb-5 border-b border-gray-200 dark:border-gray-500">
      <h2 class="text-2xl font-bold leading-7 text-gray-900 dark:text-gray-100 sm:text-3xl sm:leading-9 sm:truncate">
        Settings for {@site.domain}
      </h2>
    </div>
    <div class="lg:grid lg:grid-cols-12 lg:gap-x-5 lg:mt-4">
      <div class="lg:col-span-3">
        <.mobile_nav_dropdown
          conn={@conn}
          options={options}
          name="tab"
          href_base={"/#{URI.encode_www_form(@site.domain)}/settings/"}
          selected_fn={&is_current_tab(@conn, &1)}
        />

        <div class="hidden lg:block py-4 sticky top-0" data-testid="site_settings_sidebar">
          <Layout.settings_sidebar
            prefix={"/#{URI.encode_www_form(@site.domain)}"}
            selected_fn={&is_current_tab(@conn, &1)}
            options={options}
          />
        </div>
      </div>

      <div class="space-y-6 lg:col-span-9 lg:mt-4">
        {@inner_content}
      </div>
    </div>
  </div>
<% end %>
```

## File: `lib/plausible_web/templates/page/index.html.heex`
```
<.focus_box>
  <:title>
    Welcome to Plausible!
  </:title>

  <p>
    <.styled_link href="https://plausible.io/">
      Plausible Analytics
    </.styled_link>
    is a simple, open source, lightweight (&lt;&nbsp;1&nbsp;KB) and privacy-friendly alternative to Google Analytics. We're completely independent and solely funded by our 10,000+ paying subscribers. Read more
    <.styled_link href="https://plausible.io/about">
      about us.
    </.styled_link>
  </p>

  <:footer>
    <.focus_list>
      <:item>
        <.styled_link href={Routes.auth_path(@conn, :login)}>
          Login
        </.styled_link>
      </:item>
      <:item>
        <.styled_link href={Routes.auth_path(@conn, :register_form)}>
          Register
        </.styled_link>
      </:item>
      <:item>
        <.styled_link href="https://plausible.io/docs">
          Guides & Docs
        </.styled_link>
      </:item>
      <:item>
        <.styled_link href="https://twitter.com/plausiblehq">
          Follow on Twitter
        </.styled_link>
      </:item>
    </.focus_list>
  </:footer>
</.focus_box>
```

## File: `lib/plausible_web/templates/settings/api_keys.html.heex`
```
<.settings_tiles>
  <.tile
    docs="stats-api"
    current_role={@current_team_role}
    current_team={@current_team}
    feature_mod={Plausible.Billing.Feature.StatsAPI}
  >
    <:title>
      <a id="api-keys">API Keys</a>
    </:title>
    <:subtitle>
      Manage your API keys
    </:subtitle>

    <.filter_bar filtering_enabled?={false}>
      <.button_link mt?={false} href={Routes.settings_path(@conn, :new_api_key)}>
        New API Key
      </.button_link>
    </.filter_bar>

    <p :if={Enum.empty?(@api_keys)} class="mb-8 text-center text-sm">
      No API keys configured yet.
    </p>

    <.table rows={@api_keys}>
      <:thead>
        <.th>
          Name
        </.th>
        <.th hide_on_mobile>
          Key
        </.th>
        <.th :if={ee?()} hide_on_mobile>
          Type
        </.th>
        <.th invisible>
          Actions
        </.th>
      </:thead>

      <:tbody :let={api_key}>
        <.td truncate max_width="max-w-40">
          {api_key.name}
        </.td>
        <.td hide_on_mobile>
          {api_key.key_prefix}
          {String.duplicate("*", 32 - 6)}
        </.td>
        <.td :if={ee?()}>
          <span :if={api_key.type == "stats_api"}>Stats API</span>
          <span :if={api_key.type == "sites_api"}>Sites API</span>
        </.td>
        <.td actions>
          <.delete_button
            method="delete"
            href={Routes.settings_path(@conn, :delete_api_key, api_key.id)}
            data-confirm="Are you sure you want to revoke this key? This action cannot be reversed."
          />
        </.td>
      </:tbody>
    </.table>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/settings/danger_zone.html.heex`
```
<.notice title="Danger Zone" theme={:red}>
  Destructive actions below can result in irrecoverable data loss. Be careful.
</.notice>

<.settings_tiles>
  <.tile docs="delete-account">
    <:title>Delete Account</:title>
    <:subtitle>Deleting your account removes all sites and stats you've collected</:subtitle>

    <%= cond do %>
      <% length(@solely_owned_teams) > 0 -> %>
        <.notice theme={:gray} title="Cannot delete account at this time">
          You are the sole owner of one or more teams. If you want to delete your account, please either add another owner or delete each of the following teams:
          <ul class="w-full py-4">
            <li :for={team <- @solely_owned_teams} class="pt-1">
              <.styled_link href={
                Routes.settings_path(@conn, :team_general, __team: team.identifier)
              }>
                {Plausible.Teams.name(team)}
              </.styled_link>
            </li>
          </ul>
        </.notice>
      <% Plausible.Billing.Subscription.Status.active?(@my_team && @my_team.subscription) -> %>
        <.notice theme={:gray} title="Cannot delete account at this time">
          Your account cannot be deleted because you have an active subscription. If you want to delete your account, please cancel your subscription first.
        </.notice>
      <% true -> %>
        <.button_link
          data-confirm="Deleting your account will also delete all the sites and data that you own. This action cannot be reversed. Are you sure?"
          href="/me"
          method="delete"
          theme="danger"
        >
          Delete My Account
        </.button_link>
    <% end %>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/settings/invoices.html.heex`
```
<.settings_tiles>
  <.tile docs="download-invoices">
    <:title>
      <a id="invoices">Invoices</a>
    </:title>
    <:subtitle>
      Download your invoices
    </:subtitle>
    <%= case @invoices do %>
      <% {:error, :no_invoices} -> %>
        <p class="mt-12 mb-8 text-center text-sm">
          <span>
            Your invoice will be created once you upgrade to a subscription
          </span>
        </p>
      <% {:error, :request_failed} -> %>
        <.notice theme={:gray} title="We couldn't retrieve your invoices">
          Please refresh the page or try again later
        </.notice>
      <% {:ok, invoice_list} when is_list(invoice_list) -> %>
        <div x-data="{showAll: false}" x-cloak>
          <.table
            rows={Enum.with_index(format_invoices(invoice_list))}
            row_attrs={
              fn {_invoice, idx} ->
                %{
                  "x-show" => "showAll || #{idx} < 12"
                }
              end
            }
          >
            <:thead>
              <.th>Date</.th>
              <.th>Amount</.th>
              <.th>Invoice</.th>
            </:thead>
            <:tbody :let={{invoice, _idx}}>
              <.td>{invoice.date}</.td>
              <.td>{invoice.currency <> invoice.amount}</.td>
              <.td>
                <.styled_link href={invoice.url} new_tab={true}>View</.styled_link>
              </.td>
            </:tbody>
            <tr :if={length(invoice_list) > 12}>
              <td colspan="3" class="text-center pt-8 pb-4">
                <.button_link href={} theme="bright" x-on:click="showAll = true" x-show="!showAll">
                  Show More
                </.button_link>
              </td>
            </tr>
          </.table>
        </div>
    <% end %>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/settings/new_api_key.html.heex`
```
<.focus_box>
  <:title>Create new API key</:title>

  <div x-data="{ submitDisabled: false }">
    <.form :let={f} for={@changeset} action={Routes.settings_path(@conn, :api_keys)}>
      <.input type="text" field={f[:name]} label="Name" placeholder="Development" />

      <input :if={ce?()} type="hidden" name={f[:type].name} value={f[:type].value} />

      <div :if={ee?()} class="mt-4 flex flex-col gap-y-2">
        <div>
          <.label>Type</.label>
        </div>

        <.input
          x-on:click="submitDisabled = false"
          type="radio"
          class="block h-5 w-5 dark:bg-gray-700 border-gray-300 text-indigo-600 focus:ring-indigo-600"
          id={f[:type].id <> "_0"}
          name={f[:type].name}
          value="stats_api"
          checked={f[:type].value == "stats_api"}
          label="Stats API"
        >
          <:help_content>
            Full access to
            <.styled_link href="https://plausible.io/docs/stats-api">Stats API</.styled_link>
          </:help_content>
        </.input>

        <.input
          x-on:click={"submitDisabled = " <> if(@sites_api_enabled?, do: "false", else: "true")}
          type="radio"
          id={f[:type].id <> "_1"}
          name={f[:type].name}
          value="sites_api"
          checked={f[:type].value == "sites_api"}
          label="Sites API"
        >
          <:help_content>
            Full access to
            <.styled_link href="https://plausible.io/docs/stats-api">Stats API</.styled_link>
            and
            <.styled_link href="https://plausible.io/docs/sites-api">Sites API</.styled_link>
          </:help_content>
        </.input>

        <div x-show="submitDisabled" class="flex gap-x-2 text-sm">
          <Heroicons.exclamation_triangle class="mt-1 block w-4 h-4 shrink-0" />
          <div>
            Your current subscription plan does not include Sites API access.
            <a href="https://plausible.io/contact" class="underline">Contact us</a>
            if interested.
          </div>
        </div>
      </div>

      <div class="mt-4">
        <.input_with_clipboard
          id="key-input"
          name="api_key[key]"
          label="Key"
          value={f[:key].value}
        />

        <.error :for={
          msg <- Enum.map(f[:key].errors, &PlausibleWeb.Live.Components.Form.translate_error/1)
        }>
          {msg}
        </.error>

        <p class="mt-2 text-gray-500 dark:text-gray-200">
          Make sure to store the key in a secure place. Once created, we will not be able to show it again.
        </p>
      </div>
      <.button type="submit" class="w-full" x-bind:disabled="submitDisabled">
        Create API key
      </.button>
    </.form>
  </div>
</.focus_box>
```

## File: `lib/plausible_web/templates/settings/preferences.html.heex`
```
<.settings_tiles>
  <.tile :if={Plausible.Users.type(@current_user) == :standard}>
    <:title>
      <a id="update-name">Your Name</a>
    </:title>
    <:subtitle>
      Change the name associated with your account
    </:subtitle>
    <.form
      :let={f}
      action={Routes.settings_path(@conn, :update_name)}
      for={@name_changeset}
      method="post"
    >
      <.input type="text" field={f[:name]} label="Name" width="w-1/2" />

      <.button type="submit">
        Change Name
      </.button>
    </.form>
  </.tile>

  <.tile :if={Plausible.Users.type(@current_user) == :sso}>
    <:title>
      <a id="view-name">Your Name</a>
    </:title>
    <:subtitle>
      The name associated with your account
    </:subtitle>
    <.form :let={f} for={@name_changeset}>
      <.input type="text" field={f[:name]} disabled={true} label="Name" width="w-1/2" />
    </.form>
  </.tile>

  <.tile docs="dashboard-appearance">
    <:title>
      <a id="update-theme">Dashboard Appearance</a>
    </:title>
    <:subtitle>
      Set your visual preferences
    </:subtitle>
    <.form
      :let={f}
      action={Routes.settings_path(@conn, :update_theme)}
      for={@theme_changeset}
      method="post"
    >
      <.input
        type="select"
        field={f[:theme]}
        options={Plausible.Themes.options()}
        label="Theme"
        width="w-1/2"
      />

      <.button type="submit">
        Change Theme
      </.button>
    </.form>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/settings/security.html.heex`
```
<.settings_tiles>
  <.tile :if={Plausible.Users.type(@current_user) == :standard} docs="change-email">
    <:title>
      <a id="update-email">Email Address</a>
    </:title>
    <:subtitle>
      Change the address associated with your account
    </:subtitle>
    <.form
      :let={f}
      action={Routes.settings_path(@conn, :update_email)}
      for={@email_changeset}
      method="post"
    >
      <.input
        type="text"
        name="user[current_email]"
        value={f.data.email}
        label="Current Email"
        width="w-1/2"
        disabled
      />

      <.input type="email" field={f[:email]} label="New E-mail" width="w-1/2" />

      <.input type="password" field={f[:password]} label="Account Password" width="w-1/2" />

      <.button type="submit">
        Change Email
      </.button>
    </.form>
  </.tile>

  <.tile :if={Plausible.Users.type(@current_user) == :sso}>
    <:title>
      <a id="view-email">Email Address</a>
    </:title>
    <:subtitle>
      Address associated with your account
    </:subtitle>
    <.form :let={f} for={@email_changeset}>
      <.input
        type="text"
        name="user[current_email]"
        value={f.data.email}
        label="Current Email"
        width="w-1/2"
        disabled
      />
    </.form>
  </.tile>

  <.tile :if={Plausible.Users.type(@current_user) == :standard} docs="reset-password">
    <:title>
      <a id="update-password">Password</a>
    </:title>
    <:subtitle>
      Change your password
    </:subtitle>
    <.form
      :let={f}
      action={Routes.settings_path(@conn, :update_password)}
      for={@password_changeset}
      method="post"
    >
      <.input
        type="password"
        max_one_error
        field={f[:old_password]}
        label="Old Password"
        width="w-1/2"
      />

      <.input
        type="password"
        max_one_error
        field={f[:password]}
        label="New Password"
        width="w-1/2"
      />

      <.input
        type="password"
        max_one_error
        autocomplete="new-password"
        field={f[:password_confirmation]}
        label="Confirm New Password"
        width="w-1/2"
      />

      <div :if={@totp_enabled?} class="mt-2">
        <.label for={f[:two_factor_code].id} class="mb-2">
          Verify with 2FA Code
        </.label>
        <PlausibleWeb.Components.TwoFactor.verify_2fa_input
          form={f}
          show_button?={false}
          field={:two_factor_code}
        />
      </div>

      <.button type="submit">
        Change Password
      </.button>
    </.form>
  </.tile>

  <.tile docs="2fa">
    <:title>
      <a id="update-2fa">Two-Factor Authentication (2FA)</a>
    </:title>
    <:subtitle>
      Two-Factor Authentication protects your account by adding an extra security step when you log in
    </:subtitle>

    <div x-data="{disable2FAOpen: false, regenerate2FAOpen: false}">
      <div :if={@totp_enabled?}>
        <.button
          disabled={Plausible.Users.type(@current_user) == :sso}
          x-on:click="disable2FAOpen = true; $refs.disable2FAPassword.value = ''"
          theme="danger"
          mt?={false}
        >
          Disable 2FA
        </.button>

        <p class="mt-2 text-gray-600 text-sm dark:text-gray-400">
          Lost your recovery codes?
          <a
            href="#update-2fa"
            x-on:click="regenerate2FAOpen = true; $refs.regenerate2FAPassword.value = ''"
            class="underline text-indigo-600"
          >
            Generate new
          </a>
        </p>
      </div>

      <div :if={not @totp_enabled?}>
        <.form
          action={Routes.auth_path(@conn, :initiate_2fa_setup)}
          for={@conn.params}
          method="post"
        >
          <.button type="submit" mt?={false}>
            Enable 2FA
          </.button>
        </.form>
      </div>

      <PlausibleWeb.Components.TwoFactor.modal
        id="disable-2fa-modal"
        state_param="disable2FAOpen"
        form_data={@conn.params}
        form_target={Routes.auth_path(@conn, :disable_2fa)}
        title="Disable Two-Factor Authentication?"
      >
        <:icon>
          <Heroicons.shield_exclamation class="h-6 w-6" />
        </:icon>
        <:buttons>
          <.button type="submit" class="w-full sm:w-auto">
            Disable 2FA
          </.button>
        </:buttons>

        <div class="text-sm mt-2">
          Once disabled, verification codes from the authenticator application and current recovery codes will become invalid. 2FA will have to be setup from the start.
        </div>

        <div class="text-sm mt-2">
          Enter your password to disable 2FA.
        </div>

        <div class="mt-3">
          <.input
            type="password"
            id="disable_2fa_password"
            name="password"
            value=""
            placeholder="Enter password"
            x-ref="disable2FAPassword"
          />
        </div>
      </PlausibleWeb.Components.TwoFactor.modal>

      <PlausibleWeb.Components.TwoFactor.modal
        id="regenerate-2fa-modal"
        state_param="regenerate2FAOpen"
        form_data={@conn.params}
        form_target={Routes.auth_path(@conn, :generate_2fa_recovery_codes)}
        onsubmit="document.getElementById('generate-2fa-recovery-button').disabled = true"
        title="Generate New Recovery Codes?"
      >
        <:icon>
          <Heroicons.key class="h-6 w-6" />
        </:icon>

        <:buttons>
          <.button
            id="generate-2fa-recovery-button"
            type="submit"
            class="w-full sm:w-auto [&>span.label-enabled]:block [&>span.label-disabled]:hidden [&[disabled]>span.label-enabled]:hidden [&[disabled]>span.label-disabled]:block"
          >
            <span class="label-enabled pointer-events-none">
              Generate New Codes
            </span>

            <span class="label-disabled">
              <.spinner class="inline-block h-5 w-5 mr-2 text-white dark:text-gray-400" />
              Generating Codes
            </span>
          </.button>
        </:buttons>

        <div class="text-sm mt-2">
          If you generate new codes, the old ones will become invalid.
        </div>

        <div class="text-sm mt-2">
          Enter your password to continue.
        </div>

        <div class="mt-3 w-full">
          <.input
            type="password"
            id="regenerate_2fa_password"
            name="password"
            value=""
            placeholder="Enter password"
            x-ref="regenerate2FAPassword"
          />
        </div>
      </PlausibleWeb.Components.TwoFactor.modal>
    </div>
  </.tile>

  <.tile docs="login-management">
    <:title>
      <a id="user-sessions">Login Management</a>
    </:title>
    <:subtitle>
      Log out of your account on other devices. Note that logged-in sessions automatically expire after 14 days of inactivity
    </:subtitle>

    <.table rows={@user_sessions}>
      <:thead>
        <.th>Device</.th>
        <.th hide_on_mobile>Last seen</.th>
        <.th invisible>Actions</.th>
      </:thead>
      <:tbody :let={session}>
        <.td truncate max_width="max-w-40">{session.device}</.td>
        <.td hide_on_mobile>{Plausible.Auth.UserSessions.last_used_humanize(session)}</.td>
        <.td :if={@current_user_session.id == session.id} actions>Current session</.td>
        <.td :if={@current_user_session.id != session.id} actions>
          <.delete_button
            href={Routes.settings_path(@conn, :delete_session, session.id)}
            method="delete"
            data-confirm="Are you sure you want to log out this session?"
          />
        </.td>
      </:tbody>
    </.table>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/settings/subscription.html.heex`
```
<.settings_tiles>
  <.tile docs="billing">
    <:title>
      <a id="subscription">Subscription</a>
    </:title>
    <:subtitle>
      Manage your plan
    </:subtitle>
    <div class="w-full inline-flex gap-x-4 justify-end items-center mt-4 mb-4">
      <span
        :if={@subscription && Plausible.Billing.Plans.business_tier?(@subscription)}
        class={[
          "w-max px-2.5 py-0.5 rounded-md text-sm font-bold leading-5 text-indigo-600 bg-blue-100 dark:text-yellow-200 dark:border dark:bg-inherit dark:border-yellow-200"
        ]}
      >
        Business
      </span>
      <span
        :if={@subscription}
        class={[
          "w-max px-2.5 py-0.5 rounded-md text-sm font-bold leading-5",
          subscription_colors(@subscription.status)
        ]}
      >
        {present_subscription_status(@subscription.status)}
      </span>
    </div>

    <PlausibleWeb.Components.Billing.Notice.subscription_cancelled
      subscription={@subscription}
      dismissable={false}
    />

    <div class="flex flex-col gap-4 my-4 items-center justify-between sm:flex-row sm:items-start">
      <PlausibleWeb.Components.Billing.monthly_quota_box
        team={@current_team}
        subscription={@subscription}
      />
      <div class="w-full flex-1 h-32 px-2 py-4 text-center bg-gray-100 rounded dark:bg-gray-900">
        <h4 class="font-black dark:text-gray-100">Next bill amount</h4>
        <%= if Plausible.Billing.Subscription.Status.in?(@subscription, [Plausible.Billing.Subscription.Status.active(), Plausible.Billing.Subscription.Status.past_due()]) do %>
          <div class="py-2 text-xl font-medium dark:text-gray-100">
            {PlausibleWeb.BillingView.present_currency(@subscription.currency_code)}{@subscription.next_bill_amount}
          </div>
          <.styled_link :if={@subscription.update_url} href={@subscription.update_url}>
            Update billing info
          </.styled_link>
        <% else %>
          <div class="py-2 text-xl font-medium dark:text-gray-100">---</div>
        <% end %>
      </div>
      <div class="w-full flex-1 h-32 px-2 py-4 text-center bg-gray-100 rounded dark:bg-gray-900">
        <h4 class="font-black dark:text-gray-100">Next bill date</h4>

        <%= if @subscription && @subscription.next_bill_date && Plausible.Billing.Subscription.Status.in?(@subscription, [Plausible.Billing.Subscription.Status.active(), Plausible.Billing.Subscription.Status.past_due()]) do %>
          <div class="py-2 text-xl font-medium dark:text-gray-100">
            {Calendar.strftime(@subscription.next_bill_date, "%b %-d, %Y")}
          </div>
          <span class="text-gray-600 dark:text-gray-400">
            ({subscription_interval(@subscription)} billing)
          </span>
        <% else %>
          <div class="py-2 text-xl font-medium dark:text-gray-100">---</div>
        <% end %>
      </div>
    </div>

    <PlausibleWeb.Components.Billing.render_monthly_pageview_usage
      usage={@pageview_usage}
      limit={@pageview_limit}
    />

    <article class="mt-8">
      <.title>Sites & team members usage</.title>
      <PlausibleWeb.Components.Billing.usage_and_limits_table>
        <PlausibleWeb.Components.Billing.usage_and_limits_row
          id="site-usage-row"
          title="Owned sites"
          usage={@site_usage}
          limit={@site_limit}
        />
        <PlausibleWeb.Components.Billing.usage_and_limits_row
          id="team-member-usage-row"
          title="Team members"
          usage={@team_member_usage}
          limit={@team_member_limit}
        />
      </PlausibleWeb.Components.Billing.usage_and_limits_table>
    </article>

    <%= cond do %>
      <% Plausible.Billing.Subscriptions.resumable?(@subscription) && @subscription.cancel_url -> %>
        <div class="mt-8">
          <.button_link theme="danger" href={@subscription.cancel_url}>
            Cancel my subscription
          </.button_link>
          <%= if Application.get_env(:plausible, :environment) == "dev" do %>
            <a
              href={@subscription.update_url}
              class="ml-2 font-medium rounded-md px-3.5 py-2.5 text-sm shadow-sm border border-gray-300 dark:border-gray-500 text-yellow-600 dark:text-yellow-400 bg-white dark:bg-gray-900"
            >
              [DEV ONLY] Change subscription status
            </a>
          <% end %>
        </div>
      <% true -> %>
        <div class="mt-8">
          <PlausibleWeb.Components.Billing.upgrade_link />
        </div>
    <% end %>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/settings/team_danger_zone.html.heex`
```
<.notice title="Danger Zone" theme={:red}>
  Destructive actions below can result in irrecoverable data loss. Be careful.
</.notice>

<.settings_tiles>
  <.tile docs="delete-team">
    <:title>Delete Team</:title>
    <:subtitle>Deleting the team removes all associated sites and collected stats</:subtitle>

    <%= if Plausible.Billing.Subscription.Status.active?(@current_team && @current_team.subscription) do %>
      <.notice theme={:gray} title="Cannot delete the team at this time">
        The team cannot be deleted because it has an active subscription. Please cancel the subscription first.
      </.notice>
    <% else %>
      <.button_link
        data-confirm="Deleting the team will also delete all the associated sites and data. This action cannot be reversed. Are you sure?"
        href={Routes.settings_path(@conn, :delete_team)}
        method="delete"
        theme="danger"
      >
        Delete "{Plausible.Teams.name(@current_team)}"
      </.button_link>
    <% end %>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/settings/team_general.html.heex`
```
<.settings_tiles>
  <.tile docs="users-roles">
    <:title>
      <a id="update-name#changing-the-name-of-a-team">Team Information</a>
    </:title>
    <:subtitle>
      Change the name of your team
    </:subtitle>
    <.form
      :let={f}
      action={Routes.settings_path(@conn, :update_team_name)}
      for={@team_name_changeset}
      method="post"
    >
      <.input
        readonly={@current_team_role not in [:owner, :admin]}
        type="text"
        field={f[:name]}
        label="Name"
        width="w-1/2"
      />

      <.button type="submit" disabled={@current_team_role not in [:owner, :admin]}>
        Change Name
      </.button>
    </.form>
  </.tile>
  <.tile
    docs="users-roles#managing-team-member-roles"
    current_role={@current_team_role}
    current_team={@current_team}
    feature_mod={Plausible.Billing.Feature.Teams}
  >
    <:title>
      <a id="team-members">Team Members</a>
    </:title>
    <:subtitle>
      Add or remove team members and adjust their roles
    </:subtitle>
    {live_render(@conn, PlausibleWeb.Live.TeamManagement,
      id: "team-setup",
      session: %{"mode" => "team-management"}
    )}
  </.tile>
  <.tile docs="users-roles#leaving-team">
    <:title>Leave Team</:title>
    <:subtitle>Leaving the team removes you from this team as a member.</:subtitle>
    <.button_link
      data-confirm="Are you sure you want to leave this team?"
      href={Routes.settings_path(@conn, :leave_team)}
      method="post"
      theme="danger"
    >
      Leave Team
    </.button_link>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/change_domain.html.heex`
```
<PlausibleWeb.Components.FlowProgress.render
  flow={PlausibleWeb.Flows.domain_change()}
  current_step="Set up new domain"
/>
<.focus_box>
  <:title>Change your website domain</:title>

  <:subtitle>
    Once you change your domain, you <i>must</i>
    update Plausible Installation on your site within 72 hours to guarantee continuous tracking.
    <br /><br />If you're using the API, please also make sure to update your API credentials. Visit our
    <.styled_link new_tab href="https://plausible.io/docs/change-domain-name/">
      documentation
    </.styled_link>
    for details.
  </:subtitle>

  <:footer>
    <.focus_list>
      <:item>
        Changed your mind? Go back to
        <.styled_link href={Routes.site_path(@conn, :settings_general, @site.domain)}>
          Site Settings
        </.styled_link>
      </:item>
    </.focus_list>
  </:footer>

  <.form
    :let={f}
    for={@changeset}
    action={
      Routes.site_path(@conn, :change_domain_submit, @site.domain,
        flow: PlausibleWeb.Flows.domain_change()
      )
    }
  >
    <.input
      help_text="Just the naked domain or subdomain without 'www', 'https' etc."
      type="text"
      placeholder="example.com"
      field={f[:domain]}
      label="Domain"
    />

    <.button type="submit" class="mt-4 w-full">
      Change Domain and add new Snippet
    </.button>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/site/csv_import.html.heex`
```
<.focus_box>
  <:title>Import from CSV files</:title>
  <:subtitle>
    Please ensure each file follows
    <.styled_link href="https://plausible.io/docs/csv-import">
      our CSV format guidelines.
    </.styled_link>
    You can upload multiple files simultaneously by either selecting them in the file dialog or dragging and dropping them into the designated area.
  </:subtitle>
  {live_render(@conn, PlausibleWeb.Live.CSVImport,
    session: %{
      "site_id" => @site.id,
      "storage" => on_ee(do: "s3", else: "local")
    }
  )}
</.focus_box>
```

## File: `lib/plausible_web/templates/site/edit_shared_link.html.heex`
```
<.focus_box>
  <:title>Edit Shared Link</:title>

  <.form
    :let={f}
    for={@changeset}
    action={"/sites/#{URI.encode_www_form(@site.domain)}/shared-links/#{@changeset.data.slug}"}
    class=""
  >
    <.input type="text" field={f[:name]} label="Name" />

    <.button class="w-full" type="submit">Update</.button>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/site/membership/change_team_form.html.heex`
```
<.focus_box>
  <:title>
    Change the team of {@site.domain}
  </:title>
  <:subtitle>
    Choose the team you'd like to move the site to. The new team must have a sufficient subscription plan.
  </:subtitle>
  <.form :let={f} for={@conn} action={Routes.membership_path(@conn, :change_team, @site.domain)}>
    <div class="my-6">
      <.input
        type="select"
        options={@transferable_teams}
        field={f[:team_identifier]}
        label="Destination Team"
        required="true"
      />
      <%= if @conn.assigns[:error] do %>
        <div class="text-red-500 mt-4">{@conn.assigns[:error]}</div>
      <% end %>
    </div>

    <.button type="submit" class="w-full" mt?={false}>Change team</.button>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/site/membership/invite_member_form.html.heex`
```
<.focus_box>
  <:title>
    Invite guest to {@site.domain}
  </:title>

  <:subtitle>
    Enter the email address and role of the person you want to invite. We will contact them over email to offer them access to {@site.domain} analytics.<br /><br />
    The invitation will expire in 48 hours
  </:subtitle>

  <.form :let={f} for={@conn} action={Routes.membership_path(@conn, :invite_member, @site.domain)}>
    <PlausibleWeb.Components.Billing.Notice.limit_exceeded
      :if={Map.get(assigns, :is_at_limit, false)}
      current_role={@current_team_role}
      current_team={@site_team}
      limit={Map.get(assigns, :team_member_limit, 0)}
      resource="members"
    />

    <div class="my-6">
      <.input
        type="email"
        field={f[:email]}
        label="Email address"
        placeholder="joe@example.com"
        required="true"
      />

      <%= if @conn.assigns[:error] do %>
        <div class="text-red-500 mb-4">{@conn.assigns[:error]}</div>
      <% end %>
    </div>

    <fieldset x-data="{selectedOption: null}">
      <.label for={f[:role].id}>
        Role
      </.label>
      <div class="mt-1 bg-white rounded-md -space-y-px dark:bg-gray-800">
        <label
          class="border-gray-200 dark:border-gray-500 rounded-tl-md rounded-tr-md relative border p-4 flex cursor-pointer"
          x-class="{'bg-indigo-50 border-indigo-200 dark:bg-indigo-500 dark:border-indigo-800 z-10': selectedOption === 'editor', 'border-gray-200': selectedOption !== 'editor'}"
        >
          <.input
            type="radio"
            field={f[:role]}
            id="role_editor"
            value="editor"
            x-model="selectedOption"
            required="true"
            width="w-4"
            class="block dark:bg-gray-900 h-4 w-4 mt-0.5 cursor-pointer text-indigo-600 border-gray-300 dark:border-gray-500 focus:ring-indigo-500"
          />
          <div class="ml-3 flex flex-col">
            <span
              class="text-gray-900 dark:text-gray-100 block text-sm font-medium"
              x-class="{'text-indigo-900 dark:text-white': selectedOption === 'editor', 'text-gray-900 dark:text-gray-100': selectedOption !== 'editor'}"
            >
              Guest Editor
            </span>
            <span
              class="text-gray-500 dark:text-gray-400 text-sm block"
              x-class="{'text-indigo-700 dark:text-gray-100': selectedOption === 'editor', 'text-gray-500 dark:text-gray-200': selectedOption !== 'editor'}"
            >
              Can view stats and change site settings
            </span>
          </div>
        </label>

        <label
          class="border-gray-200 dark:border-gray-500 rounded-bl-md rounded-br-md relative border p-4 flex cursor-pointer"
          x-class="{'bg-indigo-50 border-indigo-200 dark:bg-indigo-500 dark:border-indigo-800 z-10': selectedOption === 'viewer', 'border-gray-200': selectedOption !== 'viewer'}"
        >
          <.input
            type="radio"
            field={f[:role]}
            id="role_viewer"
            value="viewer"
            x-model="selectedOption"
            required="true"
            width="w-4"
            class="block dark:bg-gray-900 h-4 w-4 mt-0.5 cursor-pointer text-indigo-600 border-gray-300 dark:border-gray-500 focus:ring-indigo-500"
          />
          <div class="ml-3 flex flex-col">
            <span
              class="text-gray-900 dark:text-gray-100 text-sm block font-medium"
              x-class="{'text-indigo-900 dark:text-white': selectedOption === 'viewer', 'text-gray-900 dark:text-gray-100': selectedOption !== 'viewer'}"
            >
              Guest Viewer
            </span>
            <span
              class="text-gray-500 dark:text-gray-400 text-sm block"
              x-class="{'text-indigo-700 dark:text-gray-100': selectedOption === 'viewer', 'text-gray-500 dark:text-gray-200': selectedOption !== 'viewer'}"
            >
              Can view stats but cannot access settings
            </span>
          </div>
        </label>
      </div>
    </fieldset>

    <div class="mt-6">
      <.button type="submit" class="w-full">
        Invite
      </.button>
    </div>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/site/membership/transfer_ownership_form.html.heex`
```
<.focus_box>
  <:title>
    Transfer ownership of {@site.domain}
  </:title>
  <:subtitle>
    Enter the email address of the new owner. We will contact them over email to
    offer them the ownership of {@site.domain}. If they don't respond in 48
    hours, the request will expire automatically. <br /><br />
    Do note that a subscription plan is not transferred alongside the site. If
    they accept the transfer request, the new owner will need to have an active
    subscription. Your access will be downgraded to <b>guest editor</b>
    and any other
    member roles will stay the same.
  </:subtitle>
  <.form
    :let={f}
    for={@conn}
    action={Routes.membership_path(@conn, :transfer_ownership, @site.domain)}
  >
    <%= if @conn.assigns[:error] do %>
      <div class="text-red-500 text-xs italic mt-4">{@conn.assigns[:error]}</div>
    <% end %>

    <div class="my-6">
      <.input
        type="email"
        field={f[:email]}
        label="Email address"
        placeholder="joe@example.com"
        required="true"
      />
    </div>

    <.button type="submit" class="w-full" mt?={false}>Request transfer</.button>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/site/new.html.heex`
```
<PlausibleWeb.Components.FlowProgress.render flow={@flow} current_step="Add site info" />

<.focus_box>
  <:title>
    Add website info
  </:title>

  <.form :let={f} for={@changeset} action={@form_submit_url}>
    <PlausibleWeb.Components.Billing.Notice.limit_exceeded
      :if={@site_limit_exceeded?}
      current_role={@current_team_role}
      current_team={@current_team}
      limit={@site_limit}
      resource="sites"
    />

    <div class="my-6">
      <.input
        help_text="Just the naked domain or subdomain without 'www', 'https' etc."
        type="text"
        placeholder="example.com"
        field={f[:domain]}
        label="Domain"
        disabled={@site_limit_exceeded?}
      />
    </div>
    <div class="my-6">
      <.input
        type="select"
        help_text="To make sure we agree on what 'today' means"
        field={f[:timezone]}
        id="tz-select"
        value="Etc/Greenwich"
        disabled={@site_limit_exceeded?}
        label="Reporting Timezone"
        options={Plausible.Timezones.options()}
      />
    </div>
    <script>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 var option;

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 if (typeof Intl !== "undefined") {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   var timezoneName = Intl.DateTimeFormat().resolvedOptions().timeZone
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     option = document.querySelector('#tz-select option[value="' + timezoneName + '"]')
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 }

      if (!option) {
        var offset = (new Date()).getTimezoneOffset()
          option = document.querySelector('#tz-select option[offset="' + offset + '"]')
      }

      if (option) { option.selected = "selected"}
    </script>

    <.button
      disabled={@site_limit_exceeded?}
      type="submit"
      class="w-full disabled:cursor-not-allowed"
    >
      Install Plausible
    </.button>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/site/new_shared_link.html.heex`
```
<.focus_box>
  <:title>New Shared Link</:title>
  <:subtitle>
    Password protection is optional. Please make sure you save it in a secure place. Once the link is created, we cannot reveal the password.
  </:subtitle>
  <.form
    :let={f}
    for={@changeset}
    action={"/sites/#{URI.encode_www_form(@site.domain)}/shared-links"}
  >
    <div class="flex flex-col gap-y-4">
      <.input field={f[:name]} label="Name" required="required" autocomplete="off" mt?={false} />
      <.input
        field={f[:password]}
        label="Password (optional)"
        type="password"
        autocomplete="new-password"
        mt?={false}
      />

      <.button class="w-full mt-4" type="submit" mt?={false}>Create shared link</.button>
    </div>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/site/settings_danger_zone.html.heex`
```
<.notice title="Danger Zone" theme={:red}>
  Destructive actions below can result in irrecoverable data loss. Be careful.
</.notice>

<.settings_tiles>
  <.tile>
    <:title>Transfer Site Ownership</:title>
    <:subtitle>Transfer ownership of the site to a different account</:subtitle>
    <.button_link
      href={Routes.membership_path(@conn, :transfer_ownership_form, @site.domain)}
      theme="danger"
    >
      Transfer {@site.domain} ownership
    </.button_link>
  </.tile>

  <.tile :if={Enum.count(Plausible.Teams.Users.teams(@current_user, roles: [:owner, :admin])) > 1}>
    <:title>Change Teams</:title>
    <:subtitle>Move the site to another team that you are a member of</:subtitle>
    <.button_link
      href={Routes.membership_path(@conn, :change_team_form, @site.domain)}
      theme="danger"
    >
      Change {@site.domain} team
    </.button_link>
  </.tile>

  <.tile>
    <:title>Reset Stats</:title>
    <:subtitle>Reset all stats but keep the site configuration intact</:subtitle>
    <.button_link
      href={Routes.site_path(@conn, :reset_stats, @site.domain)}
      method="delete"
      data-confirm="Resetting the stats cannot be reversed. Are you sure?"
      theme="danger"
    >
      Reset {@site.domain} stats
    </.button_link>
  </.tile>

  <.tile>
    <:title>Delete Site</:title>
    <:subtitle>Permanently remove all stats and the site configuration too</:subtitle>
    <.button_link
      href={Routes.site_path(@conn, :delete_site, @site.domain)}
      theme="danger"
      method="delete"
      data-confirm="Deleting the site data cannot be reversed. Are you sure?"
    >
      Delete {@site.domain}
    </.button_link>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/settings_email_reports.html.heex`
```
<.settings_tiles>
  <% email_reports = [
    weekly: %{
      report: @weekly_report,
      disable_route: :disable_weekly_report,
      enable_route: :enable_weekly_report,
      remove_route: :remove_weekly_report_recipient,
      add_route: :add_weekly_report_recipient,
      heading: "Weekly Email Reports",
      subtitle: "Send weekly analytics reports to as many addresses as you wish",
      toggle: "Send a weekly email report every Monday",
      add_label: "Add Weekly Report Recipient"
    },
    monthly: %{
      report: @monthly_report,
      disable_route: :disable_monthly_report,
      enable_route: :enable_monthly_report,
      remove_route: :remove_monthly_report_recipient,
      add_route: :add_monthly_report_recipient,
      heading: "Monthly Email Reports",
      subtitle: "Send monthly analytics reports to as many addresses as you wish",
      toggle: "Send a monthly email report on 1st of the month",
      add_label: "Add Monthly Report Recipient"
    }
  ] %>

  <.tile :for={{_type, meta} <- email_reports} docs="email-reports">
    <:title>
      {meta.heading}
    </:title>
    <:subtitle>
      {meta.subtitle}
    </:subtitle>

    <.form
      for={nil}
      action={
        (meta.report && Routes.site_path(@conn, meta.disable_route, @site.domain)) ||
          Routes.site_path(@conn, meta.enable_route, @site.domain)
      }
      method="post"
    >
      <div>
        <.toggle_submit set_to={meta.report}>
          {meta.toggle}
        </.toggle_submit>
      </div>
    </.form>

    <div :if={meta.report} class="mt-4">
      <.table
        :if={Enum.count(meta.report.recipients) > 0}
        width="w-1/2"
        rows={meta.report.recipients}
      >
        <:thead>
          <.th>
            Recipients
          </.th>
          <.th invisible>Actions</.th>
        </:thead>

        <:tbody :let={recipient}>
          <.td>
            <div class="flex items-center gap-x-2">
              <Heroicons.envelope_open class="w-6 h-6 feather" />
              <div>
                {recipient}
              </div>
            </div>
          </.td>
          <.td actions>
            <.delete_button
              method="delete"
              href={
                Routes.site_path(
                  @conn,
                  meta.remove_route,
                  @site.domain,
                  recipient
                )
              }
            />
          </.td>
        </:tbody>
      </.table>

      <.form
        :let={f}
        class="mt-4"
        for={@conn}
        action={Routes.site_path(@conn, meta.add_route, @site.domain)}
        method="post"
      >
        <div class="flex items-end gap-x-2">
          <PlausibleWeb.Live.Components.Form.input
            field={f[:recipient]}
            type="email"
            required
            placeholder="e.g. joe@example.com"
            mt?={false}
          />
          <.button type="submit" mt?={false}>
            Add Recipient
          </.button>
        </div>
      </.form>
    </div>
  </.tile>

  <% change_notifications = [
    spike: %{
      notification: @spike_notification,
      heading: "Traffic Spike Notifications",
      subtitle: "Get notified when your site has unusually high number of current visitors",
      threshold_text: "Current visitors threshold",
      toggle: "Send notifications of traffic spikes"
    },
    drop: %{
      notification: @drop_notification,
      heading: "Traffic Drop Notifications",
      subtitle:
        "Get notified when your site has unusually low number of visitors within 12 hours",
      threshold_text: "12 hours visitor threshold",
      toggle: "Send notifications of traffic drops"
    }
  ] %>

  <.tile :for={{type, meta} <- change_notifications} docs="traffic-spikes">
    <:title>
      {meta.heading}
    </:title>
    <:subtitle>
      {meta.subtitle}
    </:subtitle>

    <.form
      for={nil}
      action={
        (meta.notification &&
           Routes.site_path(@conn, :disable_traffic_change_notification, @site.domain, type)) ||
          Routes.site_path(@conn, :enable_traffic_change_notification, @site.domain, type)
      }
      method="post"
    >
      <.toggle_submit set_to={meta.notification}>
        {meta.toggle}
      </.toggle_submit>
    </.form>

    <.form
      :let={f}
      :if={meta.notification}
      class="mt-4"
      for={Plausible.Site.TrafficChangeNotification.changeset(meta.notification, %{})}
      action={Routes.site_path(@conn, :update_traffic_change_notification, @site.domain, type)}
    >
      <div class="flex items-end gap-x-4">
        <PlausibleWeb.Live.Components.Form.input
          field={f[:threshold]}
          type="number"
          required
          label={meta.threshold_text}
        />
        <.button type="submit" mt?={false}>
          Save Threshold
        </.button>
      </div>
    </.form>

    <div class="mt-4">
      <.table
        :if={meta.notification && Enum.count(meta.notification.recipients) > 0}
        width="w-1/2"
        rows={meta.notification.recipients}
      >
        <:thead>
          <.th>
            Recipients
          </.th>
          <.th invisible>Actions</.th>
        </:thead>

        <:tbody :let={recipient}>
          <.td>
            <div class="flex items-cetner gap-x-2">
              <Heroicons.envelope_open class="w-6 h-6 feather" />
              <div>
                {recipient}
              </div>
            </div>
          </.td>
          <.td actions>
            <.delete_button
              method="delete"
              href={
                Routes.site_path(
                  @conn,
                  :remove_traffic_change_notification_recipient,
                  @site.domain,
                  type,
                  recipient
                )
              }
            />
          </.td>
        </:tbody>
      </.table>
    </div>

    <div :if={meta.notification}>
      <.form
        :let={f}
        for={@conn}
        class="mt-4"
        action={
          Routes.site_path(
            @conn,
            :add_traffic_change_notification_recipient,
            @site.domain,
            type
          )
        }
      >
        <div class="flex items-end gap-x-4">
          <PlausibleWeb.Live.Components.Form.input
            field={f[:recipient]}
            type="email"
            placeholder="e.g. joe@example.com"
            mt?={false}
            required
          />
          <.button type="submit" mt?={false}>
            Add Recipient
          </.button>
        </div>
      </.form>
    </div>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/settings_funnels.html.heex`
```
<.settings_tiles>
  <.tile
    docs="funnel-analysis"
    feature_mod={Plausible.Billing.Feature.Funnels}
    feature_toggle?={true}
    current_role={@site_role}
    current_team={@site_team}
    site={@site}
    conn={@conn}
  >
    <:title>
      Funnels
    </:title>
    <:subtitle>
      Compose Goals into Funnels
    </:subtitle>

    {live_render(@conn, PlausibleWeb.Live.FunnelSettings,
      session: %{"site_id" => @site.id, "domain" => @site.domain}
    )}
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/settings_general.html.heex`
```
<.settings_tiles>
  <.tile docs="change-domain-name">
    <:title>
      Site Domain
    </:title>
    <:subtitle>
      Moving your site to a different domain? We got you!
    </:subtitle>
    <.input name="domain" label="Domain" value={@site.domain} disabled width="w-1/2" />

    <.button_link href={Routes.site_path(@conn, :change_domain, @site.domain)}>
      Change Domain
    </.button_link>
  </.tile>

  <.tile docs="general">
    <:title>Site Timezone</:title>
    <:subtitle>Update your reporting timezone</:subtitle>
    <.form :let={f} for={@changeset} action={"/#{URI.encode_www_form(@site.domain)}/settings"}>
      <.input
        field={f[:timezone]}
        label="Reporting Timezone"
        type="select"
        options={Plausible.Timezones.options()}
        width="w-1/2"
      />
      <.button type="submit">
        Save timezone
      </.button>
    </.form>
  </.tile>
  <.tile docs="plausible-script">
    <:title>Site Installation</:title>
    <:subtitle>
      Control what data is collected and verify your installation.
    </:subtitle>
    <.button_link
      class="mt-4"
      href={
        Routes.site_path(@conn, :installation, @site.domain, flow: PlausibleWeb.Flows.review())
      }
    >
      Review Installation
    </.button_link>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/settings_goals.html.heex`
```
<.settings_tiles>
  <.tile
    docs="goal-conversions"
    feature_mod={Plausible.Billing.Feature.Goals}
    feature_toggle?={true}
    site={@site}
    conn={@conn}
  >
    <:title>
      Goals
    </:title>
    <:subtitle>
      <p>
        Define actions that you want your users to take, like visiting a certain page, submitting a form, etc.
      </p>
      <p :if={ee?()}>
        You can also
        <.styled_link href={Routes.site_path(@conn, :settings_funnels, @site.domain)}>
          compose Goals into Funnels
        </.styled_link>
      </p>
    </:subtitle>

    <div :if={Plausible.Billing.Feature.Goals.enabled?(@site)}>
      {live_render(@conn, PlausibleWeb.Live.GoalSettings,
        session: %{"site_id" => @site.id, "domain" => @site.domain}
      )}
    </div>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/settings_imports_exports.html.heex`
```
<.settings_tiles docs="google-analytics-import">
  <.tile>
    <:title>
      Import Data
    </:title>
    <:subtitle>
      Import existing data from external sources.
      Pick one of the options below to start a new import. <br />
      A maximum of {Plausible.Imported.max_complete_imports()} imports at any time is allowed.
    </:subtitle>

    {live_render(@conn, PlausibleWeb.Live.ImportsExportsSettings,
      session: %{"domain" => @site.domain}
    )}
  </.tile>

  <.tile>
    <:title>
      Export Data
    </:title>
    <:subtitle>
      Export all your data into CSV format
    </:subtitle>

    {live_render(@conn, PlausibleWeb.Live.CSVExport,
      session: %{
        "site_id" => @site.id,
        "email_to" => @current_user.email,
        "storage" => on_ee(do: "s3", else: "local")
      }
    )}
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/settings_integrations.html.heex`
```
<% use Plausible %>

<.settings_tiles>
  <.tile docs="google-search-console-integration">
    <:title>
      Google Search Console Integration
    </:title>
    <:subtitle>
      <p>
        You can integrate with Google Search Console to get all of your important search results stats such as keyword phrases people find your site with.
      </p>
    </:subtitle>
    <%= if Keyword.get(Application.get_env(:plausible, :google), :client_id) do %>
      <%= if @site.google_auth do %>
        <.input
          name="account"
          label="Linked Google account"
          value={@site.google_auth.email}
          disabled="disabled"
          width="w-1/2"
        />

        <.button_link
          theme="danger"
          href={Routes.site_path(@conn, :delete_google_auth, @site.domain)}
          method="delete"
        >
          Unlink Google Account
        </.button_link>

        <%= case @search_console_domains do %>
          <% {:ok, domains} -> %>
            <%= if @site.google_auth.property && !(@site.google_auth.property in domains) do %>
              <.notice class="mt-4 mb-4">
                Your Google account does not have access to your currently configured property, {@site.google_auth.property}. Please select a verified property from the list below.
              </.notice>
            <% else %>
              <p class="text-sm mt-4">
                Select the Google Search Console property you would like to pull keyword data from. If you don't see your domain,
                <.styled_link
                  href="https://plausible.io/docs/google-search-console-integration"
                  new_tab={true}
                >
                  set it up and verify
                </.styled_link>
                on Search Console first.
              </p>
            <% end %>

            <.form
              :let={f}
              for={Plausible.Site.GoogleAuth.changeset(@site.google_auth)}
              class="max-w-xs"
              action={"/#{URI.encode_www_form(@site.domain)}/settings/google"}
            >
              <div class="inline-block relative w-full">
                <.input
                  options={domains}
                  type="select"
                  field={f[:property]}
                  prompt="(Choose property)"
                  class="dark:bg-gray-800 mt-1 block w-full pl-3 pr-10 py-2 border-gray-300 dark:border-gray-500 outline-none focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:rounded-md"
                />
              </div>

              <.button type="submit">Save</.button>
            </.form>
          <% {:error, error} -> %>
            <.notice title="Integration Error" theme={:red} class="mt-8">
              <%= case error do %>
                <% "invalid_grant" -> %>
                  Invalid Grant error returned from Google.
                  <.styled_link
                    new_tab={true}
                    href="https://plausible.io/docs/google-search-console-integration#i-get-the-invalid-grant-error"
                  >
                    See here on how to fix it
                  </.styled_link>
                <% "google_auth_error" -> %>
                  Your Search Console account hasn't been connected successfully. Please unlink your Google account and try linking it again.
                <% _ -> %>
                  Something went wrong, but looks temporary. If the problem persists, try re-linking your Google account.
              <% end %>
            </.notice>
        <% end %>
      <% else %>
        <PlausibleWeb.Components.Google.button
          id="search-console-connect"
          to={Plausible.Google.API.search_console_authorize_url(@site.id)}
        />
        <div class="mt-8 text-sm">
          NB: You also need to set up your site on
          <.styled_link href="https://search.google.com/search-console/about" new_tab={true}>
            Google Search Console
          </.styled_link>
          for the integration to work.
          <.styled_link
            href="https://plausible.io/docs/google-search-console-integration"
            new_tab={true}
          >
            Read the docs
          </.styled_link>
        </div>
      <% end %>
    <% else %>
      <div class="my-8 text-center text-lg">
        <svg
          class="block mx-auto mb-4 w-6 h-6 text-yellow-500"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            stroke-linecap="round"
            stroke-linejoin="round"
            stroke-width="2"
            d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
          >
          </path>
        </svg>
        <p>
          An extra step is needed to set up your {Plausible.product_name()} for the Google Search Console integration.
          Find instructions
          <.styled_link href="https://github.com/plausible/community-edition/wiki/google-integration">
            here
          </.styled_link>
        </p>
      </div>
    <% end %>
  </.tile>

  <.tile :if={ee?()} docs="looker-studio">
    <:title>
      Google Looker Studio Connector
    </:title>
    <:subtitle>
      <p>
        You can use our Looker Studio connector to build custom reports with your Plausible data.
      </p>
    </:subtitle>

    <div class="mt-4 text-sm">
      Plausible Looker Studio Connector adds powerful reporting features that help turn Plausible
      into an even better replacement for Google Analytics.
      <.styled_link href="https://plausible.io/docs/looker-studio" new_tab={true}>
        Read the docs
      </.styled_link>
    </div>
  </.tile>

  <.tile :if={@has_plugins_tokens? || @conn.query_params["new_token"]}>
    <:title>
      Plugin Tokens
    </:title>
    <:subtitle>
      Control Plugin Access
    </:subtitle>

    {live_render(@conn, PlausibleWeb.Live.Plugins.API.Settings,
      session: %{
        "site_id" => @site.id,
        "domain" => @site.domain,
        "new_token" => @conn.query_params["new_token"]
      }
    )}
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/settings_people.html.heex`
```
<.settings_tiles>
  <%= if not Plausible.Teams.setup?(@site.team) and not Plausible.Teams.Billing.solo?(@site.team) do %>
    <PlausibleWeb.Team.Notice.owner_cta_banner :if={@site_role == :owner} />
    <PlausibleWeb.Team.Notice.guest_cta_banner :if={@site_role != :owner} />
  <% end %>

  <.tile
    docs="users-roles"
    feature_mod={Plausible.Billing.Feature.Teams}
    site={@site}
    current_role={@site_role}
    current_team={@site_team}
    conn={@conn}
  >
    <:title>People</:title>
    <:subtitle>Invite your friends or coworkers</:subtitle>

    <.filter_bar :if={@site_role in [:owner, :admin]} filtering_enabled?={false}>
      <.button_link
        mt?={false}
        href={Routes.membership_path(@conn, :invite_member_form, @site.domain)}
      >
        Invite New Guest
      </.button_link>
    </.filter_bar>

    <PlausibleWeb.Team.Notice.team_members_notice :if={
      @site_role in [:owner, :admin] and Plausible.Teams.setup?(@current_team)
    } />

    <div class="flow-root">
      <ul class="divide-y divide-gray-200 dark:divide-gray-400">
        <%= for membership <- @memberships do %>
          <li class="py-4" id={"membership-#{membership.user.id}"}>
            <div class="flex items-center space-x-4">
              <div class="flex-shrink-0">
                <img
                  src={Plausible.Auth.User.profile_img_url(membership.user)}
                  class="h-8 w-8 rounded-full"
                />
              </div>
              <div class="flex-1 min-w-0">
                <p class="text-sm truncate">
                  <span class="font-medium text-gray-900 dark:text-gray-50">
                    {membership.user.name}
                  </span>
                  <br />
                  <span class="text-gray-500 dark:text-gray-400">
                    {membership.user.email}
                  </span>
                </p>
              </div>

              <.dropdown>
                <:button class="bg-transparent text-gray-800 dark:text-gray-100 hover:bg-gray-50 dark:hover:bg-gray-700 focus-visible:outline-gray-100 whitespace-nowrap truncate inline-flex items-center gap-x-2 font-medium rounded-md px-3.5 py-2.5 text-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 disabled:bg-gray-400 dark:disabled:text-white dark:disabled:text-gray-400 dark:disabled:bg-gray-700">
                  {site_role(membership)}
                  <Heroicons.chevron_down mini class="size-4 mt-0.5" />
                </:button>
                <:menu class="max-w-60">
                  <%= if membership.role == :owner do %>
                    <.dropdown_item disabled={true}>
                      <div>Owner</div>
                      <div class="text-gray-500 dark:text-gray-400 text-xs/5">
                        Site owner cannot be assigned to any other role
                      </div>
                    </.dropdown_item>
                    <.dropdown_divider />
                    <.dropdown_item
                      :if={@site_role in [:owner, :admin]}
                      class="text-red-600 dark:text-red-500 hover:text-red-600"
                      href={
                        Routes.membership_path(
                          @conn,
                          :transfer_ownership_form,
                          @site.domain
                        )
                      }
                    >
                      Transfer ownership
                    </.dropdown_item>
                  <% else %>
                    <.dropdown_item
                      href={
                        Routes.membership_path(
                          @conn,
                          :update_role_by_user,
                          @site.domain,
                          membership.user.id,
                          "editor"
                        )
                      }
                      method="put"
                      disabled={@site_role not in [:owner, :admin] or membership.role == "editor"}
                    >
                      <div>Guest Editor</div>
                      <div class="text-gray-500 dark:text-gray-400 text-xs/5">
                        View stats and edit site settings
                      </div>
                    </.dropdown_item>
                    <.dropdown_item
                      href={
                        Routes.membership_path(
                          @conn,
                          :update_role_by_user,
                          @site.domain,
                          membership.user.id,
                          "viewer"
                        )
                      }
                      method="put"
                      disabled={@site_role not in [:owner, :admin] or membership.role == "viewer"}
                    >
                      <div>Guest Viewer</div>
                      <div class="text-gray-500 dark:text-gray-400 text-xs/5">
                        View stats only
                      </div>
                    </.dropdown_item>
                    <.dropdown_divider />
                    <.dropdown_item
                      href={
                        Routes.membership_path(
                          @conn,
                          :remove_member_by_user,
                          @site.domain,
                          membership.user.id
                        )
                      }
                      class="text-red-600 hover:text-red-600"
                      method="delete"
                      disabled={@site_role not in [:owner, :admin]}
                    >
                      Remove member
                    </.dropdown_item>
                  <% end %>
                </:menu>
              </.dropdown>
            </div>
          </li>
        <% end %>
      </ul>
    </div>
  </.tile>

  <.tile :if={Enum.count(@invitations) > 0}>
    <:title>Pending invitations</:title>
    <:subtitle>Waiting for new members to accept their invitations</:subtitle>

    <.table
      rows={@invitations}
      row_attrs={fn invitation -> %{id: "invitation-#{invitation.invitation_id}"} end}
    >
      <:thead>
        <.th>Email</.th>
        <.th hide_on_mobile>Role</.th>
        <.th invisible>Actions</.th>
      </:thead>
      <:tbody :let={invitation}>
        <.td>{invitation.email}</.td>
        <.td hide_on_mobile>{Phoenix.Naming.humanize(invitation.role)}</.td>
        <.td actions>
          <.delete_button
            :if={@site_role in [:owner, :admin]}
            href={
              Routes.invitation_path(
                @conn,
                :remove_invitation,
                @site.domain,
                invitation.invitation_id
              )
            }
            method="delete"
          />
        </.td>
      </:tbody>
    </.table>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/settings_props.html.heex`
```
<.settings_tiles>
  <.tile
    docs="custom-props/introduction"
    feature_mod={Plausible.Billing.Feature.Props}
    feature_toggle?={true}
    site={@site}
    current_role={@site_role}
    current_team={@site_team}
    conn={@conn}
  >
    <:title>
      Custom Properties
    </:title>
    <:subtitle>
      Attach Custom Properties when sending a Pageview or an Event to
      create custom metrics.
    </:subtitle>

    {live_render(@conn, PlausibleWeb.Live.PropsSettings,
      id: "props-form",
      session: %{"site_id" => @site.id, "domain" => @site.domain}
    )}
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/site/settings_shields.html.heex`
```
<%= case @shield do %>
  <% "ip_addresses" -> %>
    {live_render(@conn, PlausibleWeb.Live.Shields.IPAddresses,
      session: %{
        "site_id" => @site.id,
        "domain" => @site.domain,
        "remote_ip" => PlausibleWeb.RemoteIP.get(@conn)
      }
    )}
  <% "countries" -> %>
    {live_render(@conn, PlausibleWeb.Live.Shields.Countries,
      session: %{
        "site_id" => @site.id,
        "domain" => @site.domain
      }
    )}
  <% "pages" -> %>
    {live_render(@conn, PlausibleWeb.Live.Shields.Pages,
      session: %{
        "site_id" => @site.id,
        "domain" => @site.domain
      }
    )}
  <% "hostnames" -> %>
    {live_render(@conn, PlausibleWeb.Live.Shields.Hostnames,
      session: %{
        "site_id" => @site.id,
        "domain" => @site.domain
      }
    )}
<% end %>
```

## File: `lib/plausible_web/templates/site/settings_visibility.html.heex`
```
<.settings_tiles>
  <.tile docs="visibility">
    <:title>
      Public Dashboard
    </:title>
    <:subtitle>
      Share your stats publicly or keep them private
    </:subtitle>

    <.form
      action={
        (@site.public && Routes.site_path(@conn, :make_private, @site.domain)) ||
          Routes.site_path(@conn, :make_public, @site.domain)
      }
      method="post"
      for={nil}
    >
      <.toggle_submit set_to={@site.public}>
        Make stats publicly available on
        <.unstyled_link
          class="text-indigo-500"
          href={Routes.stats_path(@conn, :stats, @site.domain, [])}
        >
          {PlausibleWeb.StatsView.pretty_stats_url(@site)}
        </.unstyled_link>
      </.toggle_submit>
    </.form>
  </.tile>

  <.tile
    docs="shared-links"
    feature_mod={Plausible.Billing.Feature.SharedLinks}
    site={@site}
    current_role={@site_role}
    current_team={@site_team}
    conn={@conn}
  >
    <:title>
      Shared Links
    </:title>
    <:subtitle>
      You can share your stats privately by generating a shared link. The links are impossible to guess and you can add password protection for extra security.
    </:subtitle>

    <.filter_bar filtering_enabled?={false}>
      <.button_link href={Routes.site_path(@conn, :new_shared_link, @site.domain)} mt?={false}>
        Add Shared Link
      </.button_link>
    </.filter_bar>

    <p :if={Enum.empty?(@shared_links)} class="mb-8 text-center text-sm">
      No Shared Links configured for this site.
    </p>

    <.table rows={@shared_links} id="shared-links-table">
      <:thead>
        <.th hide_on_mobile>Name</.th>
        <.th>Link</.th>
        <.th invisible>Actions</.th>
      </:thead>
      <:tbody :let={link}>
        <.td truncate hide_on_mobile>
          {link.name}
          <Heroicons.lock_closed :if={link.password_hash} class="w-6 h-6 feather ml-2" />
          <Heroicons.lock_open :if={!link.password_hash} class="w-6 h-6 feather ml-2" />
        </.td>
        <.td>
          <.input_with_clipboard
            name={link.slug}
            id={link.slug}
            value={shared_link_dest(@site, link)}
          />
        </.td>
        <.td actions>
          <.edit_button
            class="mt-2"
            href={Routes.site_path(@conn, :edit_shared_link, @site.domain, link.slug)}
          />
          <.delete_button
            class="mt-2"
            method="delete"
            href={Routes.site_path(@conn, :delete_shared_link, @site.domain, link.slug)}
            data-confirm="Are you sure you want to delete this shared link? The stats will not be accessible with this link anymore."
          />
        </.td>
      </:tbody>
    </.table>
  </.tile>

  <.tile
    docs="embed-dashboard"
    feature_mod={Plausible.Billing.Feature.SharedLinks}
    site={@site}
    current_role={@site_role}
    current_team={@site_team}
    conn={@conn}
  >
    <:title>
      Embed Dashboard
    </:title>
    <:subtitle>
      You can use shared links to embed your stats in any other webpage using an <code>iframe</code>. Copy & paste a shared link into the form below to generate the embed code.
    </:subtitle>

    <.input
      name="embed-link"
      id="embed-link"
      label="Enter Shared Link (only public shared links without password can be embedded)"
      value=""
      width="w-1/2"
    />

    <.input
      type="select"
      name="theme"
      id="theme"
      label="Select Theme"
      options={["Light", "Dark", "System"]}
      value="Light"
      width="w-1/2"
    />

    <.input
      name="background"
      id="background"
      label="Custom Background Colour (optional). Try using `transparent` background to blend the dashboard with your site."
      value=""
      placeholder="e.g. #F9FAFB"
      width="w-1/2"
    />

    <.input name="base-url" type="hidden" id="base-url" value={plausible_url()} />
    <.button id="generate-embed" class="mt-4">
      Generate Embed Code
    </.button>

    <.label for="embed-code">Embed Code</.label>

    <div class="relative mt-1">
      <textarea
        id="embed-code"
        name="embed-code"
        rows="6"
        readonly="readonly"
        onclick="this.select()"
        class="block w-full border-gray-300 dark:border-gray-700 resize-none text-sm shadow-sm focus:ring-indigo-500 focus:border-indigo-500 rounded-md dark:bg-gray-900 dark:text-gray-300"
      ></textarea>
      <a
        onclick="var textarea = document.getElementById('embed-code'); textarea.focus(); textarea.select(); document.execCommand('copy');"
        href="javascript:void(0)"
        class="text-sm text-indigo-500 no-underline hover:underline"
      >
        <Heroicons.document_duplicate class="h-5 w-5 absolute text-indigo-700 top-3 right-3" />
      </a>
    </div>
  </.tile>
</.settings_tiles>
```

## File: `lib/plausible_web/templates/stats/shared_link_password.html.heex`
```
<.focus_box>
  <:title>Enter password</:title>
  <:subtitle>
    This link is password-protected. Please enter the password to continue to the dashboard.
  </:subtitle>
  <.form :let={f} for={@conn} action={"/share/#{@link.slug}/authenticate"}>
    <div class="my-6">
      <.input type="password" field={f[:password]} />

      <%= if @conn.assigns[:error] do %>
        <div class="text-red-500 text-xs italic mt-4">{@conn.assigns[:error]}</div>
      <% end %>
    </div>

    <.button type="submit" class="w-full">
      Continue
    </.button>
  </.form>
</.focus_box>
```

## File: `lib/plausible_web/templates/stats/site_locked.html.heex`
```
<div class="w-full max-w-lg mx-auto mt-8">
  <div class="bg-white dark:bg-gray-800 shadow sm:rounded-lg">
    <div class="px-4 py-5 sm:px-8 sm:py-6">
      <div class="mx-auto flex items-center justify-center rounded-full bg-green-100 h-12 w-12">
        <svg
          class="w-6 h-6 text-green-600"
          fill="currentColor"
          viewBox="0 0 20 20"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            fill-rule="evenodd"
            d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"
            clip-rule="evenodd"
          >
          </path>
        </svg>
      </div>
      <h3 class="mt-6 text-center text-2xl leading-6 font-medium text-gray-900 dark:text-gray-200">
        <%= if @conn.assigns[:only_shared_link_access_missing?] do %>
          Shared Link Unavailable
        <% else %>
          Dashboard Locked
        <% end %>
      </h3>

      <%= case @conn.assigns do %>
        <% %{only_shared_link_access_missing?: true} -> %>
          <p class="mt-6 text-gray-600 dark:text-gray-300 text-center">
            This shared link is locked because the owner of the site does not have access to the Shared Links feature. To restore it, the owner must upgrade to a suitable plan.
          </p>
        <% %{site_role: role} when role in [:owner, :billing] -> %>
          <div class="mt-3 text-gray-600 dark:text-gray-300 text-center">
            <p>
              This dashboard is locked because you don't have a valid subscription.
              Please subscribe to the appropriate tier with the link below to access the stats again.
            </p>
            <p class="mt-6 text-sm text-gray-500">
              You can configure your
              <.styled_link href={Routes.site_path(@conn, :settings_general, @site.domain)}>
                site settings
              </.styled_link>
              but your access to the dashboard is restricted.
            </p>
          </div>
          <div class="mt-6 w-full text-center">
            <.button_link href={Routes.settings_path(@conn, :subscription)}>
              Manage my subscription
            </.button_link>
          </div>
        <% %{site_role: role} when role in [:admin, :viewer, :editor] -> %>
          <div class="mt-3 text-gray-600 dark:text-gray-300 text-center">
            <p>
              Owner of this site must upgrade their subscription plan in order to unlock the stats.
            </p>
          </div>
          <div class="mt-6 w-full text-center">
            <.button_link href={Routes.site_path(@conn, :index)}>Back to my sites</.button_link>
          </div>
        <% _ -> %>
          <div class="mt-3 text-gray-600 dark:text-gray-300 text-center">
            <p>
              This dashboard is currently locked and cannot be accessed.
              You can check back later or contact the site owner to unlock the stats.
            </p>
          </div>
          <%= if @conn.assigns[:current_user] do %>
            <div class="mt-6 w-full text-center">
              <.button_link href={Routes.site_path(@conn, :index)}>Back to my sites</.button_link>
            </div>
          <% end %>
      <% end %>
    </div>
  </div>
</div>
```

## File: `lib/plausible_web/templates/stats/stats.html.heex`
```
<div class={stats_container_class(@conn)} data-site-domain={@site.domain}>
  <PlausibleWeb.Components.FirstDashboardLaunchBanner.render site={@site} />

  <%= if Plausible.Teams.locked?(@site.team) do %>
    <div
      class="w-full px-4 py-4 text-sm font-bold text-center text-yellow-800 bg-yellow-100 rounded transition"
      style="top: 91px"
      role="alert"
    >
      <p>This dashboard is actually locked. You are viewing it with super-admin access</p>
    </div>
  <% end %>

  <div class="pt-6"></div>
  <div
    id="stats-react-container"
    style="overflow-anchor: none;"
    data-domain={@site.domain}
    data-offset={Plausible.Site.tz_offset(@site)}
    data-has-goals={to_string(@has_goals)}
    data-conversions-opted-out={to_string(Plausible.Billing.Feature.Goals.opted_out?(@site))}
    data-funnels-opted-out={to_string(Plausible.Billing.Feature.Funnels.opted_out?(@site))}
    data-props-opted-out={to_string(Plausible.Billing.Feature.Props.opted_out?(@site))}
    data-funnels-available={
      to_string(Plausible.Billing.Feature.Funnels.check_availability(@site.team) == :ok)
    }
    data-props-available={
      to_string(Plausible.Billing.Feature.Props.check_availability(@site.team) == :ok)
    }
    data-site-segments-available={
      to_string(Plausible.Billing.Feature.SiteSegments.check_availability(@site.team) == :ok)
    }
    data-revenue-goals={Jason.encode!(@revenue_goals)}
    data-funnels={Jason.encode!(@funnels)}
    data-has-props={to_string(@has_props)}
    data-logged-in={to_string(!!@conn.assigns[:current_user])}
    data-stats-begin={@stats_start_date}
    data-native-stats-begin={@native_stats_start_date}
    data-shared-link-auth={assigns[:shared_link_auth]}
    data-embedded={to_string(@conn.assigns[:embedded])}
    data-background={@conn.assigns[:background]}
    data-is-dbip={to_string(@is_dbip)}
    data-current-user-role={@site_role}
    data-current-user-id={
      if user = @conn.assigns[:current_user], do: user.id, else: Jason.encode!(nil)
    }
    data-flags={Jason.encode!(@flags)}
    data-segments={Jason.encode!(@segments)}
    data-valid-intervals-by-period={
      Plausible.Stats.Interval.valid_by_period(site: @site) |> Jason.encode!()
    }
  >
  </div>
  <div id="modal_root"></div>
  <%= if !@conn.assigns[:current_user] && @conn.assigns[:demo] do %>
    <div class="bg-gray-50 dark:bg-gray-850">
      <div class="py-12 lg:py-16 lg:flex lg:items-center lg:justify-between">
        <h2 class="text-3xl font-extrabold tracking-tight text-gray-900 leading-9 sm:text-4xl sm:leading-10 dark:text-gray-100">
          Want these stats for your website? <br />
          <span class="text-indigo-600">Start your free trial today.</span>
        </h2>
        <div class="flex mt-8 lg:flex-shrink-0 lg:mt-0">
          <div class="inline-flex shadow rounded-md">
            <a
              href="/register"
              class="inline-flex items-center justify-center px-5 py-3 text-base font-medium text-white bg-indigo-600 border border-transparent leading-6 rounded-md hover:bg-indigo-500 focus:outline-none focus:ring transition duration-150 ease-in-out"
            >
              Get started
            </a>
          </div>
          <div class="inline-flex ml-3 shadow rounded-md">
            <a
              href="/"
              class="inline-flex items-center justify-center px-5 py-3 text-base font-medium text-indigo-600 bg-white border border-transparent leading-6 rounded-md dark:text-gray-100 dark:bg-gray-800 hover:text-indigo-500 dark:hover:text-indigo-500 focus:outline-none focus:ring transition duration-150 ease-in-out"
            >
              Learn more
            </a>
          </div>
        </div>
      </div>
    </div>
  <% end %>
</div>
```

## File: `lib/plausible_web/templates/unsubscribe/success.html.heex`
```
<.focus_box>
  <:title>
    Unsubscribe successful
  </:title>

  <:subtitle>
    You will no longer receive a {@interval} analytics report for {@site.domain}
  </:subtitle>
</.focus_box>
```

## File: `lib/plausible_web/tracker.ex`
```
defmodule PlausibleWeb.Tracker do
  @moduledoc """
  Helper module for building the dynamic tracker script. Used by PlausibleWeb.TrackerPlug.
  """

  use Plausible
  use Plausible.Repo
  alias Plausible.Site.TrackerScriptConfiguration

  path = Application.app_dir(:plausible, "priv/tracker/js/plausible-web.js")
  # On CI, the file might not be present for static checks so we create an empty one
  File.touch!(path)

  @plausible_main_script File.read!(path)
  @external_resource "priv/tracker/js/plausible-web.js"

  def plausible_main_script_tag(tracker_script_configuration) do
    config_js_content =
      tracker_script_configuration
      |> plausible_main_config()
      |> Enum.flat_map(fn
        {key, value} when is_binary(value) -> ["#{key}:#{JSON.encode!(value)}"]
        # :TRICKY: Save bytes by using short-hand for true
        {key, true} -> ["#{key}:!0"]
        # Not enabled values can be omitted
        {_key, false} -> []
      end)
      |> Enum.sort_by(&String.length/1, :desc)
      |> Enum.join(",")

    @plausible_main_script
    |> String.replace("\"<%= @config_js %>\"", "{#{config_js_content}}")
  end

  def plausible_main_config(tracker_script_configuration) do
    %{
      domain: tracker_script_configuration.site.domain,
      endpoint: tracker_ingestion_endpoint(),
      outboundLinks: tracker_script_configuration.outbound_links,
      fileDownloads: tracker_script_configuration.file_downloads,
      formSubmissions: tracker_script_configuration.form_submissions
    }
  end

  def update_script_configuration(site, config_update, changeset_type) do
    {:ok, updated_config} =
      Repo.transaction(fn ->
        original_config = get_or_create_tracker_script_configuration!(site)
        changeset = changeset(original_config, config_update, changeset_type)

        updated_config = Repo.update!(changeset)

        sync_goals(site, original_config, updated_config)

        on_ee do
          if Map.keys(changeset.changes) != [:installation_type] do
            Plausible.Workers.PurgeCDNCache.new(
              %{id: updated_config.id},
              # See PurgeCDNCache.ex for more details
              schedule_in: 10,
              replace: [scheduled: [:scheduled_at]]
            )
            |> Oban.insert!()
          end
        end

        updated_config
      end)

    updated_config
  end

  def get_or_create_tracker_script_configuration!(site, params \\ %{}) do
    configuration = Repo.get_by(TrackerScriptConfiguration, site_id: site.id)

    if configuration do
      configuration
    else
      {:ok, created_config} =
        Repo.transaction(fn ->
          created_config =
            TrackerScriptConfiguration.installation_changeset(
              %TrackerScriptConfiguration{site_id: site.id},
              params
            )
            |> Repo.insert!()

          sync_goals(site, %{}, created_config)

          created_config
        end)

      created_config
    end
  end

  # Sync plausible goals with the updated script config
  defp sync_goals(site, original_config, updated_config) do
    [:track_404_pages, :outbound_links, :file_downloads, :form_submissions]
    |> Enum.map(fn key ->
      {key, Map.get(original_config, key, false), Map.get(updated_config, key, false)}
    end)
    |> Enum.each(fn
      {:track_404_pages, false, true} -> Plausible.Goals.create_404(site)
      {:track_404_pages, true, false} -> Plausible.Goals.delete_404(site)
      {:outbound_links, false, true} -> Plausible.Goals.create_outbound_links(site)
      {:outbound_links, true, false} -> Plausible.Goals.delete_outbound_links(site)
      {:file_downloads, false, true} -> Plausible.Goals.create_file_downloads(site)
      {:file_downloads, true, false} -> Plausible.Goals.delete_file_downloads(site)
      {:form_submissions, false, true} -> Plausible.Goals.create_form_submissions(site)
      {:form_submissions, true, false} -> Plausible.Goals.delete_form_submissions(site)
      _ -> nil
    end)
  end

  defp changeset(tracker_script_configuration, config_update, :installation) do
    TrackerScriptConfiguration.installation_changeset(tracker_script_configuration, config_update)
  end

  defp changeset(tracker_script_configuration, config_update, :plugins_api) do
    TrackerScriptConfiguration.plugins_api_changeset(tracker_script_configuration, config_update)
  end

  defp tracker_ingestion_endpoint() do
    # :TRICKY: Normally we would use PlausibleWeb.Endpoint.url() here, but
    # that requires the endpoint to be started. We start the TrackerScriptCache
    # before the endpoint is started, so we need to use the base_url directly.

    endpoint_config = Application.fetch_env!(:plausible, PlausibleWeb.Endpoint)
    base_url = Keyword.get(endpoint_config, :base_url)
    "#{base_url}/api/event"
  end
end
```

## File: `lib/plausible_web/tracker_script_cache.ex`
```
defmodule PlausibleWeb.TrackerScriptCache do
  @moduledoc """
  Cache for tracker script(s) for self-hosted Plausible instances.
  """
  alias Plausible.Site.TrackerScriptConfiguration

  import Ecto.Query
  use Plausible.Cache

  @cache_name :tracker_script_cache

  @impl true
  def name(), do: @cache_name

  @impl true
  def child_id(), do: :cache_tracker_script

  @impl true
  def count_all() do
    Plausible.Repo.aggregate(TrackerScriptConfiguration, :count)
  end

  @impl true
  def base_db_query() do
    from(
      t in TrackerScriptConfiguration,
      join: s in assoc(t, :site),
      preload: [site: s]
    )
  end

  @impl true
  def get_from_source(id) do
    query =
      base_db_query()
      |> where([t], t.id == ^id)

    case Plausible.Repo.one(query) do
      %TrackerScriptConfiguration{} = tracker_script_configuration ->
        PlausibleWeb.Tracker.plausible_main_script_tag(tracker_script_configuration)

      _ ->
        nil
    end
  end

  @impl true
  def unwrap_cache_keys(items) do
    Enum.reduce(items, [], fn
      tracker_script_configuration, acc ->
        [
          {tracker_script_configuration.id,
           PlausibleWeb.Tracker.plausible_main_script_tag(tracker_script_configuration)}
          | acc
        ]
    end)
  end
end
```

## File: `lib/plausible_web/two_factor/session.ex`
```
defmodule PlausibleWeb.TwoFactor.Session do
  @moduledoc """
  Functions for managing session data related to Two-Factor
  Authentication.
  """

  import Plug.Conn

  alias Plausible.Auth

  @remember_2fa_cookie "remember_2fa"
  @remember_2fa_days 30
  @remember_2fa_seconds @remember_2fa_days * 24 * 60 * 60

  @session_2fa_cookie "session_2fa"
  @session_2fa_seconds 5 * 60

  @spec set_2fa_user(Plug.Conn.t(), Auth.User.t()) :: Plug.Conn.t()
  def set_2fa_user(conn, %Auth.User{} = user) do
    put_resp_cookie(conn, @session_2fa_cookie, %{current_2fa_user_id: user.id},
      domain: domain(),
      secure: secure_cookie?(),
      encrypt: true,
      max_age: @session_2fa_seconds,
      same_site: "Lax"
    )
  end

  @spec get_2fa_user(Plug.Conn.t()) :: {:ok, Auth.User.t()} | {:error, :not_found}
  def get_2fa_user(conn) do
    conn = fetch_cookies(conn, encrypted: [@session_2fa_cookie])
    session_2fa = conn.cookies[@session_2fa_cookie]

    with id when is_integer(id) <- session_2fa[:current_2fa_user_id],
         %Auth.User{} = user <- Plausible.Repo.get(Auth.User, id) do
      {:ok, user}
    else
      _ -> {:error, :not_found}
    end
  end

  @spec clear_2fa_user(Plug.Conn.t()) :: Plug.Conn.t()
  def clear_2fa_user(conn) do
    delete_resp_cookie(conn, @session_2fa_cookie,
      domain: domain(),
      secure: secure_cookie?(),
      encrypt: true,
      max_age: @session_2fa_seconds,
      same_site: "Lax"
    )
  end

  @spec remember_2fa_days() :: non_neg_integer()
  def remember_2fa_days(), do: @remember_2fa_days

  @spec remember_2fa?(Plug.Conn.t(), Auth.User.t()) :: boolean()
  def remember_2fa?(conn, user) do
    conn = fetch_cookies(conn, encrypted: [@remember_2fa_cookie])

    not is_nil(user.totp_token) and conn.cookies[@remember_2fa_cookie] == user.totp_token
  end

  @spec maybe_set_remember_2fa(Plug.Conn.t(), Auth.User.t(), String.t() | nil) :: Plug.Conn.t()
  def maybe_set_remember_2fa(conn, user, "true") do
    put_resp_cookie(conn, @remember_2fa_cookie, user.totp_token,
      domain: domain(),
      secure: secure_cookie?(),
      encrypt: true,
      max_age: @remember_2fa_seconds,
      same_site: "Lax"
    )
  end

  def maybe_set_remember_2fa(conn, _, _) do
    clear_remember_2fa(conn)
  end

  @spec clear_remember_2fa(Plug.Conn.t()) :: Plug.Conn.t()
  def clear_remember_2fa(conn) do
    delete_resp_cookie(conn, @remember_2fa_cookie,
      domain: domain(),
      secure: secure_cookie?(),
      encrypt: true,
      max_age: @remember_2fa_seconds,
      same_site: "Lax"
    )
  end

  defp domain(), do: PlausibleWeb.Endpoint.host()

  defp secure_cookie?() do
    :plausible
    |> Application.fetch_env!(PlausibleWeb.Endpoint)
    |> Keyword.fetch!(:secure_cookie)
  end
end
```

## File: `lib/plausible_web/user_auth.ex`
```
defmodule PlausibleWeb.UserAuth do
  @moduledoc """
  Functions for user session management.
  """

  use Plausible

  alias Plausible.Auth
  alias PlausibleWeb.TwoFactor

  alias PlausibleWeb.Router.Helpers, as: Routes

  require Logger

  on_ee do
    @type login_subject() :: Auth.User.t() | Auth.SSO.Identity.t()
  else
    @type login_subject() :: Auth.User.t()
  end

  @spec log_in_user(Plug.Conn.t(), login_subject(), String.t() | nil) ::
          Plug.Conn.t()
  def log_in_user(conn, subject, redirect_path \\ nil)

  def log_in_user(conn, %Auth.User{} = user, redirect_path) do
    redirect_to = login_redirect_path(conn, redirect_path)
    device_name = get_device_name(conn)
    session = Auth.UserSessions.create!(user, device_name)

    conn
    |> set_user_token(session.token)
    |> set_logged_in_cookie()
    |> Phoenix.Controller.redirect(to: redirect_to)
  end

  on_ee do
    def log_in_user(conn, %Auth.SSO.Identity{} = identity, redirect_path) do
      case Auth.SSO.provision_user(identity) do
        {:ok, _provisioning_from, team, user} ->
          redirect_to = login_redirect_path(conn, redirect_path)
          device_name = get_device_name(conn)
          session = Auth.UserSessions.create!(user, device_name, timeout_at: identity.expires_at)

          conn
          |> set_user_token(session.token)
          |> Plug.Conn.put_session("current_team_id", team.identifier)
          |> PlausibleWeb.LoginPreference.set_sso()
          |> set_logged_in_cookie()
          |> Phoenix.Controller.redirect(to: redirect_to)

        {:error, :integration_not_found} ->
          conn
          |> log_out_user()
          |> Phoenix.Controller.put_flash(:login_error, "Wrong email.")
          |> Phoenix.Controller.redirect(
            to: Routes.sso_path(conn, :login_form, return_to: redirect_path)
          )

        {:error, :over_limit} ->
          error = "Team can't accept more members. Please contact the owner."

          conn
          |> log_out_user()
          |> Phoenix.Controller.put_flash(:login_error, error)
          |> Phoenix.Controller.redirect(
            to: Routes.sso_path(conn, :login_form, return_to: redirect_path)
          )

        {:error, reason, _team, _user}
        when reason in [:multiple_memberships, :active_personal_team] ->
          issue = to_string(reason) <> "_noforce"

          conn
          |> log_out_user()
          |> Phoenix.Controller.redirect(
            to: Routes.sso_path(conn, :provision_issue, issue: issue)
          )
      end
    end
  end

  @spec log_out_user(Plug.Conn.t()) :: Plug.Conn.t()
  def log_out_user(conn) do
    case get_user_token(conn) do
      {:ok, token} -> Auth.UserSessions.remove_by_token(token)
      {:error, _} -> :pass
    end

    if live_socket_id = Plug.Conn.get_session(conn, :live_socket_id) do
      Auth.UserSessions.disconnect_by_token(live_socket_id)
    end

    conn
    |> renew_session()
    |> clear_logged_in_cookie()
  end

  @spec get_user_session(Plug.Conn.t() | map()) ::
          {:ok, Auth.UserSession.t()}
          | {:error, :no_valid_token | :session_not_found}
          | {:error, :session_expired, Auth.UserSession.t()}
  def get_user_session(%Plug.Conn{assigns: %{current_user_session: user_session}}) do
    {:ok, user_session}
  end

  def get_user_session(conn_or_session) do
    with {:ok, token} <- get_user_token(conn_or_session) do
      case Auth.UserSessions.get_by_token(token) do
        {:ok, session} -> {:ok, session}
        {:error, :not_found} -> {:error, :session_not_found}
        {:error, :expired, user_session} -> {:error, :session_expired, user_session}
      end
    end
  end

  @doc """
  Sets the `logged_in` cookie share with the static site for determining
  whether client is authenticated.

  As it's a separate cookie, there's a chance it might fall out of sync
  with session cookie state due to manual deletion or premature expiration.
  """
  @spec set_logged_in_cookie(Plug.Conn.t()) :: Plug.Conn.t()
  def set_logged_in_cookie(conn) do
    Plug.Conn.put_resp_cookie(conn, "logged_in", "true",
      http_only: false,
      max_age: 60 * 60 * 24 * 365 * 5000
    )
  end

  defp set_user_token(conn, token) do
    conn
    |> renew_session()
    |> TwoFactor.Session.clear_2fa_user()
    |> put_token_in_session(token)
  end

  defp login_redirect_path(conn, redirect_path) do
    if String.starts_with?(redirect_path || "", "/") do
      redirect_path
    else
      Routes.site_path(conn, :index)
    end
  end

  defp renew_session(conn) do
    Phoenix.Controller.delete_csrf_token()

    conn
    |> Plug.Conn.configure_session(renew: true)
    |> Plug.Conn.clear_session()
  end

  defp clear_logged_in_cookie(conn) do
    Plug.Conn.delete_resp_cookie(conn, "logged_in")
  end

  defp put_token_in_session(conn, token) do
    conn
    |> Plug.Conn.put_session(:user_token, token)
    |> Plug.Conn.put_session(:live_socket_id, Auth.UserSessions.socket_id(token))
  end

  defp get_user_token(%Plug.Conn{} = conn) do
    conn
    |> Plug.Conn.get_session()
    |> get_user_token()
  end

  defp get_user_token(%{"user_token" => token}) when is_binary(token) do
    {:ok, token}
  end

  defp get_user_token(_) do
    {:error, :no_valid_token}
  end

  @unknown_label "Unknown"

  defp get_device_name(%Plug.Conn{} = conn) do
    conn
    |> Plug.Conn.get_req_header("user-agent")
    |> List.first()
    |> get_device_name()
  end

  defp get_device_name(user_agent) when is_binary(user_agent) do
    case UAInspector.parse(user_agent) do
      %UAInspector.Result{client: %UAInspector.Result.Client{name: "Headless Chrome"}} ->
        "Headless Chrome"

      %UAInspector.Result.Bot{name: name} when is_binary(name) ->
        name

      %UAInspector.Result{} = ua ->
        browser = browser_name(ua)

        if os = os_name(ua) do
          browser <> " (#{os})"
        else
          browser
        end

      _ ->
        @unknown_label
    end
  end

  defp get_device_name(_), do: @unknown_label

  defp browser_name(ua) do
    case ua.client do
      :unknown -> @unknown_label
      %UAInspector.Result.Client{name: "Mobile Safari"} -> "Safari"
      %UAInspector.Result.Client{name: "Chrome Mobile"} -> "Chrome"
      %UAInspector.Result.Client{name: "Chrome Mobile iOS"} -> "Chrome"
      %UAInspector.Result.Client{name: "Firefox Mobile"} -> "Firefox"
      %UAInspector.Result.Client{name: "Firefox Mobile iOS"} -> "Firefox"
      %UAInspector.Result.Client{name: "Opera Mobile"} -> "Opera"
      %UAInspector.Result.Client{name: "Opera Mini"} -> "Opera"
      %UAInspector.Result.Client{name: "Opera Mini iOS"} -> "Opera"
      %UAInspector.Result.Client{name: "Yandex Browser Lite"} -> "Yandex Browser"
      %UAInspector.Result.Client{name: "Chrome Webview"} -> "Mobile App"
      %UAInspector.Result.Client{type: "mobile app"} -> "Mobile App"
      client -> client.name || @unknown_label
    end
  end

  defp os_name(ua) do
    case ua.os do
      :unknown -> nil
      os -> os.name
    end
  end
end
```

## File: `lib/plausible_web/views/auth_view.ex`
```
defmodule PlausibleWeb.AuthView do
  use Plausible
  use PlausibleWeb, :view
  alias Plausible.Billing.Plans

  def subscription_quota(subscription, options \\ [])

  def subscription_quota(nil, _options), do: "Free trial"

  def subscription_quota(subscription, options) do
    pageview_limit = Plausible.Teams.Billing.monthly_pageview_limit(subscription)

    quota =
      if pageview_limit == :unlimited do
        "unlimited"
      else
        PlausibleWeb.StatsView.large_number_format(pageview_limit)
      end

    if Keyword.get(options, :format) == :long do
      "#{quota} pageviews"
    else
      quota
    end
  end

  def subscription_interval(subscription) do
    Plans.subscription_interval(subscription)
  end

  def delimit_integer(number) do
    Integer.to_charlist(number)
    |> :lists.reverse()
    |> delimit_integer([])
    |> String.Chars.to_string()
  end

  defp delimit_integer([a, b, c, d | tail], acc) do
    delimit_integer([d | tail], [",", c, b, a | acc])
  end

  defp delimit_integer(list, acc) do
    :lists.reverse(list) ++ acc
  end
end
```

## File: `lib/plausible_web/views/billing_view.ex`
```
defmodule PlausibleWeb.BillingView do
  use PlausibleWeb, :view

  def present_date(date) do
    Date.from_iso8601!(date)
    |> Calendar.strftime("%-d %b %Y")
  end

  def present_currency("USD"), do: "$"
  def present_currency("EUR"), do: "€"
  def present_currency("GBP"), do: "£"
end
```

## File: `lib/plausible_web/views/debug_view.ex`
```
defmodule PlausibleWeb.DebugView do
  use PlausibleWeb, :view

  def controller_name(phoenix_controller_name) do
    phoenix_controller_name
    |> String.to_existing_atom()
    |> Module.split()
    |> Enum.drop_while(&String.starts_with?(&1, "Plausible"))
    |> Enum.join(".")
  end
end
```

## File: `lib/plausible_web/views/email_view.ex`
```
defmodule PlausibleWeb.EmailView do
  use Plausible
  use PlausibleWeb, :view

  def plausible_url do
    PlausibleWeb.Endpoint.url()
  end

  def greet_recipient(%{user: %{name: name}}) when is_binary(name) do
    "Hey #{String.split(name) |> List.first()},"
  end

  def greet_recipient(_), do: "Hey,"

  def date_format(date) do
    Calendar.strftime(date, "%-d %b %Y")
  end

  def sentry_link(trace_id, dsn \\ Sentry.Config.dsn()) do
    search_query = URI.encode_query(%{query: trace_id})
    path = "/organizations/sentry/issues/"

    if is_binary(dsn) do
      dsn
      |> URI.parse()
      |> Map.replace(:userinfo, nil)
      |> Map.replace(:path, path)
      |> Map.replace(:query, search_query)
      |> URI.to_string()
    else
      ""
    end
  end
end
```

## File: `lib/plausible_web/views/error_view.ex`
```
defmodule PlausibleWeb.ErrorView do
  use Plausible
  use PlausibleWeb, :view

  def render("500.json", %{conn: %{assigns: %{plugins_api: true}}}) do
    contact_support_note =
      on_ee do
        "If the problem persists please contact support@plausible.io"
      end

    %{
      errors: [
        %{detail: "Internal server error, please try again. #{contact_support_note}"}
      ]
    }
  end

  def render("500.json", _assigns) do
    %{
      status: 500,
      message: "Server error"
    }
  end

  def render("404.html", assigns) do
    assigns =
      assigns
      |> Map.put(:status, 404)
      |> Map.put_new(:message, "Oops! There's nothing here")

    render("404_error.html", assigns)
  end

  def render(<<"5", _error_5xx::binary-size(2), ".html">>, assigns) do
    current_user = assigns[:current_user]
    last_event = Sentry.get_last_event_id_and_source()

    case {current_user, last_event} do
      {current_user, {event_id, :plug}}
      when is_binary(event_id) and not is_nil(current_user) ->
        opts = %{
          trace_id: event_id,
          user_name: current_user.name,
          user_email: current_user.email
        }

        render("server_error.html", Map.merge(opts, assigns))

      _ ->
        render("server_error.html", assigns)
    end
  end

  def template_not_found(template, assigns) do
    if String.ends_with?(template, ".json") do
      fallback_json_error(template, assigns)
    else
      fallback_html_error(template, assigns)
    end
  end

  defp fallback_html_error(template, assigns) do
    assigns =
      assigns
      |> Map.put_new(:message, Phoenix.Controller.status_message_from_template(template))
      |> Map.put(:status, String.trim_trailing(template, ".html"))

    render("generic_error.html", assigns)
  end

  defp fallback_json_error(template, _assigns) do
    status =
      String.split(template, ".")
      |> hd()
      |> String.to_integer()

    message = Plug.Conn.Status.reason_phrase(status)
    %{status: status, message: message}
  rescue
    _ -> %{status: 500, message: "Server error"}
  end

  defp url_path(%Plug.Conn{request_path: path, query_string: ""}), do: path
  defp url_path(%Plug.Conn{request_path: path, query_string: query}), do: path <> "?" <> query
end
```

## File: `lib/plausible_web/views/google_analytics_view.ex`
```
defmodule PlausibleWeb.GoogleAnalyticsView do
  use PlausibleWeb, :view
  use Plausible
end
```

## File: `lib/plausible_web/views/layout_view.ex`
```
defmodule PlausibleWeb.LayoutView do
  use PlausibleWeb, :view
  use Plausible

  alias Plausible.Teams
  alias PlausibleWeb.Components.Billing.Notice
  alias PlausibleWeb.Components.Layout

  def plausible_url do
    PlausibleWeb.Endpoint.url()
  end

  def websocket_url() do
    PlausibleWeb.Endpoint.websocket_url()
  end

  defmodule JWT do
    use Joken.Config
  end

  def feedback_link(user) do
    token_params = %{
      "id" => user.id,
      "email" => user.email,
      "name" => user.name,
      "imageUrl" => Plausible.Auth.User.profile_img_url(user)
    }

    case JWT.generate_and_sign(token_params) do
      {:ok, token, _claims} ->
        "https://feedback.plausible.io/sso/#{token}?returnUrl=https://feedback.plausible.io"

      _ ->
        "https://feedback.plausible.io"
    end
  end

  def home_dest(conn) do
    if conn.assigns[:current_user] do
      "/sites"
    else
      "/"
    end
  end

  def logo_path(filename) do
    if ee?() do
      Path.join("/images/ee/", filename)
    else
      Path.join("/images/ce/", filename)
    end
  end

  def site_settings_sidebar(conn) do
    [
      %{key: "General", value: "general", icon: :rocket_launch},
      %{key: "People", value: "people", icon: :users},
      %{key: "Visibility", value: "visibility", icon: :eye},
      %{key: "Goals", value: "goals", icon: :check_circle},
      on_ee do
        %{key: "Funnels", value: "funnels", icon: :funnel}
      end,
      %{key: "Custom Properties", value: "properties", icon: :document_text},
      %{key: "Integrations", value: "integrations", icon: :arrow_path_rounded_square},
      %{key: "Imports & Exports", value: "imports-exports", icon: :arrows_up_down},
      %{
        key: "Shields",
        icon: :shield_exclamation,
        value: [
          %{key: "IP Addresses", value: "shields/ip_addresses"},
          %{key: "Countries", value: "shields/countries"},
          %{key: "Pages", value: "shields/pages"},
          %{key: "Hostnames", value: "shields/hostnames"}
        ]
      },
      %{key: "Email Reports", value: "email-reports", icon: :envelope},
      if conn.assigns[:site_role] in [:owner, :admin] do
        %{key: "Danger Zone", value: "danger-zone", icon: :exclamation_triangle}
      end
    ]
    |> Enum.reject(&is_nil/1)
  end

  def account_settings_sidebar(conn) do
    current_team = conn.assigns[:current_team]
    current_team_role = conn.assigns[:current_team_role]

    options = %{
      "Account Settings" =>
        [
          %{key: "Preferences", value: "preferences", icon: :cog_6_tooth},
          %{key: "Security", value: "security", icon: :lock_closed},
          if(not Teams.setup?(current_team),
            do: %{key: "Subscription", value: "billing/subscription", icon: :circle_stack}
          ),
          if(not Teams.setup?(current_team),
            do: %{key: "Invoices", value: "billing/invoices", icon: :banknotes}
          ),
          if(not Teams.setup?(current_team),
            do: %{key: "API Keys", value: "api-keys", icon: :key}
          ),
          if(Plausible.Users.type(conn.assigns.current_user) == :standard,
            do: %{key: "Danger Zone", value: "danger-zone", icon: :exclamation_triangle}
          )
        ]
        |> Enum.reject(&is_nil/1)
    }

    if Teams.setup?(current_team) do
      Map.put(
        options,
        "Team Settings",
        [
          %{key: "General", value: "team/general", icon: :adjustments_horizontal},
          if(current_team_role in [:owner, :billing],
            do: %{key: "Subscription", value: "billing/subscription", icon: :circle_stack}
          ),
          if(current_team_role in [:owner, :billing],
            do: %{key: "Invoices", value: "billing/invoices", icon: :banknotes}
          ),
          if(current_team_role in [:owner, :billing, :admin, :editor],
            do: %{key: "API Keys", value: "api-keys", icon: :key}
          ),
          if(
            Plausible.sso_enabled?() and current_team_role == :owner and
              Plausible.Billing.Feature.SSO.check_availability(current_team) == :ok,
            do: %{
              key: "Single Sign-On",
              icon: :cloud,
              value: [
                %{key: "Configuration", value: "sso/general"},
                %{key: "Sessions", value: "sso/sessions"}
              ]
            }
          ),
          if(
            Plausible.sso_enabled?() and
              Plausible.Billing.Feature.SSO.check_availability(current_team) != :ok,
            do: %{
              key: "Single Sign-On",
              value: "sso/info",
              icon: :cloud,
              badge: :new
            }
          ),
          if(current_team_role == :owner,
            do: %{key: "Danger Zone", value: "team/delete", icon: :exclamation_triangle}
          )
        ]
        |> Enum.reject(&is_nil/1)
      )
    else
      options
    end
  end

  attr :conn, :map, required: true
  attr :teams, :list, required: true
  attr :my_team, :any, default: nil
  attr :current_team, :any, default: nil
  attr :more_teams?, :boolean, required: true

  def team_switcher(assigns) do
    teams = assigns[:teams]

    if teams && length(teams) > 0 do
      current_team = assigns[:current_team]
      my_team = assigns[:my_team]
      current_included? = current_team && Enum.any?(teams, &(&1.id == current_team.id))
      current_is_my? = current_team && my_team && current_team.id == my_team.id

      teams =
        if current_team && !current_included? && !current_is_my? do
          [current_team | teams]
        else
          teams
        end

      teams =
        if my_team do
          teams ++ [my_team]
        else
          teams ++ [%Teams.Team{identifier: "none", name: Teams.default_name()}]
        end

      selected_id = current_team && current_team.id

      assigns =
        assigns
        |> assign(:teams, teams)
        |> assign(:selected_id, selected_id)

      ~H"""
      <.dropdown_item>
        <div class="text-xs text-gray-500 dark:text-gray-400">Teams</div>
      </.dropdown_item>
      <.dropdown_item
        :for={team <- @teams}
        href={Routes.site_path(@conn, :index, __team: team.identifier)}
      >
        <p
          class={[
            if(team.id == @selected_id,
              do: "border-r-4 border-indigo-400 font-bold",
              else: "font-medium"
            ),
            "truncate text-gray-900 dark:text-gray-100 pr-4"
          ]}
          role="none"
        >
          {Teams.name(team)}
        </p>
      </.dropdown_item>
      <.dropdown_item :if={@more_teams?} href={Routes.auth_path(@conn, :select_team)}>
        Switch to Another Team
      </.dropdown_item>
      """
    else
      ~H""
    end
  end

  def trial_notification(team) do
    case Teams.trial_days_left(team) do
      days when days > 1 ->
        "#{days} trial days left"

      days when days == 1 ->
        "Trial ends tomorrow"

      days when days == 0 ->
        "Trial ends today"
    end
  end

  def grace_period_end(%{grace_period: %{end_date: %Date{} = date}}) do
    case Date.diff(date, Date.utc_today()) do
      0 -> "today"
      1 -> "tomorrow"
      n -> "within #{n} days"
    end
  end

  def grace_period_end(_user), do: "in the following days"

  @doc "http://blog.plataformatec.com.br/2018/05/nested-layouts-with-phoenix/"
  def render_layout(layout, assigns, do: content) do
    render(layout, Map.put(assigns, :inner_layout, content))
  end

  def is_current_tab(_, nil) do
    false
  end

  def is_current_tab(conn, tab) do
    full_path = Path.join(conn.path_info)

    one_up =
      conn.path_info
      |> Enum.drop(-1)
      |> Path.join()

    case conn.method do
      :get -> String.ends_with?(full_path, tab)
      _ -> String.ends_with?(full_path, tab) or String.ends_with?(one_up, tab)
    end
  end
end
```

## File: `lib/plausible_web/views/page_view.ex`
```
defmodule PlausibleWeb.PageView do
  use PlausibleWeb, :view
end
```

## File: `lib/plausible_web/views/settings_view.ex`
```
defmodule PlausibleWeb.SettingsView do
  use PlausibleWeb, :view
  use Phoenix.Component, global_prefixes: ~w(x-)
  use Plausible

  require Plausible.Billing.Subscription.Status
  alias Plausible.Billing.{Plans, Subscription}

  def subscription_interval(subscription) do
    Plans.subscription_interval(subscription)
  end

  def format_invoices(invoice_list) do
    Enum.map(invoice_list, fn invoice ->
      %{
        date: invoice["payout_date"] |> Date.from_iso8601!() |> Calendar.strftime("%b %-d, %Y"),
        amount: (invoice["amount"] / 1) |> :erlang.float_to_binary(decimals: 2),
        currency: invoice["currency"] |> PlausibleWeb.BillingView.present_currency(),
        url: invoice["receipt_url"]
      }
    end)
  end

  @spec present_subscription_status(Subscription.Status.status()) :: String.t()
  def present_subscription_status(Subscription.Status.active()), do: "Active"
  def present_subscription_status(Subscription.Status.past_due()), do: "Past due"
  def present_subscription_status(Subscription.Status.deleted()), do: "Cancelled"
  def present_subscription_status(Subscription.Status.paused()), do: "Paused"
  def present_subscription_status(status), do: status

  @spec subscription_colors(Subscription.Status.status()) :: String.t()
  def subscription_colors(Subscription.Status.active()), do: "bg-green-100 text-green-800"
  def subscription_colors(Subscription.Status.past_due()), do: "bg-yellow-100 text-yellow-800"
  def subscription_colors(Subscription.Status.paused()), do: "bg-red-100 text-red-800"
  def subscription_colors(Subscription.Status.deleted()), do: "bg-red-100 text-red-800"
  def subscription_colors(_), do: ""
end
```

## File: `lib/plausible_web/views/site/membership_view.ex`
```
defmodule PlausibleWeb.Site.MembershipView do
  use PlausibleWeb, :view
end
```

## File: `lib/plausible_web/views/site_view.ex`
```
defmodule PlausibleWeb.SiteView do
  use PlausibleWeb, :view
  use Plausible

  def plausible_url do
    PlausibleWeb.Endpoint.url()
  end

  def shared_link_dest(site, link) do
    Plausible.Sites.shared_link_url(site, link)
  end

  def render_snippet(site) do
    tracker = "#{plausible_url()}/js/script.js"

    """
    <script defer data-domain="#{site.domain}" src="#{tracker}"></script>
    """
  end

  def with_indefinite_article(word) do
    if String.starts_with?(word, ["a", "e", "i", "o", "u"]) do
      "an " <> word
    else
      "a " <> word
    end
  end

  def site_role(%{role: :viewer}) do
    "Guest Viewer"
  end

  def site_role(%{role: :editor}) do
    "Guest Editor"
  end

  def site_role(%{role: role}) do
    role |> to_string() |> String.capitalize()
  end
end
```

## File: `lib/plausible_web/views/stats_view.ex`
```
defmodule PlausibleWeb.StatsView do
  use PlausibleWeb, :view
  use Plausible

  def plausible_url do
    PlausibleWeb.Endpoint.url()
  end

  def large_number_format(n, opts \\ []) do
    k = if Keyword.get(opts, :capitalize_k?, false), do: "K", else: "k"

    cond do
      n >= 1_000 && n < 1_000_000 ->
        thousands = trunc(n / 100) / 10

        if thousands == trunc(thousands) || n >= 100_000 do
          "#{trunc(thousands)}" <> k
        else
          "#{thousands}" <> k
        end

      n >= 1_000_000 && n < 1_000_000_000 ->
        millions = trunc(n / 100_000) / 10

        if millions == trunc(millions) || n > 100_000_000 do
          "#{trunc(millions)}M"
        else
          "#{millions}M"
        end

      n >= 1_000_000_000 && n < 1_000_000_000_000 ->
        billions = trunc(n / 100_000_000) / 10

        if billions == trunc(billions) || n > 100_000_000_000 do
          "#{trunc(billions)}B"
        else
          "#{billions}B"
        end

      is_integer(n) ->
        Integer.to_string(n)
    end
  end

  def stats_container_class(conn) do
    cond do
      conn.assigns[:embedded] && conn.params["width"] == "manual" -> "px-6"
      conn.assigns[:embedded] -> "max-w-screen-xl mx-auto px-6"
      !conn.assigns[:embedded] -> "container print:max-w-full"
    end
  end

  @doc """
  Returns a readable stats URL.

  Native Phoenix router functions percent-encode all diacritics, resulting in
  ugly URLs, e.g. `https://plausible.io/café.com` transforms into
  `https://plausible.io/caf%C3%A9.com`.

  This function encodes only the slash (`/`) character from the site's domain.

  ## Examples

     iex> PlausibleWeb.StatsView.pretty_stats_url(%Plausible.Site{domain: "user.gittea.io/repo"})
     "http://localhost:8000/user.gittea.io%2Frepo"

     iex> PlausibleWeb.StatsView.pretty_stats_url(%Plausible.Site{domain: "anakin.test"})
     "http://localhost:8000/anakin.test"

     iex> PlausibleWeb.StatsView.pretty_stats_url(%Plausible.Site{domain: "café.test"})
     "http://localhost:8000/café.test"

  """
  def pretty_stats_url(%Plausible.Site{domain: domain}) when is_binary(domain) do
    pretty_domain = String.replace(domain, "/", "%2F")
    "#{plausible_url()}/#{pretty_domain}"
  end
end
```

## File: `lib/plausible_web/views/text_helpers.ex`
```
defmodule PlausibleWeb.TextHelpers do
  @moduledoc false

  @spec pretty_join([String.t()]) :: String.t()

  @doc """
  Turns a list of strings into a string and replaces the last comma
  with the word "and".

  ### Examples:

      iex> ["one"] |> PlausibleWeb.TextHelpers.pretty_join()
      "one"

      iex> ["one", "two"] |> PlausibleWeb.TextHelpers.pretty_join()
      "one and two"

      iex> ["one", "two", "three"] |> PlausibleWeb.TextHelpers.pretty_join()
      "one, two and three"
  """
  def pretty_join([str]), do: str

  def pretty_join(list) do
    [last_string | rest] = Enum.reverse(list)

    rest_string =
      rest
      |> Enum.reverse()
      |> Enum.join(", ")

    "#{rest_string} and #{last_string}"
  end

  def pretty_list(list) do
    list
    |> Enum.map(&String.replace("#{&1}", "_", " "))
    |> pretty_join()
  end

  def format_date_range(date_range) do
    "#{format_date(date_range.first)} - #{format_date(date_range.last)}"
  end

  def format_date(date) do
    Calendar.strftime(date, "%b %-d, %Y")
  end
end
```

## File: `lib/plausible_web/views/unsubscribe_view.ex`
```
defmodule PlausibleWeb.UnsubscribeView do
  use PlausibleWeb, :view
end
```

## File: `lib/sentry_filter.ex`
```
defmodule Plausible.SentryFilter do
  @moduledoc """
  Sentry callbacks for filtering and grouping events
  """

  @spec before_send(Sentry.Event.t()) :: Sentry.Event.t()
  def before_send(event)

  def before_send(%{original_exception: %Bamboo.PostmarkAdapter.Error{} = e} = event) do
    if Bamboo.PostmarkAdapter.Error.is_hard_bounce(e), do: false, else: event
  end

  def before_send(%{original_exception: %Phoenix.NotAcceptableError{}}), do: false
  def before_send(%{original_exception: %Plug.CSRFProtection.InvalidCSRFTokenError{}}), do: false
  def before_send(%{original_exception: %Plug.Static.InvalidPathError{}}), do: false

  def before_send(
        %{
          exception: [%{type: "DBConnection.ConnectionError"}],
          original_exception: %{reason: reason}
        } = event
      ) do
    %{event | fingerprint: ["db_connection", reason]}
  end

  def before_send(%{extra: %{request: %Plausible.Ingestion.Request{}}} = event) do
    %{event | fingerprint: ["ingestion_request"]}
  end

  def before_send(%{source: :logger, message: %{formatted: "Ranch listener" <> rest}} = event) do
    if String.contains?(rest, "had its request process") do
      false
    else
      event
    end
  end

  def before_send(event) do
    event
  end
end
```

## File: `lib/workers/accept_traffic_until_notification.ex`
```
defmodule Plausible.Workers.AcceptTrafficUntil do
  @moduledoc """
  A worker meant to be run once a day that sends out e-mail notifications to site
  owners assuming:
    - their sites still receive traffic (i.e. have stats for yesterday)
    - `site.accept_traffic_until` is approaching either tomorrow or exactly in 7 days

  Users having no sites or sites that receive no traffic, won't be notified.
  We make a tiny effort here to make sure we send the same notification at most once a day.
  """
  use Oban.Worker, queue: :check_accept_traffic_until
  import Ecto.Query

  alias Plausible.Repo
  alias Plausible.ClickhouseRepo

  def dry_run(date) do
    perform(nil, date, true)
  end

  @impl Oban.Worker
  def perform(_job, today \\ Date.utc_today(), dry_run? \\ false) do
    tomorrow = today |> Date.add(+1)
    next_week = today |> Date.add(+7)

    # send at most one notification per user, per day
    sent_today_query =
      from s in "sent_accept_traffic_until_notifications",
        where: s.user_id == parent_as(:users).id and s.sent_on == ^today,
        select: true

    notifications =
      Repo.all(
        from t in Plausible.Teams.Team,
          inner_join: u in assoc(t, :owners),
          as: :users,
          inner_join: s in assoc(t, :sites),
          where: t.accept_traffic_until == ^tomorrow or t.accept_traffic_until == ^next_week,
          where: not exists(sent_today_query),
          select: %{
            id: u.id,
            email: u.email,
            deadline: t.accept_traffic_until,
            site_ids: fragment("array_agg(?.id)", s),
            name: u.name,
            team: t
          },
          group_by: [u.id, t.id]
      )

    for notification <- notifications do
      case {has_stats?(notification.site_ids, today), notification.deadline} do
        {true, ^tomorrow} ->
          if dry_run? do
            IO.puts("Will send final notification to #{notification.email}")
          else
            notification
            |> store_sent(today)
            |> PlausibleWeb.Email.approaching_accept_traffic_until_tomorrow()
            |> Plausible.Mailer.send()
          end

        {true, ^next_week} ->
          if dry_run? do
            IO.puts("Will send weekly notification to #{notification.email}")
          else
            notification
            |> store_sent(today)
            |> PlausibleWeb.Email.approaching_accept_traffic_until()
            |> Plausible.Mailer.send()
          end

        _ ->
          nil
      end
    end

    {:ok, Enum.count(notifications)}
  end

  defp has_stats?(site_ids, today) do
    ago_2d = Date.add(today, -2)

    ClickhouseRepo.exists?(
      from e in "events_v2",
        where: fragment("toDate(?) >= ?", e.timestamp, ^ago_2d),
        where: e.site_id in ^site_ids
    )
  end

  defp store_sent(notification, today) do
    Repo.insert_all(
      "sent_accept_traffic_until_notifications",
      [
        %{
          user_id: notification.id,
          sent_on: today
        }
      ],
      on_conflict: :nothing,
      conflict_target: [:user_id, :sent_on]
    )

    notification
  end
end
```

## File: `lib/workers/check_usage.ex`
```
defmodule Plausible.Workers.CheckUsage do
  use Plausible.Repo
  use Oban.Worker, queue: :check_usage
  require Plausible.Billing.Subscription.Status
  alias Plausible.Billing.{Subscription, Quota}
  alias Plausible.Teams

  defmacro yesterday() do
    quote do
      fragment("now() - INTERVAL '1 day'")
    end
  end

  defmacro last_day_of_month(day) do
    quote do
      fragment(
        "(date_trunc('month', ?::date) + interval '1 month' - interval '1 day')::date",
        unquote(day)
      )
    end
  end

  defmacro day_of_month(date) do
    quote do
      fragment("EXTRACT(day from ?::date)", unquote(date))
    end
  end

  defmacro least(left, right) do
    quote do
      fragment("least(?, ?)", unquote(left), unquote(right))
    end
  end

  @impl Oban.Worker
  def perform(_job, usage_mod \\ Teams.Billing, today \\ Date.utc_today()) do
    yesterday = today |> Date.shift(day: -1)

    active_subscribers =
      Repo.all(
        from(t in Teams.Team,
          as: :team,
          inner_join: o in assoc(t, :owners),
          left_join: bm in assoc(t, :billing_members),
          inner_lateral_join: s in subquery(Teams.last_subscription_join_query()),
          on: true,
          left_join: ep in Plausible.Billing.EnterprisePlan,
          on: ep.team_id == t.id and ep.paddle_plan_id == s.paddle_plan_id,
          where:
            s.status in [
              ^Subscription.Status.active(),
              ^Subscription.Status.past_due(),
              ^Subscription.Status.deleted()
            ],
          where: not is_nil(s.last_bill_date),
          # Accounts for situations like last_bill_date==2021-01-31 AND today==2021-03-01. Since February never reaches the 31st day, the account is checked on 2021-03-01.
          where: s.next_bill_date >= ^today,
          where:
            least(day_of_month(s.last_bill_date), day_of_month(last_day_of_month(^yesterday))) ==
              day_of_month(^yesterday),
          order_by: t.id,
          preload: [subscription: s, enterprise_plan: ep, owners: o, billing_members: bm]
        )
      )

    for subscriber <- active_subscribers do
      case {subscriber.grace_period, subscriber.enterprise_plan} do
        {nil, nil} ->
          check_regular_subscriber(subscriber, usage_mod)

        {nil, _} ->
          check_enterprise_subscriber(subscriber, usage_mod)

        {_, nil} ->
          maybe_remove_grace_period(subscriber, usage_mod)

        _ ->
          :skip
      end
    end

    :ok
  end

  defp check_site_usage_for_enterprise(subscriber) do
    limit = subscriber.enterprise_plan.site_limit

    usage = Teams.Billing.site_usage(subscriber)

    if Quota.below_limit?(usage, limit) do
      {:below_limit, {usage, limit}}
    else
      {:over_limit, {usage, limit}}
    end
  end

  def maybe_remove_grace_period(subscriber, usage_mod) do
    case check_pageview_usage_last_cycle(subscriber, usage_mod) do
      {:below_limit, _} ->
        Plausible.Teams.remove_grace_period(subscriber)
        :ok

      _ ->
        :skip
    end
  end

  defp check_regular_subscriber(subscriber, usage_mod) do
    case check_pageview_usage_two_cycles(subscriber, usage_mod) do
      {:over_limit, pageview_usage} ->
        suggested_volume =
          Plausible.Billing.Plans.suggest_volume(subscriber, pageview_usage.last_cycle.total)

        for owner <- subscriber.owners ++ subscriber.billing_members do
          PlausibleWeb.Email.over_limit_email(owner, subscriber, pageview_usage, suggested_volume)
          |> Plausible.Mailer.send()
        end

        Plausible.Teams.start_grace_period(subscriber)

      _ ->
        nil
    end
  end

  def check_enterprise_subscriber(subscriber, usage_mod) do
    pageview_usage = check_pageview_usage_two_cycles(subscriber, usage_mod)
    site_usage = check_site_usage_for_enterprise(subscriber)

    case {pageview_usage, site_usage} do
      {{:below_limit, _}, {:below_limit, _}} ->
        nil

      {{_, pageview_usage}, {_, {site_usage, site_allowance}}} ->
        for owner <- subscriber.owners ++ subscriber.billing_members do
          PlausibleWeb.Email.enterprise_over_limit_internal_email(
            owner,
            pageview_usage,
            site_usage,
            site_allowance
          )
          |> Plausible.Mailer.send()
        end

        Plausible.Teams.start_manual_lock_grace_period(subscriber)
    end
  end

  def check_pageview_usage_two_cycles(subscriber, usage_mod) do
    usage = usage_mod.monthly_pageview_usage(subscriber)
    limit = Teams.Billing.monthly_pageview_limit(subscriber.subscription)

    if Quota.exceeds_last_two_usage_cycles?(usage, limit) do
      {:over_limit, usage}
    else
      {:below_limit, usage}
    end
  end

  defp check_pageview_usage_last_cycle(subscriber, usage_mod) do
    usage = usage_mod.monthly_pageview_usage(subscriber)
    limit = Teams.Billing.monthly_pageview_limit(subscriber.subscription)

    if :last_cycle in Quota.exceeded_cycles(usage, limit) do
      {:over_limit, usage}
    else
      {:below_limit, usage}
    end
  end
end
```

## File: `lib/workers/clean_invitations.ex`
```
defmodule Plausible.Workers.CleanInvitations do
  use Plausible.Repo
  use Oban.Worker, queue: :clean_invitations

  @cutoff Duration.new!(hour: -48)

  @impl Oban.Worker
  def perform(_job) do
    cutoff_time =
      NaiveDateTime.utc_now(:second)
      |> NaiveDateTime.shift(@cutoff)

    Repo.delete_all(
      from ti in Plausible.Teams.Invitation,
        where: ti.inserted_at < ^cutoff_time
    )

    Repo.delete_all(
      from ti in Plausible.Teams.SiteTransfer,
        where: ti.inserted_at < ^cutoff_time
    )

    :ok
  end
end
```

## File: `lib/workers/clean_user_sessions.ex`
```
defmodule Plausible.Workers.CleanUserSessions do
  @moduledoc """
  Job removing expired user sessions. A grace period is applied.
  """

  use Plausible.Repo
  use Oban.Worker, queue: :clean_user_sessions

  @grace_period Duration.new!(day: -7)

  @spec grace_period_duration() :: Duration.t()
  def grace_period_duration(), do: @grace_period

  @impl Oban.Worker
  def perform(_job) do
    grace_cutoff =
      NaiveDateTime.utc_now(:second)
      |> NaiveDateTime.shift(@grace_period)

    Repo.delete_all(
      from us in Plausible.Auth.UserSession,
        where: us.timeout_at < ^grace_cutoff
    )

    :ok
  end
end
```

## File: `lib/workers/clickhouse_clean_sites.ex`
```
defmodule Plausible.Workers.ClickhouseCleanSites do
  @moduledoc """
  Cleans deleted site data from ClickHouse asynchronously.

  We batch up data deletions from ClickHouse as deleting a single site is
  just as expensive as deleting many.
  """

  use Plausible.Repo
  use Plausible.ClickhouseRepo
  use Plausible.IngestRepo
  use Oban.Worker, queue: :clickhouse_clean_sites

  import Ecto.Query

  require Logger

  @tables_to_clear [
    "events_v2",
    "sessions_v2",
    "ingest_counters",
    "imported_browsers",
    "imported_devices",
    "imported_entry_pages",
    "imported_exit_pages",
    "imported_locations",
    "imported_operating_systems",
    "imported_pages",
    "imported_custom_events",
    "imported_sources",
    "imported_visitors"
  ]

  @settings if Mix.env() in [:test, :ce_test], do: [mutations_sync: 2], else: []

  def perform(_job) do
    deleted_sites = get_deleted_sites_with_clickhouse_data()

    if not Enum.empty?(deleted_sites) do
      Logger.notice(
        "Clearing ClickHouse data for the following #{length(deleted_sites)} sites which have been deleted: #{inspect(deleted_sites)}"
      )

      for table <- @tables_to_clear do
        IngestRepo.query!(
          "ALTER TABLE {$0:Identifier} DELETE WHERE site_id IN {$1:Array(UInt64)}",
          [table, deleted_sites],
          settings: @settings
        )
      end
    end

    :ok
  end

  def get_deleted_sites_with_clickhouse_data() do
    pg_sites =
      from(s in Plausible.Site, select: s.id)
      |> Plausible.Repo.all()
      |> MapSet.new()

    ch_sites =
      from(e in "events_v2", group_by: e.site_id, select: e.site_id)
      |> Plausible.ClickhouseRepo.all(timeout: :infinity)
      |> MapSet.new()

    MapSet.difference(ch_sites, pg_sites) |> MapSet.to_list()
  end
end
```

## File: `lib/workers/expire_domain_change_transitions.ex`
```
defmodule Plausible.Workers.ExpireDomainChangeTransitions do
  @moduledoc """
  Periodic worker that expires domain change transition period.
  Old domains are frozen for a given time, so users can still access them
  before redeploying their scripts and integrations.
  """
  use Plausible.Repo
  use Oban.Worker, queue: :domain_change_transition

  require Logger

  @impl Oban.Worker
  def perform(_job) do
    {:ok, n} = Plausible.Site.Domain.expire_change_transitions()

    if n > 0 do
      Logger.warning("Expired #{n} from the domain change transition period.")
    end

    :ok
  end
end
```

## File: `lib/workers/export_analytics.ex`
```
defmodule Plausible.Workers.ExportAnalytics do
  @moduledoc """
  Worker for running CSV export jobs. Supports S3 and local storage.
  To avoid blocking the queue, a timeout of 15 minutes is enforced.
  """

  use Oban.Worker,
    queue: :analytics_exports,
    max_attempts: 3

  alias Plausible.Exports

  @doc "This base query filters export jobs for a site"
  def base_query(site_id) do
    import Ecto.Query, only: [from: 2]

    from j in Oban.Job,
      where: j.worker == ^Oban.Worker.to_string(__MODULE__),
      where: j.args["site_id"] == ^site_id
  end

  @impl true
  def timeout(_job), do: :timer.minutes(15)

  @impl true
  def perform(%Oban.Job{args: args} = job) do
    %{
      "storage" => storage,
      "site_id" => site_id
    } = args

    site = Plausible.Repo.get!(Plausible.Site, site_id)
    %Date.Range{} = date_range = Exports.date_range(site.id, site.timezone)

    queries =
      Exports.export_queries(site_id,
        date_range: date_range,
        timezone: site.timezone,
        extname: ".csv"
      )

    # since each worker / `perform` attempt runs in a separate process
    # it's ok to use start_link to keep connection lifecycle
    # bound to that of the worker
    {:ok, ch} =
      Plausible.ClickhouseRepo.config()
      |> Keyword.replace!(:pool_size, 1)
      |> Ch.start_link()

    try do
      case storage do
        "s3" -> perform_s3_export(ch, site, queries, args)
        "local" -> perform_local_export(ch, queries, args)
      end
    after
      Exports.oban_notify(site_id)
    end

    email_success(job.args)

    :ok
  catch
    class, reason ->
      if job.attempt >= job.max_attempts, do: email_failure(job.args)
      :erlang.raise(class, reason, __STACKTRACE__)
  end

  defp perform_s3_export(ch, site, queries, args) do
    %{
      "s3_bucket" => s3_bucket,
      "s3_path" => s3_path
    } = args

    created_on = Plausible.Timezones.to_date_in_timezone(DateTime.utc_now(), site.timezone)
    filename = Exports.archive_filename(site.domain, created_on)

    DBConnection.run(
      ch,
      fn conn ->
        conn
        |> Exports.stream_archive(queries, format: "CSVWithNames")
        |> Plausible.S3.export_upload_multipart(s3_bucket, s3_path, filename)
      end,
      timeout: :infinity
    )
  end

  defp perform_local_export(ch, queries, args) do
    %{"local_path" => local_path} = args
    tmp_path = Plug.Upload.random_file!("tmp-plausible-export")

    DBConnection.run(
      ch,
      fn conn ->
        Exports.stream_archive(conn, queries, format: "CSVWithNames")
        |> Stream.into(File.stream!(tmp_path))
        |> Stream.run()
      end,
      timeout: :infinity
    )

    File.mkdir_p!(Path.dirname(local_path))
    if File.exists?(local_path), do: File.rm!(local_path)
    Plausible.File.mv!(tmp_path, local_path)
  end

  defp email_failure(args) do
    args |> Map.put("status", "failure") |> email()
  end

  defp email_success(args) do
    args |> Map.put("status", "success") |> email()
  end

  defp email(args) do
    # email delivery can potentially fail and cause already successful
    # export to be repeated which is costly, hence email is delivered
    # in a separate job
    Oban.insert!(Plausible.Workers.NotifyExportedAnalytics.new(args))
  end
end
```

## File: `lib/workers/import_analytics.ex`
```
defmodule Plausible.Workers.ImportAnalytics do
  @moduledoc """
  Worker for running analytics import jobs.
  """

  use Plausible.Repo
  require Logger

  use Oban.Worker,
    queue: :analytics_imports,
    max_attempts: 3,
    unique: [fields: [:args], keys: [:import_id], period: 60]

  alias Plausible.Imported.ImportSources
  alias Plausible.Imported.Importer
  alias Plausible.Imported.SiteImport

  @impl Oban.Worker
  def perform(%Oban.Job{
        args: %{"import_id" => import_id} = args
      }) do
    site_import =
      SiteImport
      |> Repo.get!(import_id)
      |> Repo.preload(:site)

    import_api = ImportSources.by_name(site_import.source)

    case import_api.run_import(site_import, args) do
      {:ok, site_import} ->
        import_complete(site_import)

        :ok

      {:error, error, error_opts} ->
        Sentry.capture_message("Failed to import from #{site_import.source}",
          extra: %{
            import_id: site_import.id,
            site: site_import.site.domain,
            error: inspect(error)
          }
        )

        import_fail(site_import, error_opts)

        {:discard, error}
    end
  end

  @impl Oban.Worker
  def backoff(_job) do
    # 5 minutes
    300
  end

  def import_complete(site_import) do
    site_import = Repo.preload(site_import, [:imported_by, site: :team])

    PlausibleWeb.Email.import_success(site_import, site_import.imported_by)
    |> Plausible.Mailer.send()

    Plausible.Sites.clear_stats_start_date!(site_import.site)

    Importer.notify(site_import, :complete)

    :ok
  end

  def import_fail_transient(site_import) do
    Plausible.Purge.delete_imported_stats!(site_import)

    Importer.notify(site_import, :transient_fail)
  end

  def import_fail(site_import, opts) do
    skip_purge? = Keyword.get(opts, :skip_purge?, false)
    skip_mark_failed? = Keyword.get(opts, :skip_mark_failed?, false)

    if not skip_purge? do
      Plausible.Purge.delete_imported_stats!(site_import)
    end

    if not skip_mark_failed? do
      import_api = ImportSources.by_name(site_import.source)

      site_import =
        site_import
        |> import_api.mark_failed()
        |> Repo.preload([:site, :imported_by])

      Importer.notify(site_import, :fail)

      PlausibleWeb.Email.import_failure(site_import, site_import.imported_by)
      |> Plausible.Mailer.send()
    end
  end
end
```

## File: `lib/workers/local_import_analytics_cleaner.ex`
```
defmodule Plausible.Workers.LocalImportAnalyticsCleaner do
  @moduledoc """
  Worker for cleaning local files left after analytics import jobs.
  """

  use Oban.Worker, queue: :analytics_imports, unique: [period: 3600]

  @impl Oban.Worker
  def perform(%Oban.Job{args: args}) do
    %{"import_id" => import_id, "paths" => paths} = args

    if import_in_progress?(import_id) do
      {:snooze, _one_hour = 3600}
    else
      Enum.each(paths, fn path ->
        # credo:disable-for-next-line Credo.Check.Refactor.Nesting
        if File.exists?(path), do: File.rm!(path)
      end)
    end
  end

  defp import_in_progress?(import_id) do
    import Ecto.Query
    require Plausible.Imported.SiteImport
    alias Plausible.Imported.SiteImport

    SiteImport
    |> where(id: ^import_id)
    |> where([i], i.status in ^[SiteImport.pending(), SiteImport.importing()])
    |> Plausible.Repo.exists?()
  end
end
```

## File: `lib/workers/locations_sync.ex`
```
defmodule Plausible.Workers.LocationsSync do
  @moduledoc false

  use Plausible.Repo
  use Oban.Worker, queue: :locations_sync

  @impl Oban.Worker
  def perform(_job) do
    if Plausible.DataMigration.LocationsSync.out_of_date?() do
      Plausible.DataMigration.LocationsSync.run()
    end

    :ok
  end
end
```

## File: `lib/workers/lock_sites.ex`
```
defmodule Plausible.Workers.LockSites do
  use Plausible.Repo
  use Oban.Worker, queue: :lock_sites

  alias Plausible.Teams

  @impl Oban.Worker
  def perform(_job) do
    teams =
      Repo.all(
        from t in Teams.Team,
          as: :team,
          left_lateral_join: s in subquery(Teams.last_subscription_join_query()),
          on: true,
          preload: [subscription: s]
      )

    for team <- teams do
      Plausible.Billing.SiteLocker.update_for(team)
    end

    :ok
  end
end
```

## File: `lib/workers/notify_annual_renewal.ex`
```
defmodule Plausible.Workers.NotifyAnnualRenewal do
  use Plausible.Repo
  use Oban.Worker, queue: :notify_annual_renewal

  require Plausible.Billing.Subscription.Status

  alias Money.Subscription
  alias Plausible.Billing.Subscription
  alias Plausible.Teams

  @yearly_plans Plausible.Billing.Plans.yearly_product_ids()

  @impl Oban.Worker
  @doc """
  Sends a notification at most 7 days and at least 1 day before the renewal of an annual subscription
  """
  def perform(_job) do
    sent_notification =
      from(
        s in "sent_renewal_notifications",
        where: s.timestamp > fragment("now() - INTERVAL '1 month'")
      )

    teams =
      Repo.all(
        from t in Teams.Team,
          as: :team,
          inner_join: o in assoc(t, :owners),
          left_join: bm in assoc(t, :billing_members),
          inner_lateral_join: s in subquery(Teams.last_subscription_join_query()),
          on: true,
          left_join: sent in ^sent_notification,
          on: o.id == sent.user_id,
          where: is_nil(sent.id),
          where: s.paddle_plan_id in @yearly_plans,
          where:
            s.next_bill_date > fragment("now()::date") and
              s.next_bill_date <= fragment("now()::date + INTERVAL '7 days'"),
          preload: [owners: o, subscription: s, billing_members: bm]
      )

    for team <- teams do
      recipients = team.owners ++ team.billing_members

      case team.subscription.status do
        Subscription.Status.active() ->
          for recipient <- recipients do
            template = PlausibleWeb.Email.yearly_renewal_notification(team, recipient)
            Plausible.Mailer.send(template)
          end

        Subscription.Status.deleted() ->
          for recipient <- recipients do
            template = PlausibleWeb.Email.yearly_expiration_notification(team, recipient)
            Plausible.Mailer.send(template)
          end

        _ ->
          Sentry.capture_message("Invalid subscription for renewal",
            team: team
          )
      end

      for recipient <- recipients do
        Repo.insert_all("sent_renewal_notifications", [
          %{
            user_id: recipient.id,
            timestamp: NaiveDateTime.utc_now()
          }
        ])
      end
    end

    :ok
  end
end
```

## File: `lib/workers/notify_exported_analytics.ex`
```
defmodule Plausible.Workers.NotifyExportedAnalytics do
  @moduledoc "This worker delivers emails for successful and failed exports"

  use Oban.Worker,
    queue: :notify_exported_analytics,
    max_attempts: 5

  @impl true
  def perform(%Oban.Job{args: args}) do
    %{
      "status" => status,
      "storage" => storage,
      "email_to" => email_to,
      "site_id" => site_id
    } = args

    user = Plausible.Repo.get_by!(Plausible.Auth.User, email: email_to)

    site =
      Plausible.Site
      |> Plausible.Repo.get!(site_id)
      |> Plausible.Repo.preload(:team)

    email =
      case status do
        "success" ->
          case storage do
            "s3" ->
              %{expires_at: expires_at} = Plausible.Exports.get_s3_export!(site_id, _retries = 10)
              PlausibleWeb.Email.export_success(user, site, expires_at)

            "local" ->
              PlausibleWeb.Email.export_success(user, site, _expires_at = nil)
          end

        "failure" ->
          PlausibleWeb.Email.export_failure(user, site)
      end

    Plausible.Mailer.deliver_now!(email)
    :ok
  end
end
```

## File: `lib/workers/purge_cdn_cache.ex`
```
defmodule Plausible.Workers.PurgeCDNCache do
  @moduledoc """
  Worker for purging CDN cache for tracker scripts on cloud.

  Uses Bunny CDN's API to purge cache by tag.
  Docs ref: https://docs.bunny.net/reference/pullzonepublic_purgecachepostbytag

  Note that purging by id "*" is equivalent to purging ALL cache.
  """

  use Oban.Worker,
    queue: :purge_cdn_cache,
    max_attempts: 5,
    # To avoid running into API rate limits, we:
    # - Schedule jobs with a delay
    # - Bump the scheduled time every time a new one is scheduled with the same args
    unique: [
      states: [:scheduled],
      fields: [:args]
    ]

  require Logger

  @impl Oban.Worker
  def perform(%Oban.Job{args: %{"id" => id}}) do
    pullzone_id = Application.get_env(:plausible, __MODULE__, [])[:pullzone_id]
    api_key = Application.get_env(:plausible, __MODULE__, [])[:api_key]

    purge_cache(id, pullzone_id, api_key)
  end

  @impl Oban.Worker
  def backoff(%Oban.Job{attempt: attempt}) do
    # Exponential backoff starting at 3 minutes
    trunc(:math.pow(2, attempt - 1) * 180)
  end

  defp purge_cache(id, pullzone_id, api_key) when is_nil(pullzone_id) or is_nil(api_key) do
    Logger.warning("Ignoring purge CDN cache for tracker script #{id}: Configuration missing")
    {:discard, "Configuration missing"}
  end

  defp purge_cache(id, pullzone_id, api_key) do
    options =
      [
        headers: [
          {"content-type", "application/json"},
          {"AccessKey", api_key}
        ],
        body: Jason.encode!(%{"CacheTag" => "tracker_script::#{id}"})
      ]
      |> Keyword.merge(Application.get_env(:plausible, __MODULE__)[:req_opts] || [])

    case Req.post("https://api.bunny.net/pullzone/#{pullzone_id}/purgeCache", options) do
      {:ok, %{status: 204}} ->
        Logger.notice("Successfully purged CDN cache for tracker script #{id}")
        {:ok, :success}

      {:ok, %{status: status}} ->
        Logger.warning(
          "Failed to purge CDN cache for tracker script #{id}: Unexpected status: #{status}"
        )

        {:error, "Unexpected status: #{status}"}

      {:error, reason} ->
        Logger.warning("Failed to purge CDN cache for tracker script #{id}: #{inspect(reason)}")
        {:error, reason}
    end
  end
end
```

## File: `lib/workers/rotate_salts.ex`
```
defmodule Plausible.Workers.RotateSalts do
  use Plausible.Repo
  use Oban.Worker, queue: :rotate_salts

  @impl Oban.Worker
  def perform(_job) do
    Plausible.Session.Salts.rotate()
  end
end
```

## File: `lib/workers/schedule_email_reports.ex`
```
defmodule Plausible.Workers.ScheduleEmailReports do
  use Plausible.Repo
  use Oban.Worker, queue: :schedule_email_reports
  alias Plausible.Workers.SendEmailReport
  require Logger

  @impl Oban.Worker
  @doc """
    Email reports should be sent on Monday at 9am according to the timezone
  of a site. This job runs every day at midnight to ensure that all sites
  have a scheduled job for email reports.
  """
  def perform(_job) do
    schedule_weekly_emails()
    schedule_monthly_emails()
  end

  defp schedule_weekly_emails() do
    weekly_jobs =
      from(
        j in Oban.Job,
        where:
          j.worker == "Plausible.Workers.SendEmailReport" and
            fragment("(? ->> 'interval')", j.args) == "weekly"
      )

    sites =
      Repo.all(
        from s in Plausible.Site,
          inner_join: t in assoc(s, :team),
          join: wr in Plausible.Site.WeeklyReport,
          on: wr.site_id == s.id,
          left_join: job in subquery(weekly_jobs),
          on:
            fragment("(? -> 'site_id')::int", job.args) == s.id and
              job.state not in ["completed", "discarded"],
          where: is_nil(job),
          where: not t.locked,
          preload: [weekly_report: wr]
      )

    for site <- sites do
      SendEmailReport.new(%{site_id: site.id, interval: "weekly"},
        scheduled_at: monday_9am(site.timezone)
      )
      |> Oban.insert!()
    end

    :ok
  end

  def monday_9am(timezone) do
    DateTime.now!(timezone)
    |> DateTime.shift(week: 1)
    |> Timex.beginning_of_week()
    |> DateTime.shift(hour: 9)
  end

  defp schedule_monthly_emails() do
    monthly_jobs =
      from(
        j in Oban.Job,
        where:
          j.worker == "Plausible.Workers.SendEmailReport" and
            fragment("(? ->> 'interval')", j.args) == "monthly"
      )

    sites =
      Repo.all(
        from s in Plausible.Site,
          inner_join: t in assoc(s, :team),
          join: mr in Plausible.Site.MonthlyReport,
          on: mr.site_id == s.id,
          left_join: job in subquery(monthly_jobs),
          on:
            fragment("(? -> 'site_id')::int", job.args) == s.id and
              job.state not in ["completed", "discarded"],
          where: is_nil(job),
          where: not t.locked,
          preload: [monthly_report: mr]
      )

    for site <- sites do
      SendEmailReport.new(%{site_id: site.id, interval: "monthly"},
        scheduled_at: first_of_month_9am(site.timezone)
      )
      |> Oban.insert!()
    end

    :ok
  end

  def first_of_month_9am(timezone) do
    DateTime.now!(timezone)
    |> DateTime.shift(month: 1)
    |> Timex.beginning_of_month()
    |> DateTime.shift(hour: 9)
  end
end
```

## File: `lib/workers/send_check_stats_emails.ex`
```
defmodule Plausible.Workers.SendCheckStatsEmails do
  use Plausible.Repo
  use Oban.Worker, queue: :check_stats_emails

  @impl Oban.Worker
  def perform(_job) do
    q =
      from(u in Plausible.Auth.User,
        left_join: ce in "check_stats_emails",
        on: ce.user_id == u.id,
        where: is_nil(ce.id),
        where:
          u.inserted_at > fragment("(now() at time zone 'utc') - '14 days'::interval") and
            u.inserted_at < fragment("(now() at time zone 'utc') - '7 days'::interval") and
            u.last_seen < fragment("(now() at time zone 'utc') - '7 days'::interval")
      )

    for user <- Repo.all(q) do
      if eligible_for_check_stats_email?(user) do
        send_check_stats_email(user)
      end
    end

    :ok
  end

  defp eligible_for_check_stats_email?(user) do
    sites =
      from(tm in Plausible.Teams.Membership,
        inner_join: t in assoc(tm, :team),
        inner_join: s in assoc(t, :sites),
        left_join: gm in assoc(tm, :guest_memberships),
        where: tm.user_id == ^user.id,
        where: tm.role != :guest or gm.site_id == s.id,
        select: s
      )
      |> Repo.all()
      |> Repo.preload(:weekly_report)

    not Enum.any?(sites, fn site -> site.weekly_report end) and
      Enum.any?(sites, &Plausible.Sites.has_stats?/1)
  end

  defp send_check_stats_email(user) do
    PlausibleWeb.Email.check_stats_email(user)
    |> Plausible.Mailer.send()

    Repo.insert_all("check_stats_emails", [
      %{
        user_id: user.id,
        timestamp: NaiveDateTime.utc_now()
      }
    ])
  end
end
```

## File: `lib/workers/send_email_report.ex`
```
defmodule Plausible.Workers.SendEmailReport do
  use Plausible.Repo
  use Oban.Worker, queue: :send_email_reports, max_attempts: 1
  alias Plausible.Stats.Query

  @impl Oban.Worker
  def perform(%Oban.Job{args: %{"interval" => "weekly", "site_id" => site_id}}) do
    site = Repo.get(Plausible.Site, site_id) |> Repo.preload(:weekly_report)

    if site && site.weekly_report do
      %{site: site}
      |> put_last_week_query()
      |> put_date_range()
      |> Map.put(:type, :weekly)
      |> Map.put(:name, "Weekly")
      |> put(:date, &Calendar.strftime(&1.date_range.last, "%-d %b %Y"))
      |> put_stats()
      |> send_report_for_all(site.weekly_report.recipients)
    else
      :discard
    end
  end

  @impl Oban.Worker
  def perform(%Oban.Job{args: %{"interval" => "monthly", "site_id" => site_id}}) do
    site = Repo.get(Plausible.Site, site_id) |> Repo.preload(:monthly_report)

    if site && site.monthly_report do
      %{site: site}
      |> put_last_month_query()
      |> put_date_range()
      |> Map.put(:type, :monthly)
      |> put(:name, &Calendar.strftime(&1.date_range.first, "%B"))
      |> put(:date, &Calendar.strftime(&1.date_range.last, "%-d %b %Y"))
      |> put_stats()
      |> send_report_for_all(site.monthly_report.recipients)
    else
      :discard
    end
  end

  defp send_report_for_all(_assigns, [] = _recipients), do: :ok

  defp send_report_for_all(assigns, [email | rest]) do
    unsubscribe_link =
      PlausibleWeb.Endpoint.url() <>
        "/sites/#{URI.encode_www_form(assigns.site.domain)}/#{assigns.type}-report/unsubscribe?email=#{email}"

    user = Plausible.Auth.find_user_by(email: email)
    login_link = user && Plausible.Teams.Memberships.site_member?(assigns.site, user)

    template_assigns =
      assigns
      |> Map.put(:unsubscribe_link, unsubscribe_link)
      |> Map.put(:login_link, login_link)

    PlausibleWeb.Email.stats_report(email, template_assigns)
    |> Plausible.Mailer.send()

    send_report_for_all(assigns, rest)
  end

  defp put_last_month_query(%{site: site} = assigns) do
    last_month =
      DateTime.now!(site.timezone)
      |> DateTime.shift(month: -1)
      |> DateTime.to_date()
      |> Date.beginning_of_month()
      |> Date.to_iso8601()

    query = Query.from(site, %{"period" => "month", "date" => last_month})

    Map.put(assigns, :query, query)
  end

  defp put_last_week_query(%{site: site} = assigns) do
    # In production, evaluating and sending the date param to `Query.from`
    # is redundant since the default value is today for `site.timezone` and
    # weekly reports are always sent on Monday morning. However, this makes
    # it easier to test - no need for a `now` argument.
    date_param =
      site.timezone
      |> DateTime.now!()
      |> DateTime.to_date()
      |> Date.beginning_of_week()
      |> Date.to_iso8601()

    query = Query.from(site, %{"period" => "7d", "date" => date_param})

    Map.put(assigns, :query, query)
  end

  defp put_date_range(%{query: query} = assigns) do
    Map.put(assigns, :date_range, Query.date_range(query))
  end

  defp put_stats(%{site: site, query: query} = assigns) do
    Map.put(assigns, :stats, Plausible.Stats.EmailReport.get(site, query))
  end

  defp put(assigns, key, value_fn) do
    Map.put(assigns, key, value_fn.(assigns))
  end
end
```

## File: `lib/workers/send_site_setup_emails.ex`
```
defmodule Plausible.Workers.SendSiteSetupEmails do
  use Plausible.Repo
  use Oban.Worker, queue: :site_setup_emails
  require Logger

  @impl Oban.Worker
  def perform(_job) do
    send_create_site_emails()
    send_setup_help_emails()
    send_setup_success_emails()

    :ok
  end

  defp send_create_site_emails() do
    q =
      from u in Plausible.Auth.User,
        as: :user,
        where:
          not exists(
            from tm in Plausible.Teams.Membership,
              where: tm.user_id == parent_as(:user).id,
              select: true
          ),
        where:
          not exists(
            from se in "create_site_emails",
              where: se.user_id == parent_as(:user).id,
              select: true
          ),
        where:
          u.inserted_at > fragment("(now() at time zone 'utc') - '72 hours'::interval") and
            u.inserted_at < fragment("(now() at time zone 'utc') - '48 hours'::interval")

    for user <- Repo.all(q) do
      send_create_site_email(user)
    end
  end

  defp send_setup_help_emails() do
    q =
      from(s in Plausible.Site,
        left_join: se in "setup_help_emails",
        on: se.site_id == s.id,
        where: is_nil(se.id),
        where: s.inserted_at > fragment("(now() at time zone 'utc') - '72 hours'::interval"),
        preload: [:owners, :team]
      )

    for site <- Repo.all(q) do
      owners = site.owners
      setup_completed = Plausible.Sites.has_stats?(site)
      hours_passed = NaiveDateTime.diff(DateTime.utc_now(), site.inserted_at, :hour)

      if !setup_completed && hours_passed > 47 do
        send_setup_help_email(owners, site)
      end
    end
  end

  defp send_setup_success_emails() do
    q =
      from(s in Plausible.Site,
        left_join: se in "setup_success_emails",
        on: se.site_id == s.id,
        where: is_nil(se.id),
        inner_join: t in assoc(s, :team),
        where: s.inserted_at > fragment("(now() at time zone 'utc') - '72 hours'::interval"),
        preload: [:owners, team: t]
      )

    for site <- Repo.all(q) do
      if Plausible.Sites.has_stats?(site) do
        send_setup_success_email(site)
      end
    end
  end

  defp send_create_site_email(user) do
    PlausibleWeb.Email.create_site_email(user)
    |> Plausible.Mailer.send()

    Repo.insert_all("create_site_emails", [
      %{
        user_id: user.id,
        timestamp: NaiveDateTime.utc_now()
      }
    ])
  end

  defp send_setup_success_email(site) do
    for owner <- site.owners do
      PlausibleWeb.Email.site_setup_success(owner, site.team, site)
      |> Plausible.Mailer.send()
    end

    Repo.insert_all("setup_success_emails", [
      %{
        site_id: site.id,
        timestamp: NaiveDateTime.utc_now()
      }
    ])
  end

  defp send_setup_help_email(users, site) do
    for user <- users do
      PlausibleWeb.Email.site_setup_help(user, site.team, site)
      |> Plausible.Mailer.send()
    end

    Repo.insert_all("setup_help_emails", [
      %{
        site_id: site.id,
        timestamp: NaiveDateTime.utc_now()
      }
    ])
  end
end
```

## File: `lib/workers/send_trial_notifications.ex`
```
defmodule Plausible.Workers.SendTrialNotifications do
  use Plausible.Repo

  use Oban.Worker,
    queue: :trial_notification_emails,
    max_attempts: 1

  alias Plausible.Teams

  require Logger

  @impl Oban.Worker
  def perform(_job) do
    teams =
      Repo.all(
        from t in Teams.Team,
          inner_join: o in assoc(t, :owners),
          left_join: bm in assoc(t, :billing_members),
          left_join: s in assoc(t, :subscription),
          where: not is_nil(t.trial_expiry_date),
          where: is_nil(s.id),
          order_by: t.inserted_at,
          preload: [owners: o, billing_members: bm]
      )

    for team <- teams do
      recipients = team.owners ++ team.billing_members

      case Date.diff(team.trial_expiry_date, Date.utc_today()) do
        7 ->
          if Teams.has_active_sites?(team) do
            send_one_week_reminder(recipients, team)
          end

        1 ->
          if Teams.has_active_sites?(team) do
            send_tomorrow_reminder(recipients, team)
          end

        0 ->
          if Teams.has_active_sites?(team) do
            send_today_reminder(recipients, team)
          end

        -1 ->
          if Teams.has_active_sites?(team) do
            send_over_reminder(recipients, team)
          end

        _ ->
          nil
      end
    end

    :ok
  end

  defp send_one_week_reminder(users, team) do
    for user <- users do
      PlausibleWeb.Email.trial_one_week_reminder(user, team)
      |> Plausible.Mailer.send()
    end
  end

  defp send_tomorrow_reminder(users, team) do
    usage = Plausible.Teams.Billing.usage_cycle(team, :last_30_days)
    suggested_volume = Plausible.Billing.Plans.suggest_volume(team, usage.total)

    for user <- users do
      PlausibleWeb.Email.trial_upgrade_email(user, team, "tomorrow", usage, suggested_volume)
      |> Plausible.Mailer.send()
    end
  end

  defp send_today_reminder(users, team) do
    usage = Plausible.Teams.Billing.usage_cycle(team, :last_30_days)
    suggested_volume = Plausible.Billing.Plans.suggest_volume(team, usage.total)

    for user <- users do
      PlausibleWeb.Email.trial_upgrade_email(user, team, "today", usage, suggested_volume)
      |> Plausible.Mailer.send()
    end
  end

  defp send_over_reminder(users, team) do
    for user <- users do
      PlausibleWeb.Email.trial_over_email(user, team)
      |> Plausible.Mailer.send()
    end
  end
end
```

## File: `lib/workers/set_legacy_time_on_page_cutoff.ex`
```
defmodule Plausible.Workers.SetLegacyTimeOnPageCutoff do
  @moduledoc """
  Sets sites `legacy_time_on_page_cutoff` depending on whether they have
  sent us engagement data in the past.
  """

  use Plausible.Repo
  use Plausible.ClickhouseRepo
  use Oban.Worker, queue: :legacy_time_on_page_cutoff

  import Ecto.Query

  require Logger

  @impl Oban.Worker
  def perform(%Oban.Job{args: args}) do
    cutoff_date = Map.get(args, "cutoff_date", Date.utc_today())

    {small_sites, large_sites} =
      sites_with_engagement_data(cutoff_date)
      |> filter_sites_needing_update()

    to_update = small_sites ++ large_sites

    if length(to_update) > 0 do
      Logger.notice(
        "Setting legacy_time_on_page_cutoff for #{length(to_update)} sites (#{length(small_sites)} small, #{length(large_sites)} large)"
      )

      {count, _} =
        Repo.update_all(
          from(s in Plausible.Site,
            where: s.id in ^to_update,
            where: is_nil(s.legacy_time_on_page_cutoff)
          ),
          set: [legacy_time_on_page_cutoff: cutoff_date]
        )

      Logger.notice(
        "Successfully set legacy_time_on_page_cutoff=#{cutoff_date} for #{count} sites"
      )
    else
      Logger.debug("No sites legacy_time_on_page_cutoff needs updating")
    end

    :ok
  end

  defp sites_with_engagement_data(cutoff_date) do
    site_info_q =
      from(
        e in "events_v2",
        where: e.timestamp >= fragment("toStartOfHour(? - toIntervalHour(48))", ^cutoff_date),
        where: e.timestamp < fragment("toStartOfHour(? - toIntervalHour(24))", ^cutoff_date),
        group_by: e.site_id,
        select: %{
          site_id: e.site_id,
          hours_with_engagement:
            fragment(
              "uniqIf(toStartOfHour(timestamp), name = 'engagement' AND engagement_time > 0)"
            ),
          is_small_site: fragment("count() < 2000")
        }
      )

    q =
      from(
        s in subquery(site_info_q),
        select: %{
          small_sites:
            fragment("groupArrayIf(site_id, (is_small_site and hours_with_engagement > 0))"),
          large_sites:
            fragment("groupArrayIf(site_id, (not is_small_site and hours_with_engagement = 24))")
        }
      )

    result = ClickhouseRepo.one(q)

    {MapSet.new(result.small_sites), MapSet.new(result.large_sites)}
  end

  defp filter_sites_needing_update({small_sites, large_sites}) do
    needing_update =
      from(s in Plausible.Site,
        where: is_nil(s.legacy_time_on_page_cutoff),
        select: s.id
      )
      |> Repo.all()
      |> MapSet.new()

    {
      small_sites |> MapSet.intersection(needing_update) |> MapSet.to_list(),
      large_sites |> MapSet.intersection(needing_update) |> MapSet.to_list()
    }
  end
end
```

## File: `lib/workers/traffic_change_notifier.ex`
```
defmodule Plausible.Workers.TrafficChangeNotifier do
  @moduledoc """
  Oban service sending out traffic drop/spike notifications
  """
  use Plausible.Repo
  alias Plausible.Stats.{Query, Clickhouse}
  alias Plausible.Site.TrafficChangeNotification

  alias PlausibleWeb.Router.Helpers, as: Routes

  use Oban.Worker, queue: :spike_notifications
  @min_interval_hours 12

  @impl Oban.Worker
  def perform(_job, now \\ NaiveDateTime.utc_now(:second)) do
    today = NaiveDateTime.to_date(now)

    notifications =
      Repo.all(
        from sn in TrafficChangeNotification,
          where:
            is_nil(sn.last_sent) or
              sn.last_sent < ^NaiveDateTime.add(now, -@min_interval_hours, :hour),
          inner_join: s in assoc(sn, :site),
          inner_join: t in assoc(s, :team),
          where: not t.locked,
          where: is_nil(t.accept_traffic_until) or t.accept_traffic_until > ^today,
          preload: [site: {s, team: t}]
      )

    for notification <- notifications do
      case notification.type do
        :spike ->
          current_visitors = Clickhouse.current_visitors(notification.site)

          if current_visitors >= notification.threshold do
            stats =
              notification.site
              |> get_traffic_spike_stats()
              |> Map.put(:current_visitors, current_visitors)

            notify_spike(notification, stats, now)
          end

        :drop ->
          current_visitors = Clickhouse.current_visitors_12h(notification.site)

          if current_visitors < notification.threshold do
            notify_drop(notification, current_visitors, now)
          end
      end
    end

    :ok
  end

  defp notify_spike(notification, stats, now) do
    for recipient <- notification.recipients do
      send_spike_notification(recipient, notification.site, stats)
    end

    notification
    |> TrafficChangeNotification.was_sent(now)
    |> Repo.update()
  end

  defp notify_drop(notification, current_visitors, now) do
    for recipient <- notification.recipients do
      send_drop_notification(recipient, notification.site, current_visitors)
    end

    notification
    |> TrafficChangeNotification.was_sent(now)
    |> Repo.update()
  end

  defp send_spike_notification(recipient, site, stats) do
    dashboard_link =
      if Repo.exists?(email_match_query(site, recipient)) do
        Routes.stats_url(PlausibleWeb.Endpoint, :stats, site.domain, []) <>
          "?__team=#{site.team.identifier}"
      end

    template =
      PlausibleWeb.Email.spike_notification(
        recipient,
        site,
        stats,
        dashboard_link
      )

    Plausible.Mailer.send(template)
  end

  defp send_drop_notification(recipient, site, current_visitors) do
    {dashboard_link, installation_link} =
      if Repo.exists?(email_match_query(site, recipient)) do
        {
          Routes.stats_url(PlausibleWeb.Endpoint, :stats, site.domain, []) <>
            "?__team=#{site.team.identifier}",
          Routes.site_url(PlausibleWeb.Endpoint, :installation, site.domain,
            flow: PlausibleWeb.Flows.review()
          ) <> "&__team=#{site.team.identifier}"
        }
      else
        {nil, nil}
      end

    template =
      PlausibleWeb.Email.drop_notification(
        recipient,
        site,
        current_visitors,
        dashboard_link,
        installation_link
      )

    Plausible.Mailer.send(template)
  end

  defp get_traffic_spike_stats(site) do
    {:ok, query} =
      Query.build(
        site,
        :internal,
        %{
          "site_id" => "#{site.id}",
          "metrics" => ["visitors"],
          "pagination" => %{"limit" => 3},
          "date_range" => "realtime"
        },
        %{}
      )

    %{}
    |> put_sources(site, query)
    |> put_pages(site, query)
  end

  defp put_sources(stats, site, query) do
    query =
      query
      |> Query.set(dimensions: ["visit:source"])
      |> Query.add_filter([:is_not, "visit:source", ["Direct / None"]])

    %{results: sources} = Plausible.Stats.query(site, query)

    Map.put(stats, :sources, sources)
  end

  defp put_pages(stats, site, query) do
    query = Query.set(query, dimensions: ["event:page"])

    %{results: pages} = Plausible.Stats.query(site, query)

    Map.put(stats, :pages, pages)
  end

  defp email_match_query(site, recipient) do
    from tm in Plausible.Teams.Membership,
      inner_join: u in assoc(tm, :user),
      left_join: gm in assoc(tm, :guest_memberships),
      where: tm.team_id == ^site.team_id,
      where: tm.role != :guest or gm.site_id == ^site.id,
      where: u.email == ^recipient
  end
end
```
