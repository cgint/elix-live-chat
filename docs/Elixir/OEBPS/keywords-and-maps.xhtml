<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Keyword lists and maps - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Keyword lists and maps</h1>
<p>Now let's talk about associative data structures. Associative data structures are able to associate a key to a certain value. Different languages call these different names like dictionaries, hashes, associative arrays, etc.</p><p>In Elixir, we have two main associative data structures: keyword lists and maps.</p><h2 id="keyword-lists">Keyword lists</h2><p>Keyword lists are a data-structure used to pass options to functions. Let's see a scenario where they may be useful.</p><p>Imagine you want to split a string of numbers. Initially, we can invoke <a href="String.xhtml#split/2"><code class="inline">String.split/2</code></a> passing two strings as arguments:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">String</span><span class="o">.</span><span class="n">split</span><span class="p" data-group-id="8751533187-1">(</span><span class="s">&quot;1 2 3 4&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p" data-group-id="8751533187-1">)</span><span class="w">
</span><span class="p" data-group-id="8751533187-2">[</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;3&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;4&quot;</span><span class="p" data-group-id="8751533187-2">]</span></code></pre><p>What if you only want to split at most 2 times? The <a href="String.xhtml#split/3"><code class="inline">String.split/3</code></a> function allows the <code class="inline">parts</code> option to be set to the maximum number of entries in the result:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">String</span><span class="o">.</span><span class="n">split</span><span class="p" data-group-id="2497203695-1">(</span><span class="s">&quot;1 2 3 4&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2497203695-2">[</span><span class="ss">parts</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="2497203695-2">]</span><span class="p" data-group-id="2497203695-1">)</span><span class="w">
</span><span class="p" data-group-id="2497203695-3">[</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;3 4&quot;</span><span class="p" data-group-id="2497203695-3">]</span></code></pre><p>As you can see, we got 3 parts, the last one containing the remaining of the input without splitting it.</p><p>Now imagine that some of the inputs you must split on contains additional spaces between the numbers:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">String</span><span class="o">.</span><span class="n">split</span><span class="p" data-group-id="9705860219-1">(</span><span class="s">&quot;1  2  3  4&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9705860219-2">[</span><span class="ss">parts</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="9705860219-2">]</span><span class="p" data-group-id="9705860219-1">)</span><span class="w">
</span><span class="p" data-group-id="9705860219-3">[</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2  3  4&quot;</span><span class="p" data-group-id="9705860219-3">]</span></code></pre><p>As you can see, the additional spaces lead to empty entries in the output. Luckily, we can also set the <code class="inline">trim</code> option to <code class="inline">true</code> to remove them:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">String</span><span class="o">.</span><span class="n">split</span><span class="p" data-group-id="3506733779-1">(</span><span class="s">&quot;1  2  3  4&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3506733779-2">[</span><span class="ss">parts</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="ss">trim</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="3506733779-2">]</span><span class="p" data-group-id="3506733779-1">)</span><span class="w">
</span><span class="p" data-group-id="3506733779-3">[</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; 3  4&quot;</span><span class="p" data-group-id="3506733779-3">]</span></code></pre><p>Once again we got 3 parts, with the last one containing the leftovers.</p><p><code class="inline">[parts: 3]</code> and <code class="inline">[parts: 3, trim: true]</code> are keyword lists. When a keyword list is the last argument of a function, we can skip the brackets and write:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">String</span><span class="o">.</span><span class="n">split</span><span class="p" data-group-id="3159708774-1">(</span><span class="s">&quot;1  2  3  4&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">parts</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="ss">trim</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="3159708774-1">)</span><span class="w">
</span><span class="p" data-group-id="3159708774-2">[</span><span class="s">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;2&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot; 3  4&quot;</span><span class="p" data-group-id="3159708774-2">]</span></code></pre><p>As shown in the example above, keyword lists are mostly used as optional arguments to functions.</p><p>As the name implies, keyword lists are simply lists. In particular, they are lists consisting of 2-item tuples where the first element (the key) is an atom and the second element can be any value. Both representations are the same:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="8869603606-1">[</span><span class="p" data-group-id="8869603606-2">{</span><span class="ss">:parts</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="8869603606-2">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8869603606-3">{</span><span class="ss">:trim</span><span class="p">,</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="8869603606-3">}</span><span class="p" data-group-id="8869603606-1">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p" data-group-id="8869603606-4">[</span><span class="ss">parts</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="ss">trim</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="8869603606-4">]</span><span class="w">
</span><span class="no">true</span></code></pre><p>Keyword lists are important because they have three special characteristics:</p><ul><li>Keys must be atoms.</li><li>Keys are ordered, as specified by the developer.</li><li>Keys can be given more than once.</li></ul><p>For example, we use the fact that keys can be repeated when <a href="alias-require-and-import.xhtml">importing functions</a> in Elixir:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nc">String</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="0575371566-1">[</span><span class="ss">split</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">split</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="0575371566-1">]</span><span class="w">
</span><span class="nc">String</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">split</span><span class="p" data-group-id="0575371566-2">(</span><span class="s">&quot;hello world&quot;</span><span class="p" data-group-id="0575371566-2">)</span><span class="w">
</span><span class="p" data-group-id="0575371566-3">[</span><span class="s">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p" data-group-id="0575371566-3">]</span></code></pre><p>In the example above, we imported both <code class="inline">split/1</code> and <code class="inline">split/2</code> from the <a href="String.xhtml"><code class="inline">String</code></a> module, allowing us to invoke them without typing the module name. We used a keyword list to list the functions to import.</p><p>Since keyword lists are lists, we can use all operations available to lists. For example, we can use <code class="inline">++</code> to add new values to a keyword list:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4069744742-1">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="4069744742-1">]</span><span class="w">
</span><span class="p" data-group-id="4069744742-2">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="4069744742-2">]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">list</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="p" data-group-id="4069744742-3">[</span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="4069744742-3">]</span><span class="w">
</span><span class="p" data-group-id="4069744742-4">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">c</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="4069744742-4">]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="4069744742-5">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="4069744742-5">]</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">list</span><span class="w">
</span><span class="p" data-group-id="4069744742-6">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="4069744742-6">]</span></code></pre><p>You can read the value of a keyword list using the brackets syntax, which will return the value of the first matching key. This is also known as the access syntax, as it is defined by the <a href="Access.xhtml"><code class="inline">Access</code></a> module:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">list</span><span class="p" data-group-id="0585536443-1">[</span><span class="ss">:a</span><span class="p" data-group-id="0585536443-1">]</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">list</span><span class="p" data-group-id="0585536443-2">[</span><span class="ss">:b</span><span class="p" data-group-id="0585536443-2">]</span><span class="w">
</span><span class="mi">2</span></code></pre><p>Although we can pattern match on keyword lists, it is not done in practice since pattern matching on lists requires the number of items and their order to match:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="8183153823-1">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="8183153823-1">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8183153823-2">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="8183153823-2">]</span><span class="w">
</span><span class="p" data-group-id="8183153823-3">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="8183153823-3">]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">a</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="8183153823-4">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="8183153823-4">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8183153823-5">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="8183153823-5">]</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: [a: 1, b: 2]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="8183153823-6">[</span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="8183153823-6">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8183153823-7">[</span><span class="ss">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="8183153823-7">]</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: [a: 1, b: 2]</span></code></pre><p>Furthermore, given keyword lists are often used as optional arguments, they are used in situations where not all keys may be present, which would make it impossible to match on them. In a nutshell, do not pattern match on keyword lists.</p><p>In order to manipulate keyword lists, Elixir provides the <a href="Keyword.xhtml"><code class="inline">Keyword</code></a> module. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics: the longer the list, the longer it will take to find a key, to count the number of items, and so on. If you need to store a large amount of keys in a key-value data structure, Elixir offers maps, which we will soon learn.</p><h3 id="do-blocks-and-keywords"><code class="inline">do</code>-blocks and keywords</h3><p>As we have seen, keywords are mostly used in the language to pass optional values. In fact, we have used keywords in earlier chapters. Let's look at the <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a> macro:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="k">if</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="k" data-group-id="2769114555-1">do</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="s">&quot;This will be seen&quot;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="2769114555-1">else</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="s">&quot;This won&#39;t&quot;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="2769114555-1">end</span><span class="w">
</span><span class="s">&quot;This will be seen&quot;</span></code></pre><p>In the example above, the <code class="inline">do</code> and <code class="inline">else</code> blocks make up a keyword list. They are nothing more than a syntax convenience on top of keyword lists. We can rewrite the above to:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="k">if</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;This will be seen&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">else</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;This won&#39;t&quot;</span><span class="w">
</span><span class="s">&quot;This will be seen&quot;</span></code></pre><p>Pay close attention to both syntaxes. The second example uses keyword lists, exactly as in the <a href="String.xhtml#split/3"><code class="inline">String.split/3</code></a> example, so we separate each key-value pair with commas and each key is followed by <code class="inline">:</code>. In the <code class="inline">do</code>-blocks, we use bare words, such as <code class="inline">do</code>, <code class="inline">else</code>, and <code class="inline">end</code>, and separate them by a newline. They are useful precisely when writing blocks of code. Most of the time, you will use the block syntax, but it is good to know they are equivalent.</p><p>The fact the block syntax is equivalent to keywords means we only need few data structures to represent the language, keeping it simple overall. We will come back to this topic when discussing <a href="optional-syntax.xhtml">optional syntax</a> and <a href="quote-and-unquote.xhtml">meta-programming</a>.</p><p>With this out of the way, let's talk about maps.</p><h2 id="maps-as-key-value-pairs">Maps as key-value pairs</h2><p>Whenever you need to store key-value pairs, maps are the &quot;go to&quot; data structure in Elixir. A map is created using the <code class="inline">%{}</code> syntax:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1511023722-1">%{</span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="1511023722-1">}</span><span class="w">
</span><span class="p" data-group-id="1511023722-2">%{</span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="1511023722-2">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">map</span><span class="p" data-group-id="1511023722-3">[</span><span class="ss">:a</span><span class="p" data-group-id="1511023722-3">]</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">map</span><span class="p" data-group-id="1511023722-4">[</span><span class="mi">2</span><span class="p" data-group-id="1511023722-4">]</span><span class="w">
</span><span class="ss">:b</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">map</span><span class="p" data-group-id="1511023722-5">[</span><span class="ss">:c</span><span class="p" data-group-id="1511023722-5">]</span><span class="w">
</span><span class="no">nil</span></code></pre><p>Compared to keyword lists, we can already see two differences:</p><ul><li>Maps allow any value as a key.</li><li>Maps have their own internal ordering, which is not guaranteed to be the same across different maps, even if they have the same keys</li></ul><p>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="2146980683-1">%{</span><span class="p" data-group-id="2146980683-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2146980683-2">%{</span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="2146980683-2">}</span><span class="w">
</span><span class="p" data-group-id="2146980683-3">%{</span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="2146980683-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="2146980683-4">%{</span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="2146980683-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2146980683-5">%{</span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="2146980683-5">}</span><span class="w">
</span><span class="p" data-group-id="2146980683-6">%{</span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="2146980683-6">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">a</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="2146980683-7">%{</span><span class="ss">:c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">c</span><span class="p" data-group-id="2146980683-7">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2146980683-8">%{</span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="2146980683-8">}</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: %{2 =&gt; :b, :a =&gt; 1}</span></code></pre><p>As shown above, a map matches as long as the keys in the pattern exist in the given map. Therefore, an empty map matches all maps.</p><p>The <a href="Map.xhtml"><code class="inline">Map</code></a> module provides a very similar API to the <a href="Keyword.xhtml"><code class="inline">Keyword</code></a> module with convenience functions to add, remove, and update maps keys:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">Map</span><span class="o">.</span><span class="n">get</span><span class="p" data-group-id="0221583309-1">(</span><span class="p" data-group-id="0221583309-2">%{</span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="0221583309-2">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:a</span><span class="p" data-group-id="0221583309-1">)</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="0221583309-3">(</span><span class="p" data-group-id="0221583309-4">%{</span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="0221583309-4">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:c</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="0221583309-3">)</span><span class="w">
</span><span class="p" data-group-id="0221583309-5">%{</span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p">,</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="0221583309-5">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Map</span><span class="o">.</span><span class="n">to_list</span><span class="p" data-group-id="0221583309-6">(</span><span class="p" data-group-id="0221583309-7">%{</span><span class="ss">:a</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="0221583309-7">}</span><span class="p" data-group-id="0221583309-6">)</span><span class="w">
</span><span class="p" data-group-id="0221583309-8">[</span><span class="p" data-group-id="0221583309-9">{</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="ss">:b</span><span class="p" data-group-id="0221583309-9">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0221583309-10">{</span><span class="ss">:a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="0221583309-10">}</span><span class="p" data-group-id="0221583309-8">]</span></code></pre><h2 id="maps-of-predefined-keys">Maps of predefined keys</h2><p>In the previous section, we have used maps as a key-value data structure where keys can be added or removed at any time. However, it is also common to create maps with a predefined set of keys. Their values may be updated, but new keys are never added nor removed. This is useful when we know the shape of the data we are working with and, if we get a different key, it likely means a mistake was done elsewhere. In such cases, the keys are most often atoms:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="0555098995-1">%{</span><span class="ss">:name</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">:age</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">23</span><span class="p" data-group-id="0555098995-1">}</span><span class="w">
</span><span class="p" data-group-id="0555098995-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">23</span><span class="p" data-group-id="0555098995-2">}</span></code></pre><p>As you can see from the printed result above, Elixir also allows you to write maps of atom keys using the same <code class="inline">key: value</code> syntax as keyword lists:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="3158217126-1">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">23</span><span class="p" data-group-id="3158217126-1">}</span><span class="w">
</span><span class="p" data-group-id="3158217126-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">23</span><span class="p" data-group-id="3158217126-2">}</span></code></pre><p>When a key is an atom, we can also access them using the <code class="inline">map.key</code> syntax:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">map</span><span class="o">.</span><span class="n">name</span><span class="w">
</span><span class="s">&quot;John&quot;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">map</span><span class="o">.</span><span class="n">agee</span><span class="w">
</span><span class="gt">** (KeyError) key :agee not found in: %{name: &quot;John&quot;, age: 23}</span></code></pre><p>There is also syntax for updating keys, which also raises if the key has not yet been defined:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="9021970385-1">%{</span><span class="n">map</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Mary&quot;</span><span class="p" data-group-id="9021970385-1">}</span><span class="w">
</span><span class="p" data-group-id="9021970385-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Mary&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">23</span><span class="p" data-group-id="9021970385-2">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="9021970385-3">%{</span><span class="n">map</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="ss">agee</span><span class="p">:</span><span class="w"> </span><span class="mi">27</span><span class="p" data-group-id="9021970385-3">}</span><span class="w">
</span><span class="gt">** (KeyError) key :agee not found in: %{name: &quot;John&quot;, age: 23}</span></code></pre><p>These operations have one large benefit in that they raise if the key does not exist in the map and the compiler may even detect and warn when possible. This makes them useful to get quick feedback and spot bugs and typos early on. This is also the syntax used to power another Elixir feature called &quot;Structs&quot;, which we will learn later on.</p><p>Elixir developers typically prefer to use the <code class="inline">map.key</code> syntax and pattern matching instead of the functions in the <a href="Map.xhtml"><code class="inline">Map</code></a> module when working with maps because they lead to an assertive style of programming. <a href="https://dashbit.co/blog/writing-assertive-code-with-elixir">This blog post by Jos√© Valim</a> provides insight and examples on how you get more concise and faster software by writing assertive code in Elixir.</p><h2 id="nested-data-structures">Nested data structures</h2><p>Often we will have maps inside maps, or even keywords lists inside maps, and so forth. Elixir provides conveniences for manipulating nested data structures via the <a href="Kernel.xhtml#get_in/1"><code class="inline">get_in/1</code></a>, <a href="Kernel.xhtml#put_in/2"><code class="inline">put_in/2</code></a>, <a href="Kernel.xhtml#update_in/2"><code class="inline">update_in/2</code></a>, and other macros giving the same conveniences you would find in imperative languages while keeping the immutable properties of the language.</p><p>Imagine you have the following structure:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">users</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="6668977858-1">[</span><span class="w">
  </span><span class="ss">john</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6668977858-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="ss">languages</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6668977858-3">[</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ruby&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Elixir&quot;</span><span class="p" data-group-id="6668977858-3">]</span><span class="p" data-group-id="6668977858-2">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">mary</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6668977858-4">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Mary&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">29</span><span class="p">,</span><span class="w"> </span><span class="ss">languages</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6668977858-5">[</span><span class="s">&quot;Elixir&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;F#&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Clojure&quot;</span><span class="p" data-group-id="6668977858-5">]</span><span class="p" data-group-id="6668977858-4">}</span><span class="w">
</span><span class="p" data-group-id="6668977858-1">]</span><span class="w">
</span><span class="p" data-group-id="6668977858-6">[</span><span class="w">
  </span><span class="ss">john</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6668977858-7">%{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span><span class="w"> </span><span class="ss">languages</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6668977858-8">[</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ruby&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Elixir&quot;</span><span class="p" data-group-id="6668977858-8">]</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p" data-group-id="6668977858-7">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">mary</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6668977858-9">%{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">29</span><span class="p">,</span><span class="w"> </span><span class="ss">languages</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6668977858-10">[</span><span class="s">&quot;Elixir&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;F#&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Clojure&quot;</span><span class="p" data-group-id="6668977858-10">]</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Mary&quot;</span><span class="p" data-group-id="6668977858-9">}</span><span class="w">
</span><span class="p" data-group-id="6668977858-6">]</span></code></pre><p>We have a keyword list of users where each value is a map containing the name, age and a list of programming languages each user likes. If we wanted to access the age for john, we could write:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">users</span><span class="p" data-group-id="7515915851-1">[</span><span class="ss">:john</span><span class="p" data-group-id="7515915851-1">]</span><span class="o">.</span><span class="n">age</span><span class="w">
</span><span class="mi">27</span></code></pre><p>It happens we can also use this same syntax for updating the value:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">users</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">put_in</span><span class="p" data-group-id="6199721846-1">(</span><span class="n">users</span><span class="p" data-group-id="6199721846-2">[</span><span class="ss">:john</span><span class="p" data-group-id="6199721846-2">]</span><span class="o">.</span><span class="n">age</span><span class="p">,</span><span class="w"> </span><span class="mi">31</span><span class="p" data-group-id="6199721846-1">)</span><span class="w">
</span><span class="p" data-group-id="6199721846-3">[</span><span class="w">
  </span><span class="ss">john</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6199721846-4">%{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="ss">languages</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6199721846-5">[</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ruby&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Elixir&quot;</span><span class="p" data-group-id="6199721846-5">]</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p" data-group-id="6199721846-4">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">mary</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6199721846-6">%{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">29</span><span class="p">,</span><span class="w"> </span><span class="ss">languages</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6199721846-7">[</span><span class="s">&quot;Elixir&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;F#&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Clojure&quot;</span><span class="p" data-group-id="6199721846-7">]</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Mary&quot;</span><span class="p" data-group-id="6199721846-6">}</span><span class="w">
</span><span class="p" data-group-id="6199721846-3">]</span></code></pre><p>The <a href="Kernel.xhtml#update_in/2"><code class="inline">update_in/2</code></a> macro is similar but allows us to pass a function that controls how the value changes. For example, let's remove &quot;Clojure&quot; from Mary's list of languages:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">users</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">update_in</span><span class="p" data-group-id="3330038631-1">(</span><span class="n">users</span><span class="p" data-group-id="3330038631-2">[</span><span class="ss">:mary</span><span class="p" data-group-id="3330038631-2">]</span><span class="o">.</span><span class="n">languages</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="3330038631-3">fn</span><span class="w"> </span><span class="n">languages</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">List</span><span class="o">.</span><span class="n">delete</span><span class="p" data-group-id="3330038631-4">(</span><span class="n">languages</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Clojure&quot;</span><span class="p" data-group-id="3330038631-4">)</span><span class="w"> </span><span class="k" data-group-id="3330038631-3">end</span><span class="p" data-group-id="3330038631-1">)</span><span class="w">
</span><span class="p" data-group-id="3330038631-5">[</span><span class="w">
  </span><span class="ss">john</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3330038631-6">%{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">31</span><span class="p">,</span><span class="w"> </span><span class="ss">languages</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3330038631-7">[</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Ruby&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Elixir&quot;</span><span class="p" data-group-id="3330038631-7">]</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="p" data-group-id="3330038631-6">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">mary</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3330038631-8">%{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">29</span><span class="p">,</span><span class="w"> </span><span class="ss">languages</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3330038631-9">[</span><span class="s">&quot;Elixir&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;F#&quot;</span><span class="p" data-group-id="3330038631-9">]</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Mary&quot;</span><span class="p" data-group-id="3330038631-8">}</span><span class="w">
</span><span class="p" data-group-id="3330038631-5">]</span></code></pre><h2 id="summary">Summary</h2><p>There are two different data structures for working with key-value stores in Elixir. Alongside the <a href="Access.xhtml"><code class="inline">Access</code></a> module and pattern matching, they provide a rich set of tools for manipulating complex, potentially nested, data structures.</p><p>As we conclude this chapter, remember that you should:</p><ul><li><p>Use keyword lists for passing optional values to functions</p></li><li><p>Use maps for general key-value data structures</p></li><li><p>Use maps when working with data that has a predefined set of keys</p></li></ul><p>Now let's talk about modules and functions.</p>

  </body>
</html>
