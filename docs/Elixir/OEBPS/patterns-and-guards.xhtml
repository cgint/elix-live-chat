<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Patterns and guards - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Patterns and guards</h1>
<p>Elixir provides pattern matching, which allows us to assert on the shape or extract values from data structures. Patterns are often augmented with guards, which give developers the ability to perform more complex checks, albeit limited.</p><p>This document provides a complete reference on patterns and guards, their semantics, where they are allowed, and how to extend them.</p><h2 id="patterns">Patterns</h2><p>Patterns in Elixir are made of variables, literals, and data structure specific syntax. One of the most used constructs to perform pattern matching is the match operator (<a href="Kernel.SpecialForms.xhtml#=/2"><code class="inline">=</code></a>):</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w">
</span><span class="mi">1</span></code></pre><p>In the example above, <code class="inline">x</code> starts without a value and has <code class="inline">1</code> assigned to it. Then, we compare the value of <code class="inline">x</code> to the literal <code class="inline">1</code>, which succeeds as they are both <code class="inline">1</code>.</p><p>Matching <code class="inline">x</code> against 2 would raise:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="mi">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: 1</span></code></pre><p>Patterns are not bidirectional. If you have a variable <code class="inline">y</code> that was never assigned to (often called an unbound variable) and you write <code class="inline">1 = y</code>, an error will be raised:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w">
</span><span class="gt">** (CompileError) iex:2: undefined variable &quot;y&quot;</span></code></pre><p>In other words, patterns are allowed only on the left side of <code class="inline">=</code>. The right side of <code class="inline">=</code> follows the regular evaluation semantics of the language.</p><p>Now let's cover the pattern matching rules for each construct and then for each relevant data types.</p><h3 id="variables">Variables</h3><p>Variables in patterns are always assigned to:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">x</span><span class="w">
</span><span class="mi">2</span></code></pre><p>In other words, Elixir supports rebinding. In case you don't want the value of a variable to change, you can use the pin operator (<code class="inline">^</code>):</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="o">^</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: 2</span></code></pre><p>If the same variable appears multiple times in the same pattern, then all of them must be bound to the same value:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="6245268975-1">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="6245268975-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="6245268975-2">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="6245268975-2">}</span><span class="w">
</span><span class="p" data-group-id="6245268975-3">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="6245268975-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="6245268975-4">{</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p" data-group-id="6245268975-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="6245268975-5">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="6245268975-5">}</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: {1, 2}</span></code></pre><p>The underscore variable (<code class="inline">_</code>) has a special meaning as it can never be bound to any value. It is especially useful when you don't care about certain value in a pattern:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="3861228051-1">{</span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p" data-group-id="3861228051-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="3861228051-2">{</span><span class="ss">:not_important</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="3861228051-2">}</span><span class="w">
</span><span class="p" data-group-id="3861228051-3">{</span><span class="ss">:not_important</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="3861228051-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">integer</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="bp">_</span><span class="w">
</span><span class="gt">** (CompileError) iex:3: invalid use of _</span></code></pre><h3 id="literals-numbers-and-atoms">Literals (numbers and atoms)</h3><p>Atoms and numbers (integers and floats) can appear in patterns and they are always represented as is. For example, an atom will only match an atom if they are the same atom:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="ss">:atom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:atom</span><span class="w">
</span><span class="ss">:atom</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="ss">:atom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ss">:another_atom</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: :another_atom</span></code></pre><p>Similar rule applies to numbers. Finally, note that numbers in patterns perform strict comparison. In other words, integers to do not match floats:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: 1.0</span></code></pre><h3 id="tuples">Tuples</h3><p>Tuples may appear in patterns using the curly brackets syntax (<code class="inline">{}</code>). A tuple in a pattern will match only tuples of the same size, where each individual tuple element must also match:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="9519097342-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p" data-group-id="9519097342-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9519097342-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="9519097342-2">}</span><span class="w">
</span><span class="p" data-group-id="9519097342-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="9519097342-3">}</span><span class="w">

</span><span class="c1"># won&#39;t match due to different size</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="9519097342-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p" data-group-id="9519097342-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9519097342-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="9519097342-5">}</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: {:ok, 11, 13}</span><span class="w">

</span><span class="c1"># won&#39;t match due to mismatch on first element</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="9519097342-6">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">binary</span><span class="p" data-group-id="9519097342-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9519097342-7">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:enoent</span><span class="p" data-group-id="9519097342-7">}</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: {:error, :enoent}</span></code></pre><h3 id="lists">Lists</h3><p>Lists may appear in patterns using the square brackets syntax (<code class="inline">[]</code>). A list in a pattern will match only lists of the same size, where each individual list element must also match:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="1268311504-1">[</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p" data-group-id="1268311504-1">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1268311504-2">[</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="1268311504-2">]</span><span class="w">
</span><span class="p" data-group-id="1268311504-3">[</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="1268311504-3">]</span><span class="w">

</span><span class="c1"># won&#39;t match due to different size</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="1268311504-4">[</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p" data-group-id="1268311504-4">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1268311504-5">[</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="1268311504-5">]</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: [:ok, 11, 13]</span><span class="w">

</span><span class="c1"># won&#39;t match due to mismatch on first element</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="1268311504-6">[</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">binary</span><span class="p" data-group-id="1268311504-6">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="1268311504-7">[</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="ss">:enoent</span><span class="p" data-group-id="1268311504-7">]</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: [:error, :enoent]</span></code></pre><p>Opposite to tuples, lists also allow matching on non-empty lists by using the <code class="inline">[head | tail]</code> notation, which matches on the <code class="inline">head</code> and <code class="inline">tail</code> of a list:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="0724598944-1">[</span><span class="n">head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tail</span><span class="p" data-group-id="0724598944-1">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="0724598944-2">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="0724598944-2">]</span><span class="w">
</span><span class="p" data-group-id="0724598944-3">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="0724598944-3">]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">head</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">tail</span><span class="w">
</span><span class="p" data-group-id="0724598944-4">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="0724598944-4">]</span></code></pre><p>Multiple elements may prefix the <code class="inline">| tail</code> construct:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="7830733022-1">[</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tail</span><span class="p" data-group-id="7830733022-1">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7830733022-2">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="7830733022-2">]</span><span class="w">
</span><span class="p" data-group-id="7830733022-3">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="7830733022-3">]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">tail</span><span class="w">
</span><span class="p" data-group-id="7830733022-4">[</span><span class="mi">3</span><span class="p" data-group-id="7830733022-4">]</span></code></pre><p>Note <code class="inline">[head | tail]</code> does not match empty lists:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="6879721841-1">[</span><span class="n">head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tail</span><span class="p" data-group-id="6879721841-1">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="6879721841-2">[</span><span class="p" data-group-id="6879721841-2">]</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: []</span></code></pre><p>Given charlists are represented as a list of integers, one can also perform prefix matches on charlists using the list concatenation operator (<a href="Kernel.xhtml#++/2"><code class="inline">++</code></a>):</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="s">~c&quot;hello &quot;</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">~c&quot;hello world&quot;</span><span class="w">
</span><span class="s">~c&quot;hello world&quot;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">world</span><span class="w">
</span><span class="s">~c&quot;world&quot;</span></code></pre><p>Which is equivalent to matching on <code class="inline">[?h, ?e, ?l, ?l, ?o, ?\s | world]</code>. Suffix matches (<code class="inline">hello ++ ~c&quot; world&quot;</code>) are not valid patterns.</p><h3 id="maps">Maps</h3><p>Maps may appear in patterns using the percentage sign followed by the curly brackets syntax (<code class="inline">%{}</code>). Opposite to lists and tuples, maps perform a subset match. This means a map pattern will match any other map that has at least all of the keys in the pattern.</p><p>Here is an example where all keys match:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="5893886349-1">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="5893886349-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5893886349-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="5893886349-2">}</span><span class="w">
</span><span class="p" data-group-id="5893886349-3">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="5893886349-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">name</span><span class="w">
</span><span class="s">&quot;meg&quot;</span></code></pre><p>Here is when a subset of the keys match:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="2871049992-1">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="2871049992-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="2871049992-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">23</span><span class="p" data-group-id="2871049992-2">}</span><span class="w">
</span><span class="p" data-group-id="2871049992-3">%{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="mi">23</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="2871049992-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">name</span><span class="w">
</span><span class="s">&quot;meg&quot;</span></code></pre><p>If a key in the pattern is not available in the map, then they won't match:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="8997027763-1">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="n">age</span><span class="p" data-group-id="8997027763-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8997027763-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="8997027763-2">}</span><span class="w">
</span><span class="gt">** (MatchError) no match of right hand side value: %{name: &quot;meg&quot;}</span></code></pre><p>Note that the empty map will match all maps, which is a contrast to tuples and lists, where an empty tuple or an empty list will only match empty tuples and empty lists respectively:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="5736802415-1">%{</span><span class="p" data-group-id="5736802415-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="5736802415-2">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="5736802415-2">}</span><span class="w">
</span><span class="p" data-group-id="5736802415-3">%{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="5736802415-3">}</span></code></pre><p>Finally, note map keys in patterns must always be literals or previously bound variables matched with the pin operator.</p><h3 id="structs">Structs</h3><p>Structs may appear in patterns using the percentage sign, the struct module name or a variable followed by the curly brackets syntax (<code class="inline">%{}</code>).</p><p>Given the following struct:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">User</span><span class="w"> </span><span class="k" data-group-id="3591291020-1">do</span><span class="w">
  </span><span class="kd">defstruct</span><span class="w"> </span><span class="p" data-group-id="3591291020-2">[</span><span class="ss">:name</span><span class="p" data-group-id="3591291020-2">]</span><span class="w">
</span><span class="k" data-group-id="3591291020-1">end</span></code></pre><p>Here is an example where all keys match:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="4245376855-1">%</span><span class="nc" data-group-id="4245376855-1">User</span><span class="p" data-group-id="4245376855-1">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="4245376855-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4245376855-2">%</span><span class="nc" data-group-id="4245376855-2">User</span><span class="p" data-group-id="4245376855-2">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="4245376855-2">}</span><span class="w">
</span><span class="p" data-group-id="4245376855-3">%</span><span class="nc" data-group-id="4245376855-3">User</span><span class="p" data-group-id="4245376855-3">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="4245376855-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">name</span><span class="w">
</span><span class="s">&quot;meg&quot;</span></code></pre><p>If an unknown key is given, the compiler will raise an error:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="9687025277-1">%</span><span class="nc" data-group-id="9687025277-1">User</span><span class="p" data-group-id="9687025277-1">{</span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="n">type</span><span class="p" data-group-id="9687025277-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="9687025277-2">%</span><span class="nc" data-group-id="9687025277-2">User</span><span class="p" data-group-id="9687025277-2">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="9687025277-2">}</span><span class="w">
</span><span class="gt">** (CompileError) iex: unknown key :type for struct User</span></code></pre><p>The struct name can be extracted when putting a variable instead of a module name:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p">%</span><span class="n">struct_name</span><span class="p" data-group-id="7540316232-1">{</span><span class="p" data-group-id="7540316232-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="7540316232-2">%</span><span class="nc" data-group-id="7540316232-2">User</span><span class="p" data-group-id="7540316232-2">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="7540316232-2">}</span><span class="w">
</span><span class="p" data-group-id="7540316232-3">%</span><span class="nc" data-group-id="7540316232-3">User</span><span class="p" data-group-id="7540316232-3">{</span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;meg&quot;</span><span class="p" data-group-id="7540316232-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">struct_name</span><span class="w">
</span><span class="nc">User</span></code></pre><h3 id="binaries">Binaries</h3><p>Binaries may appear in patterns using the double less-than/greater-than syntax (<a href="Kernel.SpecialForms.xhtml#%3C%3C%3E%3E/1"><code class="inline">&lt;&lt;&gt;&gt;</code></a>). A binary in a pattern can match multiple segments at the same time, each with different type, size, and unit:</p><pre><code class="makeup iex" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="8490134230-1">&lt;&lt;</span><span class="n">val</span><span class="o">::</span><span class="n">unit</span><span class="p" data-group-id="8490134230-2">(</span><span class="mi">8</span><span class="p" data-group-id="8490134230-2">)</span><span class="o">-</span><span class="n">size</span><span class="p" data-group-id="8490134230-3">(</span><span class="mi">2</span><span class="p" data-group-id="8490134230-3">)</span><span class="o">-</span><span class="n">integer</span><span class="p" data-group-id="8490134230-1">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="8490134230-4">&lt;&lt;</span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="mi">56</span><span class="p" data-group-id="8490134230-4">&gt;&gt;</span><span class="w">
</span><span class="s">&quot;{8&quot;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">val</span><span class="w">
</span><span class="mi">31544</span></code></pre><p>See the documentation for <a href="Kernel.SpecialForms.xhtml#%3C%3C%3E%3E/1"><code class="inline">&lt;&lt;&gt;&gt;</code></a> for a complete definition of pattern matching for binaries.</p><p>Finally, remember that strings in Elixir are UTF-8 encoded binaries. This means that, similar to charlists, prefix matches on strings are also possible with the binary concatenation operator (<a href="Kernel.xhtml#%3C%3E/2"><code class="inline">&lt;&gt;</code></a>):</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="s">&quot;hello &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="w">
</span><span class="s">&quot;hello world&quot;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">world</span><span class="w">
</span><span class="s">&quot;world&quot;</span></code></pre><p>Suffix matches (<code class="inline">hello &lt;&gt; &quot; world&quot;</code>) are not valid patterns.</p><h2 id="guards">Guards</h2><p>Guards are a way to augment pattern matching with more complex checks. They are allowed in a predefined set of constructs where pattern matching is allowed, such as function definitions, case clauses, and others.</p><p>Not all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (through Erlang) ensures that all guards are predictable (no mutations or other side-effects) and they can be optimized and performed efficiently.</p><h3 id="list-of-allowed-functions-and-operators">List of allowed functions and operators</h3><p>You can find the built-in list of guards <a href="Kernel.xhtml#guards">in the <code class="inline">Kernel</code> module</a>. Here is an overview:</p><ul><li>comparison operators (<a href="Kernel.xhtml#==/2"><code class="inline">==</code></a>, <a href="Kernel.xhtml#!=/2"><code class="inline">!=</code></a>, <a href="Kernel.xhtml#===/2"><code class="inline">===</code></a>, <a href="Kernel.xhtml#!==/2"><code class="inline">!==</code></a>,
<a href="Kernel.xhtml#%3C/2"><code class="inline">&lt;</code></a>, <a href="Kernel.xhtml#%3C=/2"><code class="inline">&lt;=</code></a>, <a href="Kernel.xhtml#%3E/2"><code class="inline">&gt;</code></a>, <a href="Kernel.xhtml#%3E=/2"><code class="inline">&gt;=</code></a>)</li><li>strictly boolean operators (<a href="Kernel.xhtml#and/2"><code class="inline">and</code></a>, <a href="Kernel.xhtml#or/2"><code class="inline">or</code></a>, <a href="Kernel.xhtml#not/1"><code class="inline">not</code></a>). Note <a href="Kernel.xhtml#&&/2"><code class="inline">&amp;&amp;</code></a>, <a href="Kernel.xhtml#%7C%7C/2"><code class="inline">||</code></a>, and <a href="Kernel.xhtml#!/1"><code class="inline">!</code></a> sibling operators are <strong>not allowed</strong> as they're not <em>strictly</em> boolean - meaning they don't require arguments to be booleans</li><li>arithmetic unary operators (<a href="Kernel.xhtml#+/1"><code class="inline">+</code></a>, <a href="Kernel.xhtml#-/1"><code class="inline">-</code></a>)</li><li>arithmetic binary operators (<a href="Kernel.xhtml#+/2"><code class="inline">+</code></a>, <a href="Kernel.xhtml#-/2"><code class="inline">-</code></a>, <a href="Kernel.xhtml#*/2"><code class="inline">*</code></a>, <a href="Kernel.xhtml#//2"><code class="inline">/</code></a>)</li><li><a href="Kernel.xhtml#in/2"><code class="inline">in</code></a> and <a href="Kernel.xhtml#in/2"><code class="inline">not in</code></a> operators (as long as the right-hand side is a list or a range)</li><li>&quot;type-check&quot; functions (<a href="Kernel.xhtml#is_list/1"><code class="inline">is_list/1</code></a>, <a href="Kernel.xhtml#is_number/1"><code class="inline">is_number/1</code></a>, and the like)</li><li>functions that work on built-in data types (<a href="Kernel.xhtml#abs/1"><code class="inline">abs/1</code></a>, <a href="Kernel.xhtml#hd/1"><code class="inline">hd/1</code></a>, <a href="Kernel.xhtml#map_size/1"><code class="inline">map_size/1</code></a>, and others)</li><li>the <code class="inline">map.field</code> syntax</li></ul><p>The module <a href="Bitwise.xhtml"><code class="inline">Bitwise</code></a> also includes a handful of <a href="Bitwise.html#guards">Erlang bitwise operations as guards</a>.</p><p>Macros constructed out of any combination of the above guards are also valid guards - for example, <a href="Integer.xhtml#is_even/1"><code class="inline">Integer.is_even/1</code></a>. For more information, see the &quot;Custom patterns and guards expressions&quot; section shown below.</p><h3 id="why-guards">Why guards</h3><p>Let's see an example of a guard used in a function clause:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">empty_map?</span><span class="p" data-group-id="7126508507-1">(</span><span class="n">map</span><span class="p" data-group-id="7126508507-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">map_size</span><span class="p" data-group-id="7126508507-2">(</span><span class="n">map</span><span class="p" data-group-id="7126508507-2">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">empty_map?</span><span class="p" data-group-id="7126508507-3">(</span><span class="n">map</span><span class="p" data-group-id="7126508507-3">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_map</span><span class="p" data-group-id="7126508507-4">(</span><span class="n">map</span><span class="p" data-group-id="7126508507-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">false</span></code></pre><p>Guards start with the <code class="inline">when</code> operator, followed by a guard expression. The clause will be executed if and only if the guard expression returns <code class="inline">true</code>. Multiple boolean conditions can be combined with the <a href="Kernel.xhtml#and/2"><code class="inline">and</code></a> and <a href="Kernel.xhtml#or/2"><code class="inline">or</code></a> operators.</p><p>Writing the <code class="inline">empty_map?/1</code> function by only using pattern matching would not be possible (as pattern matching on <code class="inline">%{}</code> would match <em>any</em> map, not only the empty ones).</p><h3 id="non-passing-guards">Non-passing guards</h3><p>A function clause will be executed if and only if its guard expression evaluates to <code class="inline">true</code>. If any other value is returned, the function clause will be skipped. In particular, guards have no concept of &quot;truthy&quot; or &quot;falsy&quot;.</p><p>For example, imagine a function that checks that the head of a list is not <code class="inline">nil</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">not_nil_head?</span><span class="p" data-group-id="3613430739-1">(</span><span class="p" data-group-id="3613430739-2">[</span><span class="n">head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="3613430739-2">]</span><span class="p" data-group-id="3613430739-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">not_nil_head?</span><span class="p" data-group-id="3613430739-3">(</span><span class="bp">_</span><span class="p" data-group-id="3613430739-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w">

</span><span class="n">not_nil_head?</span><span class="p" data-group-id="3613430739-4">(</span><span class="p" data-group-id="3613430739-5">[</span><span class="s">&quot;some_value&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;another_value&quot;</span><span class="p" data-group-id="3613430739-5">]</span><span class="p" data-group-id="3613430739-4">)</span><span class="w">
</span><span class="c1">#=&gt; false</span></code></pre><p>Even though the head of the list is not <code class="inline">nil</code>, the first clause for <code class="inline">not_nil_head?/1</code> fails because the expression does not evaluate to <code class="inline">true</code>, but to <code class="inline">&quot;some_value&quot;</code>, therefore triggering the second clause which returns <code class="inline">false</code>. To make the guard behave correctly, you must ensure that the guard evaluates to <code class="inline">true</code>, like so:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">not_nil_head?</span><span class="p" data-group-id="1528766546-1">(</span><span class="p" data-group-id="1528766546-2">[</span><span class="n">head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="1528766546-2">]</span><span class="p" data-group-id="1528766546-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">not_nil_head?</span><span class="p" data-group-id="1528766546-3">(</span><span class="bp">_</span><span class="p" data-group-id="1528766546-3">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w">

</span><span class="n">not_nil_head?</span><span class="p" data-group-id="1528766546-4">(</span><span class="p" data-group-id="1528766546-5">[</span><span class="s">&quot;some_value&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;another_value&quot;</span><span class="p" data-group-id="1528766546-5">]</span><span class="p" data-group-id="1528766546-4">)</span><span class="w">
</span><span class="c1">#=&gt; true</span></code></pre><h3 id="errors-in-guards">Errors in guards</h3><p>In guards, when functions would normally raise exceptions, they cause the guard to fail instead.</p><p>For example, the <a href="Kernel.xhtml#tuple_size/1"><code class="inline">tuple_size/1</code></a> function only works with tuples. If we use it with anything else, an argument error is raised:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">tuple_size</span><span class="p" data-group-id="2139010103-1">(</span><span class="s">&quot;hello&quot;</span><span class="p" data-group-id="2139010103-1">)</span><span class="w">
</span><span class="gt">** (ArgumentError) argument error</span></code></pre><p>However, when used in guards, the corresponding clause will fail to match instead of raising an error:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="k">case</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="w"> </span><span class="k" data-group-id="4715122138-1">do</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="n">something</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">tuple_size</span><span class="p" data-group-id="4715122138-2">(</span><span class="n">something</span><span class="p" data-group-id="4715122138-2">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">    </span><span class="ss">:worked</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="c">_anything_else</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">    </span><span class="ss">:failed</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="4715122138-1">end</span><span class="w">
</span><span class="ss">:failed</span></code></pre><p>In many cases, we can take advantage of this. In the code above, we used <a href="Kernel.xhtml#tuple_size/1"><code class="inline">tuple_size/1</code></a> to both check that the given value is a tuple <em>and</em> check its size (instead of using <code class="inline">is_tuple(something) and tuple_size(something) == 2</code>).</p><p>However, if your guard has multiple conditions, such as checking for tuples or maps, it is best to call type-check functions like <a href="Kernel.xhtml#is_tuple/1"><code class="inline">is_tuple/1</code></a> before <a href="Kernel.xhtml#tuple_size/1"><code class="inline">tuple_size/1</code></a>, otherwise the whole guard will fail if a tuple is not given. Alternatively, your function clause can use multiple guards as shown in the following section.</p><h3 id="multiple-guards-in-the-same-clause">Multiple guards in the same clause</h3><p>There exists an additional way to simplify a chain of <code class="inline">or</code> expressions in guards: Elixir supports writing &quot;multiple guards&quot; in the same clause. The following code:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">is_number_or_nil</span><span class="p" data-group-id="6147026410-1">(</span><span class="n">term</span><span class="p" data-group-id="6147026410-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="6147026410-2">(</span><span class="n">term</span><span class="p" data-group-id="6147026410-2">)</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">is_float</span><span class="p" data-group-id="6147026410-3">(</span><span class="n">term</span><span class="p" data-group-id="6147026410-3">)</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">is_nil</span><span class="p" data-group-id="6147026410-4">(</span><span class="n">term</span><span class="p" data-group-id="6147026410-4">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:maybe_number</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">is_number_or_nil</span><span class="p" data-group-id="6147026410-5">(</span><span class="c">_other</span><span class="p" data-group-id="6147026410-5">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:something_else</span></code></pre><p>can be alternatively written as:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">is_number_or_nil</span><span class="p" data-group-id="3956260858-1">(</span><span class="n">term</span><span class="p" data-group-id="3956260858-1">)</span><span class="w">
    </span><span class="ow">when</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="3956260858-2">(</span><span class="n">term</span><span class="p" data-group-id="3956260858-2">)</span><span class="w">
    </span><span class="ow">when</span><span class="w"> </span><span class="n">is_float</span><span class="p" data-group-id="3956260858-3">(</span><span class="n">term</span><span class="p" data-group-id="3956260858-3">)</span><span class="w">
    </span><span class="ow">when</span><span class="w"> </span><span class="n">is_nil</span><span class="p" data-group-id="3956260858-4">(</span><span class="n">term</span><span class="p" data-group-id="3956260858-4">)</span><span class="w"> </span><span class="k" data-group-id="3956260858-5">do</span><span class="w">
  </span><span class="ss">:maybe_number</span><span class="w">
</span><span class="k" data-group-id="3956260858-5">end</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">is_number_or_nil</span><span class="p" data-group-id="3956260858-6">(</span><span class="c">_other</span><span class="p" data-group-id="3956260858-6">)</span><span class="w"> </span><span class="k" data-group-id="3956260858-7">do</span><span class="w">
  </span><span class="ss">:something_else</span><span class="w">
</span><span class="k" data-group-id="3956260858-7">end</span></code></pre><p>If each guard expression always returns a boolean, the two forms are equivalent. However, recall that if any function call in a guard raises an exception, the entire guard fails. To illustrate this, the following function will not detect empty tuples:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Check</span><span class="w"> </span><span class="k" data-group-id="5494634453-1">do</span><span class="w">
  </span><span class="c1"># If given a tuple, map_size/1 will raise, and tuple_size/1 will not be evaluated</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">empty?</span><span class="p" data-group-id="5494634453-2">(</span><span class="n">val</span><span class="p" data-group-id="5494634453-2">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">map_size</span><span class="p" data-group-id="5494634453-3">(</span><span class="n">val</span><span class="p" data-group-id="5494634453-3">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">tuple_size</span><span class="p" data-group-id="5494634453-4">(</span><span class="n">val</span><span class="p" data-group-id="5494634453-4">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">empty?</span><span class="p" data-group-id="5494634453-5">(</span><span class="c">_val</span><span class="p" data-group-id="5494634453-5">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w">
</span><span class="k" data-group-id="5494634453-1">end</span><span class="w">

</span><span class="nc">Check</span><span class="o">.</span><span class="n">empty?</span><span class="p" data-group-id="5494634453-6">(</span><span class="p" data-group-id="5494634453-7">%{</span><span class="p" data-group-id="5494634453-7">}</span><span class="p" data-group-id="5494634453-6">)</span><span class="w">
</span><span class="c1">#=&gt; true</span><span class="w">

</span><span class="nc">Check</span><span class="o">.</span><span class="n">empty?</span><span class="p" data-group-id="5494634453-8">(</span><span class="p" data-group-id="5494634453-9">{</span><span class="p" data-group-id="5494634453-9">}</span><span class="p" data-group-id="5494634453-8">)</span><span class="w">
</span><span class="c1">#=&gt; false # true was expected!</span></code></pre><p>This could be corrected by ensuring that no exception is raised, either via type checks like <code class="inline">is_map(val) and map_size(val) == 0</code>, or by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Check</span><span class="w"> </span><span class="k" data-group-id="8361010034-1">do</span><span class="w">
  </span><span class="c1"># If given a tuple, map_size/1 will raise, and the second guard will be evaluated</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">empty?</span><span class="p" data-group-id="8361010034-2">(</span><span class="n">val</span><span class="p" data-group-id="8361010034-2">)</span><span class="w">
      </span><span class="ow">when</span><span class="w"> </span><span class="n">map_size</span><span class="p" data-group-id="8361010034-3">(</span><span class="n">val</span><span class="p" data-group-id="8361010034-3">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w">
      </span><span class="ow">when</span><span class="w"> </span><span class="n">tuple_size</span><span class="p" data-group-id="8361010034-4">(</span><span class="n">val</span><span class="p" data-group-id="8361010034-4">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
      </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">empty?</span><span class="p" data-group-id="8361010034-5">(</span><span class="c">_val</span><span class="p" data-group-id="8361010034-5">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w">
</span><span class="k" data-group-id="8361010034-1">end</span><span class="w">

</span><span class="nc">Check</span><span class="o">.</span><span class="n">empty?</span><span class="p" data-group-id="8361010034-6">(</span><span class="p" data-group-id="8361010034-7">%{</span><span class="p" data-group-id="8361010034-7">}</span><span class="p" data-group-id="8361010034-6">)</span><span class="w">
</span><span class="c1">#=&gt; true</span><span class="w">

</span><span class="nc">Check</span><span class="o">.</span><span class="n">empty?</span><span class="p" data-group-id="8361010034-8">(</span><span class="p" data-group-id="8361010034-9">{</span><span class="p" data-group-id="8361010034-9">}</span><span class="p" data-group-id="8361010034-8">)</span><span class="w">
</span><span class="c1">#=&gt; true</span></code></pre><h2 id="where-patterns-and-guards-can-be-used">Where patterns and guards can be used</h2><p>In the examples above, we have used the match operator (<a href="Kernel.SpecialForms.xhtml#=/2"><code class="inline">=</code></a>) and function clauses to showcase patterns and guards respectively. Here is the list of the built-in constructs in Elixir that support patterns and guards.</p><ul><li><p><a href="Kernel.xhtml#match?/2"><code class="inline">match?/2</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="n">match?</span><span class="p" data-group-id="1827126543-1">(</span><span class="p" data-group-id="1827126543-2">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="1827126543-2">}</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1827126543-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p" data-group-id="1827126543-3">}</span><span class="p" data-group-id="1827126543-1">)</span></code></pre></li><li><p>function clauses:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">type</span><span class="p" data-group-id="5369055898-1">(</span><span class="n">term</span><span class="p" data-group-id="5369055898-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="5369055898-2">(</span><span class="n">term</span><span class="p" data-group-id="5369055898-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:integer</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">type</span><span class="p" data-group-id="5369055898-3">(</span><span class="n">term</span><span class="p" data-group-id="5369055898-3">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_float</span><span class="p" data-group-id="5369055898-4">(</span><span class="n">term</span><span class="p" data-group-id="5369055898-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="ss">:float</span></code></pre></li><li><p><a href="Kernel.SpecialForms.xhtml#case/2"><code class="inline">case</code></a> expressions:</p><pre><code class="makeup elixir" translate="no"><span class="k">case</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k" data-group-id="9466730200-1">do</span><span class="w">
  </span><span class="mi">1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:one</span><span class="w">
  </span><span class="mi">2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:two</span><span class="w">
  </span><span class="n">n</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="9466730200-2">(</span><span class="n">n</span><span class="p" data-group-id="9466730200-2">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="ss">:larger_than_two</span><span class="w">
</span><span class="k" data-group-id="9466730200-1">end</span></code></pre></li><li><p>anonymous functions (<code class="inline">fn/1</code>):</p><pre><code class="makeup elixir" translate="no"><span class="n">larger_than_two?</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="0686608378-1">fn</span><span class="w">
  </span><span class="n">n</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="0686608378-2">(</span><span class="n">n</span><span class="p" data-group-id="0686608378-2">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="n">n</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="0686608378-3">(</span><span class="n">n</span><span class="p" data-group-id="0686608378-3">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
</span><span class="k" data-group-id="0686608378-1">end</span></code></pre></li><li><p><a href="Kernel.SpecialForms.xhtml#for/1"><code class="inline">for</code></a> and <a href="Kernel.SpecialForms.xhtml#with/1"><code class="inline">with</code></a> support patterns and guards on the left side of <code class="inline">&lt;-</code>:</p><pre><code class="makeup elixir" translate="no"><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="p" data-group-id="9217190330-1">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">4</span><span class="p" data-group-id="9217190330-1">]</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">x</span></code></pre><p><code class="inline">with</code> also supports the <code class="inline">else</code> keyword, which supports patterns matching and guards.</p></li><li><p><a href="Kernel.SpecialForms.xhtml#try/1"><code class="inline">try</code></a> supports patterns and guards on <code class="inline">catch</code> and <code class="inline">else</code></p></li><li><p><a href="Kernel.SpecialForms.xhtml#receive/1"><code class="inline">receive</code></a> supports patterns and guards to match on the received messages.</p></li><li><p>custom guards can also be defined with <a href="Kernel.xhtml#defguard/1"><code class="inline">defguard/1</code></a> and <a href="Kernel.xhtml#defguardp/1"><code class="inline">defguardp/1</code></a>. A custom guard can only be defined based on existing guards.</p></li></ul><p>Note that the match operator (<a href="Kernel.SpecialForms.xhtml#=/2"><code class="inline">=</code></a>) does <em>not</em> support guards:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="5790770885-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">binary</span><span class="p" data-group-id="5790770885-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">File</span><span class="o">.</span><span class="n">read</span><span class="p" data-group-id="5790770885-2">(</span><span class="s">&quot;some/file&quot;</span><span class="p" data-group-id="5790770885-2">)</span></code></pre><h2 id="custom-patterns-and-guards-expressions">Custom patterns and guards expressions</h2><p>Only the constructs listed in this page are allowed in patterns and guards. However, we can take advantage of macros to write custom patterns guards that can simplify our programs or make them more domain-specific. At the end of the day, what matters is that the <em>output</em> of the macros boils down to a combination of the constructs above.</p><p>For example, the <a href="Record.xhtml"><code class="inline">Record</code></a> module in Elixir provides a series of macros to be used in patterns and guards that allows tuples to have named fields during compilation.</p><p>For defining your own guards, Elixir even provides conveniences in <code class="inline">defguard</code> and <code class="inline">defguardp</code>. Let's look at a quick case study: we want to check whether an argument is an even or an odd integer. With pattern matching this is impossible because there is an infinite number of integers, and therefore we can't pattern match on every single one of them. Therefore we must use guards. We will just focus on checking for even numbers since checking for the odd ones is almost identical.</p><p>Such a guard would look like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">my_function</span><span class="p" data-group-id="4704661614-1">(</span><span class="n">number</span><span class="p" data-group-id="4704661614-1">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="4704661614-2">(</span><span class="n">number</span><span class="p" data-group-id="4704661614-2">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">rem</span><span class="p" data-group-id="4704661614-3">(</span><span class="n">number</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="4704661614-3">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k" data-group-id="4704661614-4">do</span><span class="w">
  </span><span class="c1"># do stuff</span><span class="w">
</span><span class="k" data-group-id="4704661614-4">end</span></code></pre><p>It would be repetitive to write every time we need this check. Instead, you can use <a href="Kernel.xhtml#defguard/1"><code class="inline">defguard/1</code></a> and <a href="Kernel.xhtml#defguardp/1"><code class="inline">defguardp/1</code></a> to create guard macros. Here's an example how:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyInteger</span><span class="w"> </span><span class="k" data-group-id="8925363772-1">do</span><span class="w">
  </span><span class="kd">defguard</span><span class="w"> </span><span class="nf">is_even</span><span class="p" data-group-id="8925363772-2">(</span><span class="n">term</span><span class="p" data-group-id="8925363772-2">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_integer</span><span class="p" data-group-id="8925363772-3">(</span><span class="n">term</span><span class="p" data-group-id="8925363772-3">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">rem</span><span class="p" data-group-id="8925363772-4">(</span><span class="n">term</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="8925363772-4">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="k" data-group-id="8925363772-1">end</span></code></pre><p>and then:</p><pre><code class="makeup elixir" translate="no"><span class="kn">import</span><span class="w"> </span><span class="nc">MyInteger</span><span class="p">,</span><span class="w"> </span><span class="ss">only</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4423154996-1">[</span><span class="ss">is_even</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="4423154996-1">]</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">my_function</span><span class="p" data-group-id="4423154996-2">(</span><span class="n">number</span><span class="p" data-group-id="4423154996-2">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">is_even</span><span class="p" data-group-id="4423154996-3">(</span><span class="n">number</span><span class="p" data-group-id="4423154996-3">)</span><span class="w"> </span><span class="k" data-group-id="4423154996-4">do</span><span class="w">
  </span><span class="c1"># do stuff</span><span class="w">
</span><span class="k" data-group-id="4423154996-4">end</span></code></pre><p>While it's possible to create custom guards with macros, it's recommended to define them using <a href="Kernel.xhtml#defguard/1"><code class="inline">defguard/1</code></a> and <a href="Kernel.xhtml#defguardp/1"><code class="inline">defguardp/1</code></a> which perform additional compile-time checks.</p>

  </body>
</html>
