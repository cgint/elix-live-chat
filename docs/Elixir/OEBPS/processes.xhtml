<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Processes - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Processes</h1>
<p>In Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Processes are not only the basis for concurrency in Elixir, but they also provide the means for building distributed and fault-tolerant programs.</p><p>Elixir's processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (even compared to threads as used in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously.</p><p>In this chapter, we will learn about the basic constructs for spawning new processes, as well as sending and receiving messages between processes.</p><h2 id="spawning-processes">Spawning processes</h2><p>The basic mechanism for spawning new processes is the auto-imported <a href="Kernel.xhtml#spawn/1"><code class="inline">spawn/1</code></a> function:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">spawn</span><span class="p" data-group-id="6449242258-1">(</span><span class="k" data-group-id="6449242258-2">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k" data-group-id="6449242258-2">end</span><span class="p" data-group-id="6449242258-1">)</span><span class="w">
</span><span class="p" data-group-id="6449242258-3">#</span><span class="nc" data-group-id="6449242258-3">PID</span><span class="p" data-group-id="6449242258-3">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">43</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="6449242258-3">&gt;</span></code></pre><p><a href="Kernel.xhtml#spawn/1"><code class="inline">spawn/1</code></a> takes a function which it will execute in another process.</p><p>Notice <a href="Kernel.xhtml#spawn/1"><code class="inline">spawn/1</code></a> returns a PID (process identifier). At this point, the process you spawned is very likely dead. The spawned process will execute the given function and exit after the function is done:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spawn</span><span class="p" data-group-id="6971155566-1">(</span><span class="k" data-group-id="6971155566-2">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k" data-group-id="6971155566-2">end</span><span class="p" data-group-id="6971155566-1">)</span><span class="w">
</span><span class="p" data-group-id="6971155566-3">#</span><span class="nc" data-group-id="6971155566-3">PID</span><span class="p" data-group-id="6971155566-3">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">44</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="6971155566-3">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Process</span><span class="o">.</span><span class="n">alive?</span><span class="p" data-group-id="6971155566-4">(</span><span class="n">pid</span><span class="p" data-group-id="6971155566-4">)</span><span class="w">
</span><span class="no">false</span></code></pre><blockquote><p>Note: you will likely get different process identifiers than the ones we are showing in our snippets.</p></blockquote><p>We can retrieve the PID of the current process by calling <a href="Kernel.xhtml#self/0"><code class="inline">self/0</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">self</span><span class="p" data-group-id="6264347699-1">(</span><span class="p" data-group-id="6264347699-1">)</span><span class="w">
</span><span class="p" data-group-id="6264347699-2">#</span><span class="nc" data-group-id="6264347699-2">PID</span><span class="p" data-group-id="6264347699-2">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">41</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="6264347699-2">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Process</span><span class="o">.</span><span class="n">alive?</span><span class="p" data-group-id="6264347699-3">(</span><span class="n">self</span><span class="p" data-group-id="6264347699-4">(</span><span class="p" data-group-id="6264347699-4">)</span><span class="p" data-group-id="6264347699-3">)</span><span class="w">
</span><span class="no">true</span></code></pre><p>Processes get much more interesting when we are able to send and receive messages.</p><h2 id="sending-and-receiving-messages">Sending and receiving messages</h2><p>We can send messages to a process with <a href="Kernel.xhtml#send/2"><code class="inline">send/2</code></a> and receive them with <a href="Kernel.SpecialForms.xhtml#receive/1"><code class="inline">receive/1</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">send</span><span class="p" data-group-id="6319027420-1">(</span><span class="n">self</span><span class="p" data-group-id="6319027420-2">(</span><span class="p" data-group-id="6319027420-2">)</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6319027420-3">{</span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p" data-group-id="6319027420-3">}</span><span class="p" data-group-id="6319027420-1">)</span><span class="w">
</span><span class="p" data-group-id="6319027420-4">{</span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;world&quot;</span><span class="p" data-group-id="6319027420-4">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="6319027420-5">do</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="p" data-group-id="6319027420-6">{</span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p" data-group-id="6319027420-6">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">msg</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="p" data-group-id="6319027420-7">{</span><span class="ss">:world</span><span class="p">,</span><span class="w"> </span><span class="c">_msg</span><span class="p" data-group-id="6319027420-7">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;won&#39;t match&quot;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="6319027420-5">end</span><span class="w">
</span><span class="s">&quot;world&quot;</span></code></pre><p>When a message is sent to a process, the message is stored in the process mailbox. The <a href="Kernel.SpecialForms.xhtml#receive/1"><code class="inline">receive/1</code></a> block goes through the current process mailbox searching for a message that matches any of the given patterns. <a href="Kernel.SpecialForms.xhtml#receive/1"><code class="inline">receive/1</code></a> supports guards and many clauses, exactly as <a href="Kernel.SpecialForms.xhtml#case/2"><code class="inline">case/2</code></a>.</p><p>The process that sends the message does not block on <a href="Kernel.xhtml#send/2"><code class="inline">send/2</code></a>, it puts the message in the recipient's mailbox and continues. In particular, a process can send messages to itself.</p><p>If there is no message in the mailbox matching any of the patterns, the current process will wait until a matching message arrives. A timeout can also be specified:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="6989418409-1">do</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="p" data-group-id="6989418409-2">{</span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p" data-group-id="6989418409-2">}</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">msg</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="6989418409-1">after</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="mi">1_000</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;nothing after 1s&quot;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="6989418409-1">end</span><span class="w">
</span><span class="s">&quot;nothing after 1s&quot;</span></code></pre><p>A timeout of 0 can be given when you already expect the message to be in the mailbox.</p><p>Let's put it all together and send messages between processes:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">self</span><span class="p" data-group-id="4776190066-1">(</span><span class="p" data-group-id="4776190066-1">)</span><span class="w">
</span><span class="p" data-group-id="4776190066-2">#</span><span class="nc" data-group-id="4776190066-2">PID</span><span class="p" data-group-id="4776190066-2">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">41</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="4776190066-2">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">spawn</span><span class="p" data-group-id="4776190066-3">(</span><span class="k" data-group-id="4776190066-4">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">send</span><span class="p" data-group-id="4776190066-5">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4776190066-6">{</span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p" data-group-id="4776190066-7">(</span><span class="p" data-group-id="4776190066-7">)</span><span class="p" data-group-id="4776190066-6">}</span><span class="p" data-group-id="4776190066-5">)</span><span class="w"> </span><span class="k" data-group-id="4776190066-4">end</span><span class="p" data-group-id="4776190066-3">)</span><span class="w">
</span><span class="p" data-group-id="4776190066-8">#</span><span class="nc" data-group-id="4776190066-8">PID</span><span class="p" data-group-id="4776190066-8">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">48</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="4776190066-8">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="4776190066-9">do</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="p" data-group-id="4776190066-10">{</span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="4776190066-10">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Got hello from </span><span class="si" data-group-id="4776190066-11">#{</span><span class="n">inspect</span><span class="w"> </span><span class="n">pid</span><span class="si" data-group-id="4776190066-11">}</span><span class="s">&quot;</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="4776190066-9">end</span><span class="w">
</span><span class="s">&quot;Got hello from #PID&lt;0.48.0&gt;&quot;</span></code></pre><p>The <a href="Kernel.xhtml#inspect/1"><code class="inline">inspect/1</code></a> function is used to convert a data structure's internal representation into a string, typically for printing. Notice that when the <code class="inline">receive</code> block gets executed the sender process we have spawned may already be dead, as its only instruction was to send a message.</p><p>While in the shell, you may find the helper <code class="inline">flush/0</code> quite useful. It flushes and prints all the messages in the mailbox.</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">send</span><span class="p" data-group-id="6691152421-1">(</span><span class="n">self</span><span class="p" data-group-id="6691152421-2">(</span><span class="p" data-group-id="6691152421-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p" data-group-id="6691152421-1">)</span><span class="w">
</span><span class="ss">:hello</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">flush</span><span class="p" data-group-id="6691152421-3">(</span><span class="p" data-group-id="6691152421-3">)</span><span class="w">
</span><span class="ss">:hello</span><span class="w">
</span><span class="ss">:ok</span></code></pre><h2 id="links">Links</h2><p>The majority of times we spawn processes in Elixir, we spawn them as linked processes. Before we show an example with <a href="Kernel.xhtml#spawn_link/1"><code class="inline">spawn_link/1</code></a>, let's see what happens when a process started with <a href="Kernel.xhtml#spawn/1"><code class="inline">spawn/1</code></a> fails:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">spawn</span><span class="p" data-group-id="5561414867-1">(</span><span class="k" data-group-id="5561414867-2">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">raise</span><span class="w"> </span><span class="s">&quot;oops&quot;</span><span class="w"> </span><span class="k" data-group-id="5561414867-2">end</span><span class="p" data-group-id="5561414867-1">)</span><span class="w">
</span><span class="p" data-group-id="5561414867-3">#</span><span class="nc" data-group-id="5561414867-3">PID</span><span class="p" data-group-id="5561414867-3">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">58</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="5561414867-3">&gt;</span><span class="w">

</span><span class="p" data-group-id="5561414867-4">[</span><span class="n">error</span><span class="p" data-group-id="5561414867-4">]</span><span class="w"> </span><span class="nc">Process</span><span class="w"> </span><span class="p" data-group-id="5561414867-5">#</span><span class="nc" data-group-id="5561414867-5">PID</span><span class="p" data-group-id="5561414867-5">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">58</span><span class="o">.</span><span class="mi">00</span><span class="p" data-group-id="5561414867-5">&gt;</span><span class="w"> </span><span class="n">raised</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">exception</span><span class="w">
</span><span class="gt">** (RuntimeError) oops
    (stdlib) erl_eval.erl:668: :erl_eval.do_apply/6</span></code></pre><p>It merely logged an error but the parent process is still running. That's because processes are isolated. If we want the failure in one process to propagate to another one, we should link them. This can be done with <a href="Kernel.xhtml#spawn_link/1"><code class="inline">spawn_link/1</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">self</span><span class="p" data-group-id="3570501477-1">(</span><span class="p" data-group-id="3570501477-1">)</span><span class="w">
</span><span class="p" data-group-id="3570501477-2">#</span><span class="nc" data-group-id="3570501477-2">PID</span><span class="p" data-group-id="3570501477-2">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">41</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="3570501477-2">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">spawn_link</span><span class="p" data-group-id="3570501477-3">(</span><span class="k" data-group-id="3570501477-4">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">raise</span><span class="w"> </span><span class="s">&quot;oops&quot;</span><span class="w"> </span><span class="k" data-group-id="3570501477-4">end</span><span class="p" data-group-id="3570501477-3">)</span><span class="w">

</span><span class="gt">** (EXIT from #PID&lt;0.41.0&gt;) evaluator process exited with reason: an exception was raised:
    ** (RuntimeError) oops
        (stdlib) erl_eval.erl:668: :erl_eval.do_apply/6</span><span class="w">

</span><span class="p" data-group-id="3570501477-5">[</span><span class="n">error</span><span class="p" data-group-id="3570501477-5">]</span><span class="w"> </span><span class="nc">Process</span><span class="w"> </span><span class="p" data-group-id="3570501477-6">#</span><span class="nc" data-group-id="3570501477-6">PID</span><span class="p" data-group-id="3570501477-6">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">289</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="3570501477-6">&gt;</span><span class="w"> </span><span class="n">raised</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">exception</span><span class="w">
</span><span class="gt">** (RuntimeError) oops
    (stdlib) erl_eval.erl:668: :erl_eval.do_apply/6</span></code></pre><p>Because processes are linked, we now see a message saying the parent process, which is the shell process, has received an EXIT signal from another process causing the shell to terminate. IEx detects this situation and starts a new shell session.</p><p>Linking can also be done manually by calling <a href="Process.xhtml#link/1"><code class="inline">Process.link/1</code></a>. We recommend that you take a look at the <a href="Process.xhtml"><code class="inline">Process</code></a> module for other functionality provided by processes.</p><p>Processes and links play an important role when building fault-tolerant systems. Elixir processes are isolated and don't share anything by default. Therefore, a failure in a process will never crash or corrupt the state of another process. Links, however, allow processes to establish a relationship in case of failure. We often link our processes to supervisors which will detect when a process dies and start a new process in its place.</p><p>While other languages would require us to catch/handle exceptions, in Elixir we are actually fine with letting processes fail because we expect supervisors to properly restart our systems. &quot;Failing fast&quot; (sometimes referred as &quot;let it crash&quot;) is a common philosophy when writing Elixir software!</p><p><a href="Kernel.xhtml#spawn/1"><code class="inline">spawn/1</code></a> and <a href="Kernel.xhtml#spawn_link/1"><code class="inline">spawn_link/1</code></a> are the basic primitives for creating processes in Elixir. Although we have used them exclusively so far, most of the time we are going to use abstractions that build on top of them. Let's see the most common one, called tasks.</p><h2 id="tasks">Tasks</h2><p>Tasks build on top of the spawn functions to provide better error reports and introspection:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">Task</span><span class="o">.</span><span class="n">start</span><span class="p" data-group-id="1199498887-1">(</span><span class="k" data-group-id="1199498887-2">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">raise</span><span class="w"> </span><span class="s">&quot;oops&quot;</span><span class="w"> </span><span class="k" data-group-id="1199498887-2">end</span><span class="p" data-group-id="1199498887-1">)</span><span class="w">
</span><span class="p" data-group-id="1199498887-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1199498887-4">#</span><span class="nc" data-group-id="1199498887-4">PID</span><span class="p" data-group-id="1199498887-4">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">55</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="1199498887-4">&gt;</span><span class="p" data-group-id="1199498887-3">}</span><span class="w">

</span><span class="mi">15</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mf">33.046</span><span class="w"> </span><span class="p" data-group-id="1199498887-5">[</span><span class="n">error</span><span class="p" data-group-id="1199498887-5">]</span><span class="w"> </span><span class="nc">Task</span><span class="w"> </span><span class="p" data-group-id="1199498887-6">#</span><span class="nc" data-group-id="1199498887-6">PID</span><span class="p" data-group-id="1199498887-6">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">55</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="1199498887-6">&gt;</span><span class="w"> </span><span class="n">started</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="p" data-group-id="1199498887-7">#</span><span class="nc" data-group-id="1199498887-7">PID</span><span class="p" data-group-id="1199498887-7">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">53</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="1199498887-7">&gt;</span><span class="w"> </span><span class="n">terminating</span><span class="w">
</span><span class="gt">** (RuntimeError) oops
    (stdlib) erl_eval.erl:668: :erl_eval.do_apply/6
    (elixir) lib/task/supervised.ex:85: Task.Supervised.do_apply/2
    (stdlib) proc_lib.erl:247: :proc_lib.init_p_do_apply/3</span><span class="w">
</span><span class="ss">Function</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1199498887-8">#</span><span class="nc" data-group-id="1199498887-8">Function</span><span class="p" data-group-id="1199498887-8">&lt;</span><span class="mf">20.99386804</span><span class="o">/</span><span class="mi">0</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">:erl_eval</span><span class="o">.</span><span class="n">expr</span><span class="o">/</span><span class="mi">5</span><span class="p" data-group-id="1199498887-8">&gt;</span><span class="w">
    </span><span class="ss">Args</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1199498887-9">[</span><span class="p" data-group-id="1199498887-9">]</span></code></pre><p>Instead of <a href="Kernel.xhtml#spawn/1"><code class="inline">spawn/1</code></a> and <a href="Kernel.xhtml#spawn_link/1"><code class="inline">spawn_link/1</code></a>, we use <a href="Task.xhtml#start/1"><code class="inline">Task.start/1</code></a> and <a href="Task.xhtml#start_link/1"><code class="inline">Task.start_link/1</code></a> which return <code class="inline">{:ok, pid}</code> rather than just the PID. This is what enables tasks to be used in supervision trees. Furthermore, <a href="Task.xhtml"><code class="inline">Task</code></a> provides convenience functions, like <a href="Task.xhtml#async/1"><code class="inline">Task.async/1</code></a> and <a href="Task.xhtml#await/1"><code class="inline">Task.await/1</code></a>, and functionality to ease distribution.</p><p>We will explore tasks and other abstractions around processes in the <a href="introduction-to-mix.xhtml">&quot;Mix and OTP guide&quot;</a>.</p><h2 id="state">State</h2><p>We haven't talked about state so far. If you are building an application that requires state, for example, to keep your application configuration, or you need to parse a file and keep it in memory, where would you store it?</p><p>Processes are the most common answer to this question. We can write processes that loop infinitely, maintain state, and send and receive messages. As an example, let's write a module that starts new processes that work as a key-value store in a file named <code class="inline">kv.exs</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">KV</span><span class="w"> </span><span class="k" data-group-id="6324738606-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">start_link</span><span class="w"> </span><span class="k" data-group-id="6324738606-2">do</span><span class="w">
    </span><span class="nc">Task</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="6324738606-3">(</span><span class="k" data-group-id="6324738606-4">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">loop</span><span class="p" data-group-id="6324738606-5">(</span><span class="p" data-group-id="6324738606-6">%{</span><span class="p" data-group-id="6324738606-6">}</span><span class="p" data-group-id="6324738606-5">)</span><span class="w"> </span><span class="k" data-group-id="6324738606-4">end</span><span class="p" data-group-id="6324738606-3">)</span><span class="w">
  </span><span class="k" data-group-id="6324738606-2">end</span><span class="w">

  </span><span class="kd">defp</span><span class="w"> </span><span class="nf">loop</span><span class="p" data-group-id="6324738606-7">(</span><span class="n">map</span><span class="p" data-group-id="6324738606-7">)</span><span class="w"> </span><span class="k" data-group-id="6324738606-8">do</span><span class="w">
    </span><span class="k">receive</span><span class="w"> </span><span class="k" data-group-id="6324738606-9">do</span><span class="w">
      </span><span class="p" data-group-id="6324738606-10">{</span><span class="ss">:get</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">caller</span><span class="p" data-group-id="6324738606-10">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="n">send</span><span class="p" data-group-id="6324738606-11">(</span><span class="n">caller</span><span class="p">,</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">get</span><span class="p" data-group-id="6324738606-12">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p" data-group-id="6324738606-12">)</span><span class="p" data-group-id="6324738606-11">)</span><span class="w">
        </span><span class="n">loop</span><span class="p" data-group-id="6324738606-13">(</span><span class="n">map</span><span class="p" data-group-id="6324738606-13">)</span><span class="w">
      </span><span class="p" data-group-id="6324738606-14">{</span><span class="ss">:put</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="6324738606-14">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="n">loop</span><span class="p" data-group-id="6324738606-15">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="6324738606-16">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="6324738606-16">)</span><span class="p" data-group-id="6324738606-15">)</span><span class="w">
    </span><span class="k" data-group-id="6324738606-9">end</span><span class="w">
  </span><span class="k" data-group-id="6324738606-8">end</span><span class="w">
</span><span class="k" data-group-id="6324738606-1">end</span></code></pre><p>Note that the <code class="inline">start_link</code> function starts a new process that runs the <code class="inline">loop/1</code> function, starting with an empty map. The <code class="inline">loop/1</code> (private) function then waits for messages and performs the appropriate action for each message. We made <code class="inline">loop/1</code> private by using <code class="inline">defp</code> instead of <code class="inline">def</code>. In the case of a <code class="inline">:get</code> message, it sends a message back to the caller and calls <code class="inline">loop/1</code> again, to wait for a new message. While the <code class="inline">:put</code> message actually invokes <code class="inline">loop/1</code> with a new version of the map, with the given <code class="inline">key</code> and <code class="inline">value</code> stored.</p><p>Let's give it a try by running <code class="inline">iex kv.exs</code>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="1707801118-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="1707801118-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">KV</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="1707801118-2">(</span><span class="p" data-group-id="1707801118-2">)</span><span class="w">
</span><span class="p" data-group-id="1707801118-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1707801118-4">#</span><span class="nc" data-group-id="1707801118-4">PID</span><span class="p" data-group-id="1707801118-4">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">62</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="1707801118-4">&gt;</span><span class="p" data-group-id="1707801118-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">send</span><span class="p" data-group-id="1707801118-5">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1707801118-6">{</span><span class="ss">:get</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p" data-group-id="1707801118-7">(</span><span class="p" data-group-id="1707801118-7">)</span><span class="p" data-group-id="1707801118-6">}</span><span class="p" data-group-id="1707801118-5">)</span><span class="w">
</span><span class="p" data-group-id="1707801118-8">{</span><span class="ss">:get</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1707801118-9">#</span><span class="nc" data-group-id="1707801118-9">PID</span><span class="p" data-group-id="1707801118-9">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">41</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="1707801118-9">&gt;</span><span class="p" data-group-id="1707801118-8">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">flush</span><span class="p" data-group-id="1707801118-10">(</span><span class="p" data-group-id="1707801118-10">)</span><span class="w">
</span><span class="no">nil</span><span class="w">
</span><span class="ss">:ok</span></code></pre><p>At first, the process map has no keys, so sending a <code class="inline">:get</code> message and then flushing the current process inbox returns <code class="inline">nil</code>. Let's send a <code class="inline">:put</code> message and try it again:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">send</span><span class="p" data-group-id="2256771672-1">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2256771672-2">{</span><span class="ss">:put</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="ss">:world</span><span class="p" data-group-id="2256771672-2">}</span><span class="p" data-group-id="2256771672-1">)</span><span class="w">
</span><span class="p" data-group-id="2256771672-3">{</span><span class="ss">:put</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="ss">:world</span><span class="p" data-group-id="2256771672-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">send</span><span class="p" data-group-id="2256771672-4">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2256771672-5">{</span><span class="ss">:get</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p" data-group-id="2256771672-6">(</span><span class="p" data-group-id="2256771672-6">)</span><span class="p" data-group-id="2256771672-5">}</span><span class="p" data-group-id="2256771672-4">)</span><span class="w">
</span><span class="p" data-group-id="2256771672-7">{</span><span class="ss">:get</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2256771672-8">#</span><span class="nc" data-group-id="2256771672-8">PID</span><span class="p" data-group-id="2256771672-8">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">41</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="2256771672-8">&gt;</span><span class="p" data-group-id="2256771672-7">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">flush</span><span class="p" data-group-id="2256771672-9">(</span><span class="p" data-group-id="2256771672-9">)</span><span class="w">
</span><span class="ss">:world</span><span class="w">
</span><span class="ss">:ok</span></code></pre><p>Notice how the process is keeping a state and we can get and update this state by sending the process messages. In fact, any process that knows the <code class="inline">pid</code> above will be able to send it messages and manipulate the state.</p><p>It is also possible to register the <code class="inline">pid</code>, giving it a name, and allowing everyone that knows the name to send it messages:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">Process</span><span class="o">.</span><span class="n">register</span><span class="p" data-group-id="2881044200-1">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="ss">:kv</span><span class="p" data-group-id="2881044200-1">)</span><span class="w">
</span><span class="no">true</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">send</span><span class="p" data-group-id="2881044200-2">(</span><span class="ss">:kv</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2881044200-3">{</span><span class="ss">:get</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p" data-group-id="2881044200-4">(</span><span class="p" data-group-id="2881044200-4">)</span><span class="p" data-group-id="2881044200-3">}</span><span class="p" data-group-id="2881044200-2">)</span><span class="w">
</span><span class="p" data-group-id="2881044200-5">{</span><span class="ss">:get</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2881044200-6">#</span><span class="nc" data-group-id="2881044200-6">PID</span><span class="p" data-group-id="2881044200-6">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">41</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="2881044200-6">&gt;</span><span class="p" data-group-id="2881044200-5">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">flush</span><span class="p" data-group-id="2881044200-7">(</span><span class="p" data-group-id="2881044200-7">)</span><span class="w">
</span><span class="ss">:world</span><span class="w">
</span><span class="ss">:ok</span></code></pre><p>Using processes to maintain state and name registration are very common patterns in Elixir applications. However, most of the time, we won't implement those patterns manually as above, but by using one of the many abstractions that ship with Elixir. For example, Elixir provides <a href="Agent.xhtml"><code class="inline">Agent</code></a>s, which are simple abstractions around state. Our code above could be directly written as:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="0960403368-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="0960403368-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Agent</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="0960403368-2">(</span><span class="k" data-group-id="0960403368-3">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="0960403368-4">%{</span><span class="p" data-group-id="0960403368-4">}</span><span class="w"> </span><span class="k" data-group-id="0960403368-3">end</span><span class="p" data-group-id="0960403368-2">)</span><span class="w">
</span><span class="p" data-group-id="0960403368-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0960403368-6">#</span><span class="nc" data-group-id="0960403368-6">PID</span><span class="p" data-group-id="0960403368-6">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">72</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="0960403368-6">&gt;</span><span class="p" data-group-id="0960403368-5">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Agent</span><span class="o">.</span><span class="n">update</span><span class="p" data-group-id="0960403368-7">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="0960403368-8">fn</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="0960403368-9">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p">,</span><span class="w"> </span><span class="ss">:world</span><span class="p" data-group-id="0960403368-9">)</span><span class="w"> </span><span class="k" data-group-id="0960403368-8">end</span><span class="p" data-group-id="0960403368-7">)</span><span class="w">
</span><span class="ss">:ok</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Agent</span><span class="o">.</span><span class="n">get</span><span class="p" data-group-id="0960403368-10">(</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="0960403368-11">fn</span><span class="w"> </span><span class="n">map</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">get</span><span class="p" data-group-id="0960403368-12">(</span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="ss">:hello</span><span class="p" data-group-id="0960403368-12">)</span><span class="w"> </span><span class="k" data-group-id="0960403368-11">end</span><span class="p" data-group-id="0960403368-10">)</span><span class="w">
</span><span class="ss">:world</span></code></pre><p>A <code class="inline">:name</code> option could also be given to <a href="Agent.xhtml#start_link/2"><code class="inline">Agent.start_link/2</code></a> and it would be automatically registered. Besides agents, Elixir provides an API for building generic servers (called <a href="GenServer.xhtml"><code class="inline">GenServer</code></a>), registries, and more, all powered by processes underneath. Those, along with supervision trees, will be explored with more detail in the <a href="introduction-to-mix.xhtml">&quot;Mix and OTP guide&quot;</a>, which will build a complete Elixir application from start to finish.</p><p>For now, let's move on and explore the world of I/O in Elixir.</p>

  </body>
</html>
