<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Meta-programming anti-patterns - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Meta-programming anti-patterns</h1>
<p>This document outlines potential anti-patterns related to meta-programming.</p><h2 id="compile-time-dependencies">Compile-time dependencies</h2><h4>Problem</h4><p>This anti-pattern is related to dependencies between files in Elixir. Because macros are used at compile-time, the use of any macro in Elixir adds a compile-time dependency to the module that defines the macro.</p><p>However, when macros are used in the body of a module, the arguments to the macro themselves may become compile-time dependencies. These dependencies may lead to dependency graphs where changing a single file causes several files to be recompiled.</p><h4>Example</h4><p>Let's take the <a href="https://github.com/elixir-plug/plug"><code class="inline">Plug</code></a> library as an example. The <code class="inline">Plug</code> project allows you specify several modules, also known as plugs, which will be invoked whenever there is a request. As a user of <code class="inline">Plug</code>, you would use it as follows:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp</span><span class="w"> </span><span class="k" data-group-id="2580206639-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Plug.Builder</span><span class="w">

  </span><span class="n">plug</span><span class="w"> </span><span class="nc">MyApp.Authentication</span><span class="w">
</span><span class="k" data-group-id="2580206639-1">end</span></code></pre><p>And imagine <code class="inline">Plug</code> has the following definitions of the macros above (simplified):</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Plug.Builder</span><span class="w"> </span><span class="k" data-group-id="9876627573-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">__using__</span><span class="p" data-group-id="9876627573-2">(</span><span class="c">_opts</span><span class="p" data-group-id="9876627573-2">)</span><span class="w"> </span><span class="k" data-group-id="9876627573-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9876627573-4">do</span><span class="w">
      </span><span class="nc">Module</span><span class="o">.</span><span class="n">register_attribute</span><span class="p" data-group-id="9876627573-5">(</span><span class="bp">__MODULE__</span><span class="p">,</span><span class="w"> </span><span class="ss">:plugs</span><span class="p">,</span><span class="w"> </span><span class="ss">accumulate</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9876627573-5">)</span><span class="w">
      </span><span class="na">@before_compile</span><span class="w"> </span><span class="nc">Plug.Builder</span><span class="w">
    </span><span class="k" data-group-id="9876627573-4">end</span><span class="w">
  </span><span class="k" data-group-id="9876627573-3">end</span><span class="w">

  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">plug</span><span class="p" data-group-id="9876627573-6">(</span><span class="n">mod</span><span class="p" data-group-id="9876627573-6">)</span><span class="w"> </span><span class="k" data-group-id="9876627573-7">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="9876627573-8">do</span><span class="w">
      </span><span class="na">@plugs</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="9876627573-9">(</span><span class="n">mod</span><span class="p" data-group-id="9876627573-9">)</span><span class="w">
    </span><span class="k" data-group-id="9876627573-8">end</span><span class="w">
  </span><span class="k" data-group-id="9876627573-7">end</span><span class="w">

  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="9876627573-1">end</span></code></pre><p>The implementation accumulates all modules inside the <code class="inline">@plugs</code> module attribute. Right before the module is compiled, <code class="inline">Plug.Builder</code> will reads all modules stored in <code class="inline">@plugs</code> and compile them into a function, like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">call</span><span class="p" data-group-id="5139804289-1">(</span><span class="n">conn</span><span class="p">,</span><span class="w"> </span><span class="c">_opts</span><span class="p" data-group-id="5139804289-1">)</span><span class="w"> </span><span class="k" data-group-id="5139804289-2">do</span><span class="w">
  </span><span class="nc">MyApp.Authentication</span><span class="o">.</span><span class="n">call</span><span class="p" data-group-id="5139804289-3">(</span><span class="n">conn</span><span class="p" data-group-id="5139804289-3">)</span><span class="w">
</span><span class="k" data-group-id="5139804289-2">end</span></code></pre><p>The trouble with the code above is that, because the <code class="inline">plug MyApp.Authentication</code> was invoked at compile-time, the module <code class="inline">MyApp.Authentication</code> is now a compile-time dependency of <code class="inline">MyApp</code>, even though <code class="inline">MyApp.Authentication</code> is never used at compile-time. If <code class="inline">MyApp.Authentication</code> depends on other modules, even at runtime, this can now lead to a large recompilation graph in case of changes.</p><h4>Refactoring</h4><p>To address this anti-pattern, a macro can expand literals within the context they are meant to be used, as follows:</p><pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">plug</span><span class="p" data-group-id="2156663586-1">(</span><span class="n">mod</span><span class="p" data-group-id="2156663586-1">)</span><span class="w"> </span><span class="k" data-group-id="2156663586-2">do</span><span class="w">
    </span><span class="n">mod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">expand_literals</span><span class="p" data-group-id="2156663586-3">(</span><span class="n">mod</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2156663586-4">%{</span><span class="bp">__CALLER__</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="ss">function</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2156663586-5">{</span><span class="ss">:call</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2156663586-5">}</span><span class="p" data-group-id="2156663586-4">}</span><span class="p" data-group-id="2156663586-3">)</span><span class="w">

    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="2156663586-6">do</span><span class="w">
      </span><span class="na">@plugs</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="2156663586-7">(</span><span class="n">mod</span><span class="p" data-group-id="2156663586-7">)</span><span class="w">
    </span><span class="k" data-group-id="2156663586-6">end</span><span class="w">
  </span><span class="k" data-group-id="2156663586-2">end</span></code></pre><p>In the example above, since <code class="inline">mod</code> is used only within the <code class="inline">call/2</code> function, we prematurely expand module reference as if it was inside the <code class="inline">call/2</code> function. Now <code class="inline">MyApp.Authentication</code> is only a runtime dependency of <code class="inline">MyApp</code>, no longer a compile-time one.</p><p>Note, however, the above must only be done if your macros do not attempt to invoke any function, access any struct, or any other metadata of the module at compile-time. If you interact with the module given to a macro anywhere outside of definition of a function, then you effectively have a compile-time dependency. And, even though you generally want to avoid them, it is not always possible.</p><p>In actual projects, developers may use <code class="inline">mix xref trace path/to/file.ex</code> to execute a file and have it print information about which modules it depends on, and if those modules are compile-time, runtime, or export dependencies. See <a href="https://hexdocs.pm/mix/Mix.Tasks.Xref.html"><code class="inline">mix xref</code></a> for more information.</p><h2 id="large-code-generation">Large code generation</h2><h4>Problem</h4><p>This anti-pattern is related to macros that generate too much code. When a macro generates a large amount of code, it impacts how the compiler and/or the runtime work. The reason for this is that Elixir may have to expand, compile, and execute the code multiple times, which will make compilation slower and the resulting compiled artifacts larger.</p><h4>Example</h4><p>Imagine you are defining a router for a web application, where you could have macros like <code class="inline">get/2</code>. On every invocation of the macro (which could be hundreds), the code inside <code class="inline">get/2</code> will be expanded and compiled, which can generate a large volume of code overall.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Routes</span><span class="w"> </span><span class="k" data-group-id="2302497536-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="2302497536-2">(</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p" data-group-id="2302497536-2">)</span><span class="w"> </span><span class="k" data-group-id="2302497536-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="2302497536-4">do</span><span class="w">
      </span><span class="n">route</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="2302497536-5">(</span><span class="n">route</span><span class="p" data-group-id="2302497536-5">)</span><span class="w">
      </span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="2302497536-6">(</span><span class="n">handler</span><span class="p" data-group-id="2302497536-6">)</span><span class="w">

      </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">is_binary</span><span class="p" data-group-id="2302497536-7">(</span><span class="n">route</span><span class="p" data-group-id="2302497536-7">)</span><span class="w"> </span><span class="k" data-group-id="2302497536-8">do</span><span class="w">
        </span><span class="k">raise</span><span class="w"> </span><span class="nc">ArgumentError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;route must be a binary&quot;</span><span class="w">
      </span><span class="k" data-group-id="2302497536-8">end</span><span class="w">

      </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">is_atom</span><span class="p" data-group-id="2302497536-9">(</span><span class="n">handler</span><span class="p" data-group-id="2302497536-9">)</span><span class="w"> </span><span class="k" data-group-id="2302497536-10">do</span><span class="w">
        </span><span class="k">raise</span><span class="w"> </span><span class="nc">ArgumentError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;handler must be a module&quot;</span><span class="w">
      </span><span class="k" data-group-id="2302497536-10">end</span><span class="w">

      </span><span class="na">@store_route_for_compilation</span><span class="w"> </span><span class="p" data-group-id="2302497536-11">{</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p" data-group-id="2302497536-11">}</span><span class="w">
    </span><span class="k" data-group-id="2302497536-4">end</span><span class="w">
  </span><span class="k" data-group-id="2302497536-3">end</span><span class="w">
</span><span class="k" data-group-id="2302497536-1">end</span></code></pre><h4>Refactoring</h4><p>To remove this anti-pattern, the developer should simplify the macro, delegating part of its work to other functions. As shown below, by encapsulating the code inside <code class="inline">quote/1</code> inside the function <code class="inline">__define__/3</code> instead, we reduce the code that is expanded and compiled on every invocation of the macro, and instead we dispatch to a function to do the bulk of the work.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Routes</span><span class="w"> </span><span class="k" data-group-id="8795174161-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">get</span><span class="p" data-group-id="8795174161-2">(</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p" data-group-id="8795174161-2">)</span><span class="w"> </span><span class="k" data-group-id="8795174161-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8795174161-4">do</span><span class="w">
      </span><span class="nc">Routes</span><span class="o">.</span><span class="c">__define__</span><span class="p" data-group-id="8795174161-5">(</span><span class="bp">__MODULE__</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="8795174161-6">(</span><span class="n">route</span><span class="p" data-group-id="8795174161-6">)</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="8795174161-7">(</span><span class="n">handler</span><span class="p" data-group-id="8795174161-7">)</span><span class="p" data-group-id="8795174161-5">)</span><span class="w">
    </span><span class="k" data-group-id="8795174161-4">end</span><span class="w">
  </span><span class="k" data-group-id="8795174161-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">__define__</span><span class="p" data-group-id="8795174161-8">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p" data-group-id="8795174161-8">)</span><span class="w"> </span><span class="k" data-group-id="8795174161-9">do</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">is_binary</span><span class="p" data-group-id="8795174161-10">(</span><span class="n">route</span><span class="p" data-group-id="8795174161-10">)</span><span class="w"> </span><span class="k" data-group-id="8795174161-11">do</span><span class="w">
      </span><span class="k">raise</span><span class="w"> </span><span class="nc">ArgumentError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;route must be a binary&quot;</span><span class="w">
    </span><span class="k" data-group-id="8795174161-11">end</span><span class="w">

    </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">is_atom</span><span class="p" data-group-id="8795174161-12">(</span><span class="n">handler</span><span class="p" data-group-id="8795174161-12">)</span><span class="w"> </span><span class="k" data-group-id="8795174161-13">do</span><span class="w">
      </span><span class="k">raise</span><span class="w"> </span><span class="nc">ArgumentError</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;handler must be a module&quot;</span><span class="w">
    </span><span class="k" data-group-id="8795174161-13">end</span><span class="w">

    </span><span class="nc">Module</span><span class="o">.</span><span class="n">put_attribute</span><span class="p" data-group-id="8795174161-14">(</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="ss">:store_route_for_compilation</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8795174161-15">{</span><span class="n">route</span><span class="p">,</span><span class="w"> </span><span class="n">handler</span><span class="p" data-group-id="8795174161-15">}</span><span class="p" data-group-id="8795174161-14">)</span><span class="w">
  </span><span class="k" data-group-id="8795174161-9">end</span><span class="w">
</span><span class="k" data-group-id="8795174161-1">end</span></code></pre><h2 id="unnecessary-macros">Unnecessary macros</h2><h4>Problem</h4><p><em>Macros</em> are powerful meta-programming mechanisms that can be used in Elixir to extend the language. While using macros is not an anti-pattern in itself, this meta-programming mechanism should only be used when absolutely necessary. Whenever a macro is used, but it would have been possible to solve the same problem using functions or other existing Elixir structures, the code becomes unnecessarily more complex and less readable. Because macros are more difficult to implement and reason about, their indiscriminate use can compromise the evolution of a system, reducing its maintainability.</p><h4>Example</h4><p>The <code class="inline">MyMath</code> module implements the <code class="inline">sum/2</code> macro to perform the sum of two numbers received as parameters. While this code has no syntax errors and can be executed correctly to get the desired result, it is unnecessarily more complex. By implementing this functionality as a macro rather than a conventional function, the code became less clear:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyMath</span><span class="w"> </span><span class="k" data-group-id="5451701190-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">sum</span><span class="p" data-group-id="5451701190-2">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p" data-group-id="5451701190-2">)</span><span class="w"> </span><span class="k" data-group-id="5451701190-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5451701190-4">do</span><span class="w">
      </span><span class="k">unquote</span><span class="p" data-group-id="5451701190-5">(</span><span class="n">v1</span><span class="p" data-group-id="5451701190-5">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="5451701190-6">(</span><span class="n">v2</span><span class="p" data-group-id="5451701190-6">)</span><span class="w">
    </span><span class="k" data-group-id="5451701190-4">end</span><span class="w">
  </span><span class="k" data-group-id="5451701190-3">end</span><span class="w">
</span><span class="k" data-group-id="5451701190-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="kn">require</span><span class="w"> </span><span class="nc">MyMath</span><span class="w">
</span><span class="nc">MyMath</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">MyMath</span><span class="o">.</span><span class="n">sum</span><span class="p" data-group-id="0577234936-1">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="0577234936-1">)</span><span class="w">
</span><span class="mi">8</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">MyMath</span><span class="o">.</span><span class="n">sum</span><span class="p" data-group-id="0577234936-2">(</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">6</span><span class="p" data-group-id="0577234936-2">)</span><span class="w">
</span><span class="mi">15</span></code></pre><h4>Refactoring</h4><p>To remove this anti-pattern, the developer must replace the unnecessary macro with structures that are simpler to write and understand, such as named functions. The code shown below is the result of the refactoring of the previous example. Basically, the <code class="inline">sum/2</code> macro has been transformed into a conventional named function. Note that the <a href="Kernel.SpecialForms.xhtml#require/2"><code class="inline">require/2</code></a> call is no longer needed:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyMath</span><span class="w"> </span><span class="k" data-group-id="4581280168-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">sum</span><span class="p" data-group-id="4581280168-2">(</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p" data-group-id="4581280168-2">)</span><span class="w"> </span><span class="k" data-group-id="4581280168-3">do</span><span class="w"> </span><span class="c1"># &lt;= The macro became a named function</span><span class="w">
    </span><span class="n">v1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">v2</span><span class="w">
  </span><span class="k" data-group-id="4581280168-3">end</span><span class="w">
</span><span class="k" data-group-id="4581280168-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">MyMath</span><span class="o">.</span><span class="n">sum</span><span class="p" data-group-id="8932456706-1">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p" data-group-id="8932456706-1">)</span><span class="w">
</span><span class="mi">8</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">MyMath</span><span class="o">.</span><span class="n">sum</span><span class="p" data-group-id="8932456706-2">(</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="o">+</span><span class="mi">6</span><span class="p" data-group-id="8932456706-2">)</span><span class="w">
</span><span class="mi">15</span></code></pre><h2 id="use-instead-of-import"><code class="inline">use</code> instead of <code class="inline">import</code></h2><h4>Problem</h4><p>Elixir has mechanisms such as <code class="inline">import/1</code>, <code class="inline">alias/1</code>, and <a href="Kernel.xhtml#use/1"><code class="inline">use/1</code></a> to establish dependencies between modules. Code implemented with these mechanisms does not characterize a smell by itself. However, while the <code class="inline">import/1</code> and <code class="inline">alias/1</code> directives have lexical scope and only facilitate a module calling functions of another, the <a href="Kernel.xhtml#use/1"><code class="inline">use/1</code></a> directive has a <em>broader scope</em>, which can be problematic.</p><p>The <a href="Kernel.xhtml#use/1"><code class="inline">use/1</code></a> directive allows a module to inject any type of code into another, including propagating dependencies. In this way, using the <a href="Kernel.xhtml#use/1"><code class="inline">use/1</code></a> directive makes code harder to read, because to understand exactly what will happen when it references a module, it is necessary to have knowledge of the internal details of the referenced module.</p><h4>Example</h4><p>The code shown below is an example of this anti-pattern. It defines three modules -- <code class="inline">ModuleA</code>, <code class="inline">Library</code>, and <code class="inline">ClientApp</code>. <code class="inline">ClientApp</code> is reusing code from the <code class="inline">Library</code> via the <a href="Kernel.xhtml#use/1"><code class="inline">use/1</code></a> directive, but is unaware of its internal details. This makes it harder for the author of <code class="inline">ClientApp</code> to visualize which modules and functionality are now available within its module. To make matters worse, <code class="inline">Library</code> also imports <code class="inline">ModuleA</code>, which defines a <code class="inline">foo/0</code> function that conflicts with a local function defined in <code class="inline">ClientApp</code>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">ModuleA</span><span class="w"> </span><span class="k" data-group-id="4433421999-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="k" data-group-id="4433421999-2">do</span><span class="w">
    </span><span class="s">&quot;From Module A&quot;</span><span class="w">
  </span><span class="k" data-group-id="4433421999-2">end</span><span class="w">
</span><span class="k" data-group-id="4433421999-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Library</span><span class="w"> </span><span class="k" data-group-id="0273675884-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">__using__</span><span class="p" data-group-id="0273675884-2">(</span><span class="c">_opts</span><span class="p" data-group-id="0273675884-2">)</span><span class="w"> </span><span class="k" data-group-id="0273675884-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="0273675884-4">do</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">Library</span><span class="w">
      </span><span class="kn">import</span><span class="w"> </span><span class="nc">ModuleA</span><span class="w">  </span><span class="c1"># &lt;= propagating dependencies!</span><span class="w">
    </span><span class="k" data-group-id="0273675884-4">end</span><span class="w">
  </span><span class="k" data-group-id="0273675884-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">from_lib</span><span class="w"> </span><span class="k" data-group-id="0273675884-5">do</span><span class="w">
    </span><span class="s">&quot;From Library&quot;</span><span class="w">
  </span><span class="k" data-group-id="0273675884-5">end</span><span class="w">
</span><span class="k" data-group-id="0273675884-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">ClientApp</span><span class="w"> </span><span class="k" data-group-id="8994069990-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Library</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="k" data-group-id="8994069990-2">do</span><span class="w">
    </span><span class="s">&quot;Local function from client app&quot;</span><span class="w">
  </span><span class="k" data-group-id="8994069990-2">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">from_client_app</span><span class="w"> </span><span class="k" data-group-id="8994069990-3">do</span><span class="w">
    </span><span class="n">from_lib</span><span class="p" data-group-id="8994069990-4">(</span><span class="p" data-group-id="8994069990-4">)</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s">&quot; - &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">foo</span><span class="p" data-group-id="8994069990-5">(</span><span class="p" data-group-id="8994069990-5">)</span><span class="w">
  </span><span class="k" data-group-id="8994069990-3">end</span><span class="w">
</span><span class="k" data-group-id="8994069990-1">end</span></code></pre><p>When we try to compile <code class="inline">ClientApp</code>, Elixir detects the conflict and throws the following error:</p><pre><code class="text">error: imported ModuleA.foo/0 conflicts with local function
  â”” client_app.ex:4:</code></pre><h4>Refactoring</h4><p>To remove this anti-pattern, we recommend library authors avoid providing <code class="inline">__using__/1</code> callbacks whenever it can be replaced by <code class="inline">alias/1</code> or <code class="inline">import/1</code> directives. In the following code, we assume <code class="inline">use Library</code> is no longer available and <code class="inline">ClientApp</code> was refactored in this way, and with that, the code is clearer and the conflict as previously shown no longer exists:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">ClientApp</span><span class="w"> </span><span class="k" data-group-id="8595667975-1">do</span><span class="w">
  </span><span class="kn">import</span><span class="w"> </span><span class="nc">Library</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">foo</span><span class="w"> </span><span class="k" data-group-id="8595667975-2">do</span><span class="w">
    </span><span class="s">&quot;Local function from client app&quot;</span><span class="w">
  </span><span class="k" data-group-id="8595667975-2">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">from_client_app</span><span class="w"> </span><span class="k" data-group-id="8595667975-3">do</span><span class="w">
    </span><span class="n">from_lib</span><span class="p" data-group-id="8595667975-4">(</span><span class="p" data-group-id="8595667975-4">)</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s">&quot; - &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">foo</span><span class="p" data-group-id="8595667975-5">(</span><span class="p" data-group-id="8595667975-5">)</span><span class="w">
  </span><span class="k" data-group-id="8595667975-3">end</span><span class="w">
</span><span class="k" data-group-id="8595667975-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">ClientApp</span><span class="o">.</span><span class="n">from_client_app</span><span class="p" data-group-id="6268584579-1">(</span><span class="p" data-group-id="6268584579-1">)</span><span class="w">
</span><span class="s">&quot;From Library - Local function from client app&quot;</span></code></pre><h4>Additional remarks</h4><p>In situations where you need to do more than importing and aliasing modules, providing <code class="inline">use MyModule</code> may be necessary, as it provides a common extension point within the Elixir ecosystem.</p><p>Therefore, to provide guidance and clarity, we recommend library authors to include an admonition block in their <code class="inline">@moduledoc</code> that explains how <code class="inline">use MyModule</code> impacts the developer's code. As an example, the <a href="GenServer.xhtml"><code class="inline">GenServer</code></a> documentation outlines:</p><section role="note" class="admonition info"><h4 class="admonition-title info"><code class="inline">use GenServer</code></h4><p>When you <code class="inline">use GenServer</code>, the <a href="GenServer.xhtml"><code class="inline">GenServer</code></a> module will
set <code class="inline">@behaviour GenServer</code> and define a <code class="inline">child_spec/1</code>
function, so your module can be used as a child
in a supervision tree.</p></section><p>Think of this summary as a <a href="https://en.wikipedia.org/wiki/Nutrition_facts_label">&quot;Nutrition facts label&quot;</a> for code generation. Make sure to only list changes made to the public API of the module. For example, if <code class="inline">use Library</code> sets an internal attribute called <code class="inline">@_some_module_info</code> and this attribute is never meant to be public, avoid documenting it in the nutrition facts.</p><p>For convenience, the markup notation to generate the admonition block above is this:</p><pre><code class="markdown">&gt; #### `use GenServer` {: .info}
&gt;
&gt; When you `use GenServer`, the `GenServer` module will
&gt; set `@behaviour GenServer` and define a `child_spec/1`
&gt; function, so your module can be used as a child
&gt; in a supervision tree.</code></pre>

  </body>
</html>
