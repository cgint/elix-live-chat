<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Client-server communication with GenServer - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Client-server communication with GenServer</h1>
<p>In the <a href="agents.xhtml">previous chapter</a>, we used agents to represent our buckets. In the <a href="introduction-to-mix.xhtml">introduction to mix</a>, we specified we would like to name each bucket so we can do the following:</p><pre><code class="makeup elixir" translate="no"><span class="nc">CREATE</span><span class="w"> </span><span class="n">shopping</span><span class="w">
</span><span class="nc">OK</span><span class="w">

</span><span class="nc">PUT</span><span class="w"> </span><span class="n">shopping</span><span class="w"> </span><span class="n">milk</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="nc">OK</span><span class="w">

</span><span class="nc">GET</span><span class="w"> </span><span class="n">shopping</span><span class="w"> </span><span class="n">milk</span><span class="w">
</span><span class="mi">1</span><span class="w">
</span><span class="nc">OK</span></code></pre><p>In the session above we interacted with the &quot;shopping&quot; bucket.</p><p>Since agents are processes, each bucket has a process identifier (PID), but buckets do not have a name. Back <a href="processes.xhtml">in the Process chapter</a>, we have learned that we can register processes in Elixir by giving them atom names:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">Agent</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="4527581797-1">(</span><span class="k" data-group-id="4527581797-2">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p" data-group-id="4527581797-3">%{</span><span class="p" data-group-id="4527581797-3">}</span><span class="w"> </span><span class="k" data-group-id="4527581797-2">end</span><span class="p">,</span><span class="w"> </span><span class="ss">name</span><span class="p">:</span><span class="w"> </span><span class="ss">:shopping</span><span class="p" data-group-id="4527581797-1">)</span><span class="w">
</span><span class="p" data-group-id="4527581797-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4527581797-5">#</span><span class="nc" data-group-id="4527581797-5">PID</span><span class="p" data-group-id="4527581797-5">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">43</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="4527581797-5">&gt;</span><span class="p" data-group-id="4527581797-4">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">KV.Bucket</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="4527581797-6">(</span><span class="ss">:shopping</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;milk&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="4527581797-6">)</span><span class="w">
</span><span class="ss">:ok</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">KV.Bucket</span><span class="o">.</span><span class="n">get</span><span class="p" data-group-id="4527581797-7">(</span><span class="ss">:shopping</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;milk&quot;</span><span class="p" data-group-id="4527581797-7">)</span><span class="w">
</span><span class="mi">1</span></code></pre><p>However, naming dynamic processes with atoms is a terrible idea! If we use atoms, we would need to convert the bucket name (often received from an external client) to atoms, and <strong>we should never convert user input to atoms</strong>. This is because atoms are not garbage collected. Once an atom is created, it is never reclaimed. Generating atoms from user input would mean the user can inject enough different names to exhaust our system memory!</p><p>In practice, it is more likely you will reach the Erlang VM limit for the maximum number of atoms before you run out of memory, which will bring your system down regardless.</p><p>Instead of abusing the built-in name facility, we will create our own <em>process registry</em> that associates the bucket name to the bucket process.</p><p>The registry needs to guarantee that it is always up to date. For example, if one of the bucket processes crashes due to a bug, the registry must notice this change and avoid serving stale entries. In Elixir, we say the registry needs to <em>monitor</em> each bucket. Because our <em>registry</em> needs to be able to receive and handle ad-hoc messages from the system, the <a href="Agent.xhtml"><code class="inline">Agent</code></a> API is not enough.</p><p>We will use a <a href="GenServer.xhtml"><code class="inline">GenServer</code></a> to create a registry process that can monitor the bucket processes. GenServer provides industrial strength functionality for building servers in both Elixir and OTP.</p><p>Please read the <a href="GenServer.xhtml"><code class="inline">GenServer</code></a> module documentation for an overview if you haven't yet. Once you do so, we are ready to proceed.</p><h2 id="genserver-callbacks">GenServer callbacks</h2><p>A GenServer is a process that invokes a limited set of functions under specific conditions. When we used an <a href="Agent.xhtml"><code class="inline">Agent</code></a>, we would keep both the client code and the server code side by side, like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">put</span><span class="p" data-group-id="0632880358-1">(</span><span class="n">bucket</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="0632880358-1">)</span><span class="w"> </span><span class="k" data-group-id="0632880358-2">do</span><span class="w">
  </span><span class="nc">Agent</span><span class="o">.</span><span class="n">update</span><span class="p" data-group-id="0632880358-3">(</span><span class="n">bucket</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="0632880358-4">(</span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="0632880358-4">)</span><span class="p" data-group-id="0632880358-3">)</span><span class="w">
</span><span class="k" data-group-id="0632880358-2">end</span></code></pre><p>Let's break that code apart a bit:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">put</span><span class="p" data-group-id="9766860066-1">(</span><span class="n">bucket</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="9766860066-1">)</span><span class="w"> </span><span class="k" data-group-id="9766860066-2">do</span><span class="w">
  </span><span class="c1"># Here is the client code</span><span class="w">
  </span><span class="nc">Agent</span><span class="o">.</span><span class="n">update</span><span class="p" data-group-id="9766860066-3">(</span><span class="n">bucket</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="9766860066-4">fn</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="c1"># Here is the server code</span><span class="w">
    </span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="9766860066-5">(</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="9766860066-5">)</span><span class="w">
  </span><span class="k" data-group-id="9766860066-4">end</span><span class="p" data-group-id="9766860066-3">)</span><span class="w">
  </span><span class="c1"># Back to the client code</span><span class="w">
</span><span class="k" data-group-id="9766860066-2">end</span></code></pre><p>In the code above, we have a process, which we call &quot;the client&quot; sending a request to an agent, &quot;the server&quot;. The request contains an anonymous function, which must be executed by the server.</p><p>In a GenServer, the code above would be two separate functions, roughly like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">put</span><span class="p" data-group-id="5385760213-1">(</span><span class="n">bucket</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5385760213-1">)</span><span class="w"> </span><span class="k" data-group-id="5385760213-2">do</span><span class="w">
  </span><span class="c1"># Send the server a :put &quot;instruction&quot;</span><span class="w">
  </span><span class="nc">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p" data-group-id="5385760213-3">(</span><span class="n">bucket</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5385760213-4">{</span><span class="ss">:put</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5385760213-4">}</span><span class="p" data-group-id="5385760213-3">)</span><span class="w">
</span><span class="k" data-group-id="5385760213-2">end</span><span class="w">

</span><span class="c1"># Server callback</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_call</span><span class="p" data-group-id="5385760213-5">(</span><span class="p" data-group-id="5385760213-6">{</span><span class="ss">:put</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5385760213-6">}</span><span class="p">,</span><span class="w"> </span><span class="c">_from</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p" data-group-id="5385760213-5">)</span><span class="w"> </span><span class="k" data-group-id="5385760213-7">do</span><span class="w">
  </span><span class="p" data-group-id="5385760213-8">{</span><span class="ss">:reply</span><span class="p">,</span><span class="w"> </span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="5385760213-9">(</span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p" data-group-id="5385760213-9">)</span><span class="p" data-group-id="5385760213-8">}</span><span class="w">
</span><span class="k" data-group-id="5385760213-7">end</span></code></pre><p>There is quite a bit more ceremony in the GenServer code but, as we will see, it brings some benefits too.</p><p>For now, we will write only the server callbacks for our bucket registering logic, without providing a proper API, which we will do later.</p><p>Create a new file at <code class="inline">lib/kv/registry.ex</code> with the following contents:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">KV.Registry</span><span class="w"> </span><span class="k" data-group-id="0570988657-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">GenServer</span><span class="w">

  </span><span class="c1">## Missing Client API - will add this later</span><span class="w">

  </span><span class="c1">## Defining GenServer Callbacks</span><span class="w">

  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p" data-group-id="0570988657-2">(</span><span class="ss">:ok</span><span class="p" data-group-id="0570988657-2">)</span><span class="w"> </span><span class="k" data-group-id="0570988657-3">do</span><span class="w">
    </span><span class="p" data-group-id="0570988657-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0570988657-5">%{</span><span class="p" data-group-id="0570988657-5">}</span><span class="p" data-group-id="0570988657-4">}</span><span class="w">
  </span><span class="k" data-group-id="0570988657-3">end</span><span class="w">

  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_call</span><span class="p" data-group-id="0570988657-6">(</span><span class="p" data-group-id="0570988657-7">{</span><span class="ss">:lookup</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="0570988657-7">}</span><span class="p">,</span><span class="w"> </span><span class="c">_from</span><span class="p">,</span><span class="w"> </span><span class="n">names</span><span class="p" data-group-id="0570988657-6">)</span><span class="w"> </span><span class="k" data-group-id="0570988657-8">do</span><span class="w">
    </span><span class="p" data-group-id="0570988657-9">{</span><span class="ss">:reply</span><span class="p">,</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">fetch</span><span class="p" data-group-id="0570988657-10">(</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="0570988657-10">)</span><span class="p">,</span><span class="w"> </span><span class="n">names</span><span class="p" data-group-id="0570988657-9">}</span><span class="w">
  </span><span class="k" data-group-id="0570988657-8">end</span><span class="w">

  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_cast</span><span class="p" data-group-id="0570988657-11">(</span><span class="p" data-group-id="0570988657-12">{</span><span class="ss">:create</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="0570988657-12">}</span><span class="p">,</span><span class="w"> </span><span class="n">names</span><span class="p" data-group-id="0570988657-11">)</span><span class="w"> </span><span class="k" data-group-id="0570988657-13">do</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">has_key?</span><span class="p" data-group-id="0570988657-14">(</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="0570988657-14">)</span><span class="w"> </span><span class="k" data-group-id="0570988657-15">do</span><span class="w">
      </span><span class="p" data-group-id="0570988657-16">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">names</span><span class="p" data-group-id="0570988657-16">}</span><span class="w">
    </span><span class="k" data-group-id="0570988657-15">else</span><span class="w">
      </span><span class="p" data-group-id="0570988657-17">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">bucket</span><span class="p" data-group-id="0570988657-17">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">KV.Bucket</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="0570988657-18">(</span><span class="p" data-group-id="0570988657-19">[</span><span class="p" data-group-id="0570988657-19">]</span><span class="p" data-group-id="0570988657-18">)</span><span class="w">
      </span><span class="p" data-group-id="0570988657-20">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="0570988657-21">(</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">bucket</span><span class="p" data-group-id="0570988657-21">)</span><span class="p" data-group-id="0570988657-20">}</span><span class="w">
    </span><span class="k" data-group-id="0570988657-15">end</span><span class="w">
  </span><span class="k" data-group-id="0570988657-13">end</span><span class="w">
</span><span class="k" data-group-id="0570988657-1">end</span></code></pre><p>There are two types of requests you can send to a GenServer: calls and casts. Calls are synchronous and the server <strong>must</strong> send a response back to such requests. While the server computes the response, the client is <strong>waiting</strong>. Casts are asynchronous: the server won't send a response back and therefore the client won't wait for one. Both requests are messages sent to the server, and will be handled in sequence. In the above implementation, we pattern-match on the <code class="inline">:create</code> messages, to be handled as cast, and on the <code class="inline">:lookup</code> messages, to be handled as call.</p><p>In order to invoke the callbacks above, we need to go through the corresponding <a href="GenServer.xhtml"><code class="inline">GenServer</code></a> functions. Let's start a registry, create a named bucket, and then look it up:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="6961944628-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">registry</span><span class="p" data-group-id="6961944628-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="6961944628-2">(</span><span class="nc">KV.Registry</span><span class="p">,</span><span class="w"> </span><span class="ss">:ok</span><span class="p" data-group-id="6961944628-2">)</span><span class="w">
</span><span class="p" data-group-id="6961944628-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6961944628-4">#</span><span class="nc" data-group-id="6961944628-4">PID</span><span class="p" data-group-id="6961944628-4">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">136</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="6961944628-4">&gt;</span><span class="p" data-group-id="6961944628-3">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p" data-group-id="6961944628-5">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6961944628-6">{</span><span class="ss">:create</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shopping&quot;</span><span class="p" data-group-id="6961944628-6">}</span><span class="p" data-group-id="6961944628-5">)</span><span class="w">
</span><span class="ss">:ok</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="6961944628-7">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">bucket</span><span class="p" data-group-id="6961944628-7">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p" data-group-id="6961944628-8">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6961944628-9">{</span><span class="ss">:lookup</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shopping&quot;</span><span class="p" data-group-id="6961944628-9">}</span><span class="p" data-group-id="6961944628-8">)</span><span class="w">
</span><span class="p" data-group-id="6961944628-10">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6961944628-11">#</span><span class="nc" data-group-id="6961944628-11">PID</span><span class="p" data-group-id="6961944628-11">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">174</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="6961944628-11">&gt;</span><span class="p" data-group-id="6961944628-10">}</span></code></pre><p>Our <code class="inline">KV.Registry</code> process received a cast with <code class="inline">{:create, &quot;shopping&quot;}</code> and a call with <code class="inline">{:lookup, &quot;shopping&quot;}</code>, in this sequence. <code class="inline">GenServer.cast</code> will immediately return, as soon as the message is sent to the <code class="inline">registry</code>. The <code class="inline">GenServer.call</code> on the other hand, is where we would be waiting for an answer, provided by the above <code class="inline">KV.Registry.handle_call</code> callback.</p><p>You may also have noticed that we have added <code class="inline">@impl true</code> before each callback. The <code class="inline">@impl true</code> informs the compiler that our intention for the subsequent function definition is to define a callback. If by any chance we make a mistake in the function name or in the number of arguments, like we define a <code class="inline">handle_call/2</code>, the compiler would warn us there isn't any <code class="inline">handle_call/2</code> to define, and would give us the complete list of known callbacks for the <a href="GenServer.xhtml"><code class="inline">GenServer</code></a> module.</p><p>This is all good and well, but we still want to offer our users an API that allows us to hide our implementation details.</p><h2 id="the-client-api">The Client API</h2><p>A GenServer is implemented in two parts: the client API and the server callbacks. You can either combine both parts into a single module or you can separate them into a client module and a server module. The client is any process that invokes the client function. The server is always the process identifier or process name that we will explicitly pass as argument to the client API. Here we'll use a single module for both the server callbacks and the client API.</p><p>Edit the file at <code class="inline">lib/kv/registry.ex</code>, filling in the blanks for the client API:</p><pre><code class="makeup elixir" translate="no"><span class="w">  </span><span class="c1">## Client API</span><span class="w">

  </span><span class="na">@doc</span><span class="w"> </span><span class="s">&quot;&quot;&quot;
  Starts the registry.
  &quot;&quot;&quot;</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">start_link</span><span class="p" data-group-id="0107544479-1">(</span><span class="n">opts</span><span class="p" data-group-id="0107544479-1">)</span><span class="w"> </span><span class="k" data-group-id="0107544479-2">do</span><span class="w">
    </span><span class="nc">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="0107544479-3">(</span><span class="bp">__MODULE__</span><span class="p">,</span><span class="w"> </span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="0107544479-3">)</span><span class="w">
  </span><span class="k" data-group-id="0107544479-2">end</span><span class="w">

  </span><span class="na">@doc</span><span class="w"> </span><span class="s">&quot;&quot;&quot;
  Looks up the bucket pid for `name` stored in `server`.

  Returns `{:ok, pid}` if the bucket exists, `:error` otherwise.
  &quot;&quot;&quot;</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">lookup</span><span class="p" data-group-id="0107544479-4">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="0107544479-4">)</span><span class="w"> </span><span class="k" data-group-id="0107544479-5">do</span><span class="w">
    </span><span class="nc">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p" data-group-id="0107544479-6">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0107544479-7">{</span><span class="ss">:lookup</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="0107544479-7">}</span><span class="p" data-group-id="0107544479-6">)</span><span class="w">
  </span><span class="k" data-group-id="0107544479-5">end</span><span class="w">

  </span><span class="na">@doc</span><span class="w"> </span><span class="s">&quot;&quot;&quot;
  Ensures there is a bucket associated with the given `name` in `server`.
  &quot;&quot;&quot;</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">create</span><span class="p" data-group-id="0107544479-8">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="0107544479-8">)</span><span class="w"> </span><span class="k" data-group-id="0107544479-9">do</span><span class="w">
    </span><span class="nc">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p" data-group-id="0107544479-10">(</span><span class="n">server</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0107544479-11">{</span><span class="ss">:create</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="0107544479-11">}</span><span class="p" data-group-id="0107544479-10">)</span><span class="w">
  </span><span class="k" data-group-id="0107544479-9">end</span></code></pre><p>The first function is <code class="inline">start_link/1</code>, which starts a new GenServer passing a list of options. <code class="inline">start_link/1</code> calls out to <a href="GenServer.xhtml#start_link/3"><code class="inline">GenServer.start_link/3</code></a>, which takes three arguments:</p><ol><li><p>The module where the server callbacks are implemented, in this case <code class="inline">__MODULE__</code> (meaning the current module)</p></li><li><p>The initialization arguments, in this case the atom <code class="inline">:ok</code></p></li><li><p>A list of options which can be used to specify things like the name of the server. For now, we forward the list of options that we receive on <code class="inline">start_link/1</code> to <a href="GenServer.xhtml#start_link/3"><code class="inline">GenServer.start_link/3</code></a></p></li></ol><p>The next two functions, <code class="inline">lookup/2</code> and <code class="inline">create/2</code>, are responsible for sending these requests to the server.  In this case, we have used <code class="inline">{:lookup, name}</code> and <code class="inline">{:create, name}</code> respectively.  Requests are often specified as tuples, like this, in order to provide more than one &quot;argument&quot; in that first argument slot. It's common to specify the action being requested as the first element of a tuple, and arguments for that action in the remaining elements. Note that the requests must match the first argument to <code class="inline">handle_call/3</code> or <code class="inline">handle_cast/2</code>.</p><p>That's it for the client API. On the server side, we can implement a variety of callbacks to guarantee the server initialization, termination, and handling of requests. Those callbacks are optional and for now, we have only implemented the ones we care about. Let's recap.</p><p>The first is the <code class="inline">init/1</code> callback, that receives the second argument given to <a href="GenServer.xhtml#start_link/3"><code class="inline">GenServer.start_link/3</code></a> and returns <code class="inline">{:ok, state}</code>, where state is a new map. We can already notice how the <a href="GenServer.xhtml"><code class="inline">GenServer</code></a> API makes the client/server segregation more apparent. <code class="inline">start_link/3</code> happens in the client, while <code class="inline">init/1</code> is the respective callback that runs on the server.</p><p>For <code class="inline">call/2</code> requests, we implement a <code class="inline">handle_call/3</code> callback that receives the <code class="inline">request</code>, the process from which we received the request (<code class="inline">_from</code>), and the current server state (<code class="inline">names</code>). The <code class="inline">handle_call/3</code> callback returns a tuple in the format <code class="inline">{:reply, reply, new_state}</code>. The first element of the tuple, <code class="inline">:reply</code>, indicates that the server should send a reply back to the client. The second element, <code class="inline">reply</code>, is what will be sent to the client while the third, <code class="inline">new_state</code> is the new server state.</p><p>For <code class="inline">cast/2</code> requests, we implement a <code class="inline">handle_cast/2</code> callback that receives the <code class="inline">request</code> and the current server state (<code class="inline">names</code>). The <code class="inline">handle_cast/2</code> callback returns a tuple in the format <code class="inline">{:noreply, new_state}</code>. Note that in a real application we would have probably implemented the callback for <code class="inline">:create</code> with a synchronous call instead of an asynchronous cast. We are doing it this way to illustrate how to implement a cast callback.</p><p>There are other tuple formats both <code class="inline">handle_call/3</code> and <code class="inline">handle_cast/2</code> callbacks may return. There are other callbacks like <code class="inline">terminate/2</code> and <code class="inline">code_change/3</code> that we could implement. You are welcome to explore the full <a href="GenServer.xhtml"><code class="inline">GenServer</code></a> documentation to learn more about those.</p><p>For now, let's write some tests to guarantee our GenServer works as expected.</p><h2 id="testing-a-genserver">Testing a GenServer</h2><p>Testing a GenServer is not much different from testing an agent. We will spawn the server on a setup callback and use it throughout our tests. Create a file at <code class="inline">test/kv/registry_test.exs</code> with the following:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">KV.RegistryTest</span><span class="w"> </span><span class="k" data-group-id="4804286904-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">ExUnit.Case</span><span class="p">,</span><span class="w"> </span><span class="ss">async</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">

  </span><span class="n">setup</span><span class="w"> </span><span class="k" data-group-id="4804286904-2">do</span><span class="w">
    </span><span class="n">registry</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_supervised!</span><span class="p" data-group-id="4804286904-3">(</span><span class="nc">KV.Registry</span><span class="p" data-group-id="4804286904-3">)</span><span class="w">
    </span><span class="p" data-group-id="4804286904-4">%{</span><span class="ss">registry</span><span class="p">:</span><span class="w"> </span><span class="n">registry</span><span class="p" data-group-id="4804286904-4">}</span><span class="w">
  </span><span class="k" data-group-id="4804286904-2">end</span><span class="w">

  </span><span class="n">test</span><span class="w"> </span><span class="s">&quot;spawns buckets&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4804286904-5">%{</span><span class="ss">registry</span><span class="p">:</span><span class="w"> </span><span class="n">registry</span><span class="p" data-group-id="4804286904-5">}</span><span class="w"> </span><span class="k" data-group-id="4804286904-6">do</span><span class="w">
    </span><span class="n">assert</span><span class="w"> </span><span class="nc">KV.Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p" data-group-id="4804286904-7">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shopping&quot;</span><span class="p" data-group-id="4804286904-7">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:error</span><span class="w">

    </span><span class="nc">KV.Registry</span><span class="o">.</span><span class="n">create</span><span class="p" data-group-id="4804286904-8">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shopping&quot;</span><span class="p" data-group-id="4804286904-8">)</span><span class="w">
    </span><span class="n">assert</span><span class="w"> </span><span class="p" data-group-id="4804286904-9">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">bucket</span><span class="p" data-group-id="4804286904-9">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">KV.Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p" data-group-id="4804286904-10">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shopping&quot;</span><span class="p" data-group-id="4804286904-10">)</span><span class="w">

    </span><span class="nc">KV.Bucket</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="4804286904-11">(</span><span class="n">bucket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;milk&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="4804286904-11">)</span><span class="w">
    </span><span class="n">assert</span><span class="w"> </span><span class="nc">KV.Bucket</span><span class="o">.</span><span class="n">get</span><span class="p" data-group-id="4804286904-12">(</span><span class="n">bucket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;milk&quot;</span><span class="p" data-group-id="4804286904-12">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="k" data-group-id="4804286904-6">end</span><span class="w">
</span><span class="k" data-group-id="4804286904-1">end</span></code></pre><p>Our test case first asserts there are no buckets in our registry, creates a named bucket, looks it up, and asserts it behaves as a bucket.</p><p>There is one important difference between the <code class="inline">setup</code> block we wrote for <code class="inline">KV.Registry</code> and the one we wrote for <code class="inline">KV.Bucket</code>. Instead of starting the registry by hand by calling <code class="inline">KV.Registry.start_link/1</code>, we instead called the <a href="https://hexdocs.pm/ex_unit/ExUnit.Callbacks.html#start_supervised!/2"><code class="inline">ExUnit.Callbacks.start_supervised!/2</code></a> function, passing the <code class="inline">KV.Registry</code> module.</p><p>The <code class="inline">start_supervised!</code> function was injected into our test module by <code class="inline">use ExUnit.Case</code>. It does the job of starting the <code class="inline">KV.Registry</code> process, by calling its <code class="inline">start_link/1</code> function. The advantage of using <code class="inline">start_supervised!</code> is that ExUnit will guarantee that the registry process will be shutdown <strong>before</strong> the next test starts. In other words, it helps guarantee that the state of one test is not going to interfere with the next one in case they depend on shared resources.</p><p>When starting processes during your tests, we should always prefer to use <code class="inline">start_supervised!</code>. We recommend you to change the <code class="inline">setup</code> block in <code class="inline">bucket_test.exs</code> to use <code class="inline">start_supervised!</code> too.</p><p>Run the tests and they should all pass!</p><h2 id="the-need-for-monitoring">The need for monitoring</h2><p>Everything we have done so far could have been implemented with a <a href="Agent.xhtml"><code class="inline">Agent</code></a>. In this section, we will see one of many things that we can achieve with a GenServer that is not possible with an Agent.</p><p>Let's start with a test that describes how we want the registry to behave if a bucket stops or crashes:</p><pre><code class="makeup elixir" translate="no"><span class="n">test</span><span class="w"> </span><span class="s">&quot;removes buckets on exit&quot;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1054728204-1">%{</span><span class="ss">registry</span><span class="p">:</span><span class="w"> </span><span class="n">registry</span><span class="p" data-group-id="1054728204-1">}</span><span class="w"> </span><span class="k" data-group-id="1054728204-2">do</span><span class="w">
  </span><span class="nc">KV.Registry</span><span class="o">.</span><span class="n">create</span><span class="p" data-group-id="1054728204-3">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shopping&quot;</span><span class="p" data-group-id="1054728204-3">)</span><span class="w">
  </span><span class="p" data-group-id="1054728204-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">bucket</span><span class="p" data-group-id="1054728204-4">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">KV.Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p" data-group-id="1054728204-5">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shopping&quot;</span><span class="p" data-group-id="1054728204-5">)</span><span class="w">
  </span><span class="nc">Agent</span><span class="o">.</span><span class="n">stop</span><span class="p" data-group-id="1054728204-6">(</span><span class="n">bucket</span><span class="p" data-group-id="1054728204-6">)</span><span class="w">
  </span><span class="n">assert</span><span class="w"> </span><span class="nc">KV.Registry</span><span class="o">.</span><span class="n">lookup</span><span class="p" data-group-id="1054728204-7">(</span><span class="n">registry</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;shopping&quot;</span><span class="p" data-group-id="1054728204-7">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:error</span><span class="w">
</span><span class="k" data-group-id="1054728204-2">end</span></code></pre><p>The test above will fail on the last assertion as the bucket name remains in the registry even after we stop the bucket process.</p><p>In order to fix this bug, we need the registry to monitor every bucket it spawns. Once we set up a monitor, the registry will receive a notification every time a bucket process exits, allowing us to clean the registry up.</p><p>Let's first play with monitors by starting a new console with <code class="inline">iex -S mix</code>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="1455238049-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p" data-group-id="1455238049-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">KV.Bucket</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="1455238049-2">(</span><span class="p" data-group-id="1455238049-3">[</span><span class="p" data-group-id="1455238049-3">]</span><span class="p" data-group-id="1455238049-2">)</span><span class="w">
</span><span class="p" data-group-id="1455238049-4">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1455238049-5">#</span><span class="nc" data-group-id="1455238049-5">PID</span><span class="p" data-group-id="1455238049-5">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">66</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="1455238049-5">&gt;</span><span class="p" data-group-id="1455238049-4">}</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Process</span><span class="o">.</span><span class="n">monitor</span><span class="p" data-group-id="1455238049-6">(</span><span class="n">pid</span><span class="p" data-group-id="1455238049-6">)</span><span class="w">
</span><span class="p" data-group-id="1455238049-7">#</span><span class="nc" data-group-id="1455238049-7">Reference</span><span class="p" data-group-id="1455238049-7">&lt;</span><span class="mf">0.0</span><span class="o">.</span><span class="mf">0.551</span><span class="p" data-group-id="1455238049-7">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Agent</span><span class="o">.</span><span class="n">stop</span><span class="p" data-group-id="1455238049-8">(</span><span class="n">pid</span><span class="p" data-group-id="1455238049-8">)</span><span class="w">
</span><span class="ss">:ok</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">flush</span><span class="p" data-group-id="1455238049-9">(</span><span class="p" data-group-id="1455238049-9">)</span><span class="w">
</span><span class="p" data-group-id="1455238049-10">{</span><span class="ss">:DOWN</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1455238049-11">#</span><span class="nc" data-group-id="1455238049-11">Reference</span><span class="p" data-group-id="1455238049-11">&lt;</span><span class="mf">0.0</span><span class="o">.</span><span class="mf">0.551</span><span class="p" data-group-id="1455238049-11">&gt;</span><span class="p">,</span><span class="w"> </span><span class="ss">:process</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1455238049-12">#</span><span class="nc" data-group-id="1455238049-12">PID</span><span class="p" data-group-id="1455238049-12">&lt;</span><span class="mi">0</span><span class="o">.</span><span class="mi">66</span><span class="o">.</span><span class="mi">0</span><span class="p" data-group-id="1455238049-12">&gt;</span><span class="p">,</span><span class="w"> </span><span class="ss">:normal</span><span class="p" data-group-id="1455238049-10">}</span></code></pre><p>Note <code class="inline">Process.monitor(pid)</code> returns a unique reference that allows us to match upcoming messages to that monitoring reference. After we stop the agent, we can <code class="inline">flush/0</code> all messages and notice a <code class="inline">:DOWN</code> message arrived, with the exact reference returned by <code class="inline">monitor</code>, notifying that the bucket process exited with reason <code class="inline">:normal</code>.</p><p>Let's reimplement the server callbacks to fix the bug and make the test pass. First, we will modify the GenServer state to two maps: one that contains <code class="inline">name -&gt; pid</code> and another that holds <code class="inline">ref -&gt; name</code>. Then we need to monitor the buckets on <code class="inline">handle_cast/2</code> as well as implement a <code class="inline">handle_info/2</code> callback to handle the monitoring messages. The full server callbacks implementation is shown below:</p><pre><code class="makeup elixir" translate="no"><span class="c1">## Server callbacks</span><span class="w">

</span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p" data-group-id="4534886736-1">(</span><span class="ss">:ok</span><span class="p" data-group-id="4534886736-1">)</span><span class="w"> </span><span class="k" data-group-id="4534886736-2">do</span><span class="w">
  </span><span class="n">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4534886736-3">%{</span><span class="p" data-group-id="4534886736-3">}</span><span class="w">
  </span><span class="n">refs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p" data-group-id="4534886736-4">%{</span><span class="p" data-group-id="4534886736-4">}</span><span class="w">
  </span><span class="p" data-group-id="4534886736-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4534886736-6">{</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">refs</span><span class="p" data-group-id="4534886736-6">}</span><span class="p" data-group-id="4534886736-5">}</span><span class="w">
</span><span class="k" data-group-id="4534886736-2">end</span><span class="w">

</span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_call</span><span class="p" data-group-id="4534886736-7">(</span><span class="p" data-group-id="4534886736-8">{</span><span class="ss">:lookup</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="4534886736-8">}</span><span class="p">,</span><span class="w"> </span><span class="c">_from</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p" data-group-id="4534886736-7">)</span><span class="w"> </span><span class="k" data-group-id="4534886736-9">do</span><span class="w">
  </span><span class="p" data-group-id="4534886736-10">{</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="4534886736-10">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">state</span><span class="w">
  </span><span class="p" data-group-id="4534886736-11">{</span><span class="ss">:reply</span><span class="p">,</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">fetch</span><span class="p" data-group-id="4534886736-12">(</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="4534886736-12">)</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p" data-group-id="4534886736-11">}</span><span class="w">
</span><span class="k" data-group-id="4534886736-9">end</span><span class="w">

</span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_cast</span><span class="p" data-group-id="4534886736-13">(</span><span class="p" data-group-id="4534886736-14">{</span><span class="ss">:create</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="4534886736-14">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4534886736-15">{</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">refs</span><span class="p" data-group-id="4534886736-15">}</span><span class="p" data-group-id="4534886736-13">)</span><span class="w"> </span><span class="k" data-group-id="4534886736-16">do</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">has_key?</span><span class="p" data-group-id="4534886736-17">(</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="4534886736-17">)</span><span class="w"> </span><span class="k" data-group-id="4534886736-18">do</span><span class="w">
    </span><span class="p" data-group-id="4534886736-19">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4534886736-20">{</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">refs</span><span class="p" data-group-id="4534886736-20">}</span><span class="p" data-group-id="4534886736-19">}</span><span class="w">
  </span><span class="k" data-group-id="4534886736-18">else</span><span class="w">
    </span><span class="p" data-group-id="4534886736-21">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">bucket</span><span class="p" data-group-id="4534886736-21">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">KV.Bucket</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="4534886736-22">(</span><span class="p" data-group-id="4534886736-23">[</span><span class="p" data-group-id="4534886736-23">]</span><span class="p" data-group-id="4534886736-22">)</span><span class="w">
    </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Process</span><span class="o">.</span><span class="n">monitor</span><span class="p" data-group-id="4534886736-24">(</span><span class="n">bucket</span><span class="p" data-group-id="4534886736-24">)</span><span class="w">
    </span><span class="n">refs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="4534886736-25">(</span><span class="n">refs</span><span class="p">,</span><span class="w"> </span><span class="n">ref</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="4534886736-25">)</span><span class="w">
    </span><span class="n">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">put</span><span class="p" data-group-id="4534886736-26">(</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">bucket</span><span class="p" data-group-id="4534886736-26">)</span><span class="w">
    </span><span class="p" data-group-id="4534886736-27">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4534886736-28">{</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">refs</span><span class="p" data-group-id="4534886736-28">}</span><span class="p" data-group-id="4534886736-27">}</span><span class="w">
  </span><span class="k" data-group-id="4534886736-18">end</span><span class="w">
</span><span class="k" data-group-id="4534886736-16">end</span><span class="w">

</span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_info</span><span class="p" data-group-id="4534886736-29">(</span><span class="p" data-group-id="4534886736-30">{</span><span class="ss">:DOWN</span><span class="p">,</span><span class="w"> </span><span class="n">ref</span><span class="p">,</span><span class="w"> </span><span class="ss">:process</span><span class="p">,</span><span class="w"> </span><span class="c">_pid</span><span class="p">,</span><span class="w"> </span><span class="c">_reason</span><span class="p" data-group-id="4534886736-30">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4534886736-31">{</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">refs</span><span class="p" data-group-id="4534886736-31">}</span><span class="p" data-group-id="4534886736-29">)</span><span class="w"> </span><span class="k" data-group-id="4534886736-32">do</span><span class="w">
  </span><span class="p" data-group-id="4534886736-33">{</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">refs</span><span class="p" data-group-id="4534886736-33">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">pop</span><span class="p" data-group-id="4534886736-34">(</span><span class="n">refs</span><span class="p">,</span><span class="w"> </span><span class="n">ref</span><span class="p" data-group-id="4534886736-34">)</span><span class="w">
  </span><span class="n">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Map</span><span class="o">.</span><span class="n">delete</span><span class="p" data-group-id="4534886736-35">(</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p" data-group-id="4534886736-35">)</span><span class="w">
  </span><span class="p" data-group-id="4534886736-36">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4534886736-37">{</span><span class="n">names</span><span class="p">,</span><span class="w"> </span><span class="n">refs</span><span class="p" data-group-id="4534886736-37">}</span><span class="p" data-group-id="4534886736-36">}</span><span class="w">
</span><span class="k" data-group-id="4534886736-32">end</span><span class="w">

</span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">handle_info</span><span class="p" data-group-id="4534886736-38">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p" data-group-id="4534886736-38">)</span><span class="w"> </span><span class="k" data-group-id="4534886736-39">do</span><span class="w">
  </span><span class="kn">require</span><span class="w"> </span><span class="nc">Logger</span><span class="w">
  </span><span class="nc">Logger</span><span class="o">.</span><span class="n">debug</span><span class="p" data-group-id="4534886736-40">(</span><span class="s">&quot;Unexpected message in KV.Registry: </span><span class="si" data-group-id="4534886736-41">#{</span><span class="n">inspect</span><span class="p" data-group-id="4534886736-42">(</span><span class="n">msg</span><span class="p" data-group-id="4534886736-42">)</span><span class="si" data-group-id="4534886736-41">}</span><span class="s">&quot;</span><span class="p" data-group-id="4534886736-40">)</span><span class="w">
  </span><span class="p" data-group-id="4534886736-43">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p" data-group-id="4534886736-43">}</span><span class="w">
</span><span class="k" data-group-id="4534886736-39">end</span></code></pre><p>Observe that we were able to considerably change the server implementation without changing any of the client API. That's one of the benefits of explicitly segregating the server and the client.</p><p>Finally, different from the other callbacks, we have defined a &quot;catch-all&quot; clause for <code class="inline">handle_info/2</code> that discards and logs any unknown message. To understand why, let's move on to the next section.</p><h2 id="call-cast-or-info"><code class="inline">call</code>, <code class="inline">cast</code> or <code class="inline">info</code>?</h2><p>So far we have used three callbacks: <code class="inline">handle_call/3</code>, <code class="inline">handle_cast/2</code> and <code class="inline">handle_info/2</code>. Here is what we should consider when deciding when to use each:</p><ol><li><p><code class="inline">handle_call/3</code> must be used for synchronous requests. This should be the default choice as waiting for the server reply is a useful back-pressure mechanism.</p></li><li><p><code class="inline">handle_cast/2</code> must be used for asynchronous requests, when you don't care about a reply. A cast does not guarantee the server has received the message and, for this reason, should be used sparingly. For example, the <code class="inline">create/2</code> function we have defined in this chapter should have used <code class="inline">call/2</code>. We have used <code class="inline">cast/2</code> for didactic purposes.</p></li><li><p><code class="inline">handle_info/2</code> must be used for all other messages a server may receive that are not sent via <a href="GenServer.xhtml#call/2"><code class="inline">GenServer.call/2</code></a> or <a href="GenServer.xhtml#cast/2"><code class="inline">GenServer.cast/2</code></a>, including regular messages sent with <a href="Kernel.xhtml#send/2"><code class="inline">send/2</code></a>. The monitoring <code class="inline">:DOWN</code> messages are an example of this.</p></li></ol><p>Since any message, including the ones sent via <a href="Kernel.xhtml#send/2"><code class="inline">send/2</code></a>, go to <code class="inline">handle_info/2</code>, there is a chance that unexpected messages will arrive to the server. Therefore, if we don't define the catch-all clause, those messages could cause our registry to crash, because no clause would match. We don't need to worry about such cases for <code class="inline">handle_call/3</code> and <code class="inline">handle_cast/2</code> though. Calls and casts are only done via the <a href="GenServer.xhtml"><code class="inline">GenServer</code></a> API, so an unknown message is quite likely a developer mistake.</p><p>To help developers remember the differences between call, cast and info, the supported return values and more, we have a tiny <a href="https://elixir-lang.org/downloads/cheatsheets/gen-server.pdf">GenServer cheat sheet</a>.</p><h2 id="monitors-or-links">Monitors or links?</h2><p>We have previously learned about links in the <a href="processes.xhtml">Process chapter</a>. Now, with the registry complete, you may be wondering: when should we use monitors and when should we use links?</p><p>Links are bi-directional. If you link two processes and one of them crashes, the other side will crash too (unless it is trapping exits). A monitor is uni-directional: only the monitoring process will receive notifications about the monitored one. In other words: use links when you want linked crashes, and monitors when you just want to be informed of crashes, exits, and so on.</p><p>Returning to our <code class="inline">handle_cast/2</code> implementation, you can see the registry is both linking and monitoring the buckets:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="5863603376-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">bucket</span><span class="p" data-group-id="5863603376-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">KV.Bucket</span><span class="o">.</span><span class="n">start_link</span><span class="p" data-group-id="5863603376-2">(</span><span class="p" data-group-id="5863603376-3">[</span><span class="p" data-group-id="5863603376-3">]</span><span class="p" data-group-id="5863603376-2">)</span><span class="w">
</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Process</span><span class="o">.</span><span class="n">monitor</span><span class="p" data-group-id="5863603376-4">(</span><span class="n">bucket</span><span class="p" data-group-id="5863603376-4">)</span></code></pre><p>This is a bad idea, as we don't want the registry to crash when a bucket crashes. The proper fix is to actually not link the bucket to the registry. Instead, we will link each bucket to a special type of process called Supervisors, which are explicitly designed to handle failures and crashes. We will learn more about them in the next chapter.</p>

  </body>
</html>
