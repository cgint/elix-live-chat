<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Kernel.SpecialForms - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Kernel.SpecialForms 
    </h1>


      <section id="moduledoc" class="docstring">
<p>Special forms are the basic building blocks of Elixir, and therefore
cannot be overridden by the developer.</p><p>The <a href="Kernel.SpecialForms.xhtml"><code class="inline">Kernel.SpecialForms</code></a> module consists solely of macros that can be
invoked anywhere in Elixir code without the use of the
<code class="inline">Kernel.SpecialForms.</code> prefix. This is possible because they all have
been automatically imported, in the same fashion as the functions and
macros from the <a href="Kernel.xhtml"><code class="inline">Kernel</code></a> module.</p><p>These building blocks are defined in this module. Some of these special forms are lexical (such as
<a href="#alias/2"><code class="inline">alias/2</code></a> and <a href="#case/2"><code class="inline">case/2</code></a>). The macros <a href="#%7B%7D/1"><code class="inline">{}/1</code></a> and <a href="#%3C%3C%3E%3E/1"><code class="inline">&lt;&lt;&gt;&gt;/1</code></a> are also special
forms used to define tuple and binary data structures respectively.</p><p>This module also documents macros that return information about Elixir's
compilation environment, such as (<a href="#__ENV__/0"><code class="inline">__ENV__/0</code></a>, <a href="#__MODULE__/0"><code class="inline">__MODULE__/0</code></a>, <a href="#__DIR__/0"><code class="inline">__DIR__/0</code></a>,
<a href="#__STACKTRACE__/0"><code class="inline">__STACKTRACE__/0</code></a>, and <a href="#__CALLER__/0"><code class="inline">__CALLER__/0</code></a>).</p><p>Additionally, it documents two special forms, <a href="#__block__/1"><code class="inline">__block__/1</code></a> and
<a href="#__aliases__/1"><code class="inline">__aliases__/1</code></a>, which are not intended to be called directly by the
developer but they appear in quoted contents since they are essential
in Elixir's constructs.</p>
      </section>


      <section id="summary" class="details-list">
        <h1 class="section-heading">Summary</h1>
<div class="summary-functions summary">
  <h2>
    <a href="#functions">Functions</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#%25/2" data-no-tooltip="" translate="no">%struct{}</a>

      </div>

        <div class="summary-synopsis"><p>Matches on or builds a struct.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#%25%7B%7D/1" data-no-tooltip="" translate="no">%{}</a>

      </div>

        <div class="summary-synopsis"><p>Creates a map.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#&/1" data-no-tooltip="" translate="no">&amp;expr</a>

      </div>

        <div class="summary-synopsis"><p>Capture operator. Captures or creates an anonymous function.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#./2" data-no-tooltip="" translate="no">left . right</a>

      </div>

        <div class="summary-synopsis"><p>Dot operator. Defines a remote call, a call to an anonymous function, or an alias.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#__aliases__/1" data-no-tooltip="" translate="no">__aliases__(args)</a>

      </div>

        <div class="summary-synopsis"><p>Internal special form to hold aliases information.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#__block__/1" data-no-tooltip="" translate="no">__block__(args)</a>

      </div>

        <div class="summary-synopsis"><p>Internal special form for block expressions.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#__CALLER__/0" data-no-tooltip="" translate="no">__CALLER__</a>

      </div>

        <div class="summary-synopsis"><p>Returns the current calling environment as a <a><code class="inline">Macro.Env</code></a> struct.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#__cursor__/1" data-no-tooltip="" translate="no">__cursor__(args)</a>

      </div>

        <div class="summary-synopsis"><p>Internal special form for cursor position.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#__DIR__/0" data-no-tooltip="" translate="no">__DIR__</a>

      </div>

        <div class="summary-synopsis"><p>Returns the absolute path of the directory of the current file as a binary.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#__ENV__/0" data-no-tooltip="" translate="no">__ENV__</a>

      </div>

        <div class="summary-synopsis"><p>Returns the current environment information as a <a><code class="inline">Macro.Env</code></a> struct.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#__MODULE__/0" data-no-tooltip="" translate="no">__MODULE__</a>

      </div>

        <div class="summary-synopsis"><p>Returns the current module name as an atom or <code class="inline">nil</code> otherwise.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#__STACKTRACE__/0" data-no-tooltip="" translate="no">__STACKTRACE__</a>

      </div>

        <div class="summary-synopsis"><p>Returns the stacktrace for the currently handled exception.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#::/2" data-no-tooltip="" translate="no">left :: right</a>

      </div>

        <div class="summary-synopsis"><p>Type operator. Used by types and bitstrings to specify types.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#%3C%3C%3E%3E/1" data-no-tooltip="" translate="no">&lt;&lt;args&gt;&gt;</a>

      </div>

        <div class="summary-synopsis"><p>Defines a new bitstring.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#=/2" data-no-tooltip="" translate="no">left = right</a>

      </div>

        <div class="summary-synopsis"><p>Match operator. Matches the value on the right against the pattern on the left.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#alias/2" data-no-tooltip="" translate="no">alias(module, opts)</a>

      </div>

        <div class="summary-synopsis"><p><a><code class="inline">alias/2</code></a> is used to set up aliases, often useful with modules' names.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#case/2" data-no-tooltip="" translate="no">case(condition, clauses)</a>

      </div>

        <div class="summary-synopsis"><p>Matches the given expression against the given clauses.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#cond/1" data-no-tooltip="" translate="no">cond(clauses)</a>

      </div>

        <div class="summary-synopsis"><p>Evaluates the expression corresponding to the first clause that
evaluates to a truthy value.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#fn/1" data-no-tooltip="" translate="no">fn(clauses)</a>

      </div>

        <div class="summary-synopsis"><p>Defines an anonymous function.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#for/1" data-no-tooltip="" translate="no">for(args)</a>

      </div>

        <div class="summary-synopsis"><p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#import/2" data-no-tooltip="" translate="no">import(module, opts)</a>

      </div>

        <div class="summary-synopsis"><p>Imports functions and macros from other modules.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#quote/2" data-no-tooltip="" translate="no">quote(opts, block)</a>

      </div>

        <div class="summary-synopsis"><p>Gets the representation of any expression.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#receive/1" data-no-tooltip="" translate="no">receive(args)</a>

      </div>

        <div class="summary-synopsis"><p>Checks if there is a message matching any of the given clauses in the current
process mailbox.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#require/2" data-no-tooltip="" translate="no">require(module, opts)</a>

      </div>

        <div class="summary-synopsis"><p>Requires a module in order to use its macros.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#super/1" data-no-tooltip="" translate="no">super(args)</a>

      </div>

        <div class="summary-synopsis"><p>Calls the overridden function when overriding it with <a><code class="inline">Kernel.defoverridable/1</code></a>.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#try/1" data-no-tooltip="" translate="no">try(args)</a>

      </div>

        <div class="summary-synopsis"><p>Evaluates the given expressions and handles any error, exit,
or throw that may have happened.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#unquote/1" data-no-tooltip="" translate="no">unquote(expr)</a>

      </div>

        <div class="summary-synopsis"><p>Unquotes the given expression inside a quoted expression.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#unquote_splicing/1" data-no-tooltip="" translate="no">unquote_splicing(expr)</a>

      </div>

        <div class="summary-synopsis"><p>Unquotes the given list expanding its arguments.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#with/1" data-no-tooltip="" translate="no">with(args)</a>

      </div>

        <div class="summary-synopsis"><p>Combine matching clauses.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#%5E/1" data-no-tooltip="" translate="no">^var</a>

      </div>

        <div class="summary-synopsis"><p>Pin operator. Accesses an already bound variable in match clauses.</p></div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#%7B%7D/1" data-no-tooltip="" translate="no">{args}</a>

      </div>

        <div class="summary-synopsis"><p>Creates a tuple.</p></div>

    </div>

</div>

      </section>


      <section id="functions" class="details-list">
        <h1 class="section-heading">Functions</h1>

        <div class="functions-list">
<section class="detail" id="%25/2">

  <div class="detail-header">
    <a href="#%25/2" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">%struct{}</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L152" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Matches on or builds a struct.</p><p>A struct is a tagged map that allows developers to provide
default values for keys, tags to be used in polymorphic
dispatches and compile time assertions.</p><p>Structs are usually defined with the <a href="Kernel.xhtml#defstruct/1"><code class="inline">Kernel.defstruct/1</code></a> macro:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">User</samp><samp class="w"> </samp><samp class="k" data-group-id="2936382880-1">do</samp><samp class="w">
  </samp><samp class="kd">defstruct</samp><samp class="w"> </samp><samp class="ss">name</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;john&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">age</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">27</samp><samp class="w">
</samp><samp class="k" data-group-id="2936382880-1">end</samp></code></pre><p>Now a struct can be created as follows:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="9014234174-1">%</samp><samp class="nc" data-group-id="9014234174-1">User</samp><samp class="p" data-group-id="9014234174-1">{</samp><samp class="p" data-group-id="9014234174-1">}</samp></code></pre><p>Underneath a struct is just a map with a <code class="inline">:__struct__</code> key
pointing to the <code class="inline">User</code> module:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="6551948631-1">%</samp><samp class="nc" data-group-id="6551948631-1">User</samp><samp class="p" data-group-id="6551948631-1">{</samp><samp class="p" data-group-id="6551948631-1">}</samp><samp class="w"> </samp><samp class="o">==</samp><samp class="w"> </samp><samp class="p" data-group-id="6551948631-2">%{</samp><samp class="ss">__struct__</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="nc">User</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">name</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;john&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">age</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">27</samp><samp class="p" data-group-id="6551948631-2">}</samp></code></pre><p>The struct fields can be given when building the struct:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="1988224513-1">%</samp><samp class="nc" data-group-id="1988224513-1">User</samp><samp class="p" data-group-id="1988224513-1">{</samp><samp class="ss">age</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">31</samp><samp class="p" data-group-id="1988224513-1">}</samp><samp class="w">
</samp><samp class="c1">#=&gt; %{__struct__: User, name: &quot;john&quot;, age: 31}</samp></code></pre><p>Or also on pattern matching to extract values out:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="3515904698-1">%</samp><samp class="nc" data-group-id="3515904698-1">User</samp><samp class="p" data-group-id="3515904698-1">{</samp><samp class="ss">age</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">age</samp><samp class="p" data-group-id="3515904698-1">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">user</samp></code></pre><p>The advantage of structs is that they validate that the given
keys are part of the defined struct. The example below will fail
because there is no key <code class="inline">:full_name</code> in the <code class="inline">User</code> struct:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="7167555393-1">%</samp><samp class="nc" data-group-id="7167555393-1">User</samp><samp class="p" data-group-id="7167555393-1">{</samp><samp class="ss">full_name</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;john doe&quot;</samp><samp class="p" data-group-id="7167555393-1">}</samp></code></pre><p>An update operation specific for structs is also available:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="0839718931-1">%</samp><samp class="nc" data-group-id="0839718931-1">User</samp><samp class="p" data-group-id="0839718931-1">{</samp><samp class="n">user</samp><samp class="w"> </samp><samp class="o">|</samp><samp class="w"> </samp><samp class="ss">age</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">28</samp><samp class="p" data-group-id="0839718931-1">}</samp></code></pre><p>Once again, the syntax above will guarantee the given keys
are valid at compilation time and it will guarantee at runtime
the given argument is a struct, failing with <a href="BadStructError.xhtml"><code class="inline">BadStructError</code></a>
otherwise. The map update syntax can also be used for updating
structs, and it is useful when you want to update any struct,
regardless of their name, as long as they have matching fields:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="1865245578-1">%{</samp><samp class="n">user</samp><samp class="w"> </samp><samp class="o">|</samp><samp class="w"> </samp><samp class="ss">age</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">28</samp><samp class="p" data-group-id="1865245578-1">}</samp></code></pre><h2 id="%25/2-pattern-matching-on-struct-names" class="section-heading"><a href="#%25/2-pattern-matching-on-struct-names" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Pattern matching on struct names</span></h2><p>Besides allowing pattern matching on struct fields, such as:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="3365849310-1">%</samp><samp class="nc" data-group-id="3365849310-1">User</samp><samp class="p" data-group-id="3365849310-1">{</samp><samp class="ss">age</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">age</samp><samp class="p" data-group-id="3365849310-1">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">user</samp></code></pre><p>Structs also allow pattern matching on the struct name:</p><pre><code class="makeup elixir" translate="no"><samp class="p">%</samp><samp class="n">struct_name</samp><samp class="p" data-group-id="2756003978-1">{</samp><samp class="p" data-group-id="2756003978-1">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">user</samp><samp class="w">
</samp><samp class="n">struct_name</samp><samp class="w"> </samp><samp class="c1">#=&gt; User</samp></code></pre><p>You can also assign the struct name to <code class="inline">_</code> when you want to
check if something is a struct but you are not interested in
its name:</p><pre><code class="makeup elixir" translate="no"><samp class="p">%</samp><samp class="bp">_</samp><samp class="p" data-group-id="5068204549-1">{</samp><samp class="p" data-group-id="5068204549-1">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">user</samp></code></pre>
  </section>
</section>
<section class="detail" id="%25%7B%7D/1">

  <div class="detail-header">
    <a href="#%25%7B%7D/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">%{}</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L82" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Creates a map.</p><p>See the <a href="Map.xhtml"><code class="inline">Map</code></a> module for more information about maps, their syntax, and ways to
access and manipulate them.</p><h2 id="%25%7B%7D/1-ast-representation" class="section-heading"><a href="#%25%7B%7D/1-ast-representation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">AST representation</span></h2><p>Regardless of whether <code class="inline">=&gt;</code> or the keyword syntax is used, key-value pairs in
maps are always represented internally as a list of two-element tuples for
simplicity:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="4154756989-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="4154756989-2">%{</samp><samp class="s">&quot;a&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="ss">:b</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">c</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:d</samp><samp class="p" data-group-id="4154756989-2">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="4154756989-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="4154756989-3">{</samp><samp class="ss">:%{}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4154756989-4">[</samp><samp class="p" data-group-id="4154756989-4">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4154756989-5">[</samp><samp class="p" data-group-id="4154756989-6">{</samp><samp class="s">&quot;a&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:b</samp><samp class="p" data-group-id="4154756989-6">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4154756989-7">{</samp><samp class="ss">:c</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:d</samp><samp class="p" data-group-id="4154756989-7">}</samp><samp class="p" data-group-id="4154756989-5">]</samp><samp class="p" data-group-id="4154756989-3">}</samp></code></pre>
  </section>
</section>
<section class="detail" id="&/1">

  <div class="detail-header">
    <a href="#&/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">&amp;expr</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1851" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Capture operator. Captures or creates an anonymous function.</p><h2 id="&/1-capture" class="section-heading"><a href="#&/1-capture" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Capture</span></h2><p>The capture operator is most commonly used to capture a
function with given name and arity from a module:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">fun</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="o">&amp;</samp><samp class="nc">Kernel</samp><samp class="o">.</samp><samp class="n">is_atom</samp><samp class="o">/</samp><samp class="mi">1</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">fun</samp><samp class="o">.</samp><samp class="p" data-group-id="2227044205-1">(</samp><samp class="ss">:atom</samp><samp class="p" data-group-id="2227044205-1">)</samp><samp class="w">
</samp><samp class="no">true</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">fun</samp><samp class="o">.</samp><samp class="p" data-group-id="2227044205-2">(</samp><samp class="s">&quot;string&quot;</samp><samp class="p" data-group-id="2227044205-2">)</samp><samp class="w">
</samp><samp class="no">false</samp></code></pre><p>In the example above, we captured <a href="Kernel.xhtml#is_atom/1"><code class="inline">Kernel.is_atom/1</code></a> as an
anonymous function and then invoked it.</p><p>The capture operator can also be used to capture local functions,
including private ones, and imported functions by omitting the
module name:</p><pre><code class="makeup elixir" translate="no"><samp class="o">&amp;</samp><samp class="n">local_function</samp><samp class="o">/</samp><samp class="mi">1</samp></code></pre><p>Note that <code class="inline">&amp;local_function/1</code> creates a local capture, but
<code class="inline">&amp;__MODULE__.local_function/1</code> or <code class="inline">&amp;imported_function/1</code> create a remote
capture. For more information, refer to the <a href="https://www.erlang.org/doc/system/eff_guide_functions.html#function-calls">&quot;Functions&quot; section in the Erlang Reference Manual</a>.</p><p>Whether a capture is local or remote has implications when using hot code
reloading: local captures dispatch to the version of the module that existed
at the time they were created, while remote captures dispatch to the current
version of the module.</p><p>See also <a href="Function.xhtml#capture/3"><code class="inline">Function.capture/3</code></a>.</p><h2 id="&/1-anonymous-functions" class="section-heading"><a href="#&/1-anonymous-functions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Anonymous functions</span></h2><p>The capture operator can also be used to partially apply
functions, where <code class="inline">&amp;1</code>, <code class="inline">&amp;2</code> and so on can be used as value
placeholders. For example:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">double</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="o">&amp;</samp><samp class="p" data-group-id="7221109904-1">(</samp><samp class="ni">&amp;1</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="7221109904-1">)</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">double</samp><samp class="o">.</samp><samp class="p" data-group-id="7221109904-2">(</samp><samp class="mi">2</samp><samp class="p" data-group-id="7221109904-2">)</samp><samp class="w">
</samp><samp class="mi">4</samp></code></pre><p>In other words, <code class="inline">&amp;(&amp;1 * 2)</code> is equivalent to <code class="inline">fn x -&gt; x * 2 end</code>.</p><p>We can partially apply a remote function with placeholder:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">take_five</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="o">&amp;</samp><samp class="nc">Enum</samp><samp class="o">.</samp><samp class="n">take</samp><samp class="p" data-group-id="0876592546-1">(</samp><samp class="ni">&amp;1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">5</samp><samp class="p" data-group-id="0876592546-1">)</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">take_five</samp><samp class="o">.</samp><samp class="p" data-group-id="0876592546-2">(</samp><samp class="mi">1</samp><samp class="o">..</samp><samp class="mi">10</samp><samp class="p" data-group-id="0876592546-2">)</samp><samp class="w">
</samp><samp class="p" data-group-id="0876592546-3">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">5</samp><samp class="p" data-group-id="0876592546-3">]</samp></code></pre><p>Another example while using an imported or local function:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">first_elem</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="o">&amp;</samp><samp class="n">elem</samp><samp class="p" data-group-id="1909137366-1">(</samp><samp class="ni">&amp;1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p" data-group-id="1909137366-1">)</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">first_elem</samp><samp class="o">.</samp><samp class="p" data-group-id="1909137366-2">(</samp><samp class="p" data-group-id="1909137366-3">{</samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="1909137366-3">}</samp><samp class="p" data-group-id="1909137366-2">)</samp><samp class="w">
</samp><samp class="mi">0</samp></code></pre><p>The <code class="inline">&amp;</code> operator can be used with more complex expressions:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">fun</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="o">&amp;</samp><samp class="p" data-group-id="4612594136-1">(</samp><samp class="ni">&amp;1</samp><samp class="w"> </samp><samp class="o">+</samp><samp class="w"> </samp><samp class="ni">&amp;2</samp><samp class="w"> </samp><samp class="o">+</samp><samp class="w"> </samp><samp class="ni">&amp;3</samp><samp class="p" data-group-id="4612594136-1">)</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">fun</samp><samp class="o">.</samp><samp class="p" data-group-id="4612594136-2">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="4612594136-2">)</samp><samp class="w">
</samp><samp class="mi">6</samp></code></pre><p>As well as with lists and tuples:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">fun</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="o">&amp;</samp><samp class="p" data-group-id="9577537459-1">{</samp><samp class="ni">&amp;1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ni">&amp;2</samp><samp class="p" data-group-id="9577537459-1">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">fun</samp><samp class="o">.</samp><samp class="p" data-group-id="9577537459-2">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="9577537459-2">)</samp><samp class="w">
</samp><samp class="p" data-group-id="9577537459-3">{</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="9577537459-3">}</samp><samp class="w">

</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">fun</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="o">&amp;</samp><samp class="p" data-group-id="9577537459-4">[</samp><samp class="ni">&amp;1</samp><samp class="w"> </samp><samp class="o">|</samp><samp class="w"> </samp><samp class="ni">&amp;2</samp><samp class="p" data-group-id="9577537459-4">]</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">fun</samp><samp class="o">.</samp><samp class="p" data-group-id="9577537459-5">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="9577537459-6">[</samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="9577537459-6">]</samp><samp class="p" data-group-id="9577537459-5">)</samp><samp class="w">
</samp><samp class="p" data-group-id="9577537459-7">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="9577537459-7">]</samp></code></pre><p>The only restrictions when creating anonymous functions is that at
least one placeholder must be present, i.e. it must contain at least
<code class="inline">&amp;1</code>, and that block expressions are not supported:</p><pre><code class="makeup elixir" translate="no"><samp class="c1"># No placeholder, fails to compile.</samp><samp class="w">
</samp><samp class="o">&amp;</samp><samp class="p" data-group-id="1827627612-1">(</samp><samp class="ss">:foo</samp><samp class="p" data-group-id="1827627612-1">)</samp><samp class="w">

</samp><samp class="c1"># Block expression, fails to compile.</samp><samp class="w">
</samp><samp class="o">&amp;</samp><samp class="p" data-group-id="1827627612-2">(</samp><samp class="ni">&amp;1</samp><samp class="p">;</samp><samp class="w"> </samp><samp class="ni">&amp;2</samp><samp class="p" data-group-id="1827627612-2">)</samp></code></pre>
  </section>
</section>
<section class="detail" id="./2">

  <div class="detail-header">
    <a href="#./2" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">left . right</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L494" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Dot operator. Defines a remote call, a call to an anonymous function, or an alias.</p><p>The dot (<code class="inline">.</code>) in Elixir can be used for remote calls:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="nc">String</samp><samp class="o">.</samp><samp class="n">downcase</samp><samp class="p" data-group-id="8083286541-1">(</samp><samp class="s">&quot;FOO&quot;</samp><samp class="p" data-group-id="8083286541-1">)</samp><samp class="w">
</samp><samp class="s">&quot;foo&quot;</samp></code></pre><p>In this example above, we have used <code class="inline">.</code> to invoke <code class="inline">downcase</code> in the
<a href="String.xhtml"><code class="inline">String</code></a> module, passing <code class="inline">&quot;FOO&quot;</code> as argument.</p><p>The dot may be used to invoke anonymous functions too:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="8930936953-1">(</samp><samp class="k" data-group-id="8930936953-2">fn</samp><samp class="w"> </samp><samp class="n">n</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">n</samp><samp class="w"> </samp><samp class="k" data-group-id="8930936953-2">end</samp><samp class="p" data-group-id="8930936953-1">)</samp><samp class="o">.</samp><samp class="p" data-group-id="8930936953-3">(</samp><samp class="mi">7</samp><samp class="p" data-group-id="8930936953-3">)</samp><samp class="w">
</samp><samp class="mi">7</samp></code></pre><p>in which case there is a function on the left hand side.</p><p>We can also use the dot for creating aliases:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="nc">Hello.World</samp><samp class="w">
</samp><samp class="nc">Hello.World</samp></code></pre><p>This time, we have joined two aliases, defining the final alias
<code class="inline">Hello.World</code>.</p><h2 id="./2-syntax" class="section-heading"><a href="#./2-syntax" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Syntax</span></h2><p>The right side of <code class="inline">.</code> may be a word starting with an uppercase letter, which represents
an alias, a word starting with lowercase or underscore, any valid language
operator or any name wrapped in single- or double-quotes. Those are all valid
examples:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="nc">Kernel.Sample</samp><samp class="w">
</samp><samp class="nc">Kernel.Sample</samp><samp class="w">

</samp><samp class="gp unselectable">iex&gt; </samp><samp class="nc">Kernel</samp><samp class="o">.</samp><samp class="n">length</samp><samp class="p" data-group-id="7136973869-1">(</samp><samp class="p" data-group-id="7136973869-2">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="7136973869-2">]</samp><samp class="p" data-group-id="7136973869-1">)</samp><samp class="w">
</samp><samp class="mi">3</samp><samp class="w">

</samp><samp class="gp unselectable">iex&gt; </samp><samp class="nc">Kernel</samp><samp class="o">.</samp><samp class="o">+</samp><samp class="p" data-group-id="7136973869-3">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="7136973869-3">)</samp><samp class="w">
</samp><samp class="mi">3</samp><samp class="w">

</samp><samp class="gp unselectable">iex&gt; </samp><samp class="nc">Kernel</samp><samp class="o">.</samp><samp class="s">&quot;+&quot;</samp><samp class="p" data-group-id="7136973869-4">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="7136973869-4">)</samp><samp class="w">
</samp><samp class="mi">3</samp></code></pre><p>Wrapping the function name in single- or double-quotes is always a
remote call. Therefore <code class="inline">Kernel.&quot;Foo&quot;</code> will attempt to call the function &quot;Foo&quot;
and not return the alias <code class="inline">Kernel.Foo</code>. This is done by design as module names
are more strict than function names.</p><p>When the dot is used to invoke an anonymous function there is only one
operand, but it is still written using a postfix notation:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">negate</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="k" data-group-id="6203833976-1">fn</samp><samp class="w"> </samp><samp class="n">n</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="o">-</samp><samp class="n">n</samp><samp class="w"> </samp><samp class="k" data-group-id="6203833976-1">end</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">negate</samp><samp class="o">.</samp><samp class="p" data-group-id="6203833976-2">(</samp><samp class="mi">7</samp><samp class="p" data-group-id="6203833976-2">)</samp><samp class="w">
</samp><samp class="o">-</samp><samp class="mi">7</samp></code></pre><h2 id="./2-quoted-expression" class="section-heading"><a href="#./2-quoted-expression" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Quoted expression</span></h2><p>When <code class="inline">.</code> is used, the quoted expression may take two distinct
forms. When the right side starts with a lowercase letter (or
underscore):</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="3790668287-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="nc">String</samp><samp class="o">.</samp><samp class="n">downcase</samp><samp class="p" data-group-id="3790668287-2">(</samp><samp class="s">&quot;FOO&quot;</samp><samp class="p" data-group-id="3790668287-2">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="3790668287-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="3790668287-3">{</samp><samp class="p" data-group-id="3790668287-4">{</samp><samp class="ss">:.</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3790668287-5">[</samp><samp class="p" data-group-id="3790668287-5">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3790668287-6">[</samp><samp class="p" data-group-id="3790668287-7">{</samp><samp class="ss">:__aliases__</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3790668287-8">[</samp><samp class="ss">alias</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="p" data-group-id="3790668287-8">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3790668287-9">[</samp><samp class="ss">:String</samp><samp class="p" data-group-id="3790668287-9">]</samp><samp class="p" data-group-id="3790668287-7">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:downcase</samp><samp class="p" data-group-id="3790668287-6">]</samp><samp class="p" data-group-id="3790668287-4">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3790668287-10">[</samp><samp class="p" data-group-id="3790668287-10">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3790668287-11">[</samp><samp class="s">&quot;FOO&quot;</samp><samp class="p" data-group-id="3790668287-11">]</samp><samp class="p" data-group-id="3790668287-3">}</samp></code></pre><p>Note that we have an inner tuple, containing the atom <code class="inline">:.</code> representing
the dot as first element:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="1066953081-1">{</samp><samp class="ss">:.</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="1066953081-2">[</samp><samp class="p" data-group-id="1066953081-2">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="1066953081-3">[</samp><samp class="p" data-group-id="1066953081-4">{</samp><samp class="ss">:__aliases__</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="1066953081-5">[</samp><samp class="ss">alias</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="p" data-group-id="1066953081-5">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="1066953081-6">[</samp><samp class="ss">:String</samp><samp class="p" data-group-id="1066953081-6">]</samp><samp class="p" data-group-id="1066953081-4">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:downcase</samp><samp class="p" data-group-id="1066953081-3">]</samp><samp class="p" data-group-id="1066953081-1">}</samp></code></pre><p>This tuple follows the general quoted expression structure in Elixir,
with the name as first argument, some keyword list as metadata as second,
and the list of arguments as third. In this case, the arguments are the
alias <a href="String.xhtml"><code class="inline">String</code></a> and the atom <code class="inline">:downcase</code>. The second argument in a remote call
is <strong>always</strong> an atom.</p><p>In the case of calls to anonymous functions, the inner tuple with the dot
special form has only one argument, reflecting the fact that the operator is
unary:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="5088623541-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="n">negate</samp><samp class="o">.</samp><samp class="p" data-group-id="5088623541-2">(</samp><samp class="mi">0</samp><samp class="p" data-group-id="5088623541-2">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="5088623541-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="5088623541-3">{</samp><samp class="p" data-group-id="5088623541-4">{</samp><samp class="ss">:.</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5088623541-5">[</samp><samp class="p" data-group-id="5088623541-5">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5088623541-6">[</samp><samp class="p" data-group-id="5088623541-7">{</samp><samp class="ss">:negate</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5088623541-8">[</samp><samp class="p" data-group-id="5088623541-8">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="bp">__MODULE__</samp><samp class="p" data-group-id="5088623541-7">}</samp><samp class="p" data-group-id="5088623541-6">]</samp><samp class="p" data-group-id="5088623541-4">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5088623541-9">[</samp><samp class="p" data-group-id="5088623541-9">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5088623541-10">[</samp><samp class="mi">0</samp><samp class="p" data-group-id="5088623541-10">]</samp><samp class="p" data-group-id="5088623541-3">}</samp></code></pre><p>When the right side is an alias (i.e. starts with uppercase), we get instead:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="8877094378-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="nc">Hello.World</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="8877094378-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="8877094378-2">{</samp><samp class="ss">:__aliases__</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8877094378-3">[</samp><samp class="ss">alias</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="p" data-group-id="8877094378-3">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8877094378-4">[</samp><samp class="ss">:Hello</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:World</samp><samp class="p" data-group-id="8877094378-4">]</samp><samp class="p" data-group-id="8877094378-2">}</samp></code></pre><p>We go into more details about aliases in the <a href="#__aliases__/1"><code class="inline">__aliases__/1</code></a> special form
documentation.</p><h2 id="./2-unquoting" class="section-heading"><a href="#./2-unquoting" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Unquoting</span></h2><p>We can also use unquote to generate a remote call in a quoted expression:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="ss">:downcase</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="3149774658-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="nc">String</samp><samp class="o">.</samp><samp class="k">unquote</samp><samp class="p" data-group-id="3149774658-2">(</samp><samp class="n">x</samp><samp class="p" data-group-id="3149774658-2">)</samp><samp class="p" data-group-id="3149774658-3">(</samp><samp class="s">&quot;FOO&quot;</samp><samp class="p" data-group-id="3149774658-3">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="3149774658-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="3149774658-4">{</samp><samp class="p" data-group-id="3149774658-5">{</samp><samp class="ss">:.</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3149774658-6">[</samp><samp class="p" data-group-id="3149774658-6">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3149774658-7">[</samp><samp class="p" data-group-id="3149774658-8">{</samp><samp class="ss">:__aliases__</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3149774658-9">[</samp><samp class="ss">alias</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="p" data-group-id="3149774658-9">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3149774658-10">[</samp><samp class="ss">:String</samp><samp class="p" data-group-id="3149774658-10">]</samp><samp class="p" data-group-id="3149774658-8">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:downcase</samp><samp class="p" data-group-id="3149774658-7">]</samp><samp class="p" data-group-id="3149774658-5">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3149774658-11">[</samp><samp class="p" data-group-id="3149774658-11">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3149774658-12">[</samp><samp class="s">&quot;FOO&quot;</samp><samp class="p" data-group-id="3149774658-12">]</samp><samp class="p" data-group-id="3149774658-4">}</samp></code></pre><p>Similar to <code class="inline">Kernel.&quot;FUNCTION_NAME&quot;</code>, <code class="inline">unquote(x)</code> will always generate a remote call,
independent of the value of <code class="inline">x</code>. To generate an alias via the quoted expression,
one needs to rely on <a href="Module.xhtml#concat/2"><code class="inline">Module.concat/2</code></a>:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="nc">Sample</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="5070952869-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="nc">Module</samp><samp class="o">.</samp><samp class="n">concat</samp><samp class="p" data-group-id="5070952869-2">(</samp><samp class="nc">String</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="5070952869-3">(</samp><samp class="n">x</samp><samp class="p" data-group-id="5070952869-3">)</samp><samp class="p" data-group-id="5070952869-2">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="5070952869-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="5070952869-4">{</samp><samp class="p" data-group-id="5070952869-5">{</samp><samp class="ss">:.</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5070952869-6">[</samp><samp class="p" data-group-id="5070952869-6">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5070952869-7">[</samp><samp class="p" data-group-id="5070952869-8">{</samp><samp class="ss">:__aliases__</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5070952869-9">[</samp><samp class="ss">alias</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="p" data-group-id="5070952869-9">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5070952869-10">[</samp><samp class="ss">:Module</samp><samp class="p" data-group-id="5070952869-10">]</samp><samp class="p" data-group-id="5070952869-8">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:concat</samp><samp class="p" data-group-id="5070952869-7">]</samp><samp class="p" data-group-id="5070952869-5">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5070952869-11">[</samp><samp class="p" data-group-id="5070952869-11">]</samp><samp class="p">,</samp><samp class="w">
 </samp><samp class="p" data-group-id="5070952869-12">[</samp><samp class="p" data-group-id="5070952869-13">{</samp><samp class="ss">:__aliases__</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5070952869-14">[</samp><samp class="ss">alias</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="p" data-group-id="5070952869-14">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5070952869-15">[</samp><samp class="ss">:String</samp><samp class="p" data-group-id="5070952869-15">]</samp><samp class="p" data-group-id="5070952869-13">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">Sample</samp><samp class="p" data-group-id="5070952869-12">]</samp><samp class="p" data-group-id="5070952869-4">}</samp></code></pre>
  </section>
</section>
<section class="detail" id="__aliases__/1">

  <div class="detail-header">
    <a href="#__aliases__/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">__aliases__(args)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1885" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Internal special form to hold aliases information.</p><p>It is usually compiled to an atom:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="4783910349-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="nc">Foo.Bar</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="4783910349-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="4783910349-2">{</samp><samp class="ss">:__aliases__</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4783910349-3">[</samp><samp class="ss">alias</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="p" data-group-id="4783910349-3">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4783910349-4">[</samp><samp class="ss">:Foo</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:Bar</samp><samp class="p" data-group-id="4783910349-4">]</samp><samp class="p" data-group-id="4783910349-2">}</samp></code></pre><p>Elixir represents <code class="inline">Foo.Bar</code> as <code class="inline">__aliases__</code> so calls can be
unambiguously identified by the operator <code class="inline">:.</code>. For example:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="2971150141-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="nc">Foo</samp><samp class="o">.</samp><samp class="n">bar</samp><samp class="p" data-group-id="2971150141-2">(</samp><samp class="p" data-group-id="2971150141-2">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="2971150141-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="2971150141-3">{</samp><samp class="p" data-group-id="2971150141-4">{</samp><samp class="ss">:.</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="2971150141-5">[</samp><samp class="p" data-group-id="2971150141-5">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="2971150141-6">[</samp><samp class="p" data-group-id="2971150141-7">{</samp><samp class="ss">:__aliases__</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="2971150141-8">[</samp><samp class="ss">alias</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="p" data-group-id="2971150141-8">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="2971150141-9">[</samp><samp class="ss">:Foo</samp><samp class="p" data-group-id="2971150141-9">]</samp><samp class="p" data-group-id="2971150141-7">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:bar</samp><samp class="p" data-group-id="2971150141-6">]</samp><samp class="p" data-group-id="2971150141-4">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="2971150141-10">[</samp><samp class="p" data-group-id="2971150141-10">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="2971150141-11">[</samp><samp class="p" data-group-id="2971150141-11">]</samp><samp class="p" data-group-id="2971150141-3">}</samp></code></pre><p>Whenever an expression iterator sees a <code class="inline">:.</code> as the tuple key,
it can be sure that it represents a call and the second argument
in the list is an atom.</p><p>On the other hand, aliases hold some properties:</p><ol><li><p>The head element of aliases can be any term that must expand to
an atom at compilation time.</p></li><li><p>The tail elements of aliases are guaranteed to always be atoms.</p></li><li><p>When the head element of aliases is the atom <code class="inline">:Elixir</code>, no expansion happens.</p></li></ol>
  </section>
</section>
<section class="detail" id="__block__/1">

  <div class="detail-header">
    <a href="#__block__/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">__block__(args)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1755" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Internal special form for block expressions.</p><p>This is the special form used whenever we have a block
of expressions in Elixir. This special form is private
and should not be invoked directly:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="4925216021-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="mi">1</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="mi">2</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="mi">3</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="4925216021-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="4925216021-2">{</samp><samp class="ss">:__block__</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4925216021-3">[</samp><samp class="p" data-group-id="4925216021-3">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4925216021-4">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="4925216021-4">]</samp><samp class="p" data-group-id="4925216021-2">}</samp></code></pre>
  </section>
</section>
<section class="detail" id="__CALLER__/0">

  <div class="detail-header">
    <a href="#__CALLER__/0" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">__CALLER__</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L717" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Returns the current calling environment as a <a href="Macro.Env.xhtml"><code class="inline">Macro.Env</code></a> struct.</p><p>In the environment you can access the filename, line numbers,
set up aliases, the function and others.</p>
  </section>
</section>
<section class="detail" id="__cursor__/1">

  <div class="detail-header">
    <a href="#__cursor__/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">__cursor__(args)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1764" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Internal special form for cursor position.</p><p>This is the special form used whenever we need to represent
the cursor position in Elixir's AST. See <a href="Code.Fragment.xhtml"><code class="inline">Code.Fragment</code></a> for
more information.</p>
  </section>
</section>
<section class="detail" id="__DIR__/0">

  <div class="detail-header">
    <a href="#__DIR__/0" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">__DIR__</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L709" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Returns the absolute path of the directory of the current file as a binary.</p><p>Although the directory can be accessed as <code class="inline">Path.dirname(__ENV__.file)</code>,
this macro is a convenient shortcut.</p>
  </section>
</section>
<section class="detail" id="__ENV__/0">

  <div class="detail-header">
    <a href="#__ENV__/0" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">__ENV__</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L693" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Returns the current environment information as a <a href="Macro.Env.xhtml"><code class="inline">Macro.Env</code></a> struct.</p><p>In the environment you can access the current filename,
line numbers, set up aliases, the current function and others.</p>
  </section>
</section>
<section class="detail" id="__MODULE__/0">

  <div class="detail-header">
    <a href="#__MODULE__/0" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">__MODULE__</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L701" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Returns the current module name as an atom or <code class="inline">nil</code> otherwise.</p><p>Although the module can be accessed in the <a href="#__ENV__/0"><code class="inline">__ENV__/0</code></a>, this macro
is a convenient shortcut.</p>
  </section>
</section>
<section class="detail" id="__STACKTRACE__/0">

  <div class="detail-header">
    <a href="#__STACKTRACE__/0" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">__STACKTRACE__</h1>

        <span class="note">(since 1.7.0)</span>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L729" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Returns the stacktrace for the currently handled exception.</p><p>It is available only in the <code class="inline">catch</code> and <code class="inline">rescue</code> clauses of <a href="#try/1"><code class="inline">try/1</code></a>
expressions.</p><p>To retrieve the stacktrace of the current process, use
<code class="inline">Process.info(self(), :current_stacktrace)</code> instead.</p>
  </section>
</section>
<section class="detail" id="::/2">

  <div class="detail-header">
    <a href="#::/2" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">left :: right</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L787" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Type operator. Used by types and bitstrings to specify types.</p><p>This operator is used in two distinct occasions in Elixir.
It is used in typespecs to specify the type of a variable,
function or of a type itself:</p><pre><code class="makeup elixir" translate="no"><samp class="na">@type</samp><samp class="w"> </samp><samp class="n">number</samp><samp class="w"> </samp><samp class="o">::</samp><samp class="w"> </samp><samp class="n">integer</samp><samp class="w"> </samp><samp class="o">|</samp><samp class="w"> </samp><samp class="n">float</samp><samp class="w">
</samp><samp class="na">@spec</samp><samp class="w"> </samp><samp class="n">add</samp><samp class="p" data-group-id="2420353910-1">(</samp><samp class="n">number</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">number</samp><samp class="p" data-group-id="2420353910-1">)</samp><samp class="w"> </samp><samp class="o">::</samp><samp class="w"> </samp><samp class="n">number</samp></code></pre><p>It may also be used in bit strings to specify the type
of a given bit segment:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="8104290486-1">&lt;&lt;</samp><samp class="n">int</samp><samp class="o">::</samp><samp class="n">integer</samp><samp class="o">-</samp><samp class="n">little</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="o">::</samp><samp class="n">bits</samp><samp class="p" data-group-id="8104290486-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">bits</samp></code></pre><p>Read the documentation on the <a href="typespecs.xhtml">Typespecs page</a> and
<a href="#%3C%3C%3E%3E/1"><code class="inline">&lt;&lt;&gt;&gt;/1</code></a> for more information on typespecs and
bitstrings respectively.</p>
  </section>
</section>
<section class="detail" id="%3C%3C%3E%3E/1">

  <div class="detail-header">
    <a href="#%3C%3C%3E%3E/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">&lt;&lt;args&gt;&gt;</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L372" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Defines a new bitstring.</p><h2 id="%3C%3C%3E%3E/1-examples" class="section-heading"><a href="#%3C%3C%3E%3E/1-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="6286145816-1">&lt;&lt;</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="6286145816-1">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="6286145816-2">&lt;&lt;</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="6286145816-2">&gt;&gt;</samp></code></pre><h2 id="%3C%3C%3E%3E/1-types" class="section-heading"><a href="#%3C%3C%3E%3E/1-types" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Types</span></h2><p>A bitstring is made of many segments and each segment has a
type. There are 9 types used in bitstrings:</p><ul><li><code class="inline">integer</code></li><li><code class="inline">float</code></li><li><code class="inline">bits</code> (alias for <code class="inline">bitstring</code>)</li><li><code class="inline">bitstring</code></li><li><code class="inline">binary</code></li><li><code class="inline">bytes</code> (alias for <code class="inline">binary</code>)</li><li><code class="inline">utf8</code></li><li><code class="inline">utf16</code></li><li><code class="inline">utf32</code></li></ul><p>When no type is specified, the default is <code class="inline">integer</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="9831802775-1">&lt;&lt;</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="9831802775-1">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="9831802775-2">&lt;&lt;</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="9831802775-2">&gt;&gt;</samp></code></pre><p>Elixir also accepts by default the segment to be a literal
string which expands to integers:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="0880376899-1">&lt;&lt;</samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;foo&quot;</samp><samp class="p" data-group-id="0880376899-1">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="0880376899-2">&lt;&lt;</samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">102</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">111</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">111</samp><samp class="p" data-group-id="0880376899-2">&gt;&gt;</samp></code></pre><p>You can use one of <code class="inline">utf8</code> (the default), <code class="inline">utf16</code>, and <code class="inline">utf32</code> to
control how the string is encoded:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="5414352633-1">&lt;&lt;</samp><samp class="s">&quot;foo&quot;</samp><samp class="o">::</samp><samp class="n">utf16</samp><samp class="p" data-group-id="5414352633-1">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="5414352633-2">&lt;&lt;</samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">102</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">111</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">111</samp><samp class="p" data-group-id="5414352633-2">&gt;&gt;</samp></code></pre><p>Which is equivalent to writing:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="7668784108-1">&lt;&lt;</samp><samp class="sc">?f</samp><samp class="o">::</samp><samp class="n">utf16</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="sc">?o</samp><samp class="o">::</samp><samp class="n">utf16</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="sc">?o</samp><samp class="o">::</samp><samp class="n">utf16</samp><samp class="p" data-group-id="7668784108-1">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="7668784108-2">&lt;&lt;</samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">102</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">111</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">111</samp><samp class="p" data-group-id="7668784108-2">&gt;&gt;</samp></code></pre><p>At runtime, binaries need to be explicitly tagged as <code class="inline">binary</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">rest</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="s">&quot;oo&quot;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="8209205230-1">&lt;&lt;</samp><samp class="mi">102</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="8209205230-1">&gt;&gt;</samp><samp class="w">
</samp><samp class="s">&quot;foo&quot;</samp></code></pre><p>Otherwise we get an <a href="ArgumentError.xhtml"><code class="inline">ArgumentError</code></a> when constructing the binary:</p><pre><code class="makeup elixir" translate="no"><samp class="n">rest</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="s">&quot;oo&quot;</samp><samp class="w">
</samp><samp class="p" data-group-id="0943985964-1">&lt;&lt;</samp><samp class="mi">102</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="p" data-group-id="0943985964-1">&gt;&gt;</samp><samp class="w">
</samp><samp class="gt">** (ArgumentError) argument error</samp></code></pre><h2 id="%3C%3C%3E%3E/1-options" class="section-heading"><a href="#%3C%3C%3E%3E/1-options" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Options</span></h2><p>Many options can be given by using <code class="inline">-</code> as separator. Order is
arbitrary, so the following are all equivalent:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="2792639556-1">&lt;&lt;</samp><samp class="mi">102</samp><samp class="o">::</samp><samp class="n">integer</samp><samp class="o">-</samp><samp class="n">native</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="2792639556-1">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="2792639556-2">&lt;&lt;</samp><samp class="mi">102</samp><samp class="o">::</samp><samp class="n">native</samp><samp class="o">-</samp><samp class="n">integer</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="2792639556-2">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="2792639556-3">&lt;&lt;</samp><samp class="mi">102</samp><samp class="o">::</samp><samp class="n">unsigned</samp><samp class="o">-</samp><samp class="n">big</samp><samp class="o">-</samp><samp class="n">integer</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="2792639556-3">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="2792639556-4">&lt;&lt;</samp><samp class="mi">102</samp><samp class="o">::</samp><samp class="n">unsigned</samp><samp class="o">-</samp><samp class="n">big</samp><samp class="o">-</samp><samp class="n">integer</samp><samp class="o">-</samp><samp class="n">size</samp><samp class="p" data-group-id="2792639556-5">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="2792639556-5">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="2792639556-4">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="2792639556-6">&lt;&lt;</samp><samp class="mi">102</samp><samp class="o">::</samp><samp class="n">unsigned</samp><samp class="o">-</samp><samp class="n">big</samp><samp class="o">-</samp><samp class="n">integer</samp><samp class="o">-</samp><samp class="mi">8</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="2792639556-6">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="2792639556-7">&lt;&lt;</samp><samp class="mi">102</samp><samp class="o">::</samp><samp class="mi">8</samp><samp class="o">-</samp><samp class="n">integer</samp><samp class="o">-</samp><samp class="n">big</samp><samp class="o">-</samp><samp class="n">unsigned</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="2792639556-7">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="2792639556-8">&lt;&lt;</samp><samp class="mi">102</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="2792639556-8">&gt;&gt;</samp></code></pre><h3 id="%3C%3C%3E%3E/1-unit-and-size" class="section-heading"><a href="#%3C%3C%3E%3E/1-unit-and-size" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Unit and Size</span></h3><p>The length of the match is equal to the <code class="inline">unit</code> (a number of bits) times the
<code class="inline">size</code> (the number of repeated segments of length <code class="inline">unit</code>).</p><table><thead><tr><th style="text-align: left;">Type</th><th style="text-align: left;">Default Unit</th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">integer</code></td><td style="text-align: left;">1 bit</td></tr><tr><td style="text-align: left;"><code class="inline">float</code></td><td style="text-align: left;">1 bit</td></tr><tr><td style="text-align: left;"><code class="inline">binary</code></td><td style="text-align: left;">8 bits</td></tr></tbody></table><p>Sizes for types are a bit more nuanced. The default size for integers is 8.</p><p>For floats, it is 64. For floats, <code class="inline">size * unit</code> must result in 16, 32, or 64,
corresponding to <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a>
binary16, binary32, and binary64, respectively.</p><p>For binaries, the default is the size of the binary. Only the last binary in a
match can use the default size. All others must have their size specified
explicitly, even if the match is unambiguous. For example:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="9329501178-1">&lt;&lt;</samp><samp class="n">name</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="o">-</samp><samp class="n">size</samp><samp class="p" data-group-id="9329501178-2">(</samp><samp class="mi">5</samp><samp class="p" data-group-id="9329501178-2">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot; the &quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">species</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="9329501178-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="9329501178-3">&lt;&lt;</samp><samp class="s">&quot;Frank the Walrus&quot;</samp><samp class="p" data-group-id="9329501178-3">&gt;&gt;</samp><samp class="w">
</samp><samp class="s">&quot;Frank the Walrus&quot;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="9329501178-4">{</samp><samp class="n">name</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">species</samp><samp class="p" data-group-id="9329501178-4">}</samp><samp class="w">
</samp><samp class="p" data-group-id="9329501178-5">{</samp><samp class="s">&quot;Frank&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;Walrus&quot;</samp><samp class="p" data-group-id="9329501178-5">}</samp></code></pre><p>The size can be a variable or any valid guard expression:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">name_size</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">5</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="8682569454-1">&lt;&lt;</samp><samp class="n">name</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="o">-</samp><samp class="n">size</samp><samp class="p" data-group-id="8682569454-2">(</samp><samp class="o">^</samp><samp class="n">name_size</samp><samp class="p" data-group-id="8682569454-2">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot; the &quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">species</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="8682569454-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="8682569454-3">&lt;&lt;</samp><samp class="s">&quot;Frank the Walrus&quot;</samp><samp class="p" data-group-id="8682569454-3">&gt;&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="8682569454-4">{</samp><samp class="n">name</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">species</samp><samp class="p" data-group-id="8682569454-4">}</samp><samp class="w">
</samp><samp class="p" data-group-id="8682569454-5">{</samp><samp class="s">&quot;Frank&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;Walrus&quot;</samp><samp class="p" data-group-id="8682569454-5">}</samp></code></pre><p>The size can access prior variables defined in the binary itself:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="4174299259-1">&lt;&lt;</samp><samp class="n">name_size</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="4174299259-2">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="4174299259-2">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">name</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="o">-</samp><samp class="n">size</samp><samp class="p" data-group-id="4174299259-3">(</samp><samp class="n">name_size</samp><samp class="p" data-group-id="4174299259-3">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot; the &quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">species</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="4174299259-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="4174299259-4">&lt;&lt;</samp><samp class="mi">5</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;Frank the Walrus&quot;</samp><samp class="p" data-group-id="4174299259-4">&gt;&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="4174299259-5">{</samp><samp class="n">name</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">species</samp><samp class="p" data-group-id="4174299259-5">}</samp><samp class="w">
</samp><samp class="p" data-group-id="4174299259-6">{</samp><samp class="s">&quot;Frank&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;Walrus&quot;</samp><samp class="p" data-group-id="4174299259-6">}</samp></code></pre><p>However, it cannot access variables defined in the match outside of the binary/bitstring:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="8127968354-1">{</samp><samp class="n">name_size</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8127968354-2">&lt;&lt;</samp><samp class="n">name</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="o">-</samp><samp class="n">size</samp><samp class="p" data-group-id="8127968354-3">(</samp><samp class="n">name_size</samp><samp class="p" data-group-id="8127968354-3">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="c">_rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="8127968354-2">&gt;&gt;</samp><samp class="p" data-group-id="8127968354-1">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="8127968354-4">{</samp><samp class="mi">5</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8127968354-5">&lt;&lt;</samp><samp class="s">&quot;Frank the Walrus&quot;</samp><samp class="p" data-group-id="8127968354-5">&gt;&gt;</samp><samp class="p" data-group-id="8127968354-4">}</samp><samp class="w">
</samp><samp class="gt">** (CompileError): undefined variable &quot;name_size&quot; in bitstring segment</samp></code></pre><p>Failing to specify the size for the non-last causes compilation to fail:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="0753742799-1">&lt;&lt;</samp><samp class="n">name</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot; the &quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">species</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="0753742799-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="0753742799-2">&lt;&lt;</samp><samp class="s">&quot;Frank the Walrus&quot;</samp><samp class="p" data-group-id="0753742799-2">&gt;&gt;</samp><samp class="w">
</samp><samp class="gt">** (CompileError): a binary field without size is only allowed at the end of a binary pattern</samp></code></pre><h4>Shortcut Syntax</h4><p>Size and unit can also be specified using a syntax shortcut
when passing integer values:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="9179565414-1">&lt;&lt;</samp><samp class="n">x</samp><samp class="o">::</samp><samp class="mi">8</samp><samp class="p" data-group-id="9179565414-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">==</samp><samp class="w"> </samp><samp class="p" data-group-id="9179565414-2">&lt;&lt;</samp><samp class="n">x</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9179565414-3">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9179565414-3">)</samp><samp class="p" data-group-id="9179565414-2">&gt;&gt;</samp><samp class="w">
</samp><samp class="no">true</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="9179565414-4">&lt;&lt;</samp><samp class="n">x</samp><samp class="o">::</samp><samp class="mi">8</samp><samp class="o">*</samp><samp class="mi">4</samp><samp class="p" data-group-id="9179565414-4">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">==</samp><samp class="w"> </samp><samp class="p" data-group-id="9179565414-5">&lt;&lt;</samp><samp class="n">x</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9179565414-6">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9179565414-6">)</samp><samp class="o">-</samp><samp class="n">unit</samp><samp class="p" data-group-id="9179565414-7">(</samp><samp class="mi">4</samp><samp class="p" data-group-id="9179565414-7">)</samp><samp class="p" data-group-id="9179565414-5">&gt;&gt;</samp><samp class="w">
</samp><samp class="no">true</samp></code></pre><p>This syntax reflects the fact the effective size is given by
multiplying the size by the unit.</p><h3 id="%3C%3C%3E%3E/1-modifiers" class="section-heading"><a href="#%3C%3C%3E%3E/1-modifiers" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Modifiers</span></h3><p>Some types have associated modifiers to clear up ambiguity in byte
representation.</p><table><thead><tr><th style="text-align: left;">Modifier</th><th style="text-align: left;">Relevant Type(s)</th></tr></thead><tbody><tr><td style="text-align: left;"><code class="inline">signed</code></td><td style="text-align: left;"><code class="inline">integer</code></td></tr><tr><td style="text-align: left;"><code class="inline">unsigned</code> (default)</td><td style="text-align: left;"><code class="inline">integer</code></td></tr><tr><td style="text-align: left;"><code class="inline">little</code></td><td style="text-align: left;"><code class="inline">integer</code>, <code class="inline">float</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code></td></tr><tr><td style="text-align: left;"><code class="inline">big</code> (default)</td><td style="text-align: left;"><code class="inline">integer</code>, <code class="inline">float</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code></td></tr><tr><td style="text-align: left;"><code class="inline">native</code></td><td style="text-align: left;"><code class="inline">integer</code>, <code class="inline">float</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code></td></tr></tbody></table><h3 id="%3C%3C%3E%3E/1-sign" class="section-heading"><a href="#%3C%3C%3E%3E/1-sign" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Sign</span></h3><p>Integers can be <code class="inline">signed</code> or <code class="inline">unsigned</code>, defaulting to <code class="inline">unsigned</code>.</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="0471780932-1">&lt;&lt;</samp><samp class="n">int</samp><samp class="o">::</samp><samp class="n">integer</samp><samp class="p" data-group-id="0471780932-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="0471780932-2">&lt;&lt;</samp><samp class="o">-</samp><samp class="mi">100</samp><samp class="p" data-group-id="0471780932-2">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="0471780932-3">&lt;&lt;</samp><samp class="mi">156</samp><samp class="p" data-group-id="0471780932-3">&gt;&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">int</samp><samp class="w">
</samp><samp class="mi">156</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="0471780932-4">&lt;&lt;</samp><samp class="n">int</samp><samp class="o">::</samp><samp class="n">integer</samp><samp class="o">-</samp><samp class="n">signed</samp><samp class="p" data-group-id="0471780932-4">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="0471780932-5">&lt;&lt;</samp><samp class="o">-</samp><samp class="mi">100</samp><samp class="p" data-group-id="0471780932-5">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="0471780932-6">&lt;&lt;</samp><samp class="mi">156</samp><samp class="p" data-group-id="0471780932-6">&gt;&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">int</samp><samp class="w">
</samp><samp class="o">-</samp><samp class="mi">100</samp></code></pre><p><code class="inline">signed</code> and <code class="inline">unsigned</code> are only used for matching binaries (see below) and
are only used for integers.</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="1637184135-1">&lt;&lt;</samp><samp class="o">-</samp><samp class="mi">100</samp><samp class="o">::</samp><samp class="n">signed</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="c">_rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="1637184135-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="1637184135-2">&lt;&lt;</samp><samp class="o">-</samp><samp class="mi">100</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;foo&quot;</samp><samp class="p" data-group-id="1637184135-2">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="1637184135-3">&lt;&lt;</samp><samp class="mi">156</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">102</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">111</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">111</samp><samp class="p" data-group-id="1637184135-3">&gt;&gt;</samp></code></pre><h3 id="%3C%3C%3E%3E/1-endianness" class="section-heading"><a href="#%3C%3C%3E%3E/1-endianness" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Endianness</span></h3><p>Elixir has three options for endianness: <code class="inline">big</code>, <code class="inline">little</code>, and <code class="inline">native</code>.
The default is <code class="inline">big</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="5149728320-1">&lt;&lt;</samp><samp class="n">number</samp><samp class="o">::</samp><samp class="n">little</samp><samp class="o">-</samp><samp class="n">integer</samp><samp class="o">-</samp><samp class="n">size</samp><samp class="p" data-group-id="5149728320-2">(</samp><samp class="mi">16</samp><samp class="p" data-group-id="5149728320-2">)</samp><samp class="p" data-group-id="5149728320-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="5149728320-3">&lt;&lt;</samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="5149728320-3">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="5149728320-4">&lt;&lt;</samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="5149728320-4">&gt;&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">number</samp><samp class="w">
</samp><samp class="mi">256</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="5149728320-5">&lt;&lt;</samp><samp class="n">number</samp><samp class="o">::</samp><samp class="n">big</samp><samp class="o">-</samp><samp class="n">integer</samp><samp class="o">-</samp><samp class="n">size</samp><samp class="p" data-group-id="5149728320-6">(</samp><samp class="mi">16</samp><samp class="p" data-group-id="5149728320-6">)</samp><samp class="p" data-group-id="5149728320-5">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="5149728320-7">&lt;&lt;</samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="5149728320-7">&gt;&gt;</samp><samp class="w">
</samp><samp class="p" data-group-id="5149728320-8">&lt;&lt;</samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="5149728320-8">&gt;&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">number</samp><samp class="w">
</samp><samp class="mi">1</samp></code></pre><p><code class="inline">native</code> is determined by the VM at startup and will depend on the
host operating system.</p><h2 id="%3C%3C%3E%3E/1-binary-bitstring-matching" class="section-heading"><a href="#%3C%3C%3E%3E/1-binary-bitstring-matching" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Binary/Bitstring Matching</span></h2><p>Binary matching is a powerful feature in Elixir that is useful for extracting
information from binaries as well as pattern matching.</p><p>Binary matching can be used by itself to extract information from binaries:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="7654328634-1">&lt;&lt;</samp><samp class="s">&quot;Hello, &quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">place</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="7654328634-1">&gt;&gt;</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="s">&quot;Hello, World&quot;</samp><samp class="w">
</samp><samp class="s">&quot;Hello, World&quot;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">place</samp><samp class="w">
</samp><samp class="s">&quot;World&quot;</samp></code></pre><p>Or as a part of function definitions to pattern match:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">ImageType</samp><samp class="w"> </samp><samp class="k" data-group-id="9468496799-1">do</samp><samp class="w">
  </samp><samp class="na">@png_signature</samp><samp class="w"> </samp><samp class="p" data-group-id="9468496799-2">&lt;&lt;</samp><samp class="mi">137</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-3">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-3">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">80</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-4">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-4">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">78</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-5">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-5">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">71</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-6">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-6">)</samp><samp class="p">,</samp><samp class="w">
                   </samp><samp class="mi">13</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-7">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-7">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-8">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-8">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">26</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-9">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-9">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-10">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-10">)</samp><samp class="p" data-group-id="9468496799-2">&gt;&gt;</samp><samp class="w">
  </samp><samp class="na">@jpg_signature</samp><samp class="w"> </samp><samp class="p" data-group-id="9468496799-11">&lt;&lt;</samp><samp class="mi">255</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-12">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-12">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">216</samp><samp class="o">::</samp><samp class="n">size</samp><samp class="p" data-group-id="9468496799-13">(</samp><samp class="mi">8</samp><samp class="p" data-group-id="9468496799-13">)</samp><samp class="p" data-group-id="9468496799-11">&gt;&gt;</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">type</samp><samp class="p" data-group-id="9468496799-14">(</samp><samp class="p" data-group-id="9468496799-15">&lt;&lt;</samp><samp class="na">@png_signature</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="c">_rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="9468496799-15">&gt;&gt;</samp><samp class="p" data-group-id="9468496799-14">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:png</samp><samp class="w">
  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">type</samp><samp class="p" data-group-id="9468496799-16">(</samp><samp class="p" data-group-id="9468496799-17">&lt;&lt;</samp><samp class="na">@jpg_signature</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="c">_rest</samp><samp class="o">::</samp><samp class="n">binary</samp><samp class="p" data-group-id="9468496799-17">&gt;&gt;</samp><samp class="p" data-group-id="9468496799-16">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:jpg</samp><samp class="w">
  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">type</samp><samp class="p" data-group-id="9468496799-18">(</samp><samp class="bp">_</samp><samp class="p" data-group-id="9468496799-18">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:unknown</samp><samp class="w">
</samp><samp class="k" data-group-id="9468496799-1">end</samp></code></pre><h3 id="%3C%3C%3E%3E/1-performance-optimizations" class="section-heading"><a href="#%3C%3C%3E%3E/1-performance-optimizations" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Performance &amp; Optimizations</span></h3><p>The Erlang compiler can provide a number of optimizations on binary creation
and matching. To see optimization output, set the <code class="inline">bin_opt_info</code> compiler
option:</p><pre><code class="makeup elixir" translate="no"><samp class="nc">ERL_COMPILER_OPTIONS</samp><samp class="o">=</samp><samp class="n">bin_opt_info</samp><samp class="w"> </samp><samp class="n">mix</samp><samp class="w"> </samp><samp class="n">compile</samp></code></pre><p>To learn more about specific optimizations and performance considerations,
check out the
<a href="https://www.erlang.org/doc/efficiency_guide/binaryhandling.html">&quot;Constructing and matching binaries&quot; chapter of the Erlang's Efficiency Guide</a>.</p>
  </section>
</section>
<section class="detail" id="=/2">

  <div class="detail-header">
    <a href="#=/2" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">left = right</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L766" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Match operator. Matches the value on the right against the pattern on the left.</p>
  </section>
</section>
<section class="detail" id="alias/2">

  <div class="detail-header">
    <a href="#alias/2" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">alias(module, opts)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L555" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p><a href="#alias/2"><code class="inline">alias/2</code></a> is used to set up aliases, often useful with modules' names.</p><h2 id="alias/2-examples" class="section-heading"><a href="#alias/2-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><p><a href="#alias/2"><code class="inline">alias/2</code></a> can be used to set up an alias for any module:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Math</samp><samp class="w"> </samp><samp class="k" data-group-id="5985614761-1">do</samp><samp class="w">
  </samp><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">MyKeyword</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">as</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="nc">Keyword</samp><samp class="w">
</samp><samp class="k" data-group-id="5985614761-1">end</samp></code></pre><p>In the example above, we have set up <code class="inline">MyKeyword</code> to be aliased
as <a href="Keyword.xhtml"><code class="inline">Keyword</code></a>. So now, any reference to <a href="Keyword.xhtml"><code class="inline">Keyword</code></a> will be
automatically replaced by <code class="inline">MyKeyword</code>.</p><p>In case one wants to access the original <a href="Keyword.xhtml"><code class="inline">Keyword</code></a>, it can be done
by accessing <code class="inline">Elixir</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="nc">Keyword</samp><samp class="o">.</samp><samp class="n">values</samp><samp class="w"> </samp><samp class="c1">#=&gt; uses MyKeyword.values</samp><samp class="w">
</samp><samp class="nc">Elixir.Keyword</samp><samp class="o">.</samp><samp class="n">values</samp><samp class="w"> </samp><samp class="c1">#=&gt; uses Keyword.values</samp></code></pre><p>Note that calling <code class="inline">alias</code> without the <code class="inline">:as</code> option automatically
sets an alias based on the last part of the module. For example:</p><pre><code class="makeup elixir" translate="no"><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">Foo.Bar.Baz</samp></code></pre><p>Is the same as:</p><pre><code class="makeup elixir" translate="no"><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">Foo.Bar.Baz</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">as</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="nc">Baz</samp></code></pre><p>We can also alias multiple modules in one line:</p><pre><code class="makeup elixir" translate="no"><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">Foo</samp><samp class="o">.</samp><samp class="p" data-group-id="7913005138-1">{</samp><samp class="nc">Bar</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">Baz</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">Biz</samp><samp class="p" data-group-id="7913005138-1">}</samp></code></pre><p>Is the same as:</p><pre><code class="makeup elixir" translate="no"><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">Foo.Bar</samp><samp class="w">
</samp><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">Foo.Baz</samp><samp class="w">
</samp><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">Foo.Biz</samp></code></pre><h2 id="alias/2-lexical-scope" class="section-heading"><a href="#alias/2-lexical-scope" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Lexical scope</span></h2><p><a href="#import/2"><code class="inline">import/2</code></a>, <a href="#require/2"><code class="inline">require/2</code></a> and <a href="#alias/2"><code class="inline">alias/2</code></a> are called directives and all
have lexical scope. This means you can set up aliases inside
specific functions and it won't affect the overall scope.</p><h2 id="alias/2-warnings" class="section-heading"><a href="#alias/2-warnings" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Warnings</span></h2><p>If you alias a module and you don't use the alias, Elixir is
going to issue a warning implying the alias is not being used.</p><p>In case the alias is generated automatically by a macro,
Elixir won't emit any warnings though, since the alias
was not explicitly defined.</p><p>Both warning behaviors could be changed by explicitly
setting the <code class="inline">:warn</code> option to <code class="inline">true</code> or <code class="inline">false</code>.</p>
  </section>
</section>
<section class="detail" id="case/2">

  <div class="detail-header">
    <a href="#case/2" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">case(condition, clauses)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1988" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Matches the given expression against the given clauses.</p><p><a href="#case/2"><code class="inline">case/2</code></a> relies on pattern matching and guards to choose
which clause to execute. If your logic cannot be expressed
within patterns and guards, consider using <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a> or <a href="#cond/1"><code class="inline">cond/1</code></a>
instead.</p><h2 id="case/2-examples" class="section-heading"><a href="#case/2-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><pre><code class="makeup elixir" translate="no"><samp class="k">case</samp><samp class="w"> </samp><samp class="nc">File</samp><samp class="o">.</samp><samp class="n">read</samp><samp class="p" data-group-id="0039479258-1">(</samp><samp class="n">file</samp><samp class="p" data-group-id="0039479258-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="0039479258-2">do</samp><samp class="w">
  </samp><samp class="p" data-group-id="0039479258-3">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">contents</samp><samp class="p" data-group-id="0039479258-3">}</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">is_binary</samp><samp class="p" data-group-id="0039479258-4">(</samp><samp class="n">contents</samp><samp class="p" data-group-id="0039479258-4">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">String</samp><samp class="o">.</samp><samp class="n">split</samp><samp class="p" data-group-id="0039479258-5">(</samp><samp class="n">contents</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;</samp><samp class="se">\n</samp><samp class="s">&quot;</samp><samp class="p" data-group-id="0039479258-5">)</samp><samp class="w">

  </samp><samp class="p" data-group-id="0039479258-6">{</samp><samp class="ss">:error</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="c">_reason</samp><samp class="p" data-group-id="0039479258-6">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">Logger</samp><samp class="o">.</samp><samp class="n">warning</samp><samp class="w"> </samp><samp class="s">&quot;could not find </samp><samp class="si" data-group-id="0039479258-7">#{</samp><samp class="n">file</samp><samp class="si" data-group-id="0039479258-7">}</samp><samp class="s">, assuming empty...&quot;</samp><samp class="w">
    </samp><samp class="p" data-group-id="0039479258-8">[</samp><samp class="p" data-group-id="0039479258-8">]</samp><samp class="w">
</samp><samp class="k" data-group-id="0039479258-2">end</samp></code></pre><p>In the example above, we match the result of <a href="File.xhtml#read/1"><code class="inline">File.read/1</code></a>
against each clause &quot;head&quot; and execute the clause &quot;body&quot;
corresponding to the first clause that matches.</p><p>If no clause matches, an error is raised. For this reason,
it may be necessary to add a final catch-all clause (like <code class="inline">_</code>)
which will always match.</p><pre><code class="makeup elixir" translate="no"><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="w">

</samp><samp class="k">case</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="k" data-group-id="8258111736-1">do</samp><samp class="w">
  </samp><samp class="mi">0</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="s">&quot;This clause won&#39;t match&quot;</samp><samp class="w">

  </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="s">&quot;This clause would match any value (x = </samp><samp class="si" data-group-id="8258111736-2">#{</samp><samp class="n">x</samp><samp class="si" data-group-id="8258111736-2">}</samp><samp class="s">)&quot;</samp><samp class="w">
</samp><samp class="k" data-group-id="8258111736-1">end</samp><samp class="w">
</samp><samp class="c1">#=&gt; &quot;This clause would match any value (x = 10)&quot;</samp></code></pre><p>If you find yourself nesting <code class="inline">case</code> expressions inside
<code class="inline">case</code> expressions, consider using <a href="#with/1"><code class="inline">with/1</code></a>.</p><h2 id="case/2-variable-handling" class="section-heading"><a href="#case/2-variable-handling" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Variable handling</span></h2><p>Note that variables bound in a clause do not leak to the outer context:</p><pre><code class="makeup elixir" translate="no"><samp class="k">case</samp><samp class="w"> </samp><samp class="n">data</samp><samp class="w"> </samp><samp class="k" data-group-id="2371565227-1">do</samp><samp class="w">
  </samp><samp class="p" data-group-id="2371565227-2">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">value</samp><samp class="p" data-group-id="2371565227-2">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">value</samp><samp class="w">
  </samp><samp class="ss">:error</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="w">
</samp><samp class="k" data-group-id="2371565227-1">end</samp><samp class="w">

</samp><samp class="n">value</samp><samp class="w">
</samp><samp class="c1">#=&gt; unbound variable value</samp></code></pre><p>Variables in the outer context cannot be overridden either:</p><pre><code class="makeup elixir" translate="no"><samp class="n">value</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">7</samp><samp class="w">

</samp><samp class="k">case</samp><samp class="w"> </samp><samp class="n">lucky?</samp><samp class="w"> </samp><samp class="k" data-group-id="0716022457-1">do</samp><samp class="w">
  </samp><samp class="no">false</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">value</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">13</samp><samp class="w">
  </samp><samp class="no">true</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="no">true</samp><samp class="w">
</samp><samp class="k" data-group-id="0716022457-1">end</samp><samp class="w">

</samp><samp class="n">value</samp><samp class="w">
</samp><samp class="c1">#=&gt; 7</samp></code></pre><p>In the example above, <code class="inline">value</code> is going to be <code class="inline">7</code> regardless of the value of
<code class="inline">lucky?</code>. The variable <code class="inline">value</code> bound in the clause and the variable <code class="inline">value</code>
bound in the outer context are two entirely separate variables.</p><p>If you want to pattern match against an existing variable,
you need to use the <a href="#%5E/1"><code class="inline">^/1</code></a> operator:</p><pre><code class="makeup elixir" translate="no"><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">

</samp><samp class="k">case</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="w"> </samp><samp class="k" data-group-id="7686031609-1">do</samp><samp class="w">
  </samp><samp class="o">^</samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="s">&quot;Won&#39;t match&quot;</samp><samp class="w">
  </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="s">&quot;Will match&quot;</samp><samp class="w">
</samp><samp class="k" data-group-id="7686031609-1">end</samp><samp class="w">
</samp><samp class="c1">#=&gt; &quot;Will match&quot;</samp></code></pre><h2 id="case/2-using-guards-to-match-against-multiple-values" class="section-heading"><a href="#case/2-using-guards-to-match-against-multiple-values" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Using guards to match against multiple values</span></h2><p>While it is not possible to match against multiple patterns in a single
clause, it's possible to match against multiple values by using guards:</p><pre><code class="makeup elixir" translate="no"><samp class="k">case</samp><samp class="w"> </samp><samp class="n">data</samp><samp class="w"> </samp><samp class="k" data-group-id="7014928576-1">do</samp><samp class="w">
  </samp><samp class="n">value</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">value</samp><samp class="w"> </samp><samp class="ow">in</samp><samp class="w"> </samp><samp class="p" data-group-id="7014928576-2">[</samp><samp class="ss">:one</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:two</samp><samp class="p" data-group-id="7014928576-2">]</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="s">&quot;</samp><samp class="si" data-group-id="7014928576-3">#{</samp><samp class="n">value</samp><samp class="si" data-group-id="7014928576-3">}</samp><samp class="s"> has been matched&quot;</samp><samp class="w">

  </samp><samp class="ss">:three</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="s">&quot;three has been matched&quot;</samp><samp class="w">
</samp><samp class="k" data-group-id="7014928576-1">end</samp></code></pre>
  </section>
</section>
<section class="detail" id="cond/1">

  <div class="detail-header">
    <a href="#cond/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">cond(clauses)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L2023" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Evaluates the expression corresponding to the first clause that
evaluates to a truthy value.</p><h2 id="cond/1-examples" class="section-heading"><a href="#cond/1-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><p>The following example has a single clause that always evaluates
to true:</p><pre><code class="makeup elixir" translate="no"><samp class="k">cond</samp><samp class="w"> </samp><samp class="k" data-group-id="4127407727-1">do</samp><samp class="w">
  </samp><samp class="n">hd</samp><samp class="p" data-group-id="4127407727-2">(</samp><samp class="p" data-group-id="4127407727-3">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="4127407727-3">]</samp><samp class="p" data-group-id="4127407727-2">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="s">&quot;1 is considered as true&quot;</samp><samp class="w">
</samp><samp class="k" data-group-id="4127407727-1">end</samp><samp class="w">
</samp><samp class="c1">#=&gt; &quot;1 is considered as true&quot;</samp></code></pre><p>If all clauses evaluate to <code class="inline">nil</code> or <code class="inline">false</code>, <code class="inline">cond</code> raises an error.
For this reason, it may be necessary to add a final always-truthy condition
(anything non-<code class="inline">false</code> and non-<code class="inline">nil</code>), which will always match:</p><pre><code class="makeup elixir" translate="no"><samp class="k">cond</samp><samp class="w"> </samp><samp class="k" data-group-id="5783957396-1">do</samp><samp class="w">
  </samp><samp class="mi">1</samp><samp class="w"> </samp><samp class="o">+</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w"> </samp><samp class="o">==</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="s">&quot;This will never match&quot;</samp><samp class="w">
  </samp><samp class="mi">2</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="w"> </samp><samp class="o">!=</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="s">&quot;Nor this&quot;</samp><samp class="w">
  </samp><samp class="no">true</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="s">&quot;This will&quot;</samp><samp class="w">
</samp><samp class="k" data-group-id="5783957396-1">end</samp><samp class="w">
</samp><samp class="c1">#=&gt; &quot;This will&quot;</samp></code></pre><p>If your <code class="inline">cond</code> has two clauses, and the last one falls back to
<code class="inline">true</code>, you may consider using <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a> instead.</p>
  </section>
</section>
<section class="detail" id="fn/1">

  <div class="detail-header">
    <a href="#fn/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">fn(clauses)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1738" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Defines an anonymous function.</p><p>See <a href="Function.xhtml"><code class="inline">Function</code></a> for more information.</p><h2 id="fn/1-examples" class="section-heading"><a href="#fn/1-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">add</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="k" data-group-id="2933810419-1">fn</samp><samp class="w"> </samp><samp class="n">a</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">b</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">a</samp><samp class="w"> </samp><samp class="o">+</samp><samp class="w"> </samp><samp class="n">b</samp><samp class="w"> </samp><samp class="k" data-group-id="2933810419-1">end</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">add</samp><samp class="o">.</samp><samp class="p" data-group-id="2933810419-2">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="2933810419-2">)</samp><samp class="w">
</samp><samp class="mi">3</samp></code></pre><p>Anonymous functions can also have multiple clauses. All clauses
should expect the same number of arguments:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">negate</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="k" data-group-id="1282584238-1">fn</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="no">true</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="no">false</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="no">true</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="1282584238-1">end</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">negate</samp><samp class="o">.</samp><samp class="p" data-group-id="1282584238-2">(</samp><samp class="no">false</samp><samp class="p" data-group-id="1282584238-2">)</samp><samp class="w">
</samp><samp class="no">true</samp></code></pre>
  </section>
</section>
<section class="detail" id="for/1">

  <div class="detail-header">
    <a href="#for/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">for(args)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1537" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring.</p><p>Let's start with an example:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="n">n</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="p" data-group-id="8787627911-1">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p" data-group-id="8787627911-1">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">n</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="w">
</samp><samp class="p" data-group-id="8787627911-2">[</samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">6</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">8</samp><samp class="p" data-group-id="8787627911-2">]</samp></code></pre><p>A comprehension accepts many generators and filters. <code class="inline">for</code> uses
the <code class="inline">&lt;-</code> operator to extract values from the enumerable on its
right side and match them against the pattern on the left.
We call them generators:</p><pre><code class="makeup elixir" translate="no"><samp class="c1"># A list generator:</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="n">n</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="p" data-group-id="5695668749-1">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p" data-group-id="5695668749-1">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">n</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="w">
</samp><samp class="p" data-group-id="5695668749-2">[</samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">6</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">8</samp><samp class="p" data-group-id="5695668749-2">]</samp><samp class="w">

</samp><samp class="c1"># A comprehension with two generators</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="p" data-group-id="5695668749-3">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="5695668749-3">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">y</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="p" data-group-id="5695668749-4">[</samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="5695668749-4">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">y</samp><samp class="w">
</samp><samp class="p" data-group-id="5695668749-5">[</samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">6</samp><samp class="p" data-group-id="5695668749-5">]</samp></code></pre><p>Filters can also be given:</p><pre><code class="makeup elixir" translate="no"><samp class="c1"># A comprehension with a generator and a filter</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="n">n</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="p" data-group-id="6455851761-1">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">5</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">6</samp><samp class="p" data-group-id="6455851761-1">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">rem</samp><samp class="p" data-group-id="6455851761-2">(</samp><samp class="n">n</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="6455851761-2">)</samp><samp class="w"> </samp><samp class="o">==</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">n</samp><samp class="w">
</samp><samp class="p" data-group-id="6455851761-3">[</samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">6</samp><samp class="p" data-group-id="6455851761-3">]</samp></code></pre><p>Filters must evaluate to truthy values (everything but <code class="inline">nil</code>
and <code class="inline">false</code>). If a filter is falsy, then the current value is
discarded.</p><p>Generators can also be used to filter as it removes any value
that doesn't match the pattern on the left side of <code class="inline">&lt;-</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">users</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="9423016500-1">[</samp><samp class="ss">user</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;john&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">admin</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;meg&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">guest</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;barbara&quot;</samp><samp class="p" data-group-id="9423016500-1">]</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="p" data-group-id="9423016500-2">{</samp><samp class="n">type</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">name</samp><samp class="p" data-group-id="9423016500-2">}</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">type</samp><samp class="w"> </samp><samp class="o">!=</samp><samp class="w"> </samp><samp class="ss">:guest</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="n">users</samp><samp class="w"> </samp><samp class="k" data-group-id="9423016500-3">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="nc">String</samp><samp class="o">.</samp><samp class="n">upcase</samp><samp class="p" data-group-id="9423016500-4">(</samp><samp class="n">name</samp><samp class="p" data-group-id="9423016500-4">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="9423016500-3">end</samp><samp class="w">
</samp><samp class="p" data-group-id="9423016500-5">[</samp><samp class="s">&quot;JOHN&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;MEG&quot;</samp><samp class="p" data-group-id="9423016500-5">]</samp></code></pre><p>Bitstring generators are also supported and are very useful when you
need to organize bitstring streams:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">pixels</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="6761698989-1">&lt;&lt;</samp><samp class="mi">213</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">45</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">132</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">64</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">76</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">32</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">76</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">234</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">32</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">15</samp><samp class="p" data-group-id="6761698989-1">&gt;&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="p" data-group-id="6761698989-2">&lt;&lt;</samp><samp class="n">r</samp><samp class="o">::</samp><samp class="mi">8</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">g</samp><samp class="o">::</samp><samp class="mi">8</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">b</samp><samp class="o">::</samp><samp class="mi">8</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="n">pixels</samp><samp class="p" data-group-id="6761698989-2">&gt;&gt;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="6761698989-3">{</samp><samp class="n">r</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">g</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">b</samp><samp class="p" data-group-id="6761698989-3">}</samp><samp class="w">
</samp><samp class="p" data-group-id="6761698989-4">[</samp><samp class="p" data-group-id="6761698989-5">{</samp><samp class="mi">213</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">45</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">132</samp><samp class="p" data-group-id="6761698989-5">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6761698989-6">{</samp><samp class="mi">64</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">76</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">32</samp><samp class="p" data-group-id="6761698989-6">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6761698989-7">{</samp><samp class="mi">76</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p" data-group-id="6761698989-7">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6761698989-8">{</samp><samp class="mi">234</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">32</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">15</samp><samp class="p" data-group-id="6761698989-8">}</samp><samp class="p" data-group-id="6761698989-4">]</samp></code></pre><p>Variable assignments inside the comprehension, be it in generators,
filters or inside the block, are not reflected outside of the
comprehension.</p><p>Variable assignments inside filters must still return a truthy value,
otherwise values are discarded. Let's see an example. Imagine you have
a keyword list where the key is a programming language and the value
is its direct parent. Then let's try to compute the grandparent of each
language. You could try this:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">languages</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="3778933336-1">[</samp><samp class="ss">elixir</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:erlang</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">erlang</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:prolog</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">prolog</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="p" data-group-id="3778933336-1">]</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="p" data-group-id="3778933336-2">{</samp><samp class="n">language</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">parent</samp><samp class="p" data-group-id="3778933336-2">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="n">languages</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">grandparent</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">languages</samp><samp class="p" data-group-id="3778933336-3">[</samp><samp class="n">parent</samp><samp class="p" data-group-id="3778933336-3">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="3778933336-4">{</samp><samp class="n">language</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">grandparent</samp><samp class="p" data-group-id="3778933336-4">}</samp><samp class="w">
</samp><samp class="p" data-group-id="3778933336-5">[</samp><samp class="ss">elixir</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:prolog</samp><samp class="p" data-group-id="3778933336-5">]</samp></code></pre><p>Given the grandparents of Erlang and Prolog were nil, those values were
filtered out. If you don't want this behavior, a simple option is to
move the filter inside the do-block:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">languages</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="3078788753-1">[</samp><samp class="ss">elixir</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:erlang</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">erlang</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:prolog</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">prolog</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="p" data-group-id="3078788753-1">]</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="p" data-group-id="3078788753-2">{</samp><samp class="n">language</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">parent</samp><samp class="p" data-group-id="3078788753-2">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="n">languages</samp><samp class="w"> </samp><samp class="k" data-group-id="3078788753-3">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="n">grandparent</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">languages</samp><samp class="p" data-group-id="3078788753-4">[</samp><samp class="n">parent</samp><samp class="p" data-group-id="3078788753-4">]</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="3078788753-5">{</samp><samp class="n">language</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">grandparent</samp><samp class="p" data-group-id="3078788753-5">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="3078788753-3">end</samp><samp class="w">
</samp><samp class="p" data-group-id="3078788753-6">[</samp><samp class="ss">elixir</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:prolog</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">erlang</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">prolog</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="p" data-group-id="3078788753-6">]</samp></code></pre><p>However, such option is not always available, as you may have further
filters. An alternative is to convert the filter into a generator by
wrapping the right side of <code class="inline">=</code> in a list:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">languages</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="6934126279-1">[</samp><samp class="ss">elixir</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:erlang</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">erlang</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:prolog</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">prolog</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="p" data-group-id="6934126279-1">]</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="p" data-group-id="6934126279-2">{</samp><samp class="n">language</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">parent</samp><samp class="p" data-group-id="6934126279-2">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="n">languages</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">grandparent</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="p" data-group-id="6934126279-3">[</samp><samp class="n">languages</samp><samp class="p" data-group-id="6934126279-4">[</samp><samp class="n">parent</samp><samp class="p" data-group-id="6934126279-4">]</samp><samp class="p" data-group-id="6934126279-3">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="6934126279-5">{</samp><samp class="n">language</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">grandparent</samp><samp class="p" data-group-id="6934126279-5">}</samp><samp class="w">
</samp><samp class="p" data-group-id="6934126279-6">[</samp><samp class="ss">elixir</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:prolog</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">erlang</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">prolog</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="p" data-group-id="6934126279-6">]</samp></code></pre><h2 id="for/1-the-into-and-uniq-options" class="section-heading"><a href="#for/1-the-into-and-uniq-options" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">The <code class="inline">:into</code> and <code class="inline">:uniq</code> options</span></h2><p>In the examples above, the result returned by the comprehension was
always a list. The returned result can be configured by passing an
<code class="inline">:into</code> option, that accepts any structure as long as it implements
the <a href="Collectable.xhtml"><code class="inline">Collectable</code></a> protocol.</p><p>For example, we can use bitstring generators with the <code class="inline">:into</code> option
to easily remove all spaces in a string:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="p" data-group-id="6549178842-1">&lt;&lt;</samp><samp class="n">c</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="s">&quot; hello world &quot;</samp><samp class="p" data-group-id="6549178842-1">&gt;&gt;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">c</samp><samp class="w"> </samp><samp class="o">!=</samp><samp class="w"> </samp><samp class="sc">?\s</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">into</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="6549178842-2">&lt;&lt;</samp><samp class="n">c</samp><samp class="p" data-group-id="6549178842-2">&gt;&gt;</samp><samp class="w">
</samp><samp class="s">&quot;helloworld&quot;</samp></code></pre><p>The <a href="IO.xhtml"><code class="inline">IO</code></a> module provides streams, that are both <a href="Enumerable.xhtml"><code class="inline">Enumerable</code></a> and
<a href="Collectable.xhtml"><code class="inline">Collectable</code></a>, here is an upcase echo server using comprehensions:</p><pre><code class="makeup elixir" translate="no"><samp class="k">for</samp><samp class="w"> </samp><samp class="n">line</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">stream</samp><samp class="p" data-group-id="3667487624-1">(</samp><samp class="p" data-group-id="3667487624-1">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">into</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">stream</samp><samp class="p" data-group-id="3667487624-2">(</samp><samp class="p" data-group-id="3667487624-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="3667487624-3">do</samp><samp class="w">
  </samp><samp class="nc">String</samp><samp class="o">.</samp><samp class="n">upcase</samp><samp class="p" data-group-id="3667487624-4">(</samp><samp class="n">line</samp><samp class="p" data-group-id="3667487624-4">)</samp><samp class="w">
</samp><samp class="k" data-group-id="3667487624-3">end</samp></code></pre><p>Similarly, <code class="inline">uniq: true</code> can also be given to comprehensions to guarantee
the results are only added to the collection if they were not returned
before. For example:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="p" data-group-id="6926451996-1">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="6926451996-1">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">uniq</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">true</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="w">
</samp><samp class="p" data-group-id="6926451996-2">[</samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">6</samp><samp class="p" data-group-id="6926451996-2">]</samp><samp class="w">

</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="p" data-group-id="6926451996-3">&lt;&lt;</samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="s">&quot;abcabc&quot;</samp><samp class="p" data-group-id="6926451996-3">&gt;&gt;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">uniq</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">true</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">into</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="6926451996-4">&lt;&lt;</samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">-</samp><samp class="w"> </samp><samp class="mi">32</samp><samp class="p" data-group-id="6926451996-4">&gt;&gt;</samp><samp class="w">
</samp><samp class="s">&quot;ABC&quot;</samp></code></pre><h2 id="for/1-the-reduce-option" class="section-heading"><a href="#for/1-the-reduce-option" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">The <code class="inline">:reduce</code> option</span></h2><p><em>Available since Elixir v1.8</em>.</p><p>While the <code class="inline">:into</code> option allows us to customize the comprehension behavior
to a given data type, such as putting all of the values inside a map or inside
a binary, it is not always enough.</p><p>For example, imagine that you have a binary with letters where you want to
count how many times each lowercase letter happens, ignoring all uppercase
ones. For instance, for the string <code class="inline">&quot;AbCabCABc&quot;</code>, we want to return the map
<code class="inline">%{&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2, &quot;c&quot; =&gt; 1}</code>.</p><p>If we were to use <code class="inline">:into</code>, we would need a data type that computes the
frequency of each element it holds. While there is no such data type in
Elixir, you could implement one yourself.</p><p>A simpler option would be to use comprehensions for the mapping and
filtering of letters, and then we invoke <a href="Enum.xhtml#reduce/3"><code class="inline">Enum.reduce/3</code></a> to build a map,
for example:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">letters</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="p" data-group-id="4243275201-1">&lt;&lt;</samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="s">&quot;AbCabCABc&quot;</samp><samp class="p" data-group-id="4243275201-1">&gt;&gt;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="ow">in</samp><samp class="w"> </samp><samp class="sc">?a</samp><samp class="o">..</samp><samp class="sc">?z</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="4243275201-2">&lt;&lt;</samp><samp class="n">x</samp><samp class="p" data-group-id="4243275201-2">&gt;&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="nc">Enum</samp><samp class="o">.</samp><samp class="n">reduce</samp><samp class="p" data-group-id="4243275201-3">(</samp><samp class="n">letters</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4243275201-4">%{</samp><samp class="p" data-group-id="4243275201-4">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k" data-group-id="4243275201-5">fn</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">acc</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">update</samp><samp class="p" data-group-id="4243275201-6">(</samp><samp class="n">acc</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="o">&amp;</samp><samp class="w"> </samp><samp class="ni">&amp;1</samp><samp class="w"> </samp><samp class="o">+</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="4243275201-6">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4243275201-5">end</samp><samp class="p" data-group-id="4243275201-3">)</samp><samp class="w">
</samp><samp class="p" data-group-id="4243275201-7">%{</samp><samp class="s">&quot;a&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;b&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;c&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="4243275201-7">}</samp></code></pre><p>While the above is straight-forward, it has the downside of traversing the
data at least twice. If you are expecting long strings as inputs, this can
be quite expensive.</p><p>Luckily, comprehensions also support the <code class="inline">:reduce</code> option, which would allow
us to fuse both steps above into a single step:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">for</samp><samp class="w"> </samp><samp class="p" data-group-id="4324621692-1">&lt;&lt;</samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="s">&quot;AbCabCABc&quot;</samp><samp class="p" data-group-id="4324621692-1">&gt;&gt;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="ow">in</samp><samp class="w"> </samp><samp class="sc">?a</samp><samp class="o">..</samp><samp class="sc">?z</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">reduce</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="4324621692-2">%{</samp><samp class="p" data-group-id="4324621692-2">}</samp><samp class="w"> </samp><samp class="k" data-group-id="4324621692-3">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="n">acc</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">update</samp><samp class="p" data-group-id="4324621692-4">(</samp><samp class="n">acc</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4324621692-5">&lt;&lt;</samp><samp class="n">x</samp><samp class="p" data-group-id="4324621692-5">&gt;&gt;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="o">&amp;</samp><samp class="w"> </samp><samp class="ni">&amp;1</samp><samp class="w"> </samp><samp class="o">+</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="4324621692-4">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="4324621692-3">end</samp><samp class="w">
</samp><samp class="p" data-group-id="4324621692-6">%{</samp><samp class="s">&quot;a&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;b&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;c&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="4324621692-6">}</samp></code></pre><p>When the <code class="inline">:reduce</code> key is given, its value is used as the initial accumulator
and the <code class="inline">do</code> block must be changed to use <code class="inline">-&gt;</code> clauses, where the left side
of <code class="inline">-&gt;</code> receives the accumulated value of the previous iteration and the
expression on the right side must return the new accumulator value. Once there are no more
elements, the final accumulated value is returned. If there are no elements
at all, then the initial accumulator value is returned.</p>
  </section>
</section>
<section class="detail" id="import/2">

  <div class="detail-header">
    <a href="#import/2" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">import(module, opts)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L685" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Imports functions and macros from other modules.</p><p><a href="#import/2"><code class="inline">import/2</code></a> allows one to easily access functions or macros from
other modules without using the qualified name.</p><h2 id="import/2-examples" class="section-heading"><a href="#import/2-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><p>If you are using several functions from a given module, you can
import those functions and reference them as local functions,
for example:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">List</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">flatten</samp><samp class="p" data-group-id="2433157210-1">(</samp><samp class="p" data-group-id="2433157210-2">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="2433157210-3">[</samp><samp class="mi">2</samp><samp class="p" data-group-id="2433157210-3">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="2433157210-2">]</samp><samp class="p" data-group-id="2433157210-1">)</samp><samp class="w">
</samp><samp class="p" data-group-id="2433157210-4">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="2433157210-4">]</samp></code></pre><h2 id="import/2-selector" class="section-heading"><a href="#import/2-selector" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Selector</span></h2><p>By default, Elixir imports functions and macros from the given
module, except the ones starting with an underscore (which are
usually callbacks):</p><pre><code class="makeup elixir" translate="no"><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">List</samp></code></pre><p>A developer can filter to import only functions, macros, or sigils
(which can be functions or macros) via the <code class="inline">:only</code> option:</p><pre><code class="makeup elixir" translate="no"><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">List</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">only</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:functions</samp><samp class="w">
</samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">List</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">only</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:macros</samp><samp class="w">
</samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">Kernel</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">only</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:sigils</samp></code></pre><p>Alternatively, Elixir allows a developer to pass pairs of
name/arities to <code class="inline">:only</code> or <code class="inline">:except</code> as a fine grained control
on what to import (or not):</p><pre><code class="makeup elixir" translate="no"><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">List</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">only</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="5083045687-1">[</samp><samp class="ss">flatten</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="5083045687-1">]</samp><samp class="w">
</samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">String</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">except</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="5083045687-2">[</samp><samp class="ss">split</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="5083045687-2">]</samp></code></pre><p>Importing the same module again will erase the previous imports,
except when the <code class="inline">except</code> option is used, which is always exclusive
on a previously declared <a href="#import/2"><code class="inline">import/2</code></a>. If there is no previous import,
then it applies to all functions and macros in the module. For
example:</p><pre><code class="makeup elixir" translate="no"><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">List</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">only</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="3593149306-1">[</samp><samp class="ss">flatten</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">keyfind</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p" data-group-id="3593149306-1">]</samp><samp class="w">
</samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">List</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">except</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="3593149306-2">[</samp><samp class="ss">flatten</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="3593149306-2">]</samp></code></pre><p>After the two import calls above, only <a href="List.xhtml#keyfind/4"><code class="inline">List.keyfind/4</code></a> will be
imported.</p><h2 id="import/2-underscore-functions" class="section-heading"><a href="#import/2-underscore-functions" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Underscore functions</span></h2><p>By default functions starting with <code class="inline">_</code> are not imported. If you really want
to import a function starting with <code class="inline">_</code> you must explicitly include it in the
<code class="inline">:only</code> selector.</p><pre><code class="makeup elixir" translate="no"><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">File.Stream</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">only</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="8757296079-1">[</samp><samp class="ss">__build__</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="8757296079-1">]</samp></code></pre><h2 id="import/2-lexical-scope" class="section-heading"><a href="#import/2-lexical-scope" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Lexical scope</span></h2><p>It is important to note that <a href="#import/2"><code class="inline">import/2</code></a> is lexical. This means you
can import specific macros inside specific functions:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Math</samp><samp class="w"> </samp><samp class="k" data-group-id="6574543554-1">do</samp><samp class="w">
  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">some_function</samp><samp class="w"> </samp><samp class="k" data-group-id="6574543554-2">do</samp><samp class="w">
    </samp><samp class="c1"># 1) Disable &quot;if/2&quot; from Kernel</samp><samp class="w">
    </samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">Kernel</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">except</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="6574543554-3">[</samp><samp class="ss">if</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="6574543554-3">]</samp><samp class="w">

    </samp><samp class="c1"># 2) Require the new &quot;if/2&quot; macro from MyMacros</samp><samp class="w">
    </samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">MyMacros</samp><samp class="w">

    </samp><samp class="c1"># 3) Use the new macro</samp><samp class="w">
    </samp><samp class="k">if</samp><samp class="w"> </samp><samp class="n">do_something</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">it_works</samp><samp class="w">
  </samp><samp class="k" data-group-id="6574543554-2">end</samp><samp class="w">
</samp><samp class="k" data-group-id="6574543554-1">end</samp></code></pre><p>In the example above, we imported macros from <code class="inline">MyMacros</code>,
replacing the original <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a> implementation by our own
within that specific function. All other functions in that
module will still be able to use the original one.</p><h2 id="import/2-warnings" class="section-heading"><a href="#import/2-warnings" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Warnings</span></h2><p>If you import a module and you don't use any of the imported
functions or macros from this module, Elixir is going to issue
a warning implying the import is not being used.</p><p>In case the import is generated automatically by a macro,
Elixir won't emit any warnings though, since the import
was not explicitly defined.</p><p>Both warning behaviors could be changed by explicitly
setting the <code class="inline">:warn</code> option to <code class="inline">true</code> or <code class="inline">false</code>.</p><h2 id="import/2-ambiguous-function-macro-names" class="section-heading"><a href="#import/2-ambiguous-function-macro-names" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Ambiguous function/macro names</span></h2><p>If two modules <code class="inline">A</code> and <code class="inline">B</code> are imported and they both contain
a <code class="inline">foo</code> function with an arity of <code class="inline">1</code>, an error is only emitted
if an ambiguous call to <code class="inline">foo/1</code> is actually made; that is, the
errors are emitted lazily, not eagerly.</p>
  </section>
</section>
<section class="detail" id="quote/2">

  <div class="detail-header">
    <a href="#quote/2" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">quote(opts, block)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1310" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Gets the representation of any expression.</p><h2 id="quote/2-examples" class="section-heading"><a href="#quote/2-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="8587715093-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="n">sum</samp><samp class="p" data-group-id="8587715093-2">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="8587715093-2">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="8587715093-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="8587715093-3">{</samp><samp class="ss">:sum</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8587715093-4">[</samp><samp class="p" data-group-id="8587715093-4">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8587715093-5">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="8587715093-5">]</samp><samp class="p" data-group-id="8587715093-3">}</samp></code></pre><h2 id="quote/2-elixir-s-ast-abstract-syntax-tree" class="section-heading"><a href="#quote/2-elixir-s-ast-abstract-syntax-tree" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Elixir's AST (Abstract Syntax Tree)</span></h2><p>Any Elixir code can be represented using Elixir data structures.
The building block of Elixir macros is a tuple with three elements,
for example:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="8277306388-1">{</samp><samp class="ss">:sum</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8277306388-2">[</samp><samp class="p" data-group-id="8277306388-2">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8277306388-3">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="8277306388-3">]</samp><samp class="p" data-group-id="8277306388-1">}</samp></code></pre><p>The tuple above represents a function call to <code class="inline">sum</code> passing 1, 2 and
3 as arguments. The tuple elements are:</p><ul><li><p>The first element of the tuple is always an atom or
another tuple in the same representation.</p></li><li><p>The second element of the tuple represents <a href="Macro.xhtml#t:metadata/0">metadata</a>.</p></li><li><p>The third element of the tuple are the arguments for the
function call. The third argument may be an atom, which is
usually a variable (or a local call).</p></li></ul><p>Besides the tuple described above, Elixir has a few literals that
are also part of its AST. Those literals return themselves when
quoted. They are:</p><pre><code class="makeup elixir" translate="no"><samp class="ss">:sum</samp><samp class="w">         </samp><samp class="c1">#=&gt; Atoms</samp><samp class="w">
</samp><samp class="mi">1</samp><samp class="w">            </samp><samp class="c1">#=&gt; Integers</samp><samp class="w">
</samp><samp class="mf">2.0</samp><samp class="w">          </samp><samp class="c1">#=&gt; Floats</samp><samp class="w">
</samp><samp class="p" data-group-id="3492177286-1">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="3492177286-1">]</samp><samp class="w">       </samp><samp class="c1">#=&gt; Lists</samp><samp class="w">
</samp><samp class="s">&quot;strings&quot;</samp><samp class="w">    </samp><samp class="c1">#=&gt; Strings</samp><samp class="w">
</samp><samp class="p" data-group-id="3492177286-2">{</samp><samp class="n">key</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">value</samp><samp class="p" data-group-id="3492177286-2">}</samp><samp class="w"> </samp><samp class="c1">#=&gt; Tuples with two elements</samp></code></pre><p>Any other value, such as a map or a four-element tuple, must be escaped
(<a href="Macro.xhtml#escape/1"><code class="inline">Macro.escape/1</code></a>) before being introduced into an AST.</p><h2 id="quote/2-options" class="section-heading"><a href="#quote/2-options" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Options</span></h2><ul><li><p><code class="inline">:bind_quoted</code> - passes a binding to the macro. Whenever a binding is
given, <a href="#unquote/1"><code class="inline">unquote/1</code></a> is automatically disabled.</p></li><li><p><code class="inline">:context</code> - sets the resolution context.</p></li><li><p><code class="inline">:generated</code> - marks the given chunk as generated so it does not emit warnings.
It is also useful to avoid dialyzer reporting errors when macros generate
unused clauses.</p></li><li><p><code class="inline">:file</code> - sets the quoted expressions to have the given file.</p></li><li><p><code class="inline">:line</code> - sets the quoted expressions to have the given line.</p></li><li><p><code class="inline">:location</code> - when set to <code class="inline">:keep</code>, keeps the current line and file from
quote. Read the &quot;Stacktrace information&quot; section below for more information.</p></li><li><p><code class="inline">:unquote</code> - when <code class="inline">false</code>, disables unquoting. This means any <code class="inline">unquote</code>
call will be kept as is in the AST, instead of replaced by the <code class="inline">unquote</code>
arguments. For example:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="1582065128-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="k">unquote</samp><samp class="p" data-group-id="1582065128-2">(</samp><samp class="s">&quot;hello&quot;</samp><samp class="p" data-group-id="1582065128-2">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="1582065128-1">end</samp><samp class="w">
</samp><samp class="s">&quot;hello&quot;</samp><samp class="w">

</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="ss">unquote</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="no">false</samp><samp class="w"> </samp><samp class="k" data-group-id="1582065128-3">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="k">unquote</samp><samp class="p" data-group-id="1582065128-4">(</samp><samp class="s">&quot;hello&quot;</samp><samp class="p" data-group-id="1582065128-4">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="1582065128-3">end</samp><samp class="w">
</samp><samp class="p" data-group-id="1582065128-5">{</samp><samp class="ss">:unquote</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="1582065128-6">[</samp><samp class="p" data-group-id="1582065128-6">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="1582065128-7">[</samp><samp class="s">&quot;hello&quot;</samp><samp class="p" data-group-id="1582065128-7">]</samp><samp class="p" data-group-id="1582065128-5">}</samp></code></pre></li></ul><h2 id="quote/2-quote-and-macros" class="section-heading"><a href="#quote/2-quote-and-macros" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Quote and macros</span></h2><p><a href="#quote/2"><code class="inline">quote/2</code></a> is commonly used with macros for code generation. As an exercise,
let's define a macro that multiplies a number by itself (squared). In practice,
there is no reason to define such a macro (and it would actually be
seen as a bad practice), but it is simple enough that it allows us to focus
on the important aspects of quotes and macros:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Math</samp><samp class="w"> </samp><samp class="k" data-group-id="4668735456-1">do</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">squared</samp><samp class="p" data-group-id="4668735456-2">(</samp><samp class="n">x</samp><samp class="p" data-group-id="4668735456-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4668735456-3">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="4668735456-4">do</samp><samp class="w">
      </samp><samp class="k">unquote</samp><samp class="p" data-group-id="4668735456-5">(</samp><samp class="n">x</samp><samp class="p" data-group-id="4668735456-5">)</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="4668735456-6">(</samp><samp class="n">x</samp><samp class="p" data-group-id="4668735456-6">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="4668735456-4">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="4668735456-3">end</samp><samp class="w">
</samp><samp class="k" data-group-id="4668735456-1">end</samp></code></pre><p>We can invoke it as:</p><pre><code class="makeup elixir" translate="no"><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">Math</samp><samp class="w">
</samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="4905127254-1">(</samp><samp class="s">&quot;Got </samp><samp class="si" data-group-id="4905127254-2">#{</samp><samp class="n">squared</samp><samp class="p" data-group-id="4905127254-3">(</samp><samp class="mi">5</samp><samp class="p" data-group-id="4905127254-3">)</samp><samp class="si" data-group-id="4905127254-2">}</samp><samp class="s">&quot;</samp><samp class="p" data-group-id="4905127254-1">)</samp></code></pre><p>At first, there is nothing in this example that actually reveals it is a
macro. But what is happening is that, at compilation time, <code class="inline">squared(5)</code>
becomes <code class="inline">5 * 5</code>. The argument <code class="inline">5</code> is duplicated in the produced code, we
can see this behavior in practice though because our macro actually has
a bug:</p><pre><code class="makeup elixir" translate="no"><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">Math</samp><samp class="w">
</samp><samp class="n">my_number</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="k" data-group-id="0312040798-1">fn</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
  </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="0312040798-2">(</samp><samp class="s">&quot;Returning 5&quot;</samp><samp class="p" data-group-id="0312040798-2">)</samp><samp class="w">
  </samp><samp class="mi">5</samp><samp class="w">
</samp><samp class="k" data-group-id="0312040798-1">end</samp><samp class="w">
</samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="0312040798-3">(</samp><samp class="s">&quot;Got </samp><samp class="si" data-group-id="0312040798-4">#{</samp><samp class="n">squared</samp><samp class="p" data-group-id="0312040798-5">(</samp><samp class="n">my_number</samp><samp class="o">.</samp><samp class="p" data-group-id="0312040798-6">(</samp><samp class="p" data-group-id="0312040798-6">)</samp><samp class="p" data-group-id="0312040798-5">)</samp><samp class="si" data-group-id="0312040798-4">}</samp><samp class="s">&quot;</samp><samp class="p" data-group-id="0312040798-3">)</samp></code></pre><p>The example above will print:</p><pre><code class="makeup elixir" translate="no"><samp class="nc">Returning</samp><samp class="w"> </samp><samp class="mi">5</samp><samp class="w">
</samp><samp class="nc">Returning</samp><samp class="w"> </samp><samp class="mi">5</samp><samp class="w">
</samp><samp class="nc">Got</samp><samp class="w"> </samp><samp class="mi">25</samp></code></pre><p>Notice how &quot;Returning 5&quot; was printed twice, instead of just once. This is
because a macro receives an expression and not a value (which is what we
would expect in a regular function). This means that:</p><pre><code class="makeup elixir" translate="no"><samp class="n">squared</samp><samp class="p" data-group-id="7391922507-1">(</samp><samp class="n">my_number</samp><samp class="o">.</samp><samp class="p" data-group-id="7391922507-2">(</samp><samp class="p" data-group-id="7391922507-2">)</samp><samp class="p" data-group-id="7391922507-1">)</samp></code></pre><p>Actually expands to:</p><pre><code class="makeup elixir" translate="no"><samp class="n">my_number</samp><samp class="o">.</samp><samp class="p" data-group-id="9879014081-1">(</samp><samp class="p" data-group-id="9879014081-1">)</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">my_number</samp><samp class="o">.</samp><samp class="p" data-group-id="9879014081-2">(</samp><samp class="p" data-group-id="9879014081-2">)</samp></code></pre><p>Which invokes the function twice, explaining why we get the printed value
twice! In the majority of the cases, this is actually unexpected behavior,
and that's why one of the first things you need to keep in mind when it
comes to macros is to <strong>not unquote the same value more than once</strong>.</p><p>Let's fix our macro:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Math</samp><samp class="w"> </samp><samp class="k" data-group-id="8874707365-1">do</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">squared</samp><samp class="p" data-group-id="8874707365-2">(</samp><samp class="n">x</samp><samp class="p" data-group-id="8874707365-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="8874707365-3">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="8874707365-4">do</samp><samp class="w">
      </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="8874707365-5">(</samp><samp class="n">x</samp><samp class="p" data-group-id="8874707365-5">)</samp><samp class="w">
      </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w">
    </samp><samp class="k" data-group-id="8874707365-4">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="8874707365-3">end</samp><samp class="w">
</samp><samp class="k" data-group-id="8874707365-1">end</samp></code></pre><p>Now invoking <code class="inline">squared(my_number.())</code> as before will print the value just
once.</p><p>In fact, this pattern is so common that most of the times you will want
to use the <code class="inline">bind_quoted</code> option with <a href="#quote/2"><code class="inline">quote/2</code></a>:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Math</samp><samp class="w"> </samp><samp class="k" data-group-id="4674694555-1">do</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">squared</samp><samp class="p" data-group-id="4674694555-2">(</samp><samp class="n">x</samp><samp class="p" data-group-id="4674694555-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4674694555-3">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="ss">bind_quoted</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="4674694555-4">[</samp><samp class="ss">x</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="p" data-group-id="4674694555-4">]</samp><samp class="w"> </samp><samp class="k" data-group-id="4674694555-5">do</samp><samp class="w">
      </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w">
    </samp><samp class="k" data-group-id="4674694555-5">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="4674694555-3">end</samp><samp class="w">
</samp><samp class="k" data-group-id="4674694555-1">end</samp></code></pre><p><code class="inline">:bind_quoted</code> will translate to the same code as the example above.
<code class="inline">:bind_quoted</code> can be used in many cases and is seen as good practice,
not only because it helps prevent us from running into common mistakes, but also
because it allows us to leverage other tools exposed by macros, such as
unquote fragments discussed in some sections below.</p><p>Before we finish this brief introduction, you will notice that, even though
we defined a variable <code class="inline">x</code> inside our quote:</p><pre><code class="makeup elixir" translate="no"><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="6423563606-1">do</samp><samp class="w">
  </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="6423563606-2">(</samp><samp class="n">x</samp><samp class="p" data-group-id="6423563606-2">)</samp><samp class="w">
  </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w">
</samp><samp class="k" data-group-id="6423563606-1">end</samp></code></pre><p>When we call:</p><pre><code class="makeup elixir" translate="no"><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">Math</samp><samp class="w">
</samp><samp class="n">squared</samp><samp class="p" data-group-id="9089103682-1">(</samp><samp class="mi">5</samp><samp class="p" data-group-id="9089103682-1">)</samp><samp class="w">
</samp><samp class="n">x</samp><samp class="w">
</samp><samp class="gt">** (CompileError) undefined variable &quot;x&quot;</samp></code></pre><p>We can see that <code class="inline">x</code> did not leak to the user context. This happens
because Elixir macros are hygienic, a topic we will discuss at length
in the next sections as well.</p><h2 id="quote/2-hygiene-in-variables" class="section-heading"><a href="#quote/2-hygiene-in-variables" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Hygiene in variables</span></h2><p>Consider the following example:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w"> </samp><samp class="k" data-group-id="3622933930-1">do</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">no_interference</samp><samp class="w"> </samp><samp class="k" data-group-id="3622933930-2">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="3622933930-3">do</samp><samp class="w">
      </samp><samp class="n">a</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
    </samp><samp class="k" data-group-id="3622933930-3">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="3622933930-2">end</samp><samp class="w">
</samp><samp class="k" data-group-id="3622933930-1">end</samp><samp class="w">

</samp><samp class="kn">require</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w">

</samp><samp class="n">a</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="w">
</samp><samp class="nc">Hygiene</samp><samp class="o">.</samp><samp class="n">no_interference</samp><samp class="p" data-group-id="3622933930-4">(</samp><samp class="p" data-group-id="3622933930-4">)</samp><samp class="w">
</samp><samp class="n">a</samp><samp class="w">
</samp><samp class="c1">#=&gt; 10</samp></code></pre><p>In the example above, <code class="inline">a</code> returns 10 even if the macro
is apparently setting it to 1 because variables defined
in the macro do not affect the context the macro is executed in.
If you want to set or get a variable in the caller's context, you
can do it with the help of the <code class="inline">var!</code> macro:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">NoHygiene</samp><samp class="w"> </samp><samp class="k" data-group-id="9788741369-1">do</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">interference</samp><samp class="w"> </samp><samp class="k" data-group-id="9788741369-2">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="9788741369-3">do</samp><samp class="w">
      </samp><samp class="n">var!</samp><samp class="p" data-group-id="9788741369-4">(</samp><samp class="n">a</samp><samp class="p" data-group-id="9788741369-4">)</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
    </samp><samp class="k" data-group-id="9788741369-3">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="9788741369-2">end</samp><samp class="w">
</samp><samp class="k" data-group-id="9788741369-1">end</samp><samp class="w">

</samp><samp class="kn">require</samp><samp class="w"> </samp><samp class="nc">NoHygiene</samp><samp class="w">

</samp><samp class="n">a</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="w">
</samp><samp class="nc">NoHygiene</samp><samp class="o">.</samp><samp class="n">interference</samp><samp class="p" data-group-id="9788741369-5">(</samp><samp class="p" data-group-id="9788741369-5">)</samp><samp class="w">
</samp><samp class="n">a</samp><samp class="w">
</samp><samp class="c1">#=&gt; 1</samp></code></pre><p>You cannot even access variables defined in the same module unless
you explicitly give it a context:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w"> </samp><samp class="k" data-group-id="4766090681-1">do</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">write</samp><samp class="w"> </samp><samp class="k" data-group-id="4766090681-2">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="4766090681-3">do</samp><samp class="w">
      </samp><samp class="n">a</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
    </samp><samp class="k" data-group-id="4766090681-3">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="4766090681-2">end</samp><samp class="w">

  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">read</samp><samp class="w"> </samp><samp class="k" data-group-id="4766090681-4">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="4766090681-5">do</samp><samp class="w">
      </samp><samp class="n">a</samp><samp class="w">
    </samp><samp class="k" data-group-id="4766090681-5">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="4766090681-4">end</samp><samp class="w">
</samp><samp class="k" data-group-id="4766090681-1">end</samp><samp class="w">

</samp><samp class="kn">require</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w">
</samp><samp class="nc">Hygiene</samp><samp class="o">.</samp><samp class="n">write</samp><samp class="p" data-group-id="4766090681-6">(</samp><samp class="p" data-group-id="4766090681-6">)</samp><samp class="w">
</samp><samp class="nc">Hygiene</samp><samp class="o">.</samp><samp class="n">read</samp><samp class="p" data-group-id="4766090681-7">(</samp><samp class="p" data-group-id="4766090681-7">)</samp><samp class="w">
</samp><samp class="gt">** (CompileError) undefined variable &quot;a&quot; (context Hygiene)</samp></code></pre><p>For such, you can explicitly pass the current module scope as
argument:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">ContextHygiene</samp><samp class="w"> </samp><samp class="k" data-group-id="7018295573-1">do</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">write</samp><samp class="w"> </samp><samp class="k" data-group-id="7018295573-2">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="7018295573-3">do</samp><samp class="w">
      </samp><samp class="n">var!</samp><samp class="p" data-group-id="7018295573-4">(</samp><samp class="n">a</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">ContextHygiene</samp><samp class="p" data-group-id="7018295573-4">)</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
    </samp><samp class="k" data-group-id="7018295573-3">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="7018295573-2">end</samp><samp class="w">

  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">read</samp><samp class="w"> </samp><samp class="k" data-group-id="7018295573-5">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="7018295573-6">do</samp><samp class="w">
      </samp><samp class="n">var!</samp><samp class="p" data-group-id="7018295573-7">(</samp><samp class="n">a</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">ContextHygiene</samp><samp class="p" data-group-id="7018295573-7">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="7018295573-6">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="7018295573-5">end</samp><samp class="w">
</samp><samp class="k" data-group-id="7018295573-1">end</samp><samp class="w">

</samp><samp class="kn">require</samp><samp class="w"> </samp><samp class="nc">ContextHygiene</samp><samp class="w">
</samp><samp class="nc">ContextHygiene</samp><samp class="o">.</samp><samp class="n">write</samp><samp class="p" data-group-id="7018295573-8">(</samp><samp class="p" data-group-id="7018295573-8">)</samp><samp class="w">
</samp><samp class="nc">ContextHygiene</samp><samp class="o">.</samp><samp class="n">read</samp><samp class="p" data-group-id="7018295573-9">(</samp><samp class="p" data-group-id="7018295573-9">)</samp><samp class="w">
</samp><samp class="c1">#=&gt; 1</samp></code></pre><p>The contexts of a variable is identified by the third element of the tuple.
The default context is <code class="inline">nil</code> and <code class="inline">quote</code> assigns another context to all
variables within:</p><pre><code class="makeup elixir" translate="no"><samp class="k">quote</samp><samp class="p" data-group-id="8131230741-1">(</samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">var</samp><samp class="p" data-group-id="8131230741-1">)</samp><samp class="w">
</samp><samp class="c1">#=&gt; {:var, [], Elixir}</samp></code></pre><p>In case of variables returned by macros, there may also be a <code class="inline">:counter</code> key
in the metadata, which is used to further refine its contexts and guarantee
isolation between macro invocations as seen in the previous example.</p><h2 id="quote/2-hygiene-in-aliases" class="section-heading"><a href="#quote/2-hygiene-in-aliases" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Hygiene in aliases</span></h2><p>Aliases inside quote are hygienic by default.
Consider the following example:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w"> </samp><samp class="k" data-group-id="9637940247-1">do</samp><samp class="w">
  </samp><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">as</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="nc">M</samp><samp class="w">

  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">no_interference</samp><samp class="w"> </samp><samp class="k" data-group-id="9637940247-2">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="9637940247-3">do</samp><samp class="w">
      </samp><samp class="nc">M</samp><samp class="o">.</samp><samp class="n">new</samp><samp class="p" data-group-id="9637940247-4">(</samp><samp class="p" data-group-id="9637940247-4">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="9637940247-3">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="9637940247-2">end</samp><samp class="w">
</samp><samp class="k" data-group-id="9637940247-1">end</samp><samp class="w">

</samp><samp class="kn">require</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w">
</samp><samp class="nc">Hygiene</samp><samp class="o">.</samp><samp class="n">no_interference</samp><samp class="p" data-group-id="9637940247-5">(</samp><samp class="p" data-group-id="9637940247-5">)</samp><samp class="w">
</samp><samp class="c1">#=&gt; %{}</samp></code></pre><p>Note that, even though the alias <code class="inline">M</code> is not available
in the context the macro is expanded, the code above works
because <code class="inline">M</code> still expands to <a href="Map.xhtml"><code class="inline">Map</code></a>.</p><p>Similarly, even if we defined an alias with the same name
before invoking a macro, it won't affect the macro's result:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w"> </samp><samp class="k" data-group-id="5468633346-1">do</samp><samp class="w">
  </samp><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">as</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="nc">M</samp><samp class="w">

  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">no_interference</samp><samp class="w"> </samp><samp class="k" data-group-id="5468633346-2">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="5468633346-3">do</samp><samp class="w">
      </samp><samp class="nc">M</samp><samp class="o">.</samp><samp class="n">new</samp><samp class="p" data-group-id="5468633346-4">(</samp><samp class="p" data-group-id="5468633346-4">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="5468633346-3">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="5468633346-2">end</samp><samp class="w">
</samp><samp class="k" data-group-id="5468633346-1">end</samp><samp class="w">

</samp><samp class="kn">require</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w">
</samp><samp class="kn">alias</samp><samp class="w"> </samp><samp class="nc">SomethingElse</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">as</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="nc">M</samp><samp class="w">
</samp><samp class="nc">Hygiene</samp><samp class="o">.</samp><samp class="n">no_interference</samp><samp class="p" data-group-id="5468633346-5">(</samp><samp class="p" data-group-id="5468633346-5">)</samp><samp class="w">
</samp><samp class="c1">#=&gt; %{}</samp></code></pre><p>In some cases, you want to access an alias or a module defined
in the caller. For such, you can use the <code class="inline">alias!</code> macro:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w"> </samp><samp class="k" data-group-id="8026278254-1">do</samp><samp class="w">
  </samp><samp class="c1"># This will expand to Elixir.Nested.hello()</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">no_interference</samp><samp class="w"> </samp><samp class="k" data-group-id="8026278254-2">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="8026278254-3">do</samp><samp class="w">
      </samp><samp class="nc">Nested</samp><samp class="o">.</samp><samp class="n">hello</samp><samp class="p" data-group-id="8026278254-4">(</samp><samp class="p" data-group-id="8026278254-4">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="8026278254-3">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="8026278254-2">end</samp><samp class="w">

  </samp><samp class="c1"># This will expand to Nested.hello() for</samp><samp class="w">
  </samp><samp class="c1"># whatever is Nested in the caller</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">interference</samp><samp class="w"> </samp><samp class="k" data-group-id="8026278254-5">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="8026278254-6">do</samp><samp class="w">
      </samp><samp class="n">alias!</samp><samp class="p" data-group-id="8026278254-7">(</samp><samp class="nc">Nested</samp><samp class="p" data-group-id="8026278254-7">)</samp><samp class="o">.</samp><samp class="n">hello</samp><samp class="p" data-group-id="8026278254-8">(</samp><samp class="p" data-group-id="8026278254-8">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="8026278254-6">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="8026278254-5">end</samp><samp class="w">
</samp><samp class="k" data-group-id="8026278254-1">end</samp><samp class="w">

</samp><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Parent</samp><samp class="w"> </samp><samp class="k" data-group-id="8026278254-9">do</samp><samp class="w">
  </samp><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Nested</samp><samp class="w"> </samp><samp class="k" data-group-id="8026278254-10">do</samp><samp class="w">
    </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">hello</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="s">&quot;world&quot;</samp><samp class="w">
  </samp><samp class="k" data-group-id="8026278254-10">end</samp><samp class="w">

  </samp><samp class="kn">require</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w">
  </samp><samp class="nc">Hygiene</samp><samp class="o">.</samp><samp class="n">no_interference</samp><samp class="p" data-group-id="8026278254-11">(</samp><samp class="p" data-group-id="8026278254-11">)</samp><samp class="w">
  </samp><samp class="gt">** (UndefinedFunctionError) ...</samp><samp class="w">

  </samp><samp class="nc">Hygiene</samp><samp class="o">.</samp><samp class="n">interference</samp><samp class="p" data-group-id="8026278254-12">(</samp><samp class="p" data-group-id="8026278254-12">)</samp><samp class="w">
  </samp><samp class="c1">#=&gt; &quot;world&quot;</samp><samp class="w">
</samp><samp class="k" data-group-id="8026278254-9">end</samp></code></pre><h2 id="quote/2-hygiene-in-imports" class="section-heading"><a href="#quote/2-hygiene-in-imports" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Hygiene in imports</span></h2><p>Similar to aliases, imports in Elixir are hygienic. Consider the
following code:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Hygiene</samp><samp class="w"> </samp><samp class="k" data-group-id="6886138937-1">do</samp><samp class="w">
  </samp><samp class="kd">defmacrop</samp><samp class="w"> </samp><samp class="nf">get_length</samp><samp class="w"> </samp><samp class="k" data-group-id="6886138937-2">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="6886138937-3">do</samp><samp class="w">
      </samp><samp class="n">length</samp><samp class="p" data-group-id="6886138937-4">(</samp><samp class="p" data-group-id="6886138937-5">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="6886138937-5">]</samp><samp class="p" data-group-id="6886138937-4">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="6886138937-3">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="6886138937-2">end</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">return_length</samp><samp class="w"> </samp><samp class="k" data-group-id="6886138937-6">do</samp><samp class="w">
    </samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">Kernel</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">except</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="6886138937-7">[</samp><samp class="ss">length</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="6886138937-7">]</samp><samp class="w">
    </samp><samp class="n">get_length</samp><samp class="w">
  </samp><samp class="k" data-group-id="6886138937-6">end</samp><samp class="w">
</samp><samp class="k" data-group-id="6886138937-1">end</samp><samp class="w">

</samp><samp class="nc">Hygiene</samp><samp class="o">.</samp><samp class="n">return_length</samp><samp class="p" data-group-id="6886138937-8">(</samp><samp class="p" data-group-id="6886138937-8">)</samp><samp class="w">
</samp><samp class="c1">#=&gt; 3</samp></code></pre><p>Notice how <code class="inline">Hygiene.return_length/0</code> returns <code class="inline">3</code> even though the <a href="Kernel.xhtml#length/1"><code class="inline">Kernel.length/1</code></a>
function is not imported. In fact, even if <code class="inline">return_length/0</code>
imported a function with the same name and arity from another
module, it wouldn't affect the function result:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">return_length</samp><samp class="w"> </samp><samp class="k" data-group-id="9364371949-1">do</samp><samp class="w">
  </samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">String</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">only</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="9364371949-2">[</samp><samp class="ss">length</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="9364371949-2">]</samp><samp class="w">
  </samp><samp class="n">get_length</samp><samp class="w">
</samp><samp class="k" data-group-id="9364371949-1">end</samp></code></pre><p>Calling this new <code class="inline">return_length/0</code> will still return <code class="inline">3</code> as result.</p><p>Elixir is smart enough to delay the resolution to the latest
possible moment. So, if you call <code class="inline">length([1, 2, 3])</code> inside quote,
but no <a href="Kernel.xhtml#length/1"><code class="inline">length/1</code></a> function is available, it is then expanded in
the caller:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Lazy</samp><samp class="w"> </samp><samp class="k" data-group-id="9075368097-1">do</samp><samp class="w">
  </samp><samp class="kd">defmacrop</samp><samp class="w"> </samp><samp class="nf">get_length</samp><samp class="w"> </samp><samp class="k" data-group-id="9075368097-2">do</samp><samp class="w">
    </samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">Kernel</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">except</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="9075368097-3">[</samp><samp class="ss">length</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="9075368097-3">]</samp><samp class="w">

    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="9075368097-4">do</samp><samp class="w">
      </samp><samp class="n">length</samp><samp class="p" data-group-id="9075368097-5">(</samp><samp class="s">&quot;hello&quot;</samp><samp class="p" data-group-id="9075368097-5">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="9075368097-4">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="9075368097-2">end</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">return_length</samp><samp class="w"> </samp><samp class="k" data-group-id="9075368097-6">do</samp><samp class="w">
    </samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">Kernel</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">except</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="9075368097-7">[</samp><samp class="ss">length</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="9075368097-7">]</samp><samp class="w">
    </samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">String</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">only</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="9075368097-8">[</samp><samp class="ss">length</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p" data-group-id="9075368097-8">]</samp><samp class="w">
    </samp><samp class="n">get_length</samp><samp class="w">
  </samp><samp class="k" data-group-id="9075368097-6">end</samp><samp class="w">
</samp><samp class="k" data-group-id="9075368097-1">end</samp><samp class="w">

</samp><samp class="nc">Lazy</samp><samp class="o">.</samp><samp class="n">return_length</samp><samp class="p" data-group-id="9075368097-9">(</samp><samp class="p" data-group-id="9075368097-9">)</samp><samp class="w">
</samp><samp class="c1">#=&gt; 5</samp></code></pre><h2 id="quote/2-stacktrace-information" class="section-heading"><a href="#quote/2-stacktrace-information" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Stacktrace information</span></h2><p>When defining functions via macros, developers have the option of
choosing if runtime errors will be reported from the caller or from
inside the quote. Let's see an example:</p><pre><code class="makeup elixir" translate="no"><samp class="c1"># adder.ex</samp><samp class="w">
</samp><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Adder</samp><samp class="w"> </samp><samp class="k" data-group-id="6684633741-1">do</samp><samp class="w">
  </samp><samp class="na">@doc</samp><samp class="w"> </samp><samp class="s">&quot;Defines a function that adds two numbers&quot;</samp><samp class="w">
  </samp><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">defadd</samp><samp class="w"> </samp><samp class="k" data-group-id="6684633741-2">do</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="ss">location</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:keep</samp><samp class="w"> </samp><samp class="k" data-group-id="6684633741-3">do</samp><samp class="w">
      </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">add</samp><samp class="p" data-group-id="6684633741-4">(</samp><samp class="n">a</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">b</samp><samp class="p" data-group-id="6684633741-4">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">a</samp><samp class="w"> </samp><samp class="o">+</samp><samp class="w"> </samp><samp class="n">b</samp><samp class="w">
    </samp><samp class="k" data-group-id="6684633741-3">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="6684633741-2">end</samp><samp class="w">
</samp><samp class="k" data-group-id="6684633741-1">end</samp><samp class="w">

</samp><samp class="c1"># sample.ex</samp><samp class="w">
</samp><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Sample</samp><samp class="w"> </samp><samp class="k" data-group-id="6684633741-5">do</samp><samp class="w">
  </samp><samp class="kn">import</samp><samp class="w"> </samp><samp class="nc">Adder</samp><samp class="w">
  </samp><samp class="n">defadd</samp><samp class="w">
</samp><samp class="k" data-group-id="6684633741-5">end</samp><samp class="w">

</samp><samp class="kn">require</samp><samp class="w"> </samp><samp class="nc">Sample</samp><samp class="w">
</samp><samp class="nc">Sample</samp><samp class="o">.</samp><samp class="n">add</samp><samp class="p" data-group-id="6684633741-6">(</samp><samp class="ss">:one</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:two</samp><samp class="p" data-group-id="6684633741-6">)</samp><samp class="w">
</samp><samp class="gt">** (ArithmeticError) bad argument in arithmetic expression
    adder.ex:5: Sample.add/2</samp></code></pre><p>When using <code class="inline">location: :keep</code> and invalid arguments are given to
<code class="inline">Sample.add/2</code>, the stacktrace information will point to the file
and line inside the quote. Without <code class="inline">location: :keep</code>, the error is
reported to where <code class="inline">defadd</code> was invoked. <code class="inline">location: :keep</code> affects
only definitions inside the quote.</p><section role="note" class="admonition warning"><h4 class="admonition-title warning"><code class="inline">location: :keep</code> and unquote</h4><p>Do not use <code class="inline">location: :keep</code> if the function definition
also <code class="inline">unquote</code>s some of the macro arguments. If you do so, Elixir
will store the file definition of the current location but the
unquoted arguments may contain line information of the macro caller,
leading to erroneous stacktraces.</p></section><h2 id="quote/2-binding-and-unquote-fragments" class="section-heading"><a href="#quote/2-binding-and-unquote-fragments" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Binding and unquote fragments</span></h2><p>Elixir quote/unquote mechanisms provide a functionality called
unquote fragments. Unquote fragments provide an easy way to generate
functions on the fly. Consider this example:</p><pre><code class="makeup elixir" translate="no"><samp class="n">kv</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="3110994264-1">[</samp><samp class="ss">foo</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">bar</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="3110994264-1">]</samp><samp class="w">
</samp><samp class="nc">Enum</samp><samp class="o">.</samp><samp class="n">each</samp><samp class="p" data-group-id="3110994264-2">(</samp><samp class="n">kv</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k" data-group-id="3110994264-3">fn</samp><samp class="w"> </samp><samp class="p" data-group-id="3110994264-4">{</samp><samp class="n">k</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">v</samp><samp class="p" data-group-id="3110994264-4">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="3110994264-5">(</samp><samp class="n">k</samp><samp class="p" data-group-id="3110994264-5">)</samp><samp class="p" data-group-id="3110994264-6">(</samp><samp class="p" data-group-id="3110994264-6">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="3110994264-7">(</samp><samp class="n">v</samp><samp class="p" data-group-id="3110994264-7">)</samp><samp class="w">
</samp><samp class="k" data-group-id="3110994264-3">end</samp><samp class="p" data-group-id="3110994264-2">)</samp></code></pre><p>In the example above, we have generated the functions <code class="inline">foo/0</code> and
<code class="inline">bar/0</code> dynamically. Now, imagine that we want to convert this
functionality into a macro:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">defkv</samp><samp class="p" data-group-id="0707991110-1">(</samp><samp class="n">kv</samp><samp class="p" data-group-id="0707991110-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="0707991110-2">do</samp><samp class="w">
  </samp><samp class="nc">Enum</samp><samp class="o">.</samp><samp class="n">map</samp><samp class="p" data-group-id="0707991110-3">(</samp><samp class="n">kv</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k" data-group-id="0707991110-4">fn</samp><samp class="w"> </samp><samp class="p" data-group-id="0707991110-5">{</samp><samp class="n">k</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">v</samp><samp class="p" data-group-id="0707991110-5">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="0707991110-6">do</samp><samp class="w">
      </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="0707991110-7">(</samp><samp class="n">k</samp><samp class="p" data-group-id="0707991110-7">)</samp><samp class="p" data-group-id="0707991110-8">(</samp><samp class="p" data-group-id="0707991110-8">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="0707991110-9">(</samp><samp class="n">v</samp><samp class="p" data-group-id="0707991110-9">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="0707991110-6">end</samp><samp class="w">
  </samp><samp class="k" data-group-id="0707991110-4">end</samp><samp class="p" data-group-id="0707991110-3">)</samp><samp class="w">
</samp><samp class="k" data-group-id="0707991110-2">end</samp></code></pre><p>We can invoke this macro as:</p><pre><code class="makeup elixir" translate="no"><samp class="n">defkv</samp><samp class="w"> </samp><samp class="p" data-group-id="9094773039-1">[</samp><samp class="ss">foo</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">bar</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="9094773039-1">]</samp></code></pre><p>However, we can't invoke it as follows:</p><pre><code class="makeup elixir" translate="no"><samp class="n">kv</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="8234278206-1">[</samp><samp class="ss">foo</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">bar</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="8234278206-1">]</samp><samp class="w">
</samp><samp class="n">defkv</samp><samp class="w"> </samp><samp class="n">kv</samp></code></pre><p>This is because the macro is expecting its arguments to be a
keyword list at <strong>compilation</strong> time. Since in the example above
we are passing the representation of the variable <code class="inline">kv</code>, our
code fails.</p><p>This is actually a common pitfall when developing macros. We are
assuming a particular shape in the macro. We can work around it
by unquoting the variable inside the quoted expression:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">defkv</samp><samp class="p" data-group-id="6018512888-1">(</samp><samp class="n">kv</samp><samp class="p" data-group-id="6018512888-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="6018512888-2">do</samp><samp class="w">
  </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="6018512888-3">do</samp><samp class="w">
    </samp><samp class="nc">Enum</samp><samp class="o">.</samp><samp class="n">each</samp><samp class="p" data-group-id="6018512888-4">(</samp><samp class="k">unquote</samp><samp class="p" data-group-id="6018512888-5">(</samp><samp class="n">kv</samp><samp class="p" data-group-id="6018512888-5">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k" data-group-id="6018512888-6">fn</samp><samp class="w"> </samp><samp class="p" data-group-id="6018512888-7">{</samp><samp class="n">k</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">v</samp><samp class="p" data-group-id="6018512888-7">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
      </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="6018512888-8">(</samp><samp class="n">k</samp><samp class="p" data-group-id="6018512888-8">)</samp><samp class="p" data-group-id="6018512888-9">(</samp><samp class="p" data-group-id="6018512888-9">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="6018512888-10">(</samp><samp class="n">v</samp><samp class="p" data-group-id="6018512888-10">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="6018512888-6">end</samp><samp class="p" data-group-id="6018512888-4">)</samp><samp class="w">
  </samp><samp class="k" data-group-id="6018512888-3">end</samp><samp class="w">
</samp><samp class="k" data-group-id="6018512888-2">end</samp></code></pre><p>If you try to run our new macro, you will notice it won't
even compile, complaining that the variables <code class="inline">k</code> and <code class="inline">v</code>
do not exist. This is because of the ambiguity: <code class="inline">unquote(k)</code>
can either be an unquote fragment, as previously, or a regular
unquote as in <code class="inline">unquote(kv)</code>.</p><p>One solution to this problem is to disable unquoting in the
macro, however, doing that would make it impossible to inject the
<code class="inline">kv</code> representation into the tree. That's when the <code class="inline">:bind_quoted</code>
option comes to the rescue (again!). By using <code class="inline">:bind_quoted</code>, we
can automatically disable unquoting while still injecting the
desired variables into the tree:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmacro</samp><samp class="w"> </samp><samp class="nf">defkv</samp><samp class="p" data-group-id="9985485828-1">(</samp><samp class="n">kv</samp><samp class="p" data-group-id="9985485828-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="9985485828-2">do</samp><samp class="w">
  </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="ss">bind_quoted</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="9985485828-3">[</samp><samp class="ss">kv</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">kv</samp><samp class="p" data-group-id="9985485828-3">]</samp><samp class="w"> </samp><samp class="k" data-group-id="9985485828-4">do</samp><samp class="w">
    </samp><samp class="nc">Enum</samp><samp class="o">.</samp><samp class="n">each</samp><samp class="p" data-group-id="9985485828-5">(</samp><samp class="n">kv</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k" data-group-id="9985485828-6">fn</samp><samp class="w"> </samp><samp class="p" data-group-id="9985485828-7">{</samp><samp class="n">k</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">v</samp><samp class="p" data-group-id="9985485828-7">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
      </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="9985485828-8">(</samp><samp class="n">k</samp><samp class="p" data-group-id="9985485828-8">)</samp><samp class="p" data-group-id="9985485828-9">(</samp><samp class="p" data-group-id="9985485828-9">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="9985485828-10">(</samp><samp class="n">v</samp><samp class="p" data-group-id="9985485828-10">)</samp><samp class="w">
    </samp><samp class="k" data-group-id="9985485828-6">end</samp><samp class="p" data-group-id="9985485828-5">)</samp><samp class="w">
  </samp><samp class="k" data-group-id="9985485828-4">end</samp><samp class="w">
</samp><samp class="k" data-group-id="9985485828-2">end</samp></code></pre><p>In fact, the <code class="inline">:bind_quoted</code> option is recommended every time
one desires to inject a value into the quote.</p>
  </section>
</section>
<section class="detail" id="receive/1">

  <div class="detail-header">
    <a href="#receive/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">receive(args)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L2388" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Checks if there is a message matching any of the given clauses in the current
process mailbox.</p><p>If there is no matching message, the current process waits until a matching
message arrives or until after a given timeout value.</p><p>Any new and existing messages that do not match will remain in the mailbox.</p><h2 id="receive/1-examples" class="section-heading"><a href="#receive/1-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><pre><code class="makeup elixir" translate="no"><samp class="k">receive</samp><samp class="w"> </samp><samp class="k" data-group-id="1201744548-1">do</samp><samp class="w">
  </samp><samp class="p" data-group-id="1201744548-2">{</samp><samp class="ss">:selector</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">number</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">name</samp><samp class="p" data-group-id="1201744548-2">}</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">is_integer</samp><samp class="p" data-group-id="1201744548-3">(</samp><samp class="n">number</samp><samp class="p" data-group-id="1201744548-3">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="n">name</samp><samp class="w">
  </samp><samp class="n">name</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">is_atom</samp><samp class="p" data-group-id="1201744548-4">(</samp><samp class="n">name</samp><samp class="p" data-group-id="1201744548-4">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="n">name</samp><samp class="w">
  </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="1201744548-5">(</samp><samp class="ss">:stderr</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;Unexpected message received&quot;</samp><samp class="p" data-group-id="1201744548-5">)</samp><samp class="w">
</samp><samp class="k" data-group-id="1201744548-1">end</samp></code></pre><p>An optional <code class="inline">after</code> clause can be given in case no matching message is
received during the given timeout period, specified in milliseconds:</p><pre><code class="makeup elixir" translate="no"><samp class="k">receive</samp><samp class="w"> </samp><samp class="k" data-group-id="7040807760-1">do</samp><samp class="w">
  </samp><samp class="p" data-group-id="7040807760-2">{</samp><samp class="ss">:selector</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">number</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">name</samp><samp class="p" data-group-id="7040807760-2">}</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">is_integer</samp><samp class="p" data-group-id="7040807760-3">(</samp><samp class="n">number</samp><samp class="p" data-group-id="7040807760-3">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="n">name</samp><samp class="w">
  </samp><samp class="n">name</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">is_atom</samp><samp class="p" data-group-id="7040807760-4">(</samp><samp class="n">name</samp><samp class="p" data-group-id="7040807760-4">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="n">name</samp><samp class="w">
  </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="7040807760-5">(</samp><samp class="ss">:stderr</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;Unexpected message received&quot;</samp><samp class="p" data-group-id="7040807760-5">)</samp><samp class="w">
</samp><samp class="k" data-group-id="7040807760-1">after</samp><samp class="w">
  </samp><samp class="mi">5000</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="7040807760-6">(</samp><samp class="ss">:stderr</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;No message in 5 seconds&quot;</samp><samp class="p" data-group-id="7040807760-6">)</samp><samp class="w">
</samp><samp class="k" data-group-id="7040807760-1">end</samp></code></pre><p>The <code class="inline">after</code> clause can be specified even if there are no match clauses.
The timeout value given to <code class="inline">after</code> can be any expression evaluating to
one of the allowed values:</p><ul><li><p><code class="inline">:infinity</code> - the process should wait indefinitely for a matching
message, this is the same as not using the after clause</p></li><li><p><code class="inline">0</code> - if there is no matching message in the mailbox, the timeout
will occur immediately</p></li><li><p>positive integer smaller than or equal to <code class="inline">4_294_967_295</code> (<code class="inline">0xFFFFFFFF</code>
in hexadecimal notation) - it should be possible to represent the timeout
value as an unsigned 32-bit integer.</p></li></ul><h2 id="receive/1-variable-handling" class="section-heading"><a href="#receive/1-variable-handling" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Variable handling</span></h2><p>The <a href="#receive/1"><code class="inline">receive/1</code></a> special form handles variables exactly as the <a href="#case/2"><code class="inline">case/2</code></a>
special macro. For more information, check the docs for <a href="#case/2"><code class="inline">case/2</code></a>.</p>
  </section>
</section>
<section class="detail" id="require/2">

  <div class="detail-header">
    <a href="#require/2" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">require(module, opts)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L582" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Requires a module in order to use its macros.</p><h2 id="require/2-examples" class="section-heading"><a href="#require/2-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><p>Public functions in modules are globally available, but in order to use
macros, you need to opt-in by requiring the module they are defined in.</p><p>Let's suppose you created your own <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a> implementation in the module
<code class="inline">MyMacros</code>. If you want to invoke it, you need to first explicitly
require the <code class="inline">MyMacros</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">Math</samp><samp class="w"> </samp><samp class="k" data-group-id="9591467269-1">do</samp><samp class="w">
  </samp><samp class="kn">require</samp><samp class="w"> </samp><samp class="nc">MyMacros</samp><samp class="w">
  </samp><samp class="nc">MyMacros</samp><samp class="o">.</samp><samp class="k">if</samp><samp class="w"> </samp><samp class="n">do_something</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">it_works</samp><samp class="w">
</samp><samp class="k" data-group-id="9591467269-1">end</samp></code></pre><p>An attempt to call a macro that was not loaded will raise an error.</p><h2 id="require/2-alias-shortcut" class="section-heading"><a href="#require/2-alias-shortcut" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Alias shortcut</span></h2><p><a href="#require/2"><code class="inline">require/2</code></a> also accepts <code class="inline">:as</code> as an option so it automatically sets
up an alias. Please check <a href="#alias/2"><code class="inline">alias/2</code></a> for more information.</p>
  </section>
</section>
<section class="detail" id="super/1">

  <div class="detail-header">
    <a href="#super/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">super(args)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1892" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Calls the overridden function when overriding it with <a href="Kernel.xhtml#defoverridable/1"><code class="inline">Kernel.defoverridable/1</code></a>.</p><p>See <a href="Kernel.xhtml#defoverridable/1"><code class="inline">Kernel.defoverridable/1</code></a> for more information and documentation.</p>
  </section>
</section>
<section class="detail" id="try/1">

  <div class="detail-header">
    <a href="#try/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">try(args)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L2332" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Evaluates the given expressions and handles any error, exit,
or throw that may have happened.</p><h2 id="try/1-examples" class="section-heading"><a href="#try/1-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="3122679959-1">do</samp><samp class="w">
  </samp><samp class="n">do_something_that_may_fail</samp><samp class="p" data-group-id="3122679959-2">(</samp><samp class="n">some_arg</samp><samp class="p" data-group-id="3122679959-2">)</samp><samp class="w">
</samp><samp class="k" data-group-id="3122679959-1">rescue</samp><samp class="w">
  </samp><samp class="nc">ArgumentError</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="3122679959-3">(</samp><samp class="s">&quot;Invalid argument given&quot;</samp><samp class="p" data-group-id="3122679959-3">)</samp><samp class="w">
</samp><samp class="k" data-group-id="3122679959-1">catch</samp><samp class="w">
  </samp><samp class="n">value</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="3122679959-4">(</samp><samp class="s">&quot;Caught </samp><samp class="si" data-group-id="3122679959-5">#{</samp><samp class="n">inspect</samp><samp class="p" data-group-id="3122679959-6">(</samp><samp class="n">value</samp><samp class="p" data-group-id="3122679959-6">)</samp><samp class="si" data-group-id="3122679959-5">}</samp><samp class="s">&quot;</samp><samp class="p" data-group-id="3122679959-4">)</samp><samp class="w">
</samp><samp class="k" data-group-id="3122679959-1">else</samp><samp class="w">
  </samp><samp class="n">value</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="3122679959-7">(</samp><samp class="s">&quot;Success! The result was </samp><samp class="si" data-group-id="3122679959-8">#{</samp><samp class="n">inspect</samp><samp class="p" data-group-id="3122679959-9">(</samp><samp class="n">value</samp><samp class="p" data-group-id="3122679959-9">)</samp><samp class="si" data-group-id="3122679959-8">}</samp><samp class="s">&quot;</samp><samp class="p" data-group-id="3122679959-7">)</samp><samp class="w">
</samp><samp class="k" data-group-id="3122679959-1">after</samp><samp class="w">
  </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="3122679959-10">(</samp><samp class="s">&quot;This is printed regardless if it failed or succeeded&quot;</samp><samp class="p" data-group-id="3122679959-10">)</samp><samp class="w">
</samp><samp class="k" data-group-id="3122679959-1">end</samp></code></pre><p>The <code class="inline">rescue</code> clause is used to handle exceptions while the <code class="inline">catch</code>
clause can be used to catch thrown values and exits.
The <code class="inline">else</code> clause can be used to control flow based on the result of
the expression. <code class="inline">catch</code>, <code class="inline">rescue</code>, and <code class="inline">else</code> clauses work based on
pattern matching (similar to the <code class="inline">case</code> special form).</p><p>Calls inside <a href="#try/1"><code class="inline">try/1</code></a> are not tail recursive since the VM needs to keep
the stacktrace in case an exception happens. To retrieve the stacktrace,
access <a href="#__STACKTRACE__/0"><code class="inline">__STACKTRACE__/0</code></a> inside the <code class="inline">rescue</code> or <code class="inline">catch</code> clause.</p><h2 id="try/1-rescue-clauses" class="section-heading"><a href="#try/1-rescue-clauses" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><code class="inline">rescue</code> clauses</span></h2><p>Besides relying on pattern matching, <code class="inline">rescue</code> clauses provide some
conveniences around exceptions that allow one to rescue an
exception by its name. All the following formats are valid patterns
in <code class="inline">rescue</code> clauses:</p><pre><code class="makeup elixir" translate="no"><samp class="c1"># Rescue a single exception without binding the exception</samp><samp class="w">
</samp><samp class="c1"># to a variable</samp><samp class="w">
</samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="2328564845-1">do</samp><samp class="w">
  </samp><samp class="nc">UndefinedModule</samp><samp class="o">.</samp><samp class="n">undefined_function</samp><samp class="w">
</samp><samp class="k" data-group-id="2328564845-1">rescue</samp><samp class="w">
  </samp><samp class="nc">UndefinedFunctionError</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="w">
</samp><samp class="k" data-group-id="2328564845-1">end</samp><samp class="w">

</samp><samp class="c1"># Rescue any of the given exception without binding</samp><samp class="w">
</samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="2328564845-2">do</samp><samp class="w">
  </samp><samp class="nc">UndefinedModule</samp><samp class="o">.</samp><samp class="n">undefined_function</samp><samp class="w">
</samp><samp class="k" data-group-id="2328564845-2">rescue</samp><samp class="w">
  </samp><samp class="p" data-group-id="2328564845-3">[</samp><samp class="nc">UndefinedFunctionError</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">ArgumentError</samp><samp class="p" data-group-id="2328564845-3">]</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="w">
</samp><samp class="k" data-group-id="2328564845-2">end</samp><samp class="w">

</samp><samp class="c1"># Rescue and bind the exception to the variable &quot;x&quot;</samp><samp class="w">
</samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="2328564845-4">do</samp><samp class="w">
  </samp><samp class="nc">UndefinedModule</samp><samp class="o">.</samp><samp class="n">undefined_function</samp><samp class="w">
</samp><samp class="k" data-group-id="2328564845-4">rescue</samp><samp class="w">
  </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="ow">in</samp><samp class="w"> </samp><samp class="p" data-group-id="2328564845-5">[</samp><samp class="nc">UndefinedFunctionError</samp><samp class="p" data-group-id="2328564845-5">]</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="w">
</samp><samp class="k" data-group-id="2328564845-4">end</samp><samp class="w">

</samp><samp class="c1"># Rescue all kinds of exceptions and bind the rescued exception</samp><samp class="w">
</samp><samp class="c1"># to the variable &quot;x&quot;</samp><samp class="w">
</samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="2328564845-6">do</samp><samp class="w">
  </samp><samp class="nc">UndefinedModule</samp><samp class="o">.</samp><samp class="n">undefined_function</samp><samp class="w">
</samp><samp class="k" data-group-id="2328564845-6">rescue</samp><samp class="w">
  </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="w">
</samp><samp class="k" data-group-id="2328564845-6">end</samp></code></pre><h3 id="try/1-erlang-errors" class="section-heading"><a href="#try/1-erlang-errors" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Erlang errors</span></h3><p>Erlang errors are transformed into Elixir ones when rescuing:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="9064347807-1">do</samp><samp class="w">
  </samp><samp class="nc">:erlang</samp><samp class="o">.</samp><samp class="n">error</samp><samp class="p" data-group-id="9064347807-2">(</samp><samp class="ss">:badarg</samp><samp class="p" data-group-id="9064347807-2">)</samp><samp class="w">
</samp><samp class="k" data-group-id="9064347807-1">rescue</samp><samp class="w">
  </samp><samp class="nc">ArgumentError</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="ss">:ok</samp><samp class="w">
</samp><samp class="k" data-group-id="9064347807-1">end</samp><samp class="w">
</samp><samp class="c1">#=&gt; :ok</samp></code></pre><p>The most common Erlang errors will be transformed into their
Elixir counterpart. Those which are not will be transformed
into the more generic <a href="ErlangError.xhtml"><code class="inline">ErlangError</code></a>:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="4027825188-1">do</samp><samp class="w">
  </samp><samp class="nc">:erlang</samp><samp class="o">.</samp><samp class="n">error</samp><samp class="p" data-group-id="4027825188-2">(</samp><samp class="ss">:unknown</samp><samp class="p" data-group-id="4027825188-2">)</samp><samp class="w">
</samp><samp class="k" data-group-id="4027825188-1">rescue</samp><samp class="w">
  </samp><samp class="nc">ErlangError</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="ss">:ok</samp><samp class="w">
</samp><samp class="k" data-group-id="4027825188-1">end</samp><samp class="w">
</samp><samp class="c1">#=&gt; :ok</samp></code></pre><p>In fact, <a href="ErlangError.xhtml"><code class="inline">ErlangError</code></a> can be used to rescue any error that is
not a proper Elixir error. For example, it can be used to rescue
the earlier <code class="inline">:badarg</code> error too, prior to transformation:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="4016086693-1">do</samp><samp class="w">
  </samp><samp class="nc">:erlang</samp><samp class="o">.</samp><samp class="n">error</samp><samp class="p" data-group-id="4016086693-2">(</samp><samp class="ss">:badarg</samp><samp class="p" data-group-id="4016086693-2">)</samp><samp class="w">
</samp><samp class="k" data-group-id="4016086693-1">rescue</samp><samp class="w">
  </samp><samp class="nc">ErlangError</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="ss">:ok</samp><samp class="w">
</samp><samp class="k" data-group-id="4016086693-1">end</samp><samp class="w">
</samp><samp class="c1">#=&gt; :ok</samp></code></pre><h2 id="try/1-catch-clauses" class="section-heading"><a href="#try/1-catch-clauses" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><code class="inline">catch</code> clauses</span></h2><p>The <code class="inline">catch</code> clause can be used to catch thrown values, exits, and errors.</p><h3 id="try/1-catching-thrown-values" class="section-heading"><a href="#try/1-catching-thrown-values" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Catching thrown values</span></h3><p><code class="inline">catch</code> can be used to catch values thrown by <a href="Kernel.xhtml#throw/1"><code class="inline">Kernel.throw/1</code></a>:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="5432908919-1">do</samp><samp class="w">
  </samp><samp class="k">throw</samp><samp class="p" data-group-id="5432908919-2">(</samp><samp class="ss">:some_value</samp><samp class="p" data-group-id="5432908919-2">)</samp><samp class="w">
</samp><samp class="k" data-group-id="5432908919-1">catch</samp><samp class="w">
  </samp><samp class="n">thrown_value</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="5432908919-3">(</samp><samp class="s">&quot;A value was thrown: </samp><samp class="si" data-group-id="5432908919-4">#{</samp><samp class="n">inspect</samp><samp class="p" data-group-id="5432908919-5">(</samp><samp class="n">thrown_value</samp><samp class="p" data-group-id="5432908919-5">)</samp><samp class="si" data-group-id="5432908919-4">}</samp><samp class="s">&quot;</samp><samp class="p" data-group-id="5432908919-3">)</samp><samp class="w">
</samp><samp class="k" data-group-id="5432908919-1">end</samp></code></pre><h3 id="try/1-catching-values-of-any-kind" class="section-heading"><a href="#try/1-catching-values-of-any-kind" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Catching values of any kind</span></h3><p>The <code class="inline">catch</code> clause also supports catching exits and errors. To do that, it
allows matching on both the <em>kind</em> of the caught value as well as the value
itself:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="6092987028-1">do</samp><samp class="w">
  </samp><samp class="n">exit</samp><samp class="p" data-group-id="6092987028-2">(</samp><samp class="ss">:shutdown</samp><samp class="p" data-group-id="6092987028-2">)</samp><samp class="w">
</samp><samp class="k" data-group-id="6092987028-1">catch</samp><samp class="w">
  </samp><samp class="ss">:exit</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">value</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="6092987028-3">(</samp><samp class="s">&quot;Exited with value </samp><samp class="si" data-group-id="6092987028-4">#{</samp><samp class="n">inspect</samp><samp class="p" data-group-id="6092987028-5">(</samp><samp class="n">value</samp><samp class="p" data-group-id="6092987028-5">)</samp><samp class="si" data-group-id="6092987028-4">}</samp><samp class="s">&quot;</samp><samp class="p" data-group-id="6092987028-3">)</samp><samp class="w">
</samp><samp class="k" data-group-id="6092987028-1">end</samp><samp class="w">

</samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="6092987028-6">do</samp><samp class="w">
  </samp><samp class="n">exit</samp><samp class="p" data-group-id="6092987028-7">(</samp><samp class="ss">:shutdown</samp><samp class="p" data-group-id="6092987028-7">)</samp><samp class="w">
</samp><samp class="k" data-group-id="6092987028-6">catch</samp><samp class="w">
  </samp><samp class="n">kind</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">value</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">kind</samp><samp class="w"> </samp><samp class="ow">in</samp><samp class="w"> </samp><samp class="p" data-group-id="6092987028-8">[</samp><samp class="ss">:exit</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:throw</samp><samp class="p" data-group-id="6092987028-8">]</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="6092987028-9">(</samp><samp class="s">&quot;Caught exit or throw with value </samp><samp class="si" data-group-id="6092987028-10">#{</samp><samp class="n">inspect</samp><samp class="p" data-group-id="6092987028-11">(</samp><samp class="n">value</samp><samp class="p" data-group-id="6092987028-11">)</samp><samp class="si" data-group-id="6092987028-10">}</samp><samp class="s">&quot;</samp><samp class="p" data-group-id="6092987028-9">)</samp><samp class="w">
</samp><samp class="k" data-group-id="6092987028-6">end</samp></code></pre><p>The <code class="inline">catch</code> clause also supports <code class="inline">:error</code> alongside <code class="inline">:exit</code> and <code class="inline">:throw</code> as
in Erlang, although this is commonly avoided in favor of <code class="inline">raise</code>/<code class="inline">rescue</code> control
mechanisms. One reason for this is that when catching <code class="inline">:error</code>, the error is
not automatically transformed into an Elixir error:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="5699824580-1">do</samp><samp class="w">
  </samp><samp class="nc">:erlang</samp><samp class="o">.</samp><samp class="n">error</samp><samp class="p" data-group-id="5699824580-2">(</samp><samp class="ss">:badarg</samp><samp class="p" data-group-id="5699824580-2">)</samp><samp class="w">
</samp><samp class="k" data-group-id="5699824580-1">catch</samp><samp class="w">
  </samp><samp class="ss">:error</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:badarg</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="ss">:ok</samp><samp class="w">
</samp><samp class="k" data-group-id="5699824580-1">end</samp><samp class="w">
</samp><samp class="c1">#=&gt; :ok</samp></code></pre><h2 id="try/1-after-clauses" class="section-heading"><a href="#try/1-after-clauses" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><code class="inline">after</code> clauses</span></h2><p>An <code class="inline">after</code> clause allows you to define cleanup logic that will be invoked both
when the block of code passed to <a href="#try/1"><code class="inline">try/1</code></a> succeeds and also when an error is raised. Note
that the process will exit as usual when receiving an exit signal that causes
it to exit abruptly and so the <code class="inline">after</code> clause is not guaranteed to be executed.
Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets,
and so on) are linked to or monitor the owning process and will automatically clean
themselves up if that process exits.</p><pre><code class="makeup elixir" translate="no"><samp class="nc">File</samp><samp class="o">.</samp><samp class="n">write!</samp><samp class="p" data-group-id="2264046161-1">(</samp><samp class="s">&quot;tmp/story.txt&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;Hello, World&quot;</samp><samp class="p" data-group-id="2264046161-1">)</samp><samp class="w">
</samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="2264046161-2">do</samp><samp class="w">
  </samp><samp class="n">do_something_with</samp><samp class="p" data-group-id="2264046161-3">(</samp><samp class="s">&quot;tmp/story.txt&quot;</samp><samp class="p" data-group-id="2264046161-3">)</samp><samp class="w">
</samp><samp class="k" data-group-id="2264046161-2">after</samp><samp class="w">
  </samp><samp class="nc">File</samp><samp class="o">.</samp><samp class="n">rm</samp><samp class="p" data-group-id="2264046161-4">(</samp><samp class="s">&quot;tmp/story.txt&quot;</samp><samp class="p" data-group-id="2264046161-4">)</samp><samp class="w">
</samp><samp class="k" data-group-id="2264046161-2">end</samp></code></pre><p>Although <code class="inline">after</code> clauses are invoked whether or not there was an error, they do not
modify the return value. All of the following examples return <code class="inline">:return_me</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="3758684115-1">do</samp><samp class="w">
  </samp><samp class="ss">:return_me</samp><samp class="w">
</samp><samp class="k" data-group-id="3758684115-1">after</samp><samp class="w">
  </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="3758684115-2">(</samp><samp class="s">&quot;I will be printed&quot;</samp><samp class="p" data-group-id="3758684115-2">)</samp><samp class="w">
  </samp><samp class="ss">:not_returned</samp><samp class="w">
</samp><samp class="k" data-group-id="3758684115-1">end</samp><samp class="w">

</samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="3758684115-3">do</samp><samp class="w">
  </samp><samp class="k">raise</samp><samp class="w"> </samp><samp class="s">&quot;boom&quot;</samp><samp class="w">
</samp><samp class="k" data-group-id="3758684115-3">rescue</samp><samp class="w">
  </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="ss">:return_me</samp><samp class="w">
</samp><samp class="k" data-group-id="3758684115-3">after</samp><samp class="w">
  </samp><samp class="nc">IO</samp><samp class="o">.</samp><samp class="n">puts</samp><samp class="p" data-group-id="3758684115-4">(</samp><samp class="s">&quot;I will be printed&quot;</samp><samp class="p" data-group-id="3758684115-4">)</samp><samp class="w">
  </samp><samp class="ss">:not_returned</samp><samp class="w">
</samp><samp class="k" data-group-id="3758684115-3">end</samp></code></pre><h2 id="try/1-else-clauses" class="section-heading"><a href="#try/1-else-clauses" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text"><code class="inline">else</code> clauses</span></h2><p><code class="inline">else</code> clauses allow the result of the body passed to <a href="#try/1"><code class="inline">try/1</code></a> to be pattern
matched on:</p><pre><code class="makeup elixir" translate="no"><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="w">
</samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="0113334688-1">do</samp><samp class="w">
  </samp><samp class="mi">1</samp><samp class="w"> </samp><samp class="o">/</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w">
</samp><samp class="k" data-group-id="0113334688-1">rescue</samp><samp class="w">
  </samp><samp class="nc">ArithmeticError</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="ss">:infinity</samp><samp class="w">
</samp><samp class="k" data-group-id="0113334688-1">else</samp><samp class="w">
  </samp><samp class="n">y</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">y</samp><samp class="w"> </samp><samp class="o">&lt;</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w"> </samp><samp class="ow">and</samp><samp class="w"> </samp><samp class="n">y</samp><samp class="w"> </samp><samp class="o">&gt;</samp><samp class="w"> </samp><samp class="o">-</samp><samp class="mi">1</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="ss">:small</samp><samp class="w">
  </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="ss">:large</samp><samp class="w">
</samp><samp class="k" data-group-id="0113334688-1">end</samp></code></pre><p>If an <code class="inline">else</code> clause is not present and no exceptions are raised,
the result of the expression will be returned:</p><pre><code class="makeup elixir" translate="no"><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
</samp><samp class="o">^</samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w">
  </samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="6498105702-1">do</samp><samp class="w">
    </samp><samp class="mi">1</samp><samp class="w"> </samp><samp class="o">/</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w">
  </samp><samp class="k" data-group-id="6498105702-1">rescue</samp><samp class="w">
    </samp><samp class="nc">ArithmeticError</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
      </samp><samp class="ss">:infinity</samp><samp class="w">
  </samp><samp class="k" data-group-id="6498105702-1">end</samp></code></pre><p>However, when an <code class="inline">else</code> clause is present but the result of the expression
does not match any of the patterns then an exception will be raised. This
exception will not be caught by a <code class="inline">catch</code> or <code class="inline">rescue</code> in the same <code class="inline">try</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
</samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="8770282251-1">do</samp><samp class="w">
  </samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="8770282251-2">do</samp><samp class="w">
    </samp><samp class="mi">1</samp><samp class="w"> </samp><samp class="o">/</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w">
  </samp><samp class="k" data-group-id="8770282251-2">rescue</samp><samp class="w">
    </samp><samp class="c1"># The TryClauseError cannot be rescued here:</samp><samp class="w">
    </samp><samp class="nc">TryClauseError</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
      </samp><samp class="ss">:error_a</samp><samp class="w">
  </samp><samp class="k" data-group-id="8770282251-2">else</samp><samp class="w">
    </samp><samp class="mi">0</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
      </samp><samp class="ss">:small</samp><samp class="w">
  </samp><samp class="k" data-group-id="8770282251-2">end</samp><samp class="w">
</samp><samp class="k" data-group-id="8770282251-1">rescue</samp><samp class="w">
  </samp><samp class="c1"># The TryClauseError is rescued here:</samp><samp class="w">
  </samp><samp class="nc">TryClauseError</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="ss">:error_b</samp><samp class="w">
</samp><samp class="k" data-group-id="8770282251-1">end</samp></code></pre><p>Similarly, an exception inside an <code class="inline">else</code> clause is not caught or rescued
inside the same <code class="inline">try</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="1723128368-1">do</samp><samp class="w">
  </samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="1723128368-2">do</samp><samp class="w">
    </samp><samp class="no">nil</samp><samp class="w">
  </samp><samp class="k" data-group-id="1723128368-2">catch</samp><samp class="w">
    </samp><samp class="c1"># The exit(1) call below can not be caught here:</samp><samp class="w">
    </samp><samp class="ss">:exit</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
      </samp><samp class="ss">:exit_a</samp><samp class="w">
  </samp><samp class="k" data-group-id="1723128368-2">else</samp><samp class="w">
    </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
      </samp><samp class="n">exit</samp><samp class="p" data-group-id="1723128368-3">(</samp><samp class="mi">1</samp><samp class="p" data-group-id="1723128368-3">)</samp><samp class="w">
  </samp><samp class="k" data-group-id="1723128368-2">end</samp><samp class="w">
</samp><samp class="k" data-group-id="1723128368-1">catch</samp><samp class="w">
  </samp><samp class="c1"># The exit is caught here:</samp><samp class="w">
  </samp><samp class="ss">:exit</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="ss">:exit_b</samp><samp class="w">
</samp><samp class="k" data-group-id="1723128368-1">end</samp></code></pre><p>This means the VM no longer needs to keep the stacktrace once inside
an <code class="inline">else</code> clause and so tail recursion is possible when using a <code class="inline">try</code>
with a tail call as the final call inside an <code class="inline">else</code> clause. The same
is true for <code class="inline">rescue</code> and <code class="inline">catch</code> clauses.</p><p>Only the result of the tried expression falls down to the <code class="inline">else</code> clause.
If the <code class="inline">try</code> ends up in the <code class="inline">rescue</code> or <code class="inline">catch</code> clauses, their result
will not fall down to <code class="inline">else</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="6306339232-1">do</samp><samp class="w">
  </samp><samp class="k">throw</samp><samp class="p" data-group-id="6306339232-2">(</samp><samp class="ss">:catch_this</samp><samp class="p" data-group-id="6306339232-2">)</samp><samp class="w">
</samp><samp class="k" data-group-id="6306339232-1">catch</samp><samp class="w">
  </samp><samp class="ss">:throw</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:catch_this</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="ss">:it_was_caught</samp><samp class="w">
</samp><samp class="k" data-group-id="6306339232-1">else</samp><samp class="w">
  </samp><samp class="c1"># :it_was_caught will not fall down to this &quot;else&quot; clause.</samp><samp class="w">
  </samp><samp class="n">other</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="p" data-group-id="6306339232-3">{</samp><samp class="ss">:else</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">other</samp><samp class="p" data-group-id="6306339232-3">}</samp><samp class="w">
</samp><samp class="k" data-group-id="6306339232-1">end</samp></code></pre><h2 id="try/1-variable-handling" class="section-heading"><a href="#try/1-variable-handling" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Variable handling</span></h2><p>Since an expression inside <code class="inline">try</code> may not have been evaluated
due to an exception, any variable created inside <code class="inline">try</code> cannot
be accessed externally. For instance:</p><pre><code class="makeup elixir" translate="no"><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="9149086747-1">do</samp><samp class="w">
  </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
  </samp><samp class="n">do_something_that_may_fail</samp><samp class="p" data-group-id="9149086747-2">(</samp><samp class="n">same_arg</samp><samp class="p" data-group-id="9149086747-2">)</samp><samp class="w">
  </samp><samp class="ss">:ok</samp><samp class="w">
</samp><samp class="k" data-group-id="9149086747-1">catch</samp><samp class="w">
  </samp><samp class="bp">_</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="ss">:failed</samp><samp class="w">
</samp><samp class="k" data-group-id="9149086747-1">end</samp><samp class="w">

</samp><samp class="n">x</samp><samp class="w">
</samp><samp class="c1">#=&gt; unbound variable &quot;x&quot;</samp></code></pre><p>In the example above, <code class="inline">x</code> cannot be accessed since it was defined
inside the <code class="inline">try</code> clause. A common practice to address this issue
is to return the variables defined inside <code class="inline">try</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w">
  </samp><samp class="k">try</samp><samp class="w"> </samp><samp class="k" data-group-id="9372803840-1">do</samp><samp class="w">
    </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
    </samp><samp class="n">do_something_that_may_fail</samp><samp class="p" data-group-id="9372803840-2">(</samp><samp class="n">same_arg</samp><samp class="p" data-group-id="9372803840-2">)</samp><samp class="w">
    </samp><samp class="n">x</samp><samp class="w">
  </samp><samp class="k" data-group-id="9372803840-1">catch</samp><samp class="w">
    </samp><samp class="bp">_</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="ss">:failed</samp><samp class="w">
  </samp><samp class="k" data-group-id="9372803840-1">end</samp></code></pre>
  </section>
</section>
<section class="detail" id="unquote/1">

  <div class="detail-header">
    <a href="#unquote/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">unquote(expr)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1364" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Unquotes the given expression inside a quoted expression.</p><p>This function expects a valid Elixir AST, also known as
quoted expression, as argument. If you would like to <code class="inline">unquote</code>
any value, such as a map or a four-element tuple, you should
call <a href="Macro.xhtml#escape/1"><code class="inline">Macro.escape/1</code></a> before unquoting.</p><h2 id="unquote/1-examples" class="section-heading"><a href="#unquote/1-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><p>Imagine the situation you have a quoted expression and
you want to inject it inside some quote. The first attempt
would be:</p><pre><code class="makeup elixir" translate="no"><samp class="n">value</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w">
  </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="1635529783-1">do</samp><samp class="w">
    </samp><samp class="mi">13</samp><samp class="w">
  </samp><samp class="k" data-group-id="1635529783-1">end</samp><samp class="w">

</samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="1635529783-2">do</samp><samp class="w">
  </samp><samp class="n">sum</samp><samp class="p" data-group-id="1635529783-3">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">value</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="1635529783-3">)</samp><samp class="w">
</samp><samp class="k" data-group-id="1635529783-2">end</samp></code></pre><p>Which the argument for the <code class="inline">:sum</code> function call is not the
expected result:</p><pre><code class="makeup elixir" translate="no"><samp class="p" data-group-id="6620580624-1">{</samp><samp class="ss">:sum</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6620580624-2">[</samp><samp class="p" data-group-id="6620580624-2">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6620580624-3">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6620580624-4">{</samp><samp class="ss">:value</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6620580624-5">[</samp><samp class="p" data-group-id="6620580624-5">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="nc">Elixir</samp><samp class="p" data-group-id="6620580624-4">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="6620580624-3">]</samp><samp class="p" data-group-id="6620580624-1">}</samp></code></pre><p>For this, we use <code class="inline">unquote</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">value</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="9814178787-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">    </samp><samp class="mi">13</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="k" data-group-id="9814178787-1">end</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="9814178787-2">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="n">sum</samp><samp class="p" data-group-id="9814178787-3">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k">unquote</samp><samp class="p" data-group-id="9814178787-4">(</samp><samp class="n">value</samp><samp class="p" data-group-id="9814178787-4">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="9814178787-3">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="9814178787-2">end</samp><samp class="w">
</samp><samp class="p" data-group-id="9814178787-5">{</samp><samp class="ss">:sum</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="9814178787-6">[</samp><samp class="p" data-group-id="9814178787-6">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="9814178787-7">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">13</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="9814178787-7">]</samp><samp class="p" data-group-id="9814178787-5">}</samp></code></pre><p>If you want to unquote a value that is not a quoted expression,
such as a map, you need to call <a href="Macro.xhtml#escape/1"><code class="inline">Macro.escape/1</code></a> before:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">value</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="3305441704-1">%{</samp><samp class="ss">foo</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:bar</samp><samp class="p" data-group-id="3305441704-1">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="3305441704-2">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="n">process_map</samp><samp class="p" data-group-id="3305441704-3">(</samp><samp class="k">unquote</samp><samp class="p" data-group-id="3305441704-4">(</samp><samp class="nc">Macro</samp><samp class="o">.</samp><samp class="n">escape</samp><samp class="p" data-group-id="3305441704-5">(</samp><samp class="n">value</samp><samp class="p" data-group-id="3305441704-5">)</samp><samp class="p" data-group-id="3305441704-4">)</samp><samp class="p" data-group-id="3305441704-3">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="3305441704-2">end</samp><samp class="w">
</samp><samp class="p" data-group-id="3305441704-6">{</samp><samp class="ss">:process_map</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3305441704-7">[</samp><samp class="p" data-group-id="3305441704-7">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3305441704-8">[</samp><samp class="p" data-group-id="3305441704-9">{</samp><samp class="ss">:%{}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3305441704-10">[</samp><samp class="p" data-group-id="3305441704-10">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3305441704-11">[</samp><samp class="ss">foo</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:bar</samp><samp class="p" data-group-id="3305441704-11">]</samp><samp class="p" data-group-id="3305441704-9">}</samp><samp class="p" data-group-id="3305441704-8">]</samp><samp class="p" data-group-id="3305441704-6">}</samp></code></pre><p>If you forget to escape it, Elixir will raise an error
when compiling the code.</p>
  </section>
</section>
<section class="detail" id="unquote_splicing/1">

  <div class="detail-header">
    <a href="#unquote_splicing/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">unquote_splicing(expr)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1380" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Unquotes the given list expanding its arguments.</p><p>Similar to <a href="#unquote/1"><code class="inline">unquote/1</code></a>.</p><h2 id="unquote_splicing/1-examples" class="section-heading"><a href="#unquote_splicing/1-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">values</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="2791257256-1">[</samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p" data-group-id="2791257256-1">]</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="2791257256-2">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="n">sum</samp><samp class="p" data-group-id="2791257256-3">(</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k">unquote_splicing</samp><samp class="p" data-group-id="2791257256-4">(</samp><samp class="n">values</samp><samp class="p" data-group-id="2791257256-4">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">5</samp><samp class="p" data-group-id="2791257256-3">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="2791257256-2">end</samp><samp class="w">
</samp><samp class="p" data-group-id="2791257256-5">{</samp><samp class="ss">:sum</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="2791257256-6">[</samp><samp class="p" data-group-id="2791257256-6">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="2791257256-7">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">4</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">5</samp><samp class="p" data-group-id="2791257256-7">]</samp><samp class="p" data-group-id="2791257256-5">}</samp></code></pre>
  </section>
</section>
<section class="detail" id="with/1">

  <div class="detail-header">
    <a href="#with/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">with(args)</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L1714" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Combine matching clauses.</p><p>One of the ways to understand <code class="inline">with</code> is to show which code
patterns it improves. Imagine you have a map where the fields
<code class="inline">width</code> and <code class="inline">height</code> are optional and you want to compute its
area, as <code class="inline">{:ok, area}</code> or return <code class="inline">:error</code>. We could implement
this function as:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">area</samp><samp class="p" data-group-id="8062612712-1">(</samp><samp class="n">opts</samp><samp class="p" data-group-id="8062612712-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="8062612712-2">do</samp><samp class="w">
  </samp><samp class="k">case</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="8062612712-3">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:width</samp><samp class="p" data-group-id="8062612712-3">)</samp><samp class="w"> </samp><samp class="k" data-group-id="8062612712-4">do</samp><samp class="w">
    </samp><samp class="p" data-group-id="8062612712-5">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="p" data-group-id="8062612712-5">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
      </samp><samp class="k">case</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="8062612712-6">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:height</samp><samp class="p" data-group-id="8062612712-6">)</samp><samp class="w"> </samp><samp class="k" data-group-id="8062612712-7">do</samp><samp class="w">
        </samp><samp class="p" data-group-id="8062612712-8">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="8062612712-8">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="p" data-group-id="8062612712-9">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="8062612712-9">}</samp><samp class="w">
        </samp><samp class="ss">:error</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="ss">:error</samp><samp class="w">
      </samp><samp class="k" data-group-id="8062612712-7">end</samp><samp class="w">

    </samp><samp class="ss">:error</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
      </samp><samp class="ss">:error</samp><samp class="w">
  </samp><samp class="k" data-group-id="8062612712-4">end</samp><samp class="w">
</samp><samp class="k" data-group-id="8062612712-2">end</samp></code></pre><p>when called as <code class="inline">area(%{width: 10, height: 15})</code>, it should return
<code class="inline">{:ok, 150}</code>. If any of the fields are missing, it returns <code class="inline">:error</code>.</p><p>While the code above works, it is quite verbose. Using <code class="inline">with</code>,
we could rewrite it as:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">area</samp><samp class="p" data-group-id="0347181661-1">(</samp><samp class="n">opts</samp><samp class="p" data-group-id="0347181661-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="0347181661-2">do</samp><samp class="w">
  </samp><samp class="k">with</samp><samp class="w"> </samp><samp class="p" data-group-id="0347181661-3">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="p" data-group-id="0347181661-3">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="0347181661-4">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:width</samp><samp class="p" data-group-id="0347181661-4">)</samp><samp class="p">,</samp><samp class="w">
       </samp><samp class="p" data-group-id="0347181661-5">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="0347181661-5">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="0347181661-6">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:height</samp><samp class="p" data-group-id="0347181661-6">)</samp><samp class="w"> </samp><samp class="k" data-group-id="0347181661-7">do</samp><samp class="w">
    </samp><samp class="p" data-group-id="0347181661-8">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="0347181661-8">}</samp><samp class="w">
  </samp><samp class="k" data-group-id="0347181661-7">end</samp><samp class="w">
</samp><samp class="k" data-group-id="0347181661-2">end</samp></code></pre><p>Instead of defining nested <code class="inline">case</code>s with clauses, we use <code class="inline">with</code>
alongside the <code class="inline">PATTERN &lt;- EXPRESSION</code> operator to match
expressions on its right side against the pattern on the left.
Consider <code class="inline">&lt;-</code> as a sibling to <code class="inline">=</code>, except that, while <code class="inline">=</code> raises
in case of not matches, <code class="inline">&lt;-</code> will simply abort the <code class="inline">with</code> chain
and return the non-matched value.</p><p>Let's give it a try on IEx:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">opts</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="0161099344-1">%{</samp><samp class="ss">width</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">height</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">15</samp><samp class="p" data-group-id="0161099344-1">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">with</samp><samp class="w"> </samp><samp class="p" data-group-id="0161099344-2">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="p" data-group-id="0161099344-2">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="0161099344-3">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:width</samp><samp class="p" data-group-id="0161099344-3">)</samp><samp class="p">,</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">     </samp><samp class="p" data-group-id="0161099344-4">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="0161099344-4">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="0161099344-5">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:height</samp><samp class="p" data-group-id="0161099344-5">)</samp><samp class="w"> </samp><samp class="k" data-group-id="0161099344-6">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="0161099344-7">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="0161099344-7">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="0161099344-6">end</samp><samp class="w">
</samp><samp class="p" data-group-id="0161099344-8">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">150</samp><samp class="p" data-group-id="0161099344-8">}</samp></code></pre><p>If all clauses match, the <code class="inline">do</code> block is executed, returning its result.
Otherwise the chain is aborted and the non-matched value is returned:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">opts</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="4038162254-1">%{</samp><samp class="ss">width</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="p" data-group-id="4038162254-1">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">with</samp><samp class="w"> </samp><samp class="p" data-group-id="4038162254-2">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="p" data-group-id="4038162254-2">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="4038162254-3">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:width</samp><samp class="p" data-group-id="4038162254-3">)</samp><samp class="p">,</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">     </samp><samp class="p" data-group-id="4038162254-4">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="4038162254-4">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="4038162254-5">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:height</samp><samp class="p" data-group-id="4038162254-5">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4038162254-6">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="4038162254-7">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="4038162254-7">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="4038162254-6">end</samp><samp class="w">
</samp><samp class="ss">:error</samp></code></pre><p>Guards can be used in patterns as well:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">users</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="5097783933-1">%{</samp><samp class="s">&quot;melany&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="s">&quot;guest&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;bob&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="ss">:admin</samp><samp class="p" data-group-id="5097783933-1">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">with</samp><samp class="w"> </samp><samp class="p" data-group-id="5097783933-2">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">role</samp><samp class="p" data-group-id="5097783933-2">}</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="ow">not</samp><samp class="w"> </samp><samp class="n">is_binary</samp><samp class="p" data-group-id="5097783933-3">(</samp><samp class="n">role</samp><samp class="p" data-group-id="5097783933-3">)</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="5097783933-4">(</samp><samp class="n">users</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;bob&quot;</samp><samp class="p" data-group-id="5097783933-4">)</samp><samp class="w"> </samp><samp class="k" data-group-id="5097783933-5">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="5097783933-6">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">to_string</samp><samp class="p" data-group-id="5097783933-7">(</samp><samp class="n">role</samp><samp class="p" data-group-id="5097783933-7">)</samp><samp class="p" data-group-id="5097783933-6">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="5097783933-5">end</samp><samp class="w">
</samp><samp class="p" data-group-id="5097783933-8">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="s">&quot;admin&quot;</samp><samp class="p" data-group-id="5097783933-8">}</samp></code></pre><p>As in <a href="#for/1"><code class="inline">for/1</code></a>, variables bound inside <a href="#with/1"><code class="inline">with/1</code></a> won't be accessible
outside of <a href="#with/1"><code class="inline">with/1</code></a>.</p><p>Expressions without <code class="inline">&lt;-</code> may also be used in clauses. For instance,
you can perform regular matches with the <code class="inline">=</code> operator:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">width</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="no">nil</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">opts</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="7296724946-1">%{</samp><samp class="ss">width</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">height</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">15</samp><samp class="p" data-group-id="7296724946-1">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">with</samp><samp class="w"> </samp><samp class="p" data-group-id="7296724946-2">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="p" data-group-id="7296724946-2">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="7296724946-3">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:width</samp><samp class="p" data-group-id="7296724946-3">)</samp><samp class="p">,</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">     </samp><samp class="n">double_width</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">     </samp><samp class="p" data-group-id="7296724946-4">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="7296724946-4">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="7296724946-5">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:height</samp><samp class="p" data-group-id="7296724946-5">)</samp><samp class="w"> </samp><samp class="k" data-group-id="7296724946-6">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="7296724946-7">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">double_width</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="7296724946-7">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="7296724946-6">end</samp><samp class="w">
</samp><samp class="p" data-group-id="7296724946-8">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">300</samp><samp class="p" data-group-id="7296724946-8">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">width</samp><samp class="w">
</samp><samp class="no">nil</samp></code></pre><p>The behavior of any expression in a clause is the same as if it was
written outside of <code class="inline">with</code>. For example, <code class="inline">=</code> will raise a <a href="MatchError.xhtml"><code class="inline">MatchError</code></a>
instead of returning the non-matched value:</p><pre><code class="makeup elixir" translate="no"><samp class="k">with</samp><samp class="w"> </samp><samp class="ss">:foo</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="ss">:bar</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:ok</samp><samp class="w">
</samp><samp class="gt">** (MatchError) no match of right hand side value: :bar</samp></code></pre><p>As with any other function or macro call in Elixir, explicit parens can
also be used around the arguments before the <code class="inline">do</code>-<code class="inline">end</code> block:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">opts</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="9743019618-1">%{</samp><samp class="ss">width</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">height</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">15</samp><samp class="p" data-group-id="9743019618-1">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">with</samp><samp class="p" data-group-id="9743019618-2">(</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="9743019618-3">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="p" data-group-id="9743019618-3">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="9743019618-4">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:width</samp><samp class="p" data-group-id="9743019618-4">)</samp><samp class="p">,</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="9743019618-5">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="9743019618-5">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="9743019618-6">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:height</samp><samp class="p" data-group-id="9743019618-6">)</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="p" data-group-id="9743019618-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="9743019618-7">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="9743019618-8">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="9743019618-8">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="9743019618-7">end</samp><samp class="w">
</samp><samp class="p" data-group-id="9743019618-9">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">150</samp><samp class="p" data-group-id="9743019618-9">}</samp></code></pre><p>The choice between parens and no parens is a matter of preference.</p><h2 id="with/1-else-clauses" class="section-heading"><a href="#with/1-else-clauses" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Else clauses</span></h2><p>An <code class="inline">else</code> option can be given to modify what is being returned from
<code class="inline">with</code> in the case of a failed match:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">opts</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="7325149247-1">%{</samp><samp class="ss">width</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="mi">10</samp><samp class="p" data-group-id="7325149247-1">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">with</samp><samp class="w"> </samp><samp class="p" data-group-id="7325149247-2">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="p" data-group-id="7325149247-2">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="7325149247-3">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:width</samp><samp class="p" data-group-id="7325149247-3">)</samp><samp class="p">,</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">     </samp><samp class="p" data-group-id="7325149247-4">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="7325149247-4">}</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">fetch</samp><samp class="p" data-group-id="7325149247-5">(</samp><samp class="n">opts</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:height</samp><samp class="p" data-group-id="7325149247-5">)</samp><samp class="w"> </samp><samp class="k" data-group-id="7325149247-6">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="7325149247-7">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">width</samp><samp class="w"> </samp><samp class="o">*</samp><samp class="w"> </samp><samp class="n">height</samp><samp class="p" data-group-id="7325149247-7">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="7325149247-6">else</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="ss">:error</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">    </samp><samp class="p" data-group-id="7325149247-8">{</samp><samp class="ss">:error</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:wrong_data</samp><samp class="p" data-group-id="7325149247-8">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="c">_other_error</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">    </samp><samp class="ss">:unexpected_error</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="7325149247-6">end</samp><samp class="w">
</samp><samp class="p" data-group-id="7325149247-9">{</samp><samp class="ss">:error</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:wrong_data</samp><samp class="p" data-group-id="7325149247-9">}</samp></code></pre><p>The <code class="inline">else</code> block works like a <code class="inline">case</code>: it can have multiple clauses,
and the first match will be used. Variables bound inside <code class="inline">with</code> (such as
<code class="inline">width</code> in this example) are not available in the <code class="inline">else</code> block.</p><p>If an <code class="inline">else</code> block is used and there are no matching clauses, a <a href="WithClauseError.xhtml"><code class="inline">WithClauseError</code></a>
exception is raised.</p><h3 id="with/1-beware" class="section-heading"><a href="#with/1-beware" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Beware!</span></h3><p>Keep in mind that, one of potential drawback of <code class="inline">with</code> is that all
failure clauses are flattened into a single <code class="inline">else</code> block. For example,
take this code that checks if a given path points to an Elixir file
and that it exists before creating a backup copy:</p><pre><code class="makeup elixir" translate="no"><samp class="k">with</samp><samp class="w"> </samp><samp class="s">&quot;.ex&quot;</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">Path</samp><samp class="o">.</samp><samp class="n">extname</samp><samp class="p" data-group-id="3157448867-1">(</samp><samp class="n">path</samp><samp class="p" data-group-id="3157448867-1">)</samp><samp class="p">,</samp><samp class="w">
     </samp><samp class="no">true</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="nc">File</samp><samp class="o">.</samp><samp class="n">exists?</samp><samp class="p" data-group-id="3157448867-2">(</samp><samp class="n">path</samp><samp class="p" data-group-id="3157448867-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="3157448867-3">do</samp><samp class="w">
  </samp><samp class="n">backup_path</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">path</samp><samp class="w"> </samp><samp class="o">&lt;&gt;</samp><samp class="w"> </samp><samp class="s">&quot;.backup&quot;</samp><samp class="w">
  </samp><samp class="nc">File</samp><samp class="o">.</samp><samp class="n">cp!</samp><samp class="p" data-group-id="3157448867-4">(</samp><samp class="n">path</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">backup_path</samp><samp class="p" data-group-id="3157448867-4">)</samp><samp class="w">
  </samp><samp class="p" data-group-id="3157448867-5">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">backup_path</samp><samp class="p" data-group-id="3157448867-5">}</samp><samp class="w">
</samp><samp class="k" data-group-id="3157448867-3">else</samp><samp class="w">
  </samp><samp class="n">binary</samp><samp class="w"> </samp><samp class="ow">when</samp><samp class="w"> </samp><samp class="n">is_binary</samp><samp class="p" data-group-id="3157448867-6">(</samp><samp class="n">binary</samp><samp class="p" data-group-id="3157448867-6">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="p" data-group-id="3157448867-7">{</samp><samp class="ss">:error</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:invalid_extension</samp><samp class="p" data-group-id="3157448867-7">}</samp><samp class="w">

  </samp><samp class="no">false</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="p" data-group-id="3157448867-8">{</samp><samp class="ss">:error</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:missing_file</samp><samp class="p" data-group-id="3157448867-8">}</samp><samp class="w">
</samp><samp class="k" data-group-id="3157448867-3">end</samp></code></pre><p>Note how we are having to reconstruct the result types of <a href="Path.xhtml#extname/1"><code class="inline">Path.extname/1</code></a>
and <a href="File.xhtml#exists?/1"><code class="inline">File.exists?/1</code></a> to build error messages. In this case, it is better
to refactor the code so each <code class="inline">&lt;-</code> already return the desired format in case
of errors, like this:</p><pre><code class="makeup elixir" translate="no"><samp class="k">with</samp><samp class="w"> </samp><samp class="ss">:ok</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="n">validate_extension</samp><samp class="p" data-group-id="4551598997-1">(</samp><samp class="n">path</samp><samp class="p" data-group-id="4551598997-1">)</samp><samp class="p">,</samp><samp class="w">
     </samp><samp class="ss">:ok</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="n">validate_exists</samp><samp class="p" data-group-id="4551598997-2">(</samp><samp class="n">path</samp><samp class="p" data-group-id="4551598997-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4551598997-3">do</samp><samp class="w">
  </samp><samp class="n">backup_path</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">path</samp><samp class="w"> </samp><samp class="o">&lt;&gt;</samp><samp class="w"> </samp><samp class="s">&quot;.backup&quot;</samp><samp class="w">
  </samp><samp class="nc">File</samp><samp class="o">.</samp><samp class="n">cp!</samp><samp class="p" data-group-id="4551598997-4">(</samp><samp class="n">path</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">backup_path</samp><samp class="p" data-group-id="4551598997-4">)</samp><samp class="w">
  </samp><samp class="p" data-group-id="4551598997-5">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">backup_path</samp><samp class="p" data-group-id="4551598997-5">}</samp><samp class="w">
</samp><samp class="k" data-group-id="4551598997-3">end</samp><samp class="w">

</samp><samp class="kd">defp</samp><samp class="w"> </samp><samp class="nf">validate_extension</samp><samp class="p" data-group-id="4551598997-6">(</samp><samp class="n">path</samp><samp class="p" data-group-id="4551598997-6">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4551598997-7">do</samp><samp class="w">
  </samp><samp class="k">if</samp><samp class="w"> </samp><samp class="nc">Path</samp><samp class="o">.</samp><samp class="n">extname</samp><samp class="p" data-group-id="4551598997-8">(</samp><samp class="n">path</samp><samp class="p" data-group-id="4551598997-8">)</samp><samp class="w"> </samp><samp class="o">==</samp><samp class="w"> </samp><samp class="s">&quot;.ex&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">else</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="4551598997-9">{</samp><samp class="ss">:error</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:invalid_extension</samp><samp class="p" data-group-id="4551598997-9">}</samp><samp class="w">
</samp><samp class="k" data-group-id="4551598997-7">end</samp><samp class="w">

</samp><samp class="kd">defp</samp><samp class="w"> </samp><samp class="nf">validate_exists</samp><samp class="p" data-group-id="4551598997-10">(</samp><samp class="n">path</samp><samp class="p" data-group-id="4551598997-10">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4551598997-11">do</samp><samp class="w">
  </samp><samp class="k">if</samp><samp class="w"> </samp><samp class="nc">File</samp><samp class="o">.</samp><samp class="n">exists?</samp><samp class="p" data-group-id="4551598997-12">(</samp><samp class="n">path</samp><samp class="p" data-group-id="4551598997-12">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">do</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">else</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="4551598997-13">{</samp><samp class="ss">:error</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:missing_file</samp><samp class="p" data-group-id="4551598997-13">}</samp><samp class="w">
</samp><samp class="k" data-group-id="4551598997-11">end</samp></code></pre><p>Note how the code above is better organized and clearer once we
make sure each <code class="inline">&lt;-</code> in <code class="inline">with</code> returns a normalized format.</p>
  </section>
</section>
<section class="detail" id="%5E/1">

  <div class="detail-header">
    <a href="#%5E/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">^var</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L761" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Pin operator. Accesses an already bound variable in match clauses.</p><h2 id="%5E/1-examples" class="section-heading"><a href="#%5E/1-examples" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Examples</span></h2><p>Elixir allows variables to be rebound via static single assignment:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">+</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">x</samp><samp class="w">
</samp><samp class="mi">2</samp></code></pre><p>However, in some situations, it is useful to match against an existing
value, instead of rebinding. This can be done with the <code class="inline">^</code> special form,
colloquially known as the pin operator:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">1</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="o">^</samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="nc">List</samp><samp class="o">.</samp><samp class="n">first</samp><samp class="p" data-group-id="3511230411-1">(</samp><samp class="p" data-group-id="3511230411-2">[</samp><samp class="mi">1</samp><samp class="p" data-group-id="3511230411-2">]</samp><samp class="p" data-group-id="3511230411-1">)</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="o">^</samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="nc">List</samp><samp class="o">.</samp><samp class="n">first</samp><samp class="p" data-group-id="3511230411-3">(</samp><samp class="p" data-group-id="3511230411-4">[</samp><samp class="mi">2</samp><samp class="p" data-group-id="3511230411-4">]</samp><samp class="p" data-group-id="3511230411-3">)</samp><samp class="w">
</samp><samp class="gt">** (MatchError) no match of right hand side value: 2</samp></code></pre><p>Note that <code class="inline">^x</code> always refers to the value of <code class="inline">x</code> prior to the match. The
following example will match:</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="n">x</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="p" data-group-id="6564783874-1">{</samp><samp class="n">x</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="o">^</samp><samp class="n">x</samp><samp class="p" data-group-id="6564783874-1">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="6564783874-2">{</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">0</samp><samp class="p" data-group-id="6564783874-2">}</samp><samp class="w">
</samp><samp class="gp unselectable">iex&gt; </samp><samp class="n">x</samp><samp class="w">
</samp><samp class="mi">1</samp></code></pre>
  </section>
</section>
<section class="detail" id="%7B%7D/1">

  <div class="detail-header">
    <a href="#%7B%7D/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">{args}</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/elixir-lang/elixir/blob/v1.18.4/lib/elixir/lib/kernel/special_forms.ex#L62" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Creates a tuple.</p><p>More information about the tuple data type and about functions to manipulate
tuples can be found in the <a href="Tuple.xhtml"><code class="inline">Tuple</code></a> module; some functions for working with
tuples are also available in <a href="Kernel.xhtml"><code class="inline">Kernel</code></a> (such as <a href="Kernel.xhtml#elem/2"><code class="inline">Kernel.elem/2</code></a> or
<a href="Kernel.xhtml#tuple_size/1"><code class="inline">Kernel.tuple_size/1</code></a>).</p><h2 id="%7B%7D/1-ast-representation" class="section-heading"><a href="#%7B%7D/1-ast-representation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">AST representation</span></h2><p>Only two-element tuples are considered literals in Elixir and return themselves
when quoted. Therefore, all other tuples are represented in the AST as calls to
the <code class="inline">:{}</code> special form.</p><pre><code class="makeup elixir" translate="no"><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="4116866797-1">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="4116866797-2">{</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="4116866797-2">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="4116866797-1">end</samp><samp class="w">
</samp><samp class="p" data-group-id="4116866797-3">{</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p" data-group-id="4116866797-3">}</samp><samp class="w">

</samp><samp class="gp unselectable">iex&gt; </samp><samp class="k">quote</samp><samp class="w"> </samp><samp class="k" data-group-id="4116866797-4">do</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="w">  </samp><samp class="p" data-group-id="4116866797-5">{</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="4116866797-5">}</samp><samp class="w">
</samp><samp class="gp unselectable">...&gt; </samp><samp class="k" data-group-id="4116866797-4">end</samp><samp class="w">
</samp><samp class="p" data-group-id="4116866797-6">{</samp><samp class="ss">:{}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4116866797-7">[</samp><samp class="p" data-group-id="4116866797-7">]</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="4116866797-8">[</samp><samp class="mi">1</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">2</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="mi">3</samp><samp class="p" data-group-id="4116866797-8">]</samp><samp class="p" data-group-id="4116866797-6">}</samp></code></pre>
  </section>
</section>

        </div>
      </section>


  </body>
</html>
