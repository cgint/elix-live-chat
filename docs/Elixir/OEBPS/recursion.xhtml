<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Recursion - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Recursion</h1>
<p>Elixir does not provide loop constructs. Instead we leverage recursion and high-level functions for working with collections. This chapter will explore the former.</p><h2 id="loops-through-recursion">Loops through recursion</h2><p>Due to immutability, loops in Elixir (as in any functional programming language) are written differently from imperative languages. For example, in an imperative language like C, one would write:</p><pre><code class="c">for(i = 0; i &lt; sizeof(array); i++) {
  array[i] = array[i] * 2;
}</code></pre><p>In the example above, we are mutating both the array and the variable <code class="inline">i</code>. However, data structures in Elixir are immutable. For this reason, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Recursion</span><span class="w"> </span><span class="k" data-group-id="5688520474-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">print_multiple_times</span><span class="p" data-group-id="5688520474-2">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p" data-group-id="5688520474-2">)</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k" data-group-id="5688520474-3">do</span><span class="w">
    </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="5688520474-4">(</span><span class="n">msg</span><span class="p" data-group-id="5688520474-4">)</span><span class="w">
    </span><span class="n">print_multiple_times</span><span class="p" data-group-id="5688520474-5">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="5688520474-5">)</span><span class="w">
  </span><span class="k" data-group-id="5688520474-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">print_multiple_times</span><span class="p" data-group-id="5688520474-6">(</span><span class="c">_msg</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="5688520474-6">)</span><span class="w"> </span><span class="k" data-group-id="5688520474-7">do</span><span class="w">
    </span><span class="ss">:ok</span><span class="w">
  </span><span class="k" data-group-id="5688520474-7">end</span><span class="w">
</span><span class="k" data-group-id="5688520474-1">end</span><span class="w">

</span><span class="nc">Recursion</span><span class="o">.</span><span class="n">print_multiple_times</span><span class="p" data-group-id="5688520474-8">(</span><span class="s">&quot;Hello!&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="5688520474-8">)</span><span class="w">
</span><span class="c1"># Hello!</span><span class="w">
</span><span class="c1"># Hello!</span><span class="w">
</span><span class="c1"># Hello!</span><span class="w">
</span><span class="ss">:ok</span></code></pre><p>Similar to <code class="inline">case</code>, a function may have many clauses. A particular clause is executed when the arguments passed to the function match the clause's argument patterns and its guards evaluate to <code class="inline">true</code>.</p><p>When <code class="inline">print_multiple_times/2</code> is initially called in the example above, the argument <code class="inline">n</code> is equal to <code class="inline">3</code>.</p><p>The first clause has a guard which says &quot;use this definition if and only if <code class="inline">n</code> is more than <code class="inline">0</code>&quot;. Since this is the case, it prints the <code class="inline">msg</code> and then calls itself passing <code class="inline">n - 1</code> (<code class="inline">2</code>) as the second argument.</p><p>Now we execute the same function again, starting from the first clause. Given the second argument, <code class="inline">n</code>, is still more than 0, we print the message and call ourselves once more, now with the second argument set to <code class="inline">1</code>. Then we print the message one last time and call <code class="inline">print_multiple_times(&quot;Hello!&quot;, 0)</code>, starting from the top once again.</p><p>When the second argument is zero, the guard <code class="inline">n &gt; 0</code> evaluates to false, and the first function clause won't execute. Elixir then proceeds to try the next function clause, which explicitly matches on the case where <code class="inline">n</code> is <code class="inline">0</code>. This clause, also known as the termination clause, ignores the message argument by assigning it to the <code class="inline">_msg</code> variable and returns the atom <code class="inline">:ok</code>.</p><p>Finally, if you pass an argument that does not match any clause, Elixir raises a <a href="FunctionClauseError.xhtml"><code class="inline">FunctionClauseError</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">Recursion</span><span class="o">.</span><span class="n">print_multiple_times</span><span class="p" data-group-id="9309889179-1">(</span><span class="s">&quot;Hello!&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p" data-group-id="9309889179-1">)</span><span class="w">
</span><span class="gt">** (FunctionClauseError) no function clause matching in Recursion.print_multiple_times/2</span><span class="w">

    </span><span class="nc">The</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="n">given</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="nc">Recursion</span><span class="o">.</span><span class="n">print_multiple_times</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span><span class="w">

        </span><span class="c1"># 1</span><span class="w">
        </span><span class="s">&quot;Hello!&quot;</span><span class="w">

        </span><span class="c1"># 2</span><span class="w">
        </span><span class="o">-</span><span class="mi">1</span><span class="w">

    </span><span class="n">iex</span><span class="p">:</span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="nc">Recursion</span><span class="o">.</span><span class="n">print_multiple_times</span><span class="o">/</span><span class="mi">2</span></code></pre><h2 id="reduce-and-map-algorithms">Reduce and map algorithms</h2><p>Let's now see how we can use the power of recursion to sum a list of numbers:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Math</span><span class="w"> </span><span class="k" data-group-id="4770993337-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">sum_list</span><span class="p" data-group-id="4770993337-2">(</span><span class="p" data-group-id="4770993337-3">[</span><span class="n">head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tail</span><span class="p" data-group-id="4770993337-3">]</span><span class="p">,</span><span class="w"> </span><span class="n">accumulator</span><span class="p" data-group-id="4770993337-2">)</span><span class="w"> </span><span class="k" data-group-id="4770993337-4">do</span><span class="w">
    </span><span class="n">sum_list</span><span class="p" data-group-id="4770993337-5">(</span><span class="n">tail</span><span class="p">,</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">accumulator</span><span class="p" data-group-id="4770993337-5">)</span><span class="w">
  </span><span class="k" data-group-id="4770993337-4">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">sum_list</span><span class="p" data-group-id="4770993337-6">(</span><span class="p" data-group-id="4770993337-7">[</span><span class="p" data-group-id="4770993337-7">]</span><span class="p">,</span><span class="w"> </span><span class="n">accumulator</span><span class="p" data-group-id="4770993337-6">)</span><span class="w"> </span><span class="k" data-group-id="4770993337-8">do</span><span class="w">
    </span><span class="n">accumulator</span><span class="w">
  </span><span class="k" data-group-id="4770993337-8">end</span><span class="w">
</span><span class="k" data-group-id="4770993337-1">end</span><span class="w">

</span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="w"> </span><span class="nc">Math</span><span class="o">.</span><span class="n">sum_list</span><span class="p" data-group-id="4770993337-9">(</span><span class="p" data-group-id="4770993337-10">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="4770993337-10">]</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="4770993337-9">)</span><span class="w"> </span><span class="c1">#=&gt; 6</span></code></pre><p>We invoke <code class="inline">sum_list</code> with the list <code class="inline">[1, 2, 3]</code> and the initial value <code class="inline">0</code> as arguments. We will try each clause until we find one that matches according to the pattern matching rules. In this case, the list <code class="inline">[1, 2, 3]</code> matches against <code class="inline">[head | tail]</code> which binds <code class="inline">head</code> to <code class="inline">1</code> and <code class="inline">tail</code> to <code class="inline">[2, 3]</code>; <code class="inline">accumulator</code> is set to <code class="inline">0</code>.</p><p>Then, we add the head of the list to the accumulator <code class="inline">head + accumulator</code> and call <code class="inline">sum_list</code> again, recursively, passing the tail of the list as its first argument. The tail will once again match <code class="inline">[head | tail]</code> until the list is empty, as seen below:</p><pre><code class="makeup elixir" translate="no"><span class="n">sum_list</span><span class="p" data-group-id="1289931143-1">(</span><span class="p" data-group-id="1289931143-2">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1289931143-2">]</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="1289931143-1">)</span><span class="w">
</span><span class="n">sum_list</span><span class="p" data-group-id="1289931143-3">(</span><span class="p" data-group-id="1289931143-4">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1289931143-4">]</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="1289931143-3">)</span><span class="w">
</span><span class="n">sum_list</span><span class="p" data-group-id="1289931143-5">(</span><span class="p" data-group-id="1289931143-6">[</span><span class="mi">3</span><span class="p" data-group-id="1289931143-6">]</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1289931143-5">)</span><span class="w">
</span><span class="n">sum_list</span><span class="p" data-group-id="1289931143-7">(</span><span class="p" data-group-id="1289931143-8">[</span><span class="p" data-group-id="1289931143-8">]</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p" data-group-id="1289931143-7">)</span></code></pre><p>When the list is empty, it will match the final clause which returns the final result of <code class="inline">6</code>.</p><p>The process of taking a list and <em>reducing</em> it down to one value is known as a <em>reduce algorithm</em> and is central to functional programming.</p><p>What if we instead want to double all of the values in our list?</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Math</span><span class="w"> </span><span class="k" data-group-id="9499486099-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">double_each</span><span class="p" data-group-id="9499486099-2">(</span><span class="p" data-group-id="9499486099-3">[</span><span class="n">head</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">tail</span><span class="p" data-group-id="9499486099-3">]</span><span class="p" data-group-id="9499486099-2">)</span><span class="w"> </span><span class="k" data-group-id="9499486099-4">do</span><span class="w">
    </span><span class="p" data-group-id="9499486099-5">[</span><span class="n">head</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">double_each</span><span class="p" data-group-id="9499486099-6">(</span><span class="n">tail</span><span class="p" data-group-id="9499486099-6">)</span><span class="p" data-group-id="9499486099-5">]</span><span class="w">
  </span><span class="k" data-group-id="9499486099-4">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">double_each</span><span class="p" data-group-id="9499486099-7">(</span><span class="p" data-group-id="9499486099-8">[</span><span class="p" data-group-id="9499486099-8">]</span><span class="p" data-group-id="9499486099-7">)</span><span class="w"> </span><span class="k" data-group-id="9499486099-9">do</span><span class="w">
    </span><span class="p" data-group-id="9499486099-10">[</span><span class="p" data-group-id="9499486099-10">]</span><span class="w">
  </span><span class="k" data-group-id="9499486099-9">end</span><span class="w">
</span><span class="k" data-group-id="9499486099-1">end</span><span class="w">

</span><span class="nc">Math</span><span class="o">.</span><span class="n">double_each</span><span class="p" data-group-id="9499486099-11">(</span><span class="p" data-group-id="9499486099-12">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="9499486099-12">]</span><span class="p" data-group-id="9499486099-11">)</span><span class="w"> </span><span class="c1">#=&gt; [2, 4, 6]</span></code></pre><p>Here we have used recursion to traverse a list, doubling each element and returning a new list. The process of taking a list and <em>mapping</em> over it is known as a <em>map algorithm</em>.</p><p>Recursion and <a href="https://en.wikipedia.org/wiki/Tail_call">tail call</a> optimization are an important part of Elixir and are commonly used to create loops. However, when programming in Elixir you will rarely use recursion as above to manipulate lists.</p><p>The <a href="Enum.xhtml"><code class="inline">Enum</code></a> module, which we're going to see in the next chapter already provides many conveniences for working with lists. For instance, the examples above could be written as:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p" data-group-id="3025531953-1">(</span><span class="p" data-group-id="3025531953-2">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="3025531953-2">]</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="3025531953-3">fn</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="k" data-group-id="3025531953-3">end</span><span class="p" data-group-id="3025531953-1">)</span><span class="w">
</span><span class="mi">6</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="3025531953-4">(</span><span class="p" data-group-id="3025531953-5">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="3025531953-5">]</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="3025531953-6">fn</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k" data-group-id="3025531953-6">end</span><span class="p" data-group-id="3025531953-4">)</span><span class="w">
</span><span class="p" data-group-id="3025531953-7">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p" data-group-id="3025531953-7">]</span></code></pre><p>Or, using the <a href="Kernel.SpecialForms.xhtml#&/1">capture syntax</a>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p" data-group-id="1877728733-1">(</span><span class="p" data-group-id="1877728733-2">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1877728733-2">]</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="o">+</span><span class="o">/</span><span class="mi">2</span><span class="p" data-group-id="1877728733-1">)</span><span class="w">
</span><span class="mi">6</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="1877728733-3">(</span><span class="p" data-group-id="1877728733-4">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="1877728733-4">]</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="1877728733-5">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1877728733-5">)</span><span class="p" data-group-id="1877728733-3">)</span><span class="w">
</span><span class="p" data-group-id="1877728733-6">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p" data-group-id="1877728733-6">]</span></code></pre><p>Let's take a deeper look at <a href="Enumerable.xhtml"><code class="inline">Enumerable</code></a> and, while we're at it, its lazy counterpart, <a href="Stream.xhtml"><code class="inline">Stream</code></a>.</p>

  </body>
</html>
