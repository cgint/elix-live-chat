<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Anonymous functions - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Anonymous functions</h1>
<p>Anonymous functions allow us to store and pass executable code around as if it was an integer or a string. Let's learn more.</p><h2 id="identifying-functions-and-documentation">Identifying functions and documentation</h2><p>Before we move on to discuss anonymous functions, let's talk about how Elixir identifies named functions.</p><p>Functions in Elixir are identified by both their name and their arity. The arity of a function describes the number of arguments that the function takes. From this point on we will use both the function name and its arity to describe functions throughout the documentation. <a href="Kernel.xhtml#trunc/1"><code class="inline">trunc/1</code></a> identifies the function which is named <code class="inline">trunc</code> and takes <code class="inline">1</code> argument, whereas <code class="inline">trunc/2</code> identifies a different (nonexistent) function with the same name but with an arity of <code class="inline">2</code>.</p><p>We can also use this syntax to access documentation. The Elixir shell defines the <a href="https://hexdocs.pm/iex/IEx.Helpers.html#h/1"><code class="inline">h</code></a> function, which you can use to access documentation for any function. For example, typing <code class="inline">h trunc/1</code> is going to print the documentation for the <a href="Kernel.xhtml#trunc/1"><code class="inline">trunc/1</code></a> function:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">h</span><span class="w"> </span><span class="n">trunc</span><span class="o">/</span><span class="mi">1</span><span class="w">
                             </span><span class="kd">def</span><span class="w"> </span><span class="nf">trunc</span><span class="p" data-group-id="8099823084-1">(</span><span class="n">number</span><span class="p" data-group-id="8099823084-1">)</span><span class="w">

</span><span class="nc">Returns</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">number</span><span class="o">.</span></code></pre><p><code class="inline">h trunc/1</code> works because it is defined in the <a href="Kernel.xhtml"><code class="inline">Kernel</code></a> module. All functions in the <a href="Kernel.xhtml"><code class="inline">Kernel</code></a> module are automatically imported into our namespace. Most often you will also include the module name when looking up the documentation for a given function:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">h</span><span class="w"> </span><span class="nc">Kernel</span><span class="o">.</span><span class="n">trunc</span><span class="o">/</span><span class="mi">1</span><span class="w">
                             </span><span class="kd">def</span><span class="w"> </span><span class="nf">trunc</span><span class="p" data-group-id="0149245194-1">(</span><span class="n">number</span><span class="p" data-group-id="0149245194-1">)</span><span class="w">

</span><span class="nc">Returns</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">number</span><span class="o">.</span></code></pre><p>You can use the module+function to lookup for anything, including operators (try <code class="inline">h Kernel.+/2</code>). Invoking <a href="https://hexdocs.pm/iex/IEx.Helpers.html#h/1"><code class="inline">h</code></a> without arguments displays the documentation for <a href="https://hexdocs.pm/iex/IEx.Helpers.html"><code class="inline">IEx.Helpers</code></a>, which is where <code class="inline">h</code> and other functionalities are defined.</p><h2 id="defining-anonymous-functions">Defining anonymous functions</h2><p>Anonymous functions in Elixir are delimited by the keywords <code class="inline">fn</code> and <code class="inline">end</code>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="2655954606-1">fn</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k" data-group-id="2655954606-1">end</span><span class="w">
</span><span class="p" data-group-id="2655954606-2">#</span><span class="nc" data-group-id="2655954606-2">Function</span><span class="p" data-group-id="2655954606-2">&lt;</span><span class="mf">12.71889879</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">:erl_eval</span><span class="o">.</span><span class="n">expr</span><span class="o">/</span><span class="mi">5</span><span class="p" data-group-id="2655954606-2">&gt;</span></code></pre><p>In the example above, we defined an anonymous function that receives two arguments, <code class="inline">a</code> and <code class="inline">b</code>, and returns the result of <code class="inline">a + b</code>. The arguments are always on the left-hand side of <code class="inline">-&gt;</code> and the code to be executed on the right-hand side. The anonymous function is stored in the variable <code class="inline">add</code>. You can see it returns a value represented by <code class="inline">#Function&lt;...&gt;</code>. While its representation is opaque, the <code class="inline">:erl_eval.expr</code> bit tells us the function was defined in the shell (during evaluation).</p><p>We can invoke anonymous functions by passing arguments to it, using a dot (<code class="inline">.</code>) between the variable and the opening parenthesis:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">add</span><span class="o">.</span><span class="p" data-group-id="3564708244-1">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="3564708244-1">)</span><span class="w">
</span><span class="mi">3</span></code></pre><p>The dot makes it clear when you are calling an anonymous function, stored in the variable <code class="inline">add</code>, opposed to a function named <code class="inline">add/2</code>. For example, if you have an anonymous function stored in the variable <code class="inline">is_atom</code>, there is no ambiguity between <code class="inline">is_atom.(:foo)</code> and <code class="inline">is_atom(:foo)</code>. If both used the same <code class="inline">is_atom(:foo)</code> syntax, the only way to know the actual behavior of <code class="inline">is_atom(:foo)</code> would be by scanning all code thus far for a possible definition of the <code class="inline">is_atom</code> variable. This scanning hurts maintainability as it requires developers to track additional context in their head when reading and writing code.</p><p>Anonymous functions in Elixir are also identified by the number of arguments they receive. We can check if a value is function using <a href="Kernel.xhtml#is_function/1"><code class="inline">is_function/1</code></a> and also check its arity by using <a href="Kernel.xhtml#is_function/2"><code class="inline">is_function/2</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">is_function</span><span class="p" data-group-id="1460260726-1">(</span><span class="n">add</span><span class="p" data-group-id="1460260726-1">)</span><span class="w">
</span><span class="no">true</span><span class="w">
</span><span class="c1"># check if add is a function that expects exactly 2 arguments</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">is_function</span><span class="p" data-group-id="1460260726-2">(</span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1460260726-2">)</span><span class="w">
</span><span class="no">true</span><span class="w">
</span><span class="c1"># check if add is a function that expects exactly 1 argument</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">is_function</span><span class="p" data-group-id="1460260726-3">(</span><span class="n">add</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="1460260726-3">)</span><span class="w">
</span><span class="no">false</span></code></pre><h2 id="closures">Closures</h2><p>Anonymous functions can also access variables that are in scope when the function is defined. This is typically referred to as closures, as they close over their scope. Let's define a new anonymous function that uses the <code class="inline">add</code> anonymous function we have previously defined:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">double</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="7868359161-1">fn</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">add</span><span class="o">.</span><span class="p" data-group-id="7868359161-2">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p" data-group-id="7868359161-2">)</span><span class="w"> </span><span class="k" data-group-id="7868359161-1">end</span><span class="w">
</span><span class="p" data-group-id="7868359161-3">#</span><span class="nc" data-group-id="7868359161-3">Function</span><span class="p" data-group-id="7868359161-3">&lt;</span><span class="mf">6.71889879</span><span class="o">/</span><span class="mi">1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">:erl_eval</span><span class="o">.</span><span class="n">expr</span><span class="o">/</span><span class="mi">5</span><span class="p" data-group-id="7868359161-3">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">double</span><span class="o">.</span><span class="p" data-group-id="7868359161-4">(</span><span class="mi">2</span><span class="p" data-group-id="7868359161-4">)</span><span class="w">
</span><span class="mi">4</span></code></pre><p>A variable assigned inside a function does not affect its surrounding environment:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="w">
</span><span class="mi">42</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="1838880513-1">(</span><span class="k" data-group-id="1838880513-2">fn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k" data-group-id="1838880513-2">end</span><span class="p" data-group-id="1838880513-1">)</span><span class="o">.</span><span class="p" data-group-id="1838880513-3">(</span><span class="p" data-group-id="1838880513-3">)</span><span class="w">
</span><span class="mi">0</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">x</span><span class="w">
</span><span class="mi">42</span></code></pre><h2 id="clauses-and-guards">Clauses and guards</h2><p>Similar to <a href="Kernel.SpecialForms.xhtml#case/2"><code class="inline">case/2</code></a>, we can pattern match on the arguments of anonymous functions as well as define multiple clauses and guards:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="5635291013-1">fn</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="5635291013-1">end</span><span class="w">
</span><span class="p" data-group-id="5635291013-2">#</span><span class="nc" data-group-id="5635291013-2">Function</span><span class="p" data-group-id="5635291013-2">&lt;</span><span class="mf">12.71889879</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">:erl_eval</span><span class="o">.</span><span class="n">expr</span><span class="o">/</span><span class="mi">5</span><span class="p" data-group-id="5635291013-2">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">f</span><span class="o">.</span><span class="p" data-group-id="5635291013-3">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="5635291013-3">)</span><span class="w">
</span><span class="mi">4</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">f</span><span class="o">.</span><span class="p" data-group-id="5635291013-4">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="5635291013-4">)</span><span class="w">
</span><span class="o">-</span><span class="mi">3</span></code></pre><p>The number of arguments in each anonymous function clause needs to be the same, otherwise an error is raised.</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="4641284743-1">fn</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="4641284743-1">end</span><span class="w">
</span><span class="gt">** (CompileError) iex:1: cannot mix clauses with different arities in anonymous functions</span></code></pre><h2 id="the-capture-operator">The capture operator</h2><p>Throughout this guide, we have been using the notation <code class="inline">name/arity</code> to refer to functions. It happens that this notation can actually be used to capture an existing function into a data-type we can pass around, similar to how anonymous functions behave.</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_atom</span><span class="o">/</span><span class="mi">1</span><span class="w">
</span><span class="o">&amp;</span><span class="nc">:erlang</span><span class="o">.</span><span class="n">is_atom</span><span class="o">/</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">is_function</span><span class="p" data-group-id="6513719161-1">(</span><span class="n">fun</span><span class="p" data-group-id="6513719161-1">)</span><span class="w">
</span><span class="no">true</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="6513719161-2">(</span><span class="ss">:hello</span><span class="p" data-group-id="6513719161-2">)</span><span class="w">
</span><span class="no">true</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="6513719161-3">(</span><span class="mi">123</span><span class="p" data-group-id="6513719161-3">)</span><span class="w">
</span><span class="no">false</span></code></pre><p>As you can see, once a function is captured, we can pass it as argument or invoke it using the anonymous function notation. The returned value above also hints we can capture functions defined in modules:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">String</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="mi">1</span><span class="w">
</span><span class="o">&amp;</span><span class="nc">String</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="mi">1</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="3417640799-1">(</span><span class="s">&quot;hello&quot;</span><span class="p" data-group-id="3417640799-1">)</span><span class="w">
</span><span class="mi">5</span></code></pre><p>Since operators are functions in Elixir, you can also capture operators:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">add</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="o">+</span><span class="o">/</span><span class="mi">2</span><span class="w">
</span><span class="o">&amp;</span><span class="ss">:erlang</span><span class="o">.</span><span class="o">+</span><span class="o">/</span><span class="mi">2</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">add</span><span class="o">.</span><span class="p" data-group-id="2875044986-1">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="2875044986-1">)</span><span class="w">
</span><span class="mi">3</span></code></pre><p>The capture syntax can also be used as a shortcut for creating functions that wrap existing functions. For example, imagine you want to create an anonymous function that checks if a given function has arity 2. You could write it as:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">is_arity_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k" data-group-id="3959765879-1">fn</span><span class="w"> </span><span class="n">fun</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">is_function</span><span class="p" data-group-id="3959765879-2">(</span><span class="n">fun</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="3959765879-2">)</span><span class="w"> </span><span class="k" data-group-id="3959765879-1">end</span><span class="w">
</span><span class="p" data-group-id="3959765879-3">#</span><span class="nc" data-group-id="3959765879-3">Function</span><span class="p" data-group-id="3959765879-3">&lt;</span><span class="mf">8.71889879</span><span class="o">/</span><span class="mi">1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">:erl_eval</span><span class="o">.</span><span class="n">expr</span><span class="o">/</span><span class="mi">5</span><span class="p" data-group-id="3959765879-3">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">is_arity_2</span><span class="o">.</span><span class="p" data-group-id="3959765879-4">(</span><span class="n">add</span><span class="p" data-group-id="3959765879-4">)</span><span class="w">
</span><span class="no">true</span></code></pre><p>But using the capture syntax, you can write it as:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">is_arity_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_function</span><span class="p" data-group-id="1970950518-1">(</span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="1970950518-1">)</span><span class="w">
</span><span class="p" data-group-id="1970950518-2">#</span><span class="nc" data-group-id="1970950518-2">Function</span><span class="p" data-group-id="1970950518-2">&lt;</span><span class="mf">8.71889879</span><span class="o">/</span><span class="mi">1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">:erl_eval</span><span class="o">.</span><span class="n">expr</span><span class="o">/</span><span class="mi">5</span><span class="p" data-group-id="1970950518-2">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">is_arity_2</span><span class="o">.</span><span class="p" data-group-id="1970950518-3">(</span><span class="n">add</span><span class="p" data-group-id="1970950518-3">)</span><span class="w">
</span><span class="no">true</span></code></pre><p>The <code class="inline">&amp;1</code> represents the first argument passed into the function. Therefore both <code class="inline">is_arity_2</code> anonymous functions defined above are equivalent.</p><p>Once again, given operators are function calls, the capture syntax shorthand also works with operators, or even string interpolation:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">fun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p" data-group-id="7886349456-1">(</span><span class="ni">&amp;1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="7886349456-1">)</span><span class="w">
</span><span class="p" data-group-id="7886349456-2">#</span><span class="nc" data-group-id="7886349456-2">Function</span><span class="p" data-group-id="7886349456-2">&lt;</span><span class="mf">6.71889879</span><span class="o">/</span><span class="mi">1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">:erl_eval</span><span class="o">.</span><span class="n">expr</span><span class="o">/</span><span class="mi">5</span><span class="p" data-group-id="7886349456-2">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">fun</span><span class="o">.</span><span class="p" data-group-id="7886349456-3">(</span><span class="mi">1</span><span class="p" data-group-id="7886349456-3">)</span><span class="w">
</span><span class="mi">2</span><span class="w">

</span><span class="gp unselectable">iex&gt; </span><span class="n">fun2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="s">&quot;Good </span><span class="si" data-group-id="7886349456-4">#{</span><span class="ni">&amp;1</span><span class="si" data-group-id="7886349456-4">}</span><span class="s">&quot;</span><span class="w">
</span><span class="p" data-group-id="7886349456-5">#</span><span class="nc" data-group-id="7886349456-5">Function</span><span class="p" data-group-id="7886349456-5">&lt;</span><span class="mf">6.127694169</span><span class="o">/</span><span class="mi">1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nc">:erl_eval</span><span class="o">.</span><span class="n">expr</span><span class="o">/</span><span class="mi">5</span><span class="p" data-group-id="7886349456-5">&gt;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">fun2</span><span class="o">.</span><span class="p" data-group-id="7886349456-6">(</span><span class="s">&quot;morning&quot;</span><span class="p" data-group-id="7886349456-6">)</span><span class="w">
</span><span class="s">&quot;Good morning&quot;</span></code></pre><p><code class="inline">&amp;(&amp;1 + 1)</code> above is exactly the same as <code class="inline">fn x -&gt; x + 1 end</code>. You can read more about the capture operator <code class="inline">&amp;</code> in <a href="Kernel.SpecialForms.xhtml#&/1">its documentation</a>.</p><p>Next let's revisit some of the data-types we learned in the past and dig deeper into how they work.</p>

  </body>
</html>
