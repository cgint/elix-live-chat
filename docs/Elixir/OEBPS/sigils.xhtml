<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Sigils - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Sigils</h1>
<p>Elixir provides double-quoted strings as well as a concept called charlists, which are defined using the <code class="inline">~c&quot;hello world&quot;</code> sigil syntax. In this chapter, we will learn more about sigils and how to define our own.</p><p>One of Elixir's goals is extensibility: developers should be able to extend the language to fit any particular domain. Sigils provide the foundation for extending the language with custom textual representations. Sigils start with the tilde (<code class="inline">~</code>) character which is followed by either a single lower-case letter or one or more upper-case letters, and then a delimiter. Optional modifiers are added after the final delimiter.</p><h2 id="regular-expressions">Regular expressions</h2><p>The most common sigil in Elixir is <code class="inline">~r</code>, which is used to create <a href="https://en.wikipedia.org/wiki/Regular_Expressions">regular expressions</a>:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># A regular expression that matches strings which contain &quot;foo&quot; or &quot;bar&quot;:</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">regex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sr">~r/foo|bar/</span><span class="w">
</span><span class="sr">~r/foo|bar/</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="s">&quot;foo&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">regex</span><span class="w">
</span><span class="no">true</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="s">&quot;bat&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="n">regex</span><span class="w">
</span><span class="no">false</span></code></pre><p>Elixir provides Perl-compatible regular expressions (regexes), as implemented by the <a href="http://www.pcre.org/">PCRE</a> library. Regexes also support modifiers. For example, the <code class="inline">i</code> modifier makes a regular expression case insensitive:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="s">&quot;HELLO&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="sr">~r/hello/</span><span class="w">
</span><span class="no">false</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="s">&quot;HELLO&quot;</span><span class="w"> </span><span class="o">=~</span><span class="w"> </span><span class="sr">~r/hello/i</span><span class="w">
</span><span class="no">true</span></code></pre><p>Check out the <a href="Regex.xhtml"><code class="inline">Regex</code></a> module for more information on other modifiers and the supported operations with regular expressions.</p><p>So far, all examples have used <code class="inline">/</code> to delimit a regular expression. However, sigils support 8 different delimiters:</p><pre><code class="makeup elixir" translate="no"><span class="sr">~r/hello/</span><span class="w">
</span><span class="sr">~r|hello|</span><span class="w">
</span><span class="sr">~r&quot;hello&quot;</span><span class="w">
</span><span class="sr">~r&#39;hello&#39;</span><span class="w">
</span><span class="sr">~r(hello)</span><span class="w">
</span><span class="sr">~r[hello]</span><span class="w">
</span><span class="sr">~r{hello}</span><span class="w">
</span><span class="sr">~r&lt;hello&gt;</span></code></pre><p>The reason behind supporting different delimiters is to provide a way to write literals without escaped delimiters. For example, a regular expression with forward slashes like <code class="inline">~r(^https?://)</code> reads arguably better than <code class="inline">~r/^https?:\/\//</code>. Similarly, if the regular expression has forward slashes and capturing groups (that use <code class="inline">()</code>), you may then choose double quotes instead of parentheses.</p><h2 id="strings-charlists-and-word-lists-sigils">Strings, charlists, and word lists sigils</h2><p>Besides regular expressions, Elixir ships with three other sigils.</p><h3 id="strings">Strings</h3><p>The <code class="inline">~s</code> sigil is used to generate strings, like double quotes are. The <code class="inline">~s</code> sigil is useful when a string contains double quotes:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="s">~s(this is a string with &quot;double&quot; quotes, not &#39;single&#39; ones)</span><span class="w">
</span><span class="s">&quot;this is a string with </span><span class="se">\&quot;</span><span class="s">double</span><span class="se">\&quot;</span><span class="s"> quotes, not &#39;single&#39; ones&quot;</span></code></pre><h3 id="charlists">Charlists</h3><p>The <code class="inline">~c</code> sigil is the regular way to represent charlists.</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="1548929805-1">[</span><span class="sc">?c</span><span class="p">,</span><span class="w"> </span><span class="sc">?a</span><span class="p">,</span><span class="w"> </span><span class="sc">?t</span><span class="p" data-group-id="1548929805-1">]</span><span class="w">
</span><span class="s">~c&quot;cat&quot;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="s">~c(this is a char list containing &quot;double quotes&quot;)</span><span class="w">
</span><span class="s">~c&quot;this is a char list containing </span><span class="se">\&quot;</span><span class="s">double quotes</span><span class="se">\&quot;</span><span class="s">&quot;</span></code></pre><h3 id="word-lists">Word lists</h3><p>The <code class="inline">~w</code> sigil is used to generate lists of words (<em>words</em> are just regular strings). Inside the <code class="inline">~w</code> sigil, words are separated by whitespace.</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="sx">~w(foo bar bat)</span><span class="w">
</span><span class="p" data-group-id="9708403962-1">[</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bar&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bat&quot;</span><span class="p" data-group-id="9708403962-1">]</span></code></pre><p>The <code class="inline">~w</code> sigil also accepts the <code class="inline">c</code>, <code class="inline">s</code> and <code class="inline">a</code> modifiers (for charlists, strings, and atoms, respectively), which specify the data type of the elements of the resulting list:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="sx">~w(foo bar bat)a</span><span class="w">
</span><span class="p" data-group-id="2852973360-1">[</span><span class="ss">:foo</span><span class="p">,</span><span class="w"> </span><span class="ss">:bar</span><span class="p">,</span><span class="w"> </span><span class="ss">:bat</span><span class="p" data-group-id="2852973360-1">]</span></code></pre><h2 id="interpolation-and-escaping-in-string-sigils">Interpolation and escaping in string sigils</h2><p>Elixir supports some sigil variants to deal with escaping characters and interpolation. In particular, uppercase letters sigils do not perform interpolation nor escaping. For example, although both <code class="inline">~s</code> and <code class="inline">~S</code> will return strings, the former allows escape codes and interpolation while the latter does not:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="s">~s(String with escape codes </span><span class="se">\x</span><span class="s">26 </span><span class="si" data-group-id="8627242816-1">#{</span><span class="s">&quot;inter&quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s">&quot;polation&quot;</span><span class="si" data-group-id="8627242816-1">}</span><span class="s">)</span><span class="w">
</span><span class="s">&quot;String with escape codes &amp; interpolation&quot;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="s">~S(String without escape codes \x26 without #{interpolation})</span><span class="w">
</span><span class="s">&quot;String without escape codes </span><span class="se">\\</span><span class="s">x26 without </span><span class="se">\#</span><span class="s">{interpolation}&quot;</span></code></pre><p>The following escape codes can be used in strings and charlists:</p><ul><li><code class="inline">\\</code> – single backslash</li><li><code class="inline">\a</code> – bell/alert</li><li><code class="inline">\b</code> – backspace</li><li><code class="inline">\d</code> - delete</li><li><code class="inline">\e</code> - escape</li><li><code class="inline">\f</code> - form feed</li><li><code class="inline">\n</code> – newline</li><li><code class="inline">\r</code> – carriage return</li><li><code class="inline">\s</code> – space</li><li><code class="inline">\t</code> – tab</li><li><code class="inline">\v</code> – vertical tab</li><li><code class="inline">\0</code> - null byte</li><li><code class="inline">\xDD</code> - represents a single byte in hexadecimal (such as <code class="inline">\x13</code>)</li><li><code class="inline">\uDDDD</code> and <code class="inline">\u{D...}</code> - represents a Unicode codepoint in hexadecimal (such as <code class="inline">\u{1F600}</code>)</li></ul><p>In addition to those, a double quote inside a double-quoted string needs to be escaped as <code class="inline">\&quot;</code>, and, analogously, a single quote inside a single-quoted char list needs to be escaped as <code class="inline">\'</code>. Nevertheless, it is better style to change delimiters as seen above than to escape them.</p><p>Sigils also support heredocs, that is, three double-quotes or single-quotes as separators:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="s">~s&quot;&quot;&quot;</span><span class="gp unselectable">
...&gt; </span><span class="s">this is</span><span class="gp unselectable">
...&gt; </span><span class="s">a heredoc string</span><span class="gp unselectable">
...&gt; </span><span class="s">&quot;&quot;&quot;</span></code></pre><p>The most common use case for heredoc sigils is when writing documentation. For example, writing escape characters in the documentation would soon become error prone because of the need to double-escape some characters:</p><pre><code class="makeup elixir" translate="no"><span class="na">@doc</span><span class="w"> </span><span class="s">&quot;&quot;&quot;
Converts double-quotes to single-quotes.

## Examples

    iex&gt; convert(&quot;</span><span class="se">\\</span><span class="se">\&quot;</span><span class="s">foo</span><span class="se">\\</span><span class="se">\&quot;</span><span class="s">&quot;)
    &quot;&#39;foo&#39;&quot;

&quot;&quot;&quot;</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">convert</span><span class="p" data-group-id="9570390600-1">(</span><span class="n">...</span><span class="p" data-group-id="9570390600-1">)</span></code></pre><p>By using <code class="inline">~S</code>, this problem can be avoided altogether:</p><pre><code class="makeup elixir" translate="no"><span class="na">@doc</span><span class="w"> </span><span class="s">~S&quot;&quot;&quot;
Converts double-quotes to single-quotes.

## Examples

    iex&gt; convert(&quot;\&quot;foo\&quot;&quot;)
    &quot;&#39;foo&#39;&quot;

&quot;&quot;&quot;</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">convert</span><span class="p" data-group-id="7479502082-1">(</span><span class="n">...</span><span class="p" data-group-id="7479502082-1">)</span></code></pre><h2 id="calendar-sigils">Calendar sigils</h2><p>Elixir offers several sigils to deal with various flavors of times and dates.</p><h3 id="date">Date</h3><p>A <a href="Date.xhtml">%Date{}</a> struct contains the fields <code class="inline">year</code>, <code class="inline">month</code>, <code class="inline">day</code>, and <code class="inline">calendar</code>. You can create one using the <code class="inline">~D</code> sigil:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ld">~D[2019-10-31]</span><span class="w">
</span><span class="ld">~D[2019-10-31]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">day</span><span class="w">
</span><span class="mi">31</span></code></pre><h3 id="time">Time</h3><p>The <a href="Time.xhtml">%Time{}</a> struct contains the fields <code class="inline">hour</code>, <code class="inline">minute</code>, <code class="inline">second</code>, <code class="inline">microsecond</code>, and <code class="inline">calendar</code>. You can create one using the <code class="inline">~T</code> sigil:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ld">~T[23:00:07.0]</span><span class="w">
</span><span class="ld">~T[23:00:07.0]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">second</span><span class="w">
</span><span class="mi">7</span></code></pre><h3 id="naivedatetime">NaiveDateTime</h3><p>The <a href="NaiveDateTime.xhtml">%NaiveDateTime{}</a> struct contains fields from both <a href="Date.xhtml"><code class="inline">Date</code></a> and <a href="Time.xhtml"><code class="inline">Time</code></a>. You can create one using the <code class="inline">~N</code> sigil:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">ndt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ld">~N[2019-10-31 23:00:07]</span><span class="w">
</span><span class="ld">~N[2019-10-31 23:00:07]</span></code></pre><p>Why is it called naive? Because it does not contain timezone information. Therefore, the given datetime may not exist at all or it may exist twice in certain timezones - for example, when we move the clock back and forward for daylight saving time.</p><h3 id="utc-datetime">UTC DateTime</h3><p>A <a href="DateTime.xhtml">%DateTime{}</a> struct contains the same fields as a <a href="NaiveDateTime.xhtml"><code class="inline">NaiveDateTime</code></a> with the addition of fields to track timezones. The <code class="inline">~U</code> sigil allows developers to create a DateTime in the UTC timezone:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">dt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ld">~U[2019-10-31 19:59:03Z]</span><span class="w">
</span><span class="ld">~U[2019-10-31 19:59:03Z]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="p" data-group-id="7106450595-1">%</span><span class="nc" data-group-id="7106450595-1">DateTime</span><span class="p" data-group-id="7106450595-1">{</span><span class="ss">minute</span><span class="p">:</span><span class="w"> </span><span class="n">minute</span><span class="p">,</span><span class="w"> </span><span class="ss">time_zone</span><span class="p">:</span><span class="w"> </span><span class="n">time_zone</span><span class="p" data-group-id="7106450595-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt</span><span class="w">
</span><span class="ld">~U[2019-10-31 19:59:03Z]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">minute</span><span class="w">
</span><span class="mi">59</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">time_zone</span><span class="w">
</span><span class="s">&quot;Etc/UTC&quot;</span></code></pre><h2 id="custom-sigils">Custom sigils</h2><p>As hinted at the beginning of this chapter, sigils in Elixir are extensible. In fact, using the sigil <code class="inline">~r/foo/i</code> is equivalent to calling <code class="inline">sigil_r</code> with a binary and a char list as the argument:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">sigil_r</span><span class="p" data-group-id="3194105967-1">(</span><span class="p" data-group-id="3194105967-2">&lt;&lt;</span><span class="s">&quot;foo&quot;</span><span class="p" data-group-id="3194105967-2">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3194105967-3">[</span><span class="sc">?i</span><span class="p" data-group-id="3194105967-3">]</span><span class="p" data-group-id="3194105967-1">)</span><span class="w">
</span><span class="sr">~r&quot;foo&quot;i</span></code></pre><p>We can access the documentation for the <code class="inline">~r</code> sigil via <code class="inline">sigil_r</code>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">h</span><span class="w"> </span><span class="n">sigil_r</span><span class="w">
</span><span class="n">...</span></code></pre><p>We can also provide our own sigils by implementing functions that follow the <code class="inline">sigil_{character}</code> pattern. For example, let's implement the <code class="inline">~i</code> sigil that returns an integer (with the optional <code class="inline">n</code> modifier to make it negative):</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MySigils</span><span class="w"> </span><span class="k" data-group-id="3473263647-1">do</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="nf">sigil_i</span><span class="p" data-group-id="3473263647-2">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3473263647-3">[</span><span class="p" data-group-id="3473263647-3">]</span><span class="p" data-group-id="3473263647-2">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">to_integer</span><span class="p" data-group-id="3473263647-4">(</span><span class="n">string</span><span class="p" data-group-id="3473263647-4">)</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w">  </span><span class="kd">def</span><span class="w"> </span><span class="nf">sigil_i</span><span class="p" data-group-id="3473263647-5">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3473263647-6">[</span><span class="sc">?n</span><span class="p" data-group-id="3473263647-6">]</span><span class="p" data-group-id="3473263647-5">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="o">-</span><span class="nc">String</span><span class="o">.</span><span class="n">to_integer</span><span class="p" data-group-id="3473263647-7">(</span><span class="n">string</span><span class="p" data-group-id="3473263647-7">)</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="3473263647-1">end</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nc">MySigils</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="sx">~i(13)</span><span class="w">
</span><span class="mi">13</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="sx">~i(42)n</span><span class="w">
</span><span class="o">-</span><span class="mi">42</span></code></pre><p>Custom sigils may be either a single lowercase character, or an uppercase character followed by more uppercase characters and digits.</p><p>Sigils can also be used to do compile-time work with the help of macros. For example, regular expressions in Elixir are compiled into an efficient representation during compilation of the source code, therefore skipping this step at runtime. If you're interested in the subject, you can learn more about macros and check out how sigils are implemented in the <a href="Kernel.xhtml"><code class="inline">Kernel</code></a> module (where the <code class="inline">sigil_*</code> functions are defined).</p>

  </body>
</html>
