<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Macros - Elixir v1.18.4</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Macros</h1>
<p>Even though Elixir attempts its best to provide a safe environment for macros, most of the responsibility of writing clean code with macros falls on developers. Macros are harder to write than ordinary Elixir functions, and it's considered to be bad style to use them when they're not necessary. Write macros responsibly.</p><p>Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that <strong>explicit is better than implicit</strong>. <strong>Clear code is better than concise code.</strong></p><h2 id="our-first-macro">Our first macro</h2><p>Macros in Elixir are defined via <a href="Kernel.xhtml#defmacro/2"><code class="inline">defmacro/2</code></a>.</p><blockquote><p>For this guide, we will be using files instead of running code samples in IEx. That's because the code samples will span multiple lines of code and typing them all in IEx can be counter-productive. You should be able to run the code samples by saving them into a <code class="inline">macros.exs</code> file and running it with <code class="inline">elixir macros.exs</code> or <code class="inline">iex macros.exs</code>.</p></blockquote><p>In order to better understand how macros work, let's create a new module where we are going to implement <code class="inline">unless</code> (which does the opposite of <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a>), as a macro and as a function:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Unless</span><span class="w"> </span><span class="k" data-group-id="2676228814-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">fun_unless</span><span class="p" data-group-id="2676228814-2">(</span><span class="n">clause</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">expression</span><span class="p" data-group-id="2676228814-2">)</span><span class="w"> </span><span class="k" data-group-id="2676228814-3">do</span><span class="w">
    </span><span class="k">if</span><span class="p" data-group-id="2676228814-4">(</span><span class="o">!</span><span class="n">clause</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">expression</span><span class="p" data-group-id="2676228814-4">)</span><span class="w">
  </span><span class="k" data-group-id="2676228814-3">end</span><span class="w">

  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">macro_unless</span><span class="p" data-group-id="2676228814-5">(</span><span class="n">clause</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">expression</span><span class="p" data-group-id="2676228814-5">)</span><span class="w"> </span><span class="k" data-group-id="2676228814-6">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="2676228814-7">do</span><span class="w">
      </span><span class="k">if</span><span class="p" data-group-id="2676228814-8">(</span><span class="o">!</span><span class="k">unquote</span><span class="p" data-group-id="2676228814-9">(</span><span class="n">clause</span><span class="p" data-group-id="2676228814-9">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="2676228814-10">(</span><span class="n">expression</span><span class="p" data-group-id="2676228814-10">)</span><span class="p" data-group-id="2676228814-8">)</span><span class="w">
    </span><span class="k" data-group-id="2676228814-7">end</span><span class="w">
  </span><span class="k" data-group-id="2676228814-6">end</span><span class="w">
</span><span class="k" data-group-id="2676228814-1">end</span></code></pre><p>The function receives the arguments and passes them to <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a>. However, as we learned in the <a href="quote-and-unquote.xhtml">previous guide</a>, the macro will receive quoted expressions, inject them into the quote, and finally return another quoted expression.</p><p>Let's start <code class="inline">iex</code> with the module above:</p><pre><code class="makeup console" translate="no"><span class="gp unselectable">$ </span><span class="">iex macros.exs
</span></code></pre><p>and play with those definitions:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="kn">require</span><span class="w"> </span><span class="nc">Unless</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Unless</span><span class="o">.</span><span class="n">macro_unless</span><span class="p" data-group-id="2299557160-1">(</span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="2299557160-2">(</span><span class="s">&quot;this should never be printed&quot;</span><span class="p" data-group-id="2299557160-2">)</span><span class="p" data-group-id="2299557160-1">)</span><span class="w">
</span><span class="no">nil</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">Unless</span><span class="o">.</span><span class="n">fun_unless</span><span class="p" data-group-id="2299557160-3">(</span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="2299557160-4">(</span><span class="s">&quot;this should never be printed&quot;</span><span class="p" data-group-id="2299557160-4">)</span><span class="p" data-group-id="2299557160-3">)</span><span class="w">
</span><span class="s">&quot;this should never be printed&quot;</span><span class="w">
</span><span class="no">nil</span></code></pre><p>In our <em>macro</em> implementation, the sentence was not printed, although it was printed in our <em>function</em> implementation. That's because the arguments to a function call are evaluated before calling the function. However, macros do not evaluate their arguments. Instead, they receive the arguments as quoted expressions which are then transformed into other quoted expressions. In this case, we have rewritten our <code class="inline">unless</code> macro to become an <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a> behind the scenes.</p><p>In other words, when invoked as:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Unless</span><span class="o">.</span><span class="n">macro_unless</span><span class="p" data-group-id="3186425237-1">(</span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="3186425237-2">(</span><span class="s">&quot;this should never be printed&quot;</span><span class="p" data-group-id="3186425237-2">)</span><span class="p" data-group-id="3186425237-1">)</span></code></pre><p>Our <code class="inline">macro_unless</code> macro received the following:</p><pre><code class="makeup elixir" translate="no"><span class="n">macro_unless</span><span class="p" data-group-id="4204456269-1">(</span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4204456269-2">[</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4204456269-3">{</span><span class="p" data-group-id="4204456269-4">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4204456269-5">[</span><span class="p" data-group-id="4204456269-5">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4204456269-6">[</span><span class="p" data-group-id="4204456269-7">{</span><span class="ss">:__aliases__</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4204456269-8">[</span><span class="ss">alias</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="4204456269-8">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4204456269-9">[</span><span class="ss">:IO</span><span class="p" data-group-id="4204456269-9">]</span><span class="p" data-group-id="4204456269-7">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:puts</span><span class="p" data-group-id="4204456269-6">]</span><span class="p" data-group-id="4204456269-4">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4204456269-10">[</span><span class="p" data-group-id="4204456269-10">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4204456269-11">[</span><span class="s">&quot;this should never be printed&quot;</span><span class="p" data-group-id="4204456269-11">]</span><span class="p" data-group-id="4204456269-3">}</span><span class="p" data-group-id="4204456269-2">]</span><span class="p" data-group-id="4204456269-1">)</span></code></pre><p>and it then returned a quoted expression as follows:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="2794241452-1">{</span><span class="ss">:if</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2794241452-2">[</span><span class="p" data-group-id="2794241452-2">]</span><span class="p">,</span><span class="w">
 </span><span class="p" data-group-id="2794241452-3">[</span><span class="p" data-group-id="2794241452-4">{</span><span class="ss">:!</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2794241452-5">[</span><span class="p" data-group-id="2794241452-5">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2794241452-6">[</span><span class="no">true</span><span class="p" data-group-id="2794241452-6">]</span><span class="p" data-group-id="2794241452-4">}</span><span class="p">,</span><span class="w">
  </span><span class="p" data-group-id="2794241452-7">[</span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2794241452-8">{</span><span class="p" data-group-id="2794241452-9">{</span><span class="ss">:.</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2794241452-10">[</span><span class="p" data-group-id="2794241452-10">]</span><span class="p">,</span><span class="w">
     </span><span class="p" data-group-id="2794241452-11">[</span><span class="p" data-group-id="2794241452-12">{</span><span class="ss">:__aliases__</span><span class="p">,</span><span class="w">
       </span><span class="p" data-group-id="2794241452-13">[</span><span class="p" data-group-id="2794241452-13">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2794241452-14">[</span><span class="ss">:IO</span><span class="p" data-group-id="2794241452-14">]</span><span class="p" data-group-id="2794241452-12">}</span><span class="p">,</span><span class="w">
      </span><span class="ss">:puts</span><span class="p" data-group-id="2794241452-11">]</span><span class="p" data-group-id="2794241452-9">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2794241452-15">[</span><span class="p" data-group-id="2794241452-15">]</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2794241452-16">[</span><span class="s">&quot;this should never be printed&quot;</span><span class="p" data-group-id="2794241452-16">]</span><span class="p" data-group-id="2794241452-8">}</span><span class="p" data-group-id="2794241452-7">]</span><span class="p" data-group-id="2794241452-3">]</span><span class="p" data-group-id="2794241452-1">}</span></code></pre><p>We can actually verify that this is the case by using <a href="Macro.xhtml#expand_once/2"><code class="inline">Macro.expand_once/2</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="n">expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">quote</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">Unless</span><span class="o">.</span><span class="n">macro_unless</span><span class="p" data-group-id="9201849922-1">(</span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="9201849922-2">(</span><span class="s">&quot;this should never be printed&quot;</span><span class="p" data-group-id="9201849922-2">)</span><span class="p" data-group-id="9201849922-1">)</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="n">res</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">expand_once</span><span class="p" data-group-id="9201849922-3">(</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="bp">__ENV__</span><span class="p" data-group-id="9201849922-3">)</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="9201849922-4">(</span><span class="nc">Macro</span><span class="o">.</span><span class="n">to_string</span><span class="p" data-group-id="9201849922-5">(</span><span class="n">res</span><span class="p" data-group-id="9201849922-5">)</span><span class="p" data-group-id="9201849922-4">)</span><span class="w">
</span><span class="k">if</span><span class="p" data-group-id="9201849922-6">(</span><span class="o">!</span><span class="no">true</span><span class="p" data-group-id="9201849922-6">)</span><span class="w"> </span><span class="k" data-group-id="9201849922-7">do</span><span class="w">
  </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="9201849922-8">(</span><span class="s">&quot;this should never be printed&quot;</span><span class="p" data-group-id="9201849922-8">)</span><span class="w">
</span><span class="k" data-group-id="9201849922-7">end</span><span class="w">
</span><span class="ss">:ok</span></code></pre><p><a href="Macro.xhtml#expand_once/2"><code class="inline">Macro.expand_once/2</code></a> receives a quoted expression and expands it according to the current environment. In this case, it expanded/invoked the <code class="inline">Unless.macro_unless/2</code> macro and returned its result. We then proceeded to convert the returned quoted expression to a string and print it (we will talk about <code class="inline">__ENV__</code> later in this chapter).</p><p>That's what macros are all about. They are about receiving quoted expressions and transforming them into something else.
In fact, <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a> in Elixir is implemented as a macro:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmacro</span><span class="w"> </span><span class="nf">if</span><span class="p" data-group-id="1746300296-1">(</span><span class="n">clause</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">expression</span><span class="p" data-group-id="1746300296-1">)</span><span class="w"> </span><span class="k" data-group-id="1746300296-2">do</span><span class="w">
  </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="1746300296-3">do</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">clause</span><span class="w"> </span><span class="k" data-group-id="1746300296-4">do</span><span class="w">
      </span><span class="n">x</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p" data-group-id="1746300296-5">[</span><span class="no">false</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="1746300296-5">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">nil</span><span class="w">
      </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="1746300296-6">(</span><span class="n">expression</span><span class="p" data-group-id="1746300296-6">)</span><span class="w">
  </span><span class="k" data-group-id="1746300296-4">end</span><span class="w">
</span><span class="k" data-group-id="1746300296-3">end</span></code></pre><p>Constructs such as <a href="Kernel.xhtml#if/2"><code class="inline">if/2</code></a>, <a href="Kernel.xhtml#defmacro/2"><code class="inline">defmacro/2</code></a>, <a href="Kernel.xhtml#def/2"><code class="inline">def/2</code></a>, <a href="Kernel.xhtml#defprotocol/2"><code class="inline">defprotocol/2</code></a>, and many others used throughout the Elixir standard library are written in pure Elixir, often as a macro. This means that the constructs being used to build the language can be used by developers to extend the language to the domains they are working on.</p><p>We can define any function and macro we want, including ones that override the built-in definitions provided by Elixir. The only exceptions are Elixir special forms which are not implemented in Elixir and therefore cannot be overridden. The full list of special forms is available in <a href="Kernel.SpecialForms.xhtml"><code class="inline">Kernel.SpecialForms</code></a>.</p><h2 id="macro-hygiene">Macro hygiene</h2><p>Elixir macros have &quot;late resolution&quot;. This guarantees that a variable defined inside a quote won't conflict with a variable defined in the context where that macro is expanded. For example:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Hygiene</span><span class="w"> </span><span class="k" data-group-id="6192076590-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">no_interference</span><span class="w"> </span><span class="k" data-group-id="6192076590-2">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="k" data-group-id="6192076590-2">end</span><span class="w">
</span><span class="k" data-group-id="6192076590-1">end</span><span class="w">

</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HygieneTest</span><span class="w"> </span><span class="k" data-group-id="6192076590-3">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">go</span><span class="w"> </span><span class="k" data-group-id="6192076590-4">do</span><span class="w">
    </span><span class="kn">require</span><span class="w"> </span><span class="nc">Hygiene</span><span class="w">
    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="w">
    </span><span class="nc">Hygiene</span><span class="o">.</span><span class="n">no_interference</span><span class="p" data-group-id="6192076590-5">(</span><span class="p" data-group-id="6192076590-5">)</span><span class="w">
    </span><span class="n">a</span><span class="w">
  </span><span class="k" data-group-id="6192076590-4">end</span><span class="w">
</span><span class="k" data-group-id="6192076590-3">end</span><span class="w">

</span><span class="nc">HygieneTest</span><span class="o">.</span><span class="n">go</span><span class="p" data-group-id="6192076590-6">(</span><span class="p" data-group-id="6192076590-6">)</span><span class="w">
</span><span class="c1"># =&gt; 13</span></code></pre><p>In the example above, even though the macro injects <code class="inline">a = 1</code>, it does not affect the variable <code class="inline">a</code> defined by the <code class="inline">go/0</code> function. If a macro wants to explicitly affect the context, it can use <a href="Kernel.xhtml#var!/1"><code class="inline">var!/1</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Hygiene</span><span class="w"> </span><span class="k" data-group-id="4789410336-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">interference</span><span class="w"> </span><span class="k" data-group-id="4789410336-2">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">var!</span><span class="p" data-group-id="4789410336-3">(</span><span class="n">a</span><span class="p" data-group-id="4789410336-3">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
  </span><span class="k" data-group-id="4789410336-2">end</span><span class="w">
</span><span class="k" data-group-id="4789410336-1">end</span><span class="w">

</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">HygieneTest</span><span class="w"> </span><span class="k" data-group-id="4789410336-4">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">go</span><span class="w"> </span><span class="k" data-group-id="4789410336-5">do</span><span class="w">
    </span><span class="kn">require</span><span class="w"> </span><span class="nc">Hygiene</span><span class="w">
    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="w">
    </span><span class="nc">Hygiene</span><span class="o">.</span><span class="n">interference</span><span class="p" data-group-id="4789410336-6">(</span><span class="p" data-group-id="4789410336-6">)</span><span class="w">
    </span><span class="n">a</span><span class="w">
  </span><span class="k" data-group-id="4789410336-5">end</span><span class="w">
</span><span class="k" data-group-id="4789410336-4">end</span><span class="w">

</span><span class="nc">HygieneTest</span><span class="o">.</span><span class="n">go</span><span class="p" data-group-id="4789410336-7">(</span><span class="p" data-group-id="4789410336-7">)</span><span class="w">
</span><span class="c1"># =&gt; 1</span></code></pre><p>The code above will work but issue a warning: <code class="inline">variable &quot;a&quot; is unused</code>. The macro is overriding the original value and the original value is never used.</p><p>Variable hygiene only works because Elixir annotates variables with their <strong>context</strong>. For example, a variable <code class="inline">x</code> defined on line 3 of a module would be represented as:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="4016541034-1">{</span><span class="ss">:x</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4016541034-2">[</span><span class="ss">line</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p" data-group-id="4016541034-2">]</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="4016541034-1">}</span></code></pre><p>However, a quoted variable would be represented as:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Sample</span><span class="w"> </span><span class="k" data-group-id="3545895672-1">do</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">quoted</span><span class="w"> </span><span class="k" data-group-id="3545895672-2">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">x</span><span class="w">
  </span><span class="k" data-group-id="3545895672-2">end</span><span class="w">
</span><span class="k" data-group-id="3545895672-1">end</span><span class="w">

</span><span class="nc">Sample</span><span class="o">.</span><span class="n">quoted</span><span class="p" data-group-id="3545895672-3">(</span><span class="p" data-group-id="3545895672-3">)</span><span class="w"> </span><span class="c1">#=&gt; {:x, [line: 3], Sample}</span></code></pre><p>Notice that the <em>third element</em> in the quoted variable is the atom <code class="inline">Sample</code>, instead of <code class="inline">nil</code>, which marks the variable as coming from the <code class="inline">Sample</code> module. Therefore, Elixir considers these two variables as coming from different contexts and handles them accordingly.</p><p>Elixir provides similar mechanisms for imports and aliases too. This guarantees that a macro will behave as specified by its source module rather than conflicting with the target module where the macro is expanded. Hygiene can be bypassed under specific situations by using macros like <a href="Kernel.xhtml#var!/2"><code class="inline">var!/2</code></a> and <a href="Kernel.xhtml#alias!/1"><code class="inline">alias!/1</code></a>, although one must be careful when using those as they directly change the user environment.</p><p>Sometimes variable names might be dynamically created. In such cases, <a href="Macro.xhtml#var/2"><code class="inline">Macro.var/2</code></a> can be used to define new variables:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Sample</span><span class="w"> </span><span class="k" data-group-id="5723844836-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">initialize_to_char_count</span><span class="p" data-group-id="5723844836-2">(</span><span class="n">variables</span><span class="p" data-group-id="5723844836-2">)</span><span class="w"> </span><span class="k" data-group-id="5723844836-3">do</span><span class="w">
    </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="5723844836-4">(</span><span class="n">variables</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="5723844836-5">fn</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Macro</span><span class="o">.</span><span class="n">var</span><span class="p" data-group-id="5723844836-6">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="no">nil</span><span class="p" data-group-id="5723844836-6">)</span><span class="w">
      </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Atom</span><span class="o">.</span><span class="n">to_string</span><span class="p" data-group-id="5723844836-7">(</span><span class="p" data-group-id="5723844836-7">)</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">length</span><span class="p" data-group-id="5723844836-8">(</span><span class="p" data-group-id="5723844836-8">)</span><span class="w">

      </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="5723844836-9">do</span><span class="w">
        </span><span class="k">unquote</span><span class="p" data-group-id="5723844836-10">(</span><span class="n">var</span><span class="p" data-group-id="5723844836-10">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="5723844836-11">(</span><span class="n">length</span><span class="p" data-group-id="5723844836-11">)</span><span class="w">
      </span><span class="k" data-group-id="5723844836-9">end</span><span class="w">
    </span><span class="k" data-group-id="5723844836-5">end</span><span class="p" data-group-id="5723844836-4">)</span><span class="w">
  </span><span class="k" data-group-id="5723844836-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">run</span><span class="w"> </span><span class="k" data-group-id="5723844836-12">do</span><span class="w">
    </span><span class="n">initialize_to_char_count</span><span class="p" data-group-id="5723844836-13">(</span><span class="p" data-group-id="5723844836-14">[</span><span class="ss">:red</span><span class="p">,</span><span class="w"> </span><span class="ss">:green</span><span class="p">,</span><span class="w"> </span><span class="ss">:yellow</span><span class="p" data-group-id="5723844836-14">]</span><span class="p" data-group-id="5723844836-13">)</span><span class="w">
    </span><span class="p" data-group-id="5723844836-15">[</span><span class="n">red</span><span class="p">,</span><span class="w"> </span><span class="n">green</span><span class="p">,</span><span class="w"> </span><span class="n">yellow</span><span class="p" data-group-id="5723844836-15">]</span><span class="w">
  </span><span class="k" data-group-id="5723844836-12">end</span><span class="w">
</span><span class="k" data-group-id="5723844836-1">end</span><span class="w">

</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">Sample</span><span class="o">.</span><span class="n">run</span><span class="p" data-group-id="5723844836-16">(</span><span class="p" data-group-id="5723844836-16">)</span><span class="w"> </span><span class="c1">#=&gt; [3, 5, 6]</span></code></pre><p>Take note of the second argument to <a href="Macro.xhtml#var/2"><code class="inline">Macro.var/2</code></a>. This is the <strong>context</strong> being used and will determine hygiene as described in the next section. Check out also <a href="Macro.xhtml#unique_var/2"><code class="inline">Macro.unique_var/2</code></a>, for cases when you need to generate variables with unique names.</p><h2 id="the-environment">The environment</h2><p>When calling <a href="Macro.xhtml#expand_once/2"><code class="inline">Macro.expand_once/2</code></a> earlier in this chapter, we used the special form <a href="Kernel.SpecialForms.xhtml#__ENV__/0"><code class="inline">__ENV__/0</code></a>.</p><p><a href="Kernel.SpecialForms.xhtml#__ENV__/0"><code class="inline">__ENV__/0</code></a> returns a <a href="Macro.Env.xhtml"><code class="inline">Macro.Env</code></a> struct which contains useful information about the compilation environment, including the current module, file, and line, all variables defined in the current scope, as well as imports, requires, and more:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">module</span><span class="w">
</span><span class="no">nil</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">file</span><span class="w">
</span><span class="s">&quot;iex&quot;</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">requires</span><span class="w">
</span><span class="p" data-group-id="2727058800-1">[</span><span class="nc">IEx.Helpers</span><span class="p">,</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">,</span><span class="w"> </span><span class="nc">Kernel.Typespec</span><span class="p" data-group-id="2727058800-1">]</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="kn">require</span><span class="w"> </span><span class="nc">Integer</span><span class="w">
</span><span class="no">nil</span><span class="w">
</span><span class="gp unselectable">iex&gt; </span><span class="bp">__ENV__</span><span class="o">.</span><span class="n">requires</span><span class="w">
</span><span class="p" data-group-id="2727058800-2">[</span><span class="nc">IEx.Helpers</span><span class="p">,</span><span class="w"> </span><span class="nc">Integer</span><span class="p">,</span><span class="w"> </span><span class="nc">Kernel</span><span class="p">,</span><span class="w"> </span><span class="nc">Kernel.Typespec</span><span class="p" data-group-id="2727058800-2">]</span></code></pre><p>Many of the functions in the <a href="Macro.xhtml"><code class="inline">Macro</code></a> module expect a <a href="Macro.Env.xhtml"><code class="inline">Macro.Env</code></a> environment. You can read more about these functions in <a href="Macro.xhtml"><code class="inline">Macro</code></a> and learn more about the compilation environment in the <a href="Macro.Env.xhtml"><code class="inline">Macro.Env</code></a>.</p><h2 id="private-macros">Private macros</h2><p>Elixir also supports <strong>private macros</strong> via <code class="inline">defmacrop</code>. Like private functions, these macros are only available inside the module that defines them, and only at compilation time.</p><p>It is important that a macro is defined before its usage. Failing to define a macro before its invocation will raise an error at runtime, since the macro won't be expanded and will be translated to a function call:</p><pre><code class="makeup elixir" translate="no"><span class="gp unselectable">iex&gt; </span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Sample</span><span class="w"> </span><span class="k" data-group-id="4095788106-1">do</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w"> </span><span class="kd">def</span><span class="w"> </span><span class="nf">four</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="n">two</span><span class="p" data-group-id="4095788106-2">(</span><span class="p" data-group-id="4095788106-2">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">two</span><span class="p" data-group-id="4095788106-3">(</span><span class="p" data-group-id="4095788106-3">)</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="w"> </span><span class="kd">defmacrop</span><span class="w"> </span><span class="nf">two</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="gp unselectable">...&gt; </span><span class="k" data-group-id="4095788106-1">end</span><span class="w">
</span><span class="gt">** (CompileError) iex:2: function two/0 undefined</span></code></pre><h2 id="write-macros-responsibly">Write macros responsibly</h2><p>Macros are a powerful construct and Elixir provides many mechanisms to ensure they are used responsibly.</p><ul><li><p>Macros are <strong>hygienic</strong>: by default, variables defined inside a macro are not going to affect the user code. Furthermore, function calls and aliases available in the macro context are not going to leak into the user context.</p></li><li><p>Macros are <strong>lexical</strong>: it is impossible to inject code or macros globally. In order to use a macro, you need to explicitly <code class="inline">require</code> or <code class="inline">import</code> the module that defines the macro.</p></li><li><p>Macros are <strong>explicit</strong>: it is impossible to run a macro without explicitly invoking it. For example, some languages allow developers to completely rewrite functions behind the scenes, often via parse transforms or via some reflection mechanisms. In Elixir, a macro must be explicitly invoked in the caller during compilation time.</p></li><li><p>Macros' language is clear: many languages provide syntax shortcuts for <code class="inline">quote</code> and <code class="inline">unquote</code>. In Elixir, we preferred to have them explicitly spelled out, in order to clearly delimit the boundaries of a macro definition and its quoted expressions.</p></li></ul><p>Even with such guarantees, the developer plays a big role when writing macros responsibly. If you are confident you need to resort to macros, remember that macros are not your API. Keep your macro definitions short, including their quoted contents. For example, instead of writing a macro like this:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyModule</span><span class="w"> </span><span class="k" data-group-id="8879874953-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">my_macro</span><span class="p" data-group-id="8879874953-2">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p" data-group-id="8879874953-2">)</span><span class="w"> </span><span class="k" data-group-id="8879874953-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="8879874953-4">do</span><span class="w">
      </span><span class="n">do_this</span><span class="p" data-group-id="8879874953-5">(</span><span class="k">unquote</span><span class="p" data-group-id="8879874953-6">(</span><span class="n">a</span><span class="p" data-group-id="8879874953-6">)</span><span class="p" data-group-id="8879874953-5">)</span><span class="w">
      </span><span class="c1"># ...</span><span class="w">
      </span><span class="n">do_that</span><span class="p" data-group-id="8879874953-7">(</span><span class="k">unquote</span><span class="p" data-group-id="8879874953-8">(</span><span class="n">b</span><span class="p" data-group-id="8879874953-8">)</span><span class="p" data-group-id="8879874953-7">)</span><span class="w">
      </span><span class="c1"># ...</span><span class="w">
      </span><span class="n">and_that</span><span class="p" data-group-id="8879874953-9">(</span><span class="k">unquote</span><span class="p" data-group-id="8879874953-10">(</span><span class="n">c</span><span class="p" data-group-id="8879874953-10">)</span><span class="p" data-group-id="8879874953-9">)</span><span class="w">
    </span><span class="k" data-group-id="8879874953-4">end</span><span class="w">
  </span><span class="k" data-group-id="8879874953-3">end</span><span class="w">
</span><span class="k" data-group-id="8879874953-1">end</span></code></pre><p>write:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyModule</span><span class="w"> </span><span class="k" data-group-id="3577468769-1">do</span><span class="w">
  </span><span class="kd">defmacro</span><span class="w"> </span><span class="nf">my_macro</span><span class="p" data-group-id="3577468769-2">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p" data-group-id="3577468769-2">)</span><span class="w"> </span><span class="k" data-group-id="3577468769-3">do</span><span class="w">
    </span><span class="k">quote</span><span class="w"> </span><span class="k" data-group-id="3577468769-4">do</span><span class="w">
      </span><span class="c1"># Keep what you need to do here to a minimum</span><span class="w">
      </span><span class="c1"># and move everything else to a function</span><span class="w">
      </span><span class="nc">MyModule</span><span class="o">.</span><span class="n">do_this_that_and_that</span><span class="p" data-group-id="3577468769-5">(</span><span class="k">unquote</span><span class="p" data-group-id="3577468769-6">(</span><span class="n">a</span><span class="p" data-group-id="3577468769-6">)</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3577468769-7">(</span><span class="n">b</span><span class="p" data-group-id="3577468769-7">)</span><span class="p">,</span><span class="w"> </span><span class="k">unquote</span><span class="p" data-group-id="3577468769-8">(</span><span class="n">c</span><span class="p" data-group-id="3577468769-8">)</span><span class="p" data-group-id="3577468769-5">)</span><span class="w">
    </span><span class="k" data-group-id="3577468769-4">end</span><span class="w">
  </span><span class="k" data-group-id="3577468769-3">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">do_this_that_and_that</span><span class="p" data-group-id="3577468769-9">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span><span class="p" data-group-id="3577468769-9">)</span><span class="w"> </span><span class="k" data-group-id="3577468769-10">do</span><span class="w">
    </span><span class="n">do_this</span><span class="p" data-group-id="3577468769-11">(</span><span class="n">a</span><span class="p" data-group-id="3577468769-11">)</span><span class="w">
    </span><span class="n">...</span><span class="w">
    </span><span class="n">do_that</span><span class="p" data-group-id="3577468769-12">(</span><span class="n">b</span><span class="p" data-group-id="3577468769-12">)</span><span class="w">
    </span><span class="n">...</span><span class="w">
    </span><span class="n">and_that</span><span class="p" data-group-id="3577468769-13">(</span><span class="n">c</span><span class="p" data-group-id="3577468769-13">)</span><span class="w">
  </span><span class="k" data-group-id="3577468769-10">end</span><span class="w">
</span><span class="k" data-group-id="3577468769-1">end</span></code></pre><p>This makes your code clearer and easier to test and maintain, as you can invoke and test <code class="inline">do_this_that_and_that/3</code> directly. It also helps you design an actual API for developers that do not want to rely on macros.</p><p>With this guide, we finish our introduction to macros. The next guide is a brief discussion on <strong>DSLs</strong> that shows how we can mix macros and module attributes to annotate and extend modules and functions.</p>

  </body>
</html>
