<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Phoenix.LiveComponent - Phoenix LiveView v1.1.2</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">
Phoenix.LiveComponent <small>behaviour</small>
    </h1>


      <section id="moduledoc" class="docstring">
<p>LiveComponents are a mechanism to compartmentalize state, markup, and
events for sharing across LiveViews.</p><p>LiveComponents are defined by using <a href="Phoenix.LiveComponent.xhtml"><code class="inline">Phoenix.LiveComponent</code></a> and are used
by calling <a href="Phoenix.Component.xhtml#live_component/1"><code class="inline">Phoenix.Component.live_component/1</code></a> in a parent LiveView.
They run inside the LiveView process but have their own state and
life-cycle. For this reason, they are also often called &quot;stateful components&quot;.
This is a contrast to <a href="Phoenix.Component.xhtml"><code class="inline">Phoenix.Component</code></a>, also known as &quot;function components&quot;,
which are stateless and do not have a life-cycle.</p><p>The smallest LiveComponent only needs to define a <a href="#c:render/1"><code class="inline">render/1</code></a> function:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">HeroComponent</samp><samp class="w"> </samp><samp class="k" data-group-id="0095199532-1">do</samp><samp class="w">
  </samp><samp class="c1"># In Phoenix apps, the line is typically: use MyAppWeb, :live_component</samp><samp class="w">
  </samp><samp class="kn">use</samp><samp class="w"> </samp><samp class="nc">Phoenix.LiveComponent</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">render</samp><samp class="p" data-group-id="0095199532-2">(</samp><samp class="n">assigns</samp><samp class="p" data-group-id="0095199532-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="0095199532-3">do</samp><samp class="w">
    </samp><samp class="sx">~H&quot;&quot;&quot;</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="p">&lt;</samp><samp class="nt">div</samp><samp class="w"> </samp><samp class="na">class</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">h</samp><samp class="s2">e</samp><samp class="s2">r</samp><samp class="s2">o</samp><samp class="p">&quot;</samp><samp class="p">&gt;</samp><samp class="p" data-group-id="4147518698-1">{</samp><samp class="na">@content</samp><samp class="p" data-group-id="4147518698-1">}</samp><samp class="p">&lt;/</samp><samp class="nt">div</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="sx">&quot;&quot;&quot;</samp><samp class="w">
  </samp><samp class="k" data-group-id="0095199532-3">end</samp><samp class="w">
</samp><samp class="k" data-group-id="0095199532-1">end</samp></code></pre><p>A LiveComponent is rendered as:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w"> </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="2955579661-1">{</samp><samp class="nc">HeroComponent</samp><samp class="p" data-group-id="2955579661-1">}</samp><samp class="w"> </samp><samp class="na">id</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">h</samp><samp class="s2">e</samp><samp class="s2">r</samp><samp class="s2">o</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">content</samp><samp class="p">=</samp><samp class="p" data-group-id="2955579661-2">{</samp><samp class="na">@content</samp><samp class="p" data-group-id="2955579661-2">}</samp><samp class="w"> </samp><samp class="p">/&gt;</samp></code></pre><p>You must always pass the <code class="inline">module</code> and <code class="inline">id</code> attributes. The <code class="inline">id</code> will be
available as an assign and it must be used to uniquely identify the
component. All other attributes will be available as assigns inside the
LiveComponent.</p><section role="note" class="admonition neutral"><h4 class="admonition-title neutral">Functional components or live components?</h4><p>Generally speaking, you should prefer function components over live
components, as they are a simpler abstraction, with a smaller surface
area. The use case for live components only arises when there is a need
for encapsulating both event handling and additional state.</p><p>Similarly, avoid using LiveComponents for code design purposes, where
their main goal is to organize code, rather than sharing it across
LiveViews. When it comes to code organization and design, Elixir developers
prefer to use functions and data structures.</p></section><h2 id="module-life-cycle">Life-cycle</h2><h3 id="module-mount-and-update">Mount and update</h3><p>Live components are identified by the component module and their ID.
We often tie the component ID to some application based ID:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w"> </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="7888407976-1">{</samp><samp class="nc">UserComponent</samp><samp class="p" data-group-id="7888407976-1">}</samp><samp class="w"> </samp><samp class="na">id</samp><samp class="p">=</samp><samp class="p" data-group-id="7888407976-2">{</samp><samp class="na">@user</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p" data-group-id="7888407976-2">}</samp><samp class="w"> </samp><samp class="na">user</samp><samp class="p">=</samp><samp class="p" data-group-id="7888407976-3">{</samp><samp class="na">@user</samp><samp class="p" data-group-id="7888407976-3">}</samp><samp class="w"> </samp><samp class="p">/&gt;</samp></code></pre><p>When <a href="Phoenix.Component.xhtml#live_component/1"><code class="inline">live_component/1</code></a> is called,
<a href="#c:mount/1"><code class="inline">mount/1</code></a> is called once, when the component is first added to the page.
<a href="#c:mount/1"><code class="inline">mount/1</code></a> receives a <code class="inline">socket</code> as its argument. Note that this is <em>not</em> the
same <code class="inline">socket</code> struct from the parent LiveView. It doesn't contain the parent
LiveView's <code class="inline">assigns</code>, and updating it won't affect the parent LiveView's
<code class="inline">socket</code>.</p><p>Then <a href="#c:update/2"><code class="inline">update/2</code></a> is invoked with all of the assigns passed to
<a href="Phoenix.Component.xhtml#live_component/1"><code class="inline">live_component/1</code></a>. The assigns
received as the first argument to <a href="#c:update/2"><code class="inline">update/2</code></a> will only include those
assigns given to <a href="Phoenix.Component.xhtml#live_component/1"><code class="inline">live_component/1</code></a>,
and not any pre-existing assigns in <code class="inline">socket.assigns</code> such as those assigned
by <a href="#c:mount/1"><code class="inline">mount/1</code></a>.</p><p>If <a href="#c:update/2"><code class="inline">update/2</code></a> is not defined then all assigns given to
<a href="Phoenix.Component.xhtml#live_component/1"><code class="inline">live_component/1</code></a> will simply be
merged into <code class="inline">socket.assigns</code>.</p><p>Both <a href="#c:mount/1"><code class="inline">mount/1</code></a> and <a href="#c:update/2"><code class="inline">update/2</code></a> must return a tuple whose first element is
<code class="inline">:ok</code> and whose second element is the updated <code class="inline">socket</code>.</p><p>After the component is updated, <a href="#c:render/1"><code class="inline">render/1</code></a> is called with all assigns.
On first render, we get:</p><pre><code class="makeup elixir" translate="no"><samp class="n">mount</samp><samp class="p" data-group-id="5040486529-1">(</samp><samp class="n">socket</samp><samp class="p" data-group-id="5040486529-1">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">update</samp><samp class="p" data-group-id="5040486529-2">(</samp><samp class="n">assigns</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="5040486529-2">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">render</samp><samp class="p" data-group-id="5040486529-3">(</samp><samp class="n">assigns</samp><samp class="p" data-group-id="5040486529-3">)</samp></code></pre><p>On further rendering:</p><pre><code class="makeup elixir" translate="no"><samp class="n">update</samp><samp class="p" data-group-id="3183017331-1">(</samp><samp class="n">assigns</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="3183017331-1">)</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">render</samp><samp class="p" data-group-id="3183017331-2">(</samp><samp class="n">assigns</samp><samp class="p" data-group-id="3183017331-2">)</samp></code></pre><p>Two live components with the same module and ID are treated as the same component,
regardless of where they are in the page. Therefore, if you change the location
of where a component is rendered within its parent LiveView, it won't be remounted.
This means you can use live components to implement cards and other elements that
can be moved around without losing state. A component is only discarded when the
client observes it is removed from the page.</p><p>Finally, the given <code class="inline">id</code> is not automatically used as the DOM ID. If you want to set
a DOM ID, it is your responsibility to do so when rendering:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">UserComponent</samp><samp class="w"> </samp><samp class="k" data-group-id="0082010034-1">do</samp><samp class="w">
  </samp><samp class="c1"># In Phoenix apps, the line is typically: use MyAppWeb, :live_component</samp><samp class="w">
  </samp><samp class="kn">use</samp><samp class="w"> </samp><samp class="nc">Phoenix.LiveComponent</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">render</samp><samp class="p" data-group-id="0082010034-2">(</samp><samp class="n">assigns</samp><samp class="p" data-group-id="0082010034-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="0082010034-3">do</samp><samp class="w">
    </samp><samp class="sx">~H&quot;&quot;&quot;</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="p">&lt;</samp><samp class="nt">div</samp><samp class="w"> </samp><samp class="na">id</samp><samp class="p">=</samp><samp class="p" data-group-id="1596119891-1">{</samp><samp class="s">&quot;user-</samp><samp class="si" data-group-id="0082010034-4">#{</samp><samp class="na">@id</samp><samp class="si" data-group-id="0082010034-4">}</samp><samp class="s">&quot;</samp><samp class="p" data-group-id="1596119891-1">}</samp><samp class="w"> </samp><samp class="na">class</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">u</samp><samp class="s2">s</samp><samp class="s2">e</samp><samp class="s2">r</samp><samp class="p">&quot;</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">      </samp><samp class="p" data-group-id="1596119891-2">{</samp><samp class="na">@user</samp><samp class="o">.</samp><samp class="n">name</samp><samp class="p" data-group-id="1596119891-2">}</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="p">&lt;/</samp><samp class="nt">div</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="sx">&quot;&quot;&quot;</samp><samp class="w">
  </samp><samp class="k" data-group-id="0082010034-3">end</samp><samp class="w">
</samp><samp class="k" data-group-id="0082010034-1">end</samp></code></pre><h3 id="module-events">Events</h3><p>LiveComponents can also implement the <a href="#c:handle_event/3"><code class="inline">handle_event/3</code></a> callback
that works exactly the same as in LiveView. For a client event to
reach a component, the tag must be annotated with a <code class="inline">phx-target</code>.
If you want to send the event to yourself, you can simply use the
<code class="inline">@myself</code> assign, which is an <em>internal unique reference</em> to the
component instance:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nt">a</samp><samp class="w"> </samp><samp class="na">href</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">#</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">phx-click</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">say_hello</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">phx-target</samp><samp class="p">=</samp><samp class="p" data-group-id="4990415868-1">{</samp><samp class="na">@myself</samp><samp class="p" data-group-id="4990415868-1">}</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="n">  Say hello!
</samp><samp class="p">&lt;/</samp><samp class="nt">a</samp><samp class="p">&gt;</samp></code></pre><p>Note that <code class="inline">@myself</code> is not set for stateless components, as they cannot
receive events.</p><p>If you want to target another component, you can also pass an ID
or a class selector to any element inside the targeted component.
For example, if there is a <code class="inline">UserComponent</code> with the DOM ID of <code class="inline">&quot;user-13&quot;</code>,
using a query selector, we can send an event to it with:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nt">a</samp><samp class="w"> </samp><samp class="na">href</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">#</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">phx-click</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">say_hello</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">phx-target</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">#user-13</samp><samp class="p">&quot;</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="n">  Say hello!
</samp><samp class="p">&lt;/</samp><samp class="nt">a</samp><samp class="p">&gt;</samp></code></pre><p>In both cases, <a href="#c:handle_event/3"><code class="inline">handle_event/3</code></a> will be called with the
&quot;say_hello&quot; event. When <a href="#c:handle_event/3"><code class="inline">handle_event/3</code></a> is called for a component,
only the diff of the component is sent to the client, making them
extremely efficient.</p><p>Any valid query selector for <code class="inline">phx-target</code> is supported, provided that the
matched nodes are children of a LiveView or LiveComponent, for example
to send the <code class="inline">close</code> event to multiple components:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nt">a</samp><samp class="w"> </samp><samp class="na">href</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">#</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">phx-click</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">close</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">phx-target</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">#modal, #sidebar</samp><samp class="p">&quot;</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="n">  Dismiss
</samp><samp class="p">&lt;/</samp><samp class="nt">a</samp><samp class="p">&gt;</samp></code></pre><h3 id="module-update-many">Update many</h3><p>Live components also support an optional <a href="#c:update_many/1"><code class="inline">update_many/1</code></a> callback
as an alternative to <a href="#c:update/2"><code class="inline">update/2</code></a>. While <a href="#c:update/2"><code class="inline">update/2</code></a> is called for
each component individually, <a href="#c:update_many/1"><code class="inline">update_many/1</code></a> is called with all
LiveComponents of the same module being currently rendered/updated.
The advantage is that you can preload data from the database using
a single query for all components, instead of running one query per
component.</p><p>To provide a more complete understanding of why both callbacks are necessary,
let's see an example. Imagine you are implementing a component and the component
needs to load some state from the database. For example:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w"> </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="3694332614-1">{</samp><samp class="nc">UserComponent</samp><samp class="p" data-group-id="3694332614-1">}</samp><samp class="w"> </samp><samp class="na">id</samp><samp class="p">=</samp><samp class="p" data-group-id="3694332614-2">{</samp><samp class="n">user_id</samp><samp class="p" data-group-id="3694332614-2">}</samp><samp class="w"> </samp><samp class="p">/&gt;</samp></code></pre><p>A possible implementation would be to load the user on the <a href="#c:update/2"><code class="inline">update/2</code></a>
callback:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">update</samp><samp class="p" data-group-id="4080255814-1">(</samp><samp class="n">assigns</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="4080255814-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4080255814-2">do</samp><samp class="w">
  </samp><samp class="n">user</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="nc">Repo</samp><samp class="o">.</samp><samp class="n">get!</samp><samp class="p" data-group-id="4080255814-3">(</samp><samp class="nc">User</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p" data-group-id="4080255814-3">)</samp><samp class="w">
  </samp><samp class="p" data-group-id="4080255814-4">{</samp><samp class="ss">:ok</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">assign</samp><samp class="p" data-group-id="4080255814-5">(</samp><samp class="n">socket</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:user</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">user</samp><samp class="p" data-group-id="4080255814-5">)</samp><samp class="p" data-group-id="4080255814-4">}</samp><samp class="w">
</samp><samp class="k" data-group-id="4080255814-2">end</samp></code></pre><p>However, the issue with said approach is that, if you are rendering
multiple user components in the same page, you have a N+1 query problem.
By using <a href="#c:update_many/1"><code class="inline">update_many/1</code></a> instead of <a href="#c:update/2"><code class="inline">update/2</code></a> , we receive a list
of all assigns and sockets, allowing us to update many at once:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">update_many</samp><samp class="p" data-group-id="6519516134-1">(</samp><samp class="n">assigns_sockets</samp><samp class="p" data-group-id="6519516134-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="6519516134-2">do</samp><samp class="w">
  </samp><samp class="n">list_of_ids</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="nc">Enum</samp><samp class="o">.</samp><samp class="n">map</samp><samp class="p" data-group-id="6519516134-3">(</samp><samp class="n">assigns_sockets</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k" data-group-id="6519516134-4">fn</samp><samp class="w"> </samp><samp class="p" data-group-id="6519516134-5">{</samp><samp class="n">assigns</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="c">_socket</samp><samp class="p" data-group-id="6519516134-5">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="w"> </samp><samp class="k" data-group-id="6519516134-4">end</samp><samp class="p" data-group-id="6519516134-3">)</samp><samp class="w">

  </samp><samp class="n">users</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w">
    </samp><samp class="n">from</samp><samp class="p" data-group-id="6519516134-6">(</samp><samp class="n">u</samp><samp class="w"> </samp><samp class="ow">in</samp><samp class="w"> </samp><samp class="nc">User</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">where</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">u</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="w"> </samp><samp class="ow">in</samp><samp class="w"> </samp><samp class="o">^</samp><samp class="n">list_of_ids</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">select</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="p" data-group-id="6519516134-7">{</samp><samp class="n">u</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">u</samp><samp class="p" data-group-id="6519516134-7">}</samp><samp class="p" data-group-id="6519516134-6">)</samp><samp class="w">
    </samp><samp class="o">|&gt;</samp><samp class="w"> </samp><samp class="nc">Repo</samp><samp class="o">.</samp><samp class="n">all</samp><samp class="p" data-group-id="6519516134-8">(</samp><samp class="p" data-group-id="6519516134-8">)</samp><samp class="w">
    </samp><samp class="o">|&gt;</samp><samp class="w"> </samp><samp class="nc">Map</samp><samp class="o">.</samp><samp class="n">new</samp><samp class="p" data-group-id="6519516134-9">(</samp><samp class="p" data-group-id="6519516134-9">)</samp><samp class="w">

  </samp><samp class="nc">Enum</samp><samp class="o">.</samp><samp class="n">map</samp><samp class="p" data-group-id="6519516134-10">(</samp><samp class="n">assigns_sockets</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="k" data-group-id="6519516134-11">fn</samp><samp class="w"> </samp><samp class="p" data-group-id="6519516134-12">{</samp><samp class="n">assigns</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="6519516134-12">}</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w">
    </samp><samp class="n">assign</samp><samp class="p" data-group-id="6519516134-13">(</samp><samp class="n">socket</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">:user</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">users</samp><samp class="p" data-group-id="6519516134-14">[</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p" data-group-id="6519516134-14">]</samp><samp class="p" data-group-id="6519516134-13">)</samp><samp class="w">
  </samp><samp class="k" data-group-id="6519516134-11">end</samp><samp class="p" data-group-id="6519516134-10">)</samp><samp class="w">
</samp><samp class="k" data-group-id="6519516134-2">end</samp></code></pre><p>Now only a single query to the database will be made. In fact, the
<code class="inline">update_many/1</code> algorithm is a breadth-first tree traversal, which means
that even for nested components, the amount of queries are kept to
a minimum.</p><p>Finally, note that <a href="#c:update_many/1"><code class="inline">update_many/1</code></a> must return an updated list of
sockets in the same order as they are given. If <a href="#c:update_many/1"><code class="inline">update_many/1</code></a> is
defined, <a href="#c:update/2"><code class="inline">update/2</code></a> is not invoked.</p><h3 id="module-summary">Summary</h3><p>All of the life-cycle events are summarized in the diagram below.
The bubble events in white are triggers that invoke the component.
In blue you have component callbacks, where the underlined names
represent required callbacks:</p><pre><code class="mermaid">flowchart LR
    *((start)):::event-.-&gt;M
    WE([wait for&lt;br&gt;parent changes]):::event-.-&gt;M
    W([wait for&lt;br&gt;events]):::event-.-&gt;H

    subgraph j__transparent[&quot; &quot;]

      subgraph i[&quot; &quot;]
        direction TB
        M(mount/1&lt;br&gt;&lt;em&gt;only once&lt;/em&gt;):::callback
        M--&gt;U
        M--&gt;UM
      end

      U(update/2):::callback--&gt;A
      UM(update_many/1):::callback--&gt;A

      subgraph j[&quot; &quot;]
        direction TB
        A --&gt; |yes| R
        H(handle_event/3):::callback--&gt;A{any&lt;br&gt;changes?}:::diamond
      end

      A --&gt; |no| W

    end

    R(render/1):::callback_req--&gt;W

    classDef event fill:#fff,color:#000,stroke:#000
    classDef diamond fill:#FFC28C,color:#000,stroke:#000
    classDef callback fill:#B7ADFF,color:#000,stroke-width:0
    classDef callback_req fill:#B7ADFF,color:#000,stroke-width:0,text-decoration:underline</code></pre><h2 id="module-managing-state">Managing state</h2><p>Now that we have learned how to define and use components, as well as
how to use <a href="#c:update_many/1"><code class="inline">update_many/1</code></a> as a data loading optimization, it is important
to talk about how to manage state in components.</p><p>Generally speaking, you want to avoid both the parent LiveView and the
LiveComponent working on two different copies of the state. Instead, you
should assume only one of them to be the source of truth. Let's discuss
the two different approaches in detail.</p><p>Imagine a scenario where a LiveView represents a board with each card
in it as a separate LiveComponent. Each card has a form to
allow update of the card title directly in the component, as follows:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">CardComponent</samp><samp class="w"> </samp><samp class="k" data-group-id="4048132120-1">do</samp><samp class="w">
  </samp><samp class="kn">use</samp><samp class="w"> </samp><samp class="nc">Phoenix.LiveComponent</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">render</samp><samp class="p" data-group-id="4048132120-2">(</samp><samp class="n">assigns</samp><samp class="p" data-group-id="4048132120-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4048132120-3">do</samp><samp class="w">
    </samp><samp class="sx">~H&quot;&quot;&quot;</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="p">&lt;</samp><samp class="nt">form</samp><samp class="w"> </samp><samp class="na">phx-submit</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">...</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">phx-target</samp><samp class="p">=</samp><samp class="p" data-group-id="6643757584-1">{</samp><samp class="na">@myself</samp><samp class="p" data-group-id="6643757584-1">}</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">      </samp><samp class="p">&lt;</samp><samp class="nt">input</samp><samp class="w"> </samp><samp class="na">name</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">title</samp><samp class="p">&quot;</samp><samp class="p">&gt;</samp><samp class="p" data-group-id="6643757584-2">{</samp><samp class="na">@card</samp><samp class="o">.</samp><samp class="n">title</samp><samp class="p" data-group-id="6643757584-2">}</samp><samp class="p">&lt;/</samp><samp class="nt">input</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="n">      ...
</samp><samp class="w">    </samp><samp class="p">&lt;/</samp><samp class="nt">form</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="sx">&quot;&quot;&quot;</samp><samp class="w">
  </samp><samp class="k" data-group-id="4048132120-3">end</samp><samp class="w">

  </samp><samp class="n">...</samp><samp class="w">
</samp><samp class="k" data-group-id="4048132120-1">end</samp></code></pre><p>We will see how to organize the data flow to keep either the board LiveView or
the card LiveComponents as the source of truth.</p><h3 id="module-liveview-as-the-source-of-truth">LiveView as the source of truth</h3><p>If the board LiveView is the source of truth, it will be responsible
for fetching all of the cards in a board. Then it will call
<a href="Phoenix.Component.xhtml#live_component/1"><code class="inline">live_component/1</code></a>
for each card, passing the card struct as argument to <code class="inline">CardComponent</code>:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">:for</samp><samp class="p">=</samp><samp class="p" data-group-id="3118250045-1">{</samp><samp class="n">card</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="na">@cards</samp><samp class="p" data-group-id="3118250045-1">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="3118250045-2">{</samp><samp class="nc">CardComponent</samp><samp class="p" data-group-id="3118250045-2">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">card</samp><samp class="p">=</samp><samp class="p" data-group-id="3118250045-3">{</samp><samp class="n">card</samp><samp class="p" data-group-id="3118250045-3">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">id</samp><samp class="p">=</samp><samp class="p" data-group-id="3118250045-4">{</samp><samp class="n">card</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p" data-group-id="3118250045-4">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">board_id</samp><samp class="p">=</samp><samp class="p" data-group-id="3118250045-5">{</samp><samp class="na">@id</samp><samp class="p" data-group-id="3118250045-5">}</samp><samp class="w">
</samp><samp class="p">/&gt;</samp></code></pre><p>Now, when the user submits the form, <code class="inline">CardComponent.handle_event/3</code>
will be triggered. However, if the update succeeds, you must not
change the card struct inside the component. If you do so, the card
struct in the component will get out of sync with the LiveView.  Since
the LiveView is the source of truth, you should instead tell the
LiveView that the card was updated.</p><p>Luckily, because the component and the view run in the same process,
sending a message from the LiveComponent to the parent LiveView is as
simple as sending a message to <code class="inline">self()</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">CardComponent</samp><samp class="w"> </samp><samp class="k" data-group-id="6628794753-1">do</samp><samp class="w">
  </samp><samp class="n">...</samp><samp class="w">
  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_event</samp><samp class="p" data-group-id="6628794753-2">(</samp><samp class="s">&quot;update_title&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6628794753-3">%{</samp><samp class="s">&quot;title&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="n">title</samp><samp class="p" data-group-id="6628794753-3">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="6628794753-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="6628794753-4">do</samp><samp class="w">
    </samp><samp class="n">send</samp><samp class="w"> </samp><samp class="n">self</samp><samp class="p" data-group-id="6628794753-5">(</samp><samp class="p" data-group-id="6628794753-5">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6628794753-6">{</samp><samp class="ss">:updated_card</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="6628794753-7">%{</samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">card</samp><samp class="w"> </samp><samp class="o">|</samp><samp class="w"> </samp><samp class="ss">title</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">title</samp><samp class="p" data-group-id="6628794753-7">}</samp><samp class="p" data-group-id="6628794753-6">}</samp><samp class="w">
    </samp><samp class="p" data-group-id="6628794753-8">{</samp><samp class="ss">:noreply</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="6628794753-8">}</samp><samp class="w">
  </samp><samp class="k" data-group-id="6628794753-4">end</samp><samp class="w">
</samp><samp class="k" data-group-id="6628794753-1">end</samp></code></pre><p>The LiveView then receives this event using <a href="Phoenix.LiveView.xhtml#c:handle_info/2"><code class="inline">Phoenix.LiveView.handle_info/2</code></a>:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">BoardView</samp><samp class="w"> </samp><samp class="k" data-group-id="7594148793-1">do</samp><samp class="w">
  </samp><samp class="n">...</samp><samp class="w">
  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_info</samp><samp class="p" data-group-id="7594148793-2">(</samp><samp class="p" data-group-id="7594148793-3">{</samp><samp class="ss">:updated_card</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">card</samp><samp class="p" data-group-id="7594148793-3">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="7594148793-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="7594148793-4">do</samp><samp class="w">
    </samp><samp class="c1"># update the list of cards in the socket</samp><samp class="w">
    </samp><samp class="p" data-group-id="7594148793-5">{</samp><samp class="ss">:noreply</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">updated_socket</samp><samp class="p" data-group-id="7594148793-5">}</samp><samp class="w">
  </samp><samp class="k" data-group-id="7594148793-4">end</samp><samp class="w">
</samp><samp class="k" data-group-id="7594148793-1">end</samp></code></pre><p>Because the list of cards in the parent socket was updated, the parent
LiveView will be re-rendered, sending the updated card to the component.
So in the end, the component does get the updated card, but always
driven from the parent.</p><p>Alternatively, instead of having the component send a message directly to the
parent view, the component could broadcast the update using <a href="https://hexdocs.pm/phoenix_pubsub/2.1.3/Phoenix.PubSub.html"><code class="inline">Phoenix.PubSub</code></a>.
Such as:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">CardComponent</samp><samp class="w"> </samp><samp class="k" data-group-id="0226854780-1">do</samp><samp class="w">
  </samp><samp class="n">...</samp><samp class="w">
  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_event</samp><samp class="p" data-group-id="0226854780-2">(</samp><samp class="s">&quot;update_title&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="0226854780-3">%{</samp><samp class="s">&quot;title&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="n">title</samp><samp class="p" data-group-id="0226854780-3">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="0226854780-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="0226854780-4">do</samp><samp class="w">
    </samp><samp class="n">message</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="p" data-group-id="0226854780-5">{</samp><samp class="ss">:updated_card</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="0226854780-6">%{</samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">card</samp><samp class="w"> </samp><samp class="o">|</samp><samp class="w"> </samp><samp class="ss">title</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">title</samp><samp class="p" data-group-id="0226854780-6">}</samp><samp class="p" data-group-id="0226854780-5">}</samp><samp class="w">
    </samp><samp class="nc">Phoenix.PubSub</samp><samp class="o">.</samp><samp class="n">broadcast</samp><samp class="p" data-group-id="0226854780-7">(</samp><samp class="nc">MyApp.PubSub</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">board_topic</samp><samp class="p" data-group-id="0226854780-8">(</samp><samp class="n">socket</samp><samp class="p" data-group-id="0226854780-8">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">message</samp><samp class="p" data-group-id="0226854780-7">)</samp><samp class="w">
    </samp><samp class="p" data-group-id="0226854780-9">{</samp><samp class="ss">:noreply</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="0226854780-9">}</samp><samp class="w">
  </samp><samp class="k" data-group-id="0226854780-4">end</samp><samp class="w">

  </samp><samp class="kd">defp</samp><samp class="w"> </samp><samp class="nf">board_topic</samp><samp class="p" data-group-id="0226854780-10">(</samp><samp class="n">socket</samp><samp class="p" data-group-id="0226854780-10">)</samp><samp class="w"> </samp><samp class="k" data-group-id="0226854780-11">do</samp><samp class="w">
    </samp><samp class="s">&quot;board:&quot;</samp><samp class="w"> </samp><samp class="o">&lt;&gt;</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">board_id</samp><samp class="w">
  </samp><samp class="k" data-group-id="0226854780-11">end</samp><samp class="w">
</samp><samp class="k" data-group-id="0226854780-1">end</samp></code></pre><p>As long as the parent LiveView subscribes to the <code class="inline">board:&lt;ID&gt;</code> topic,
it will receive updates. The advantage of using PubSub is that we get
distributed updates out of the box. Now, if any user connected to the
board changes a card, all other users will see the change.</p><h3 id="module-livecomponent-as-the-source-of-truth">LiveComponent as the source of truth</h3><p>If each card LiveComponent is the source of truth, then the board LiveView
must no longer fetch the card structs from the database. Instead, the board
LiveView must only fetch the card ids, then render each component only by
passing an ID:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">:for</samp><samp class="p">=</samp><samp class="p" data-group-id="5593731136-1">{</samp><samp class="n">card_id</samp><samp class="w"> </samp><samp class="o">&lt;-</samp><samp class="w"> </samp><samp class="na">@card_ids</samp><samp class="p" data-group-id="5593731136-1">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="5593731136-2">{</samp><samp class="nc">CardComponent</samp><samp class="p" data-group-id="5593731136-2">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">id</samp><samp class="p">=</samp><samp class="p" data-group-id="5593731136-3">{</samp><samp class="n">card_id</samp><samp class="p" data-group-id="5593731136-3">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">board_id</samp><samp class="p">=</samp><samp class="p" data-group-id="5593731136-4">{</samp><samp class="na">@id</samp><samp class="p" data-group-id="5593731136-4">}</samp><samp class="w">
</samp><samp class="p">/&gt;</samp></code></pre><p>Now, each CardComponent will load its own card. Of course, doing so
per card could be expensive and lead to N queries, where N is the
number of cards, so we can use the <a href="#c:update_many/1"><code class="inline">update_many/1</code></a> callback to make it
efficient.</p><p>Once the card components are started, they can each manage their own
card, without concerning themselves with the parent LiveView.</p><p>However, note that components do not have a <a href="Phoenix.LiveView.xhtml#c:handle_info/2"><code class="inline">Phoenix.LiveView.handle_info/2</code></a>
callback. Therefore, if you want to track distributed changes on a card,
you must have the parent LiveView receive those events and redirect them
to the appropriate card. For example, assuming card updates are sent
to the &quot;board:ID&quot; topic, and that the board LiveView is subscribed to
said topic, one could do:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_info</samp><samp class="p" data-group-id="8224205464-1">(</samp><samp class="p" data-group-id="8224205464-2">{</samp><samp class="ss">:updated_card</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">card</samp><samp class="p" data-group-id="8224205464-2">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="8224205464-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="8224205464-3">do</samp><samp class="w">
  </samp><samp class="n">send_update</samp><samp class="w"> </samp><samp class="nc">CardComponent</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">id</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">card</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">board_id</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="w">
  </samp><samp class="p" data-group-id="8224205464-4">{</samp><samp class="ss">:noreply</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="8224205464-4">}</samp><samp class="w">
</samp><samp class="k" data-group-id="8224205464-3">end</samp></code></pre><p>With <a href="Phoenix.LiveView.xhtml#send_update/3"><code class="inline">Phoenix.LiveView.send_update/3</code></a>, the <code class="inline">CardComponent</code> given by <code class="inline">id</code>
will be invoked, triggering the update or update_many callback, which will
load the most up to date data from the database.</p><h3 id="module-unifying-liveview-and-livecomponent-communication">Unifying LiveView and LiveComponent communication</h3><p>In the examples above, we have used <a href="https://hexdocs.pm/elixir/Kernel.html#send/2"><code class="inline">send/2</code></a> to communicate with LiveView
and <code class="inline">send_update/2</code> to communicate with components. This introduces a problem:
what if you have a component that may be mounted both inside a LiveView
or another component? Given each uses a different API for exchanging data,
this may seem tricky at first, but an elegant solution is to use anonymous
functions as callbacks. Let's see an example.</p><p>In the sections above, we wrote the following code in our <code class="inline">CardComponent</code>:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_event</samp><samp class="p" data-group-id="5064240427-1">(</samp><samp class="s">&quot;update_title&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5064240427-2">%{</samp><samp class="s">&quot;title&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="n">title</samp><samp class="p" data-group-id="5064240427-2">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="5064240427-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="5064240427-3">do</samp><samp class="w">
  </samp><samp class="n">send</samp><samp class="w"> </samp><samp class="n">self</samp><samp class="p" data-group-id="5064240427-4">(</samp><samp class="p" data-group-id="5064240427-4">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5064240427-5">{</samp><samp class="ss">:updated_card</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="5064240427-6">%{</samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">card</samp><samp class="w"> </samp><samp class="o">|</samp><samp class="w"> </samp><samp class="ss">title</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">title</samp><samp class="p" data-group-id="5064240427-6">}</samp><samp class="p" data-group-id="5064240427-5">}</samp><samp class="w">
  </samp><samp class="p" data-group-id="5064240427-7">{</samp><samp class="ss">:noreply</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="5064240427-7">}</samp><samp class="w">
</samp><samp class="k" data-group-id="5064240427-3">end</samp></code></pre><p>The issue with this code is that, if CardComponent is mounted inside another
component, it will still message the LiveView. Not only that, this code may
be hard to maintain because the message sent by the component is defined far
away from the LiveView that will receive it.</p><p>Instead let's define a callback that will be invoked by CardComponent:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_event</samp><samp class="p" data-group-id="8836196540-1">(</samp><samp class="s">&quot;update_title&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="8836196540-2">%{</samp><samp class="s">&quot;title&quot;</samp><samp class="w"> </samp><samp class="p">=&gt;</samp><samp class="w"> </samp><samp class="n">title</samp><samp class="p" data-group-id="8836196540-2">}</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="8836196540-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="8836196540-3">do</samp><samp class="w">
  </samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">on_card_update</samp><samp class="o">.</samp><samp class="p" data-group-id="8836196540-4">(</samp><samp class="p" data-group-id="8836196540-5">%{</samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">card</samp><samp class="w"> </samp><samp class="o">|</samp><samp class="w"> </samp><samp class="ss">title</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">title</samp><samp class="p" data-group-id="8836196540-5">}</samp><samp class="p" data-group-id="8836196540-4">)</samp><samp class="w">
  </samp><samp class="p" data-group-id="8836196540-6">{</samp><samp class="ss">:noreply</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="8836196540-6">}</samp><samp class="w">
</samp><samp class="k" data-group-id="8836196540-3">end</samp></code></pre><p>And now when initializing the CardComponent from a LiveView, we may write:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="3544857954-1">{</samp><samp class="nc">CardComponent</samp><samp class="p" data-group-id="3544857954-1">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">card</samp><samp class="p">=</samp><samp class="p" data-group-id="3544857954-2">{</samp><samp class="n">card</samp><samp class="p" data-group-id="3544857954-2">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">id</samp><samp class="p">=</samp><samp class="p" data-group-id="3544857954-3">{</samp><samp class="n">card</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p" data-group-id="3544857954-3">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">board_id</samp><samp class="p">=</samp><samp class="p" data-group-id="3544857954-4">{</samp><samp class="na">@id</samp><samp class="p" data-group-id="3544857954-4">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">on_card_update</samp><samp class="p">=</samp><samp class="p" data-group-id="3544857954-5">{</samp><samp class="k" data-group-id="3544857954-ex-1">fn</samp><samp class="w"> </samp><samp class="n">card</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">send</samp><samp class="p" data-group-id="3544857954-ex-2">(</samp><samp class="n">self</samp><samp class="p" data-group-id="3544857954-ex-3">(</samp><samp class="p" data-group-id="3544857954-ex-3">)</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="p" data-group-id="3544857954-ex-4">{</samp><samp class="ss">:updated_card</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">card</samp><samp class="p" data-group-id="3544857954-ex-4">}</samp><samp class="p" data-group-id="3544857954-ex-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="3544857954-ex-1">end</samp><samp class="p" data-group-id="3544857954-5">}</samp><samp class="w"> </samp><samp class="p">/&gt;</samp></code></pre><p>If initializing it inside another component, one may write:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="4903475069-1">{</samp><samp class="nc">CardComponent</samp><samp class="p" data-group-id="4903475069-1">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">card</samp><samp class="p">=</samp><samp class="p" data-group-id="4903475069-2">{</samp><samp class="n">card</samp><samp class="p" data-group-id="4903475069-2">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">id</samp><samp class="p">=</samp><samp class="p" data-group-id="4903475069-3">{</samp><samp class="n">card</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p" data-group-id="4903475069-3">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">board_id</samp><samp class="p">=</samp><samp class="p" data-group-id="4903475069-4">{</samp><samp class="na">@id</samp><samp class="p" data-group-id="4903475069-4">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="na">on_card_update</samp><samp class="p">=</samp><samp class="p" data-group-id="4903475069-5">{</samp><samp class="k" data-group-id="4903475069-ex-1">fn</samp><samp class="w"> </samp><samp class="n">card</samp><samp class="w"> </samp><samp class="o">-&gt;</samp><samp class="w"> </samp><samp class="n">send_update</samp><samp class="p" data-group-id="4903475069-ex-2">(</samp><samp class="na">@myself</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">card</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="n">card</samp><samp class="p" data-group-id="4903475069-ex-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="4903475069-ex-1">end</samp><samp class="p" data-group-id="4903475069-5">}</samp><samp class="w"> </samp><samp class="p">/&gt;</samp></code></pre><p>The major benefit in both cases is that the parent has explicit control
over the messages it will receive.</p><h2 id="module-slots">Slots</h2><p>LiveComponent can also receive slots, in the same way as a <a href="Phoenix.Component.xhtml"><code class="inline">Phoenix.Component</code></a>:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w"> </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="6422632336-1">{</samp><samp class="nc">MyComponent</samp><samp class="p" data-group-id="6422632336-1">}</samp><samp class="w"> </samp><samp class="na">id</samp><samp class="p">=</samp><samp class="p" data-group-id="6422632336-2">{</samp><samp class="na">@data</samp><samp class="o">.</samp><samp class="n">id</samp><samp class="p" data-group-id="6422632336-2">}</samp><samp class="w"> </samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="p">&lt;</samp><samp class="nt">div</samp><samp class="p">&gt;</samp><samp class="n">Inner content here</samp><samp class="p">&lt;/</samp><samp class="nt">div</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="p">&lt;/</samp><samp class="nf">.live_component</samp><samp class="p">&gt;</samp></code></pre><p>If the LiveComponent defines an <a href="#c:update/2"><code class="inline">update/2</code></a>, be sure that the socket it returns
includes the <code class="inline">:inner_block</code> assign it received.</p><p>See <a href="Phoenix.Component.html#module-slots.md">the docs</a> for <a href="Phoenix.Component.xhtml"><code class="inline">Phoenix.Component</code></a> for more information.</p><h2 id="module-live-patches-and-live-redirects">Live patches and live redirects</h2><p>A template rendered inside a component can use <code class="inline">&lt;.link patch={...}&gt;</code> and
<code class="inline">&lt;.link navigate={...}&gt;</code>. Patches are always handled by the parent LiveView,
as components do not provide <code class="inline">handle_params</code>.</p><h2 id="module-cost-of-live-components">Cost of live components</h2><p>The internal infrastructure LiveView uses to keep track of live
components is very lightweight. However, be aware that in order to
provide change tracking and to send diffs over the wire, all of the
components' assigns are kept in memory - exactly as it is done in
LiveViews themselves.</p><p>Therefore it is your responsibility to keep only the assigns necessary
in each component. For example, avoid passing all of LiveView's assigns
when rendering a component:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w"> </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="0808986605-1">{</samp><samp class="nc">MyComponent</samp><samp class="p" data-group-id="0808986605-1">}</samp><samp class="w"> </samp><samp class="p" data-group-id="0808986605-2">{</samp><samp class="n">assigns</samp><samp class="p" data-group-id="0808986605-2">}</samp><samp class="w"> </samp><samp class="p">/&gt;</samp></code></pre><p>Instead pass only the keys that you need:</p><pre><code class="makeup heex" translate="no"><samp class="p">&lt;</samp><samp class="nf">.live_component</samp><samp class="w"> </samp><samp class="na">module</samp><samp class="p">=</samp><samp class="p" data-group-id="1723831484-1">{</samp><samp class="nc">MyComponent</samp><samp class="p" data-group-id="1723831484-1">}</samp><samp class="w"> </samp><samp class="na">user</samp><samp class="p">=</samp><samp class="p" data-group-id="1723831484-2">{</samp><samp class="na">@user</samp><samp class="p" data-group-id="1723831484-2">}</samp><samp class="w"> </samp><samp class="na">org</samp><samp class="p">=</samp><samp class="p" data-group-id="1723831484-3">{</samp><samp class="na">@org</samp><samp class="p" data-group-id="1723831484-3">}</samp><samp class="w"> </samp><samp class="p">/&gt;</samp></code></pre><p>Luckily, because LiveViews and LiveComponents are in the same process,
they share the data structure representations in memory. For example,
in the code above, the view and the component will share the same copies
of the <code class="inline">@user</code> and <code class="inline">@org</code> assigns.</p><p>You should also avoid using live components to provide abstract DOM
components. As a guideline, a good LiveComponent encapsulates
application concerns and not DOM functionality. For example, if you
have a page that shows products for sale, you can encapsulate the
rendering of each of those products in a component. This component
may have many buttons and events within it. On the opposite side,
do not write a component that is simply encapsulating generic DOM
components. For instance, do not do this:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">defmodule</samp><samp class="w"> </samp><samp class="nc">MyButton</samp><samp class="w"> </samp><samp class="k" data-group-id="6587440899-1">do</samp><samp class="w">
  </samp><samp class="kn">use</samp><samp class="w"> </samp><samp class="nc">Phoenix.LiveComponent</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">render</samp><samp class="p" data-group-id="6587440899-2">(</samp><samp class="n">assigns</samp><samp class="p" data-group-id="6587440899-2">)</samp><samp class="w"> </samp><samp class="k" data-group-id="6587440899-3">do</samp><samp class="w">
    </samp><samp class="sx">~H&quot;&quot;&quot;</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="p">&lt;</samp><samp class="nt">button</samp><samp class="w"> </samp><samp class="na">class</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">c</samp><samp class="s2">s</samp><samp class="s2">s</samp><samp class="s2">-</samp><samp class="s2">f</samp><samp class="s2">r</samp><samp class="s2">a</samp><samp class="s2">m</samp><samp class="s2">e</samp><samp class="s2">w</samp><samp class="s2">o</samp><samp class="s2">r</samp><samp class="s2">k</samp><samp class="s2">-</samp><samp class="s2">c</samp><samp class="s2">l</samp><samp class="s2">a</samp><samp class="s2">s</samp><samp class="s2">s</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">phx-click</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">click</samp><samp class="p">&quot;</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">      </samp><samp class="p" data-group-id="6747756696-1">{</samp><samp class="na">@text</samp><samp class="p" data-group-id="6747756696-1">}</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="p">&lt;/</samp><samp class="nt">button</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="sx">&quot;&quot;&quot;</samp><samp class="w">
  </samp><samp class="k" data-group-id="6587440899-3">end</samp><samp class="w">

  </samp><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">handle_event</samp><samp class="p" data-group-id="6587440899-4">(</samp><samp class="s">&quot;click&quot;</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="bp">_</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="6587440899-4">)</samp><samp class="w"> </samp><samp class="k" data-group-id="6587440899-5">do</samp><samp class="w">
    </samp><samp class="bp">_</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="o">.</samp><samp class="n">assigns</samp><samp class="o">.</samp><samp class="n">on_click</samp><samp class="o">.</samp><samp class="p" data-group-id="6587440899-6">(</samp><samp class="p" data-group-id="6587440899-6">)</samp><samp class="w">
    </samp><samp class="p" data-group-id="6587440899-7">{</samp><samp class="ss">:noreply</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="n">socket</samp><samp class="p" data-group-id="6587440899-7">}</samp><samp class="w">
  </samp><samp class="k" data-group-id="6587440899-5">end</samp><samp class="w">
</samp><samp class="k" data-group-id="6587440899-1">end</samp></code></pre><p>Instead, it is much simpler to create a function component:</p><pre><code class="makeup elixir" translate="no"><samp class="kd">def</samp><samp class="w"> </samp><samp class="nf">my_button</samp><samp class="p" data-group-id="1098394853-1">(</samp><samp class="p" data-group-id="1098394853-2">%{</samp><samp class="ss">text</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="bp">_</samp><samp class="p">,</samp><samp class="w"> </samp><samp class="ss">click</samp><samp class="p">:</samp><samp class="w"> </samp><samp class="bp">_</samp><samp class="p" data-group-id="1098394853-2">}</samp><samp class="w"> </samp><samp class="o">=</samp><samp class="w"> </samp><samp class="n">assigns</samp><samp class="p" data-group-id="1098394853-1">)</samp><samp class="w"> </samp><samp class="k" data-group-id="1098394853-3">do</samp><samp class="w">
  </samp><samp class="sx">~H&quot;&quot;&quot;</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="p">&lt;</samp><samp class="nt">button</samp><samp class="w"> </samp><samp class="na">class</samp><samp class="p">=</samp><samp class="p">&quot;</samp><samp class="s2">c</samp><samp class="s2">s</samp><samp class="s2">s</samp><samp class="s2">-</samp><samp class="s2">f</samp><samp class="s2">r</samp><samp class="s2">a</samp><samp class="s2">m</samp><samp class="s2">e</samp><samp class="s2">w</samp><samp class="s2">o</samp><samp class="s2">r</samp><samp class="s2">k</samp><samp class="s2">-</samp><samp class="s2">c</samp><samp class="s2">l</samp><samp class="s2">a</samp><samp class="s2">s</samp><samp class="s2">s</samp><samp class="p">&quot;</samp><samp class="w"> </samp><samp class="na">phx-click</samp><samp class="p">=</samp><samp class="p" data-group-id="8256532912-1">{</samp><samp class="na">@click</samp><samp class="p" data-group-id="8256532912-1">}</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">    </samp><samp class="p" data-group-id="8256532912-2">{</samp><samp class="na">@text</samp><samp class="p" data-group-id="8256532912-2">}</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="p">&lt;/</samp><samp class="nt">button</samp><samp class="p">&gt;</samp><samp class="w">
</samp><samp class="w">  </samp><samp class="sx">&quot;&quot;&quot;</samp><samp class="w">
</samp><samp class="k" data-group-id="1098394853-3">end</samp></code></pre><p>If you keep components mostly as an application concern with
only the necessary assigns, it is unlikely you will run into
issues related to live components.</p><h2 id="module-limitations">Limitations</h2><p>Live Components require a single HTML tag at the root. It is not possible
to have components that render only text or multiple tags.</p>
      </section>


      <section id="summary" class="details-list">
        <h1 class="section-heading">Summary</h1>
<div class="summary-callbacks summary">
  <h2>
    <a href="#callbacks">Callbacks</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#c:handle_async/3" data-no-tooltip="" translate="no">handle_async(name, async_fun_result, socket)</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#c:handle_event/3" data-no-tooltip="" translate="no">handle_event(event, unsigned_params, socket)</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#c:mount/1" data-no-tooltip="" translate="no">mount(socket)</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#c:render/1" data-no-tooltip="" translate="no">render(assigns)</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#c:update/2" data-no-tooltip="" translate="no">update(assigns, socket)</a>

      </div>

    </div>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#c:update_many/1" data-no-tooltip="" translate="no">update_many(list)</a>

      </div>

    </div>

</div>
<div class="summary-functions summary">
  <h2>
    <a href="#functions">Functions</a>
  </h2>

    <div class="summary-row">
      <div class="summary-signature">
        <a href="#__using__/1" data-no-tooltip="" translate="no">__using__(opts \\ [])</a>

      </div>

        <div class="summary-synopsis"><p>Uses LiveComponent in the current module.</p></div>

    </div>

</div>

      </section>


      <section id="callbacks" class="details-list">
        <h1 class="section-heading">Callbacks</h1>
        <div class="callbacks-list">
<section class="detail" id="c:handle_async/3">

  <div class="detail-header">
    <a href="#c:handle_async/3" class="detail-link" data-no-tooltip="" aria-label="Link to this callback">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">handle_async(name, async_fun_result, socket)</h1>

        <span class="note">(optional)</span>


        <a href="https://github.com/phoenixframework/phoenix_live_view/blob/v1.1.2/lib/phoenix_live_component.ex#L611" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@callback</span> handle_async(
  name :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>(),
  async_fun_result :: {:ok, <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()} | {:exit, <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">term</a>()},
  socket :: <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()
) :: {:noreply, <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()}</pre>

      </div>


  </section>
</section>
<section class="detail" id="c:handle_event/3">

  <div class="detail-header">
    <a href="#c:handle_event/3" class="detail-link" data-no-tooltip="" aria-label="Link to this callback">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">handle_event(event, unsigned_params, socket)</h1>

        <span class="note">(optional)</span>


        <a href="https://github.com/phoenixframework/phoenix_live_view/blob/v1.1.2/lib/phoenix_live_component.ex#L604" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@callback</span> handle_event(
  event :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(),
  unsigned_params :: <a href="Phoenix.LiveView.xhtml#t:unsigned_params/0">Phoenix.LiveView.unsigned_params</a>(),
  socket :: <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()
) ::
  {:noreply, <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()}
  | {:reply, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">map</a>(), <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()}</pre>

      </div>


  </section>
</section>
<section class="detail" id="c:mount/1">

  <div class="detail-header">
    <a href="#c:mount/1" class="detail-link" data-no-tooltip="" aria-label="Link to this callback">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">mount(socket)</h1>

        <span class="note">(optional)</span>


        <a href="https://github.com/phoenixframework/phoenix_live_view/blob/v1.1.2/lib/phoenix_live_component.ex#L595" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@callback</span> mount(socket :: <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()) ::
  {:ok, <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()}
  | {:ok, <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">keyword</a>()}</pre>

      </div>


  </section>
</section>
<section class="detail" id="c:render/1">

  <div class="detail-header">
    <a href="#c:render/1" class="detail-link" data-no-tooltip="" aria-label="Link to this callback">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">render(assigns)</h1>

        <span class="note">(optional)</span>


        <a href="https://github.com/phoenixframework/phoenix_live_view/blob/v1.1.2/lib/phoenix_live_component.ex#L602" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@callback</span> render(assigns :: <a href="Phoenix.LiveView.Socket.xhtml#t:assigns/0">Phoenix.LiveView.Socket.assigns</a>()) ::
  <a href="Phoenix.LiveView.Rendered.xhtml#t:t/0">Phoenix.LiveView.Rendered.t</a>()</pre>

      </div>


  </section>
</section>
<section class="detail" id="c:update/2">

  <div class="detail-header">
    <a href="#c:update/2" class="detail-link" data-no-tooltip="" aria-label="Link to this callback">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">update(assigns, socket)</h1>

        <span class="note">(optional)</span>


        <a href="https://github.com/phoenixframework/phoenix_live_view/blob/v1.1.2/lib/phoenix_live_component.ex#L598" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@callback</span> update(
  assigns :: <a href="Phoenix.LiveView.Socket.xhtml#t:assigns/0">Phoenix.LiveView.Socket.assigns</a>(),
  socket :: <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()
) ::
  {:ok, <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()}</pre>

      </div>


  </section>
</section>
<section class="detail" id="c:update_many/1">

  <div class="detail-header">
    <a href="#c:update_many/1" class="detail-link" data-no-tooltip="" aria-label="Link to this callback">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">update_many(list)</h1>

        <span class="note">(optional)</span>


        <a href="https://github.com/phoenixframework/phoenix_live_view/blob/v1.1.2/lib/phoenix_live_component.ex#L600" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

      <div class="specs">

          <pre translate="no"><span class="attribute">@callback</span> update_many([{<a href="Phoenix.LiveView.Socket.xhtml#t:assigns/0">Phoenix.LiveView.Socket.assigns</a>(), <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()}]) ::
  [
    <a href="Phoenix.LiveView.Socket.xhtml#t:t/0">Phoenix.LiveView.Socket.t</a>()
  ]</pre>

      </div>


  </section>
</section>

        </div>
      </section>

      <section id="functions" class="details-list">
        <h1 class="section-heading">Functions</h1>
        <div class="functions-list">
<section class="detail" id="__using__/1">

    <span id="__using__/0"></span>

  <div class="detail-header">
    <a href="#__using__/1" class="detail-link" data-no-tooltip="" aria-label="Link to this macro">
      <i class="ri-link-m" aria-hidden="true"></i>
    </a>
    <div class="heading-with-actions">
      <h1 class="signature" translate="no">__using__(opts \\ [])</h1>

        <span class="note">(macro)</span>


        <a href="https://github.com/phoenixframework/phoenix_live_view/blob/v1.1.2/lib/phoenix_live_component.ex#L581" class="icon-action" rel="help" aria-label="View Source">
          <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        </a>

    </div>
  </div>

  <section class="docstring">

<p>Uses LiveComponent in the current module.</p><pre><code class="makeup elixir" translate="no"><samp class="kn">use</samp><samp class="w"> </samp><samp class="nc">Phoenix.LiveComponent</samp></code></pre><h2 id="__using__/1-options" class="section-heading"><a href="#__using__/1-options" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Options</span></h2><ul><li><code class="inline">:global_prefixes</code> - the global prefixes to use for components. See
<code class="inline">Global Attributes</code> in <a href="Phoenix.Component.xhtml"><code class="inline">Phoenix.Component</code></a> for more information.</li></ul>
  </section>
</section>

        </div>
      </section>


  </body>
</html>
