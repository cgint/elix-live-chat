<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Error and exception handling - Phoenix LiveView v1.1.2</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Error and exception handling</h1>
<p>As with any other Elixir code, exceptions may happen during the LiveView
life-cycle. This page describes how LiveView handles errors at different
stages.</p><h2 id="expected-scenarios">Expected scenarios</h2><p>In this section, we will talk about error cases that you expect to happen
within your application. For example, a user filling in a form with invalid
data is expected. In a LiveView, we typically handle those cases by storing
the form state in LiveView assigns and rendering any relevant error message
back to the client.</p><p>We may also use <code class="inline">flash</code> messages for this. For example, imagine you have a
page to manage all &quot;Team members&quot; in an organization. However, if there is
only one member left in the organization, they should not be allowed to
leave. You may want to handle this by using flash messages:</p><pre><code class="makeup elixir" translate="no"><span class="k">if</span><span class="w"> </span><span class="nc">MyApp.Org</span><span class="o">.</span><span class="n">leave</span><span class="p" data-group-id="8219178740-1">(</span><span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_org</span><span class="p">,</span><span class="w"> </span><span class="n">member</span><span class="p" data-group-id="8219178740-1">)</span><span class="w"> </span><span class="k" data-group-id="8219178740-2">do</span><span class="w">
  </span><span class="p" data-group-id="8219178740-3">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="8219178740-3">}</span><span class="w">
</span><span class="k" data-group-id="8219178740-2">else</span><span class="w">
  </span><span class="p" data-group-id="8219178740-4">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">put_flash</span><span class="p" data-group-id="8219178740-5">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;last member cannot leave organization&quot;</span><span class="p" data-group-id="8219178740-5">)</span><span class="p" data-group-id="8219178740-4">}</span><span class="w">
</span><span class="k" data-group-id="8219178740-2">end</span></code></pre><p>However, one may argue that, if the last member of an organization cannot
leave it, it may be better to not even show the &quot;Leave&quot; button in the UI
when the organization has only one member.</p><p>Given the button does not appear in the UI, triggering the &quot;leave&quot; action when
the organization has only one member is an unexpected scenario. This means we
can rewrite the code above to:</p><pre><code class="makeup elixir" translate="no"><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">MyApp.Org</span><span class="o">.</span><span class="n">leave</span><span class="p" data-group-id="5248874261-1">(</span><span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_org</span><span class="p">,</span><span class="w"> </span><span class="n">member</span><span class="p" data-group-id="5248874261-1">)</span><span class="w">
</span><span class="p" data-group-id="5248874261-2">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="5248874261-2">}</span></code></pre><p>If <code class="inline">leave</code> does not return <code class="inline">true</code>, Elixir will raise a <a href="https://hexdocs.pm/elixir/MatchError.html"><code class="inline">MatchError</code></a>
exception. Or you could provide a <code class="inline">leave!</code> function that raises a specific
exception:</p><pre><code class="makeup elixir" translate="no"><span class="nc">MyApp.Org</span><span class="o">.</span><span class="n">leave!</span><span class="p" data-group-id="6325249919-1">(</span><span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_org</span><span class="p">,</span><span class="w"> </span><span class="n">member</span><span class="p" data-group-id="6325249919-1">)</span><span class="w">
</span><span class="p" data-group-id="6325249919-2">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="6325249919-2">}</span></code></pre><p>However, what will happen with a LiveView in case of exceptions?
Let's talk about unexpected scenarios.</p><h2 id="unexpected-scenarios">Unexpected scenarios</h2><p>Elixir developers tend to write assertive code. This means that, if we
expect <code class="inline">leave</code> to always return true, we can explicitly match on its
result, as we did above:</p><pre><code class="makeup elixir" translate="no"><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">MyApp.Org</span><span class="o">.</span><span class="n">leave</span><span class="p" data-group-id="8871667750-1">(</span><span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_org</span><span class="p">,</span><span class="w"> </span><span class="n">member</span><span class="p" data-group-id="8871667750-1">)</span><span class="w">
</span><span class="p" data-group-id="8871667750-2">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="8871667750-2">}</span></code></pre><p>If <code class="inline">leave</code> fails and returns <code class="inline">false</code>, an exception is raised. It is common
for Elixir developers to use exceptions for unexpected scenarios in their
Phoenix applications.</p><p>For example, if you are building an application where a user may belong to
one or more organizations, when accessing the organization page, you may want to
check that the user has access to it like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">organizations_query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ecto</span><span class="o">.</span><span class="n">assoc</span><span class="p" data-group-id="7618192325-1">(</span><span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_user</span><span class="p">,</span><span class="w"> </span><span class="ss">:organizations</span><span class="p" data-group-id="7618192325-1">)</span><span class="w">
</span><span class="nc">Repo</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="7618192325-2">(</span><span class="n">organizations_query</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p" data-group-id="7618192325-3">[</span><span class="s">&quot;org_id&quot;</span><span class="p" data-group-id="7618192325-3">]</span><span class="p" data-group-id="7618192325-2">)</span></code></pre><p>The code above builds a query that returns all organizations that belongs to
the current user and then validates that the given <code class="inline">org_id</code> belongs to the
user. If there is no such <code class="inline">org_id</code> or if the user has no access to it,
<code class="inline">Repo.get!</code> will raise an <code class="inline">Ecto.NoResultsError</code> exception.</p><p>During a regular controller request, this exception will be converted to a
404 exception and rendered as a custom error page, as
<a href="https://hexdocs.pm/phoenix/custom_error_pages.html">detailed here</a>.
LiveView will react to exceptions in three different ways, depending on
where it is in its life-cycle.</p><h3 id="exceptions-during-http-mount">Exceptions during HTTP mount</h3><p>When you first access a LiveView, a regular HTTP request is sent to the server
and processed by the LiveView. The <code class="inline">mount</code> callback is invoked and then a page
is rendered. Any exception here is caught, logged, and converted to an exception
page by Phoenix error views - exactly how it works with controllers too.</p><h3 id="exceptions-during-connected-mount">Exceptions during connected mount</h3><p>If the initial HTTP request succeeds, LiveView will connect to the server
using a stateful connection, typically a WebSocket. This spawns a long-running
lightweight Elixir process on the server, which invokes the <code class="inline">mount</code> callback
and renders an updated version of the page.</p><p>An exception during this stage will crash the LiveView process, which will be logged.
Once the client notices the crash, it fully reloads the page. This will cause <code class="inline">mount</code>
to be invoked again during a regular HTTP request (the exact scenario of the previous
subsection).</p><p>In other words, LiveView will reload the page in case of errors, making it
fail as if LiveView was not involved in the rendering in the first place.</p><h3 id="exceptions-after-connected-mount">Exceptions after connected mount</h3><p>Once your LiveView is mounted and connected, any error will cause the LiveView process
to crash and be logged. Once the client notices the error, it will remount the LiveView
over the stateful connection, without reloading the page (the exact scenario of the
previous subsection). If remounting succeeds, the LiveView goes back to a working
state, updating the page and showing the user the latest information.</p><p>For example, let's say two users try to leave the organization at the same time.
In this case, both of them see the &quot;Leave&quot; button, but our <code class="inline">leave</code> function call
will succeed only for one of them:</p><pre><code class="makeup elixir" translate="no"><span class="no">true</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">MyApp.Org</span><span class="o">.</span><span class="n">leave</span><span class="p" data-group-id="7955457037-1">(</span><span class="n">socket</span><span class="o">.</span><span class="n">assigns</span><span class="o">.</span><span class="n">current_org</span><span class="p">,</span><span class="w"> </span><span class="n">member</span><span class="p" data-group-id="7955457037-1">)</span><span class="w">
</span><span class="p" data-group-id="7955457037-2">{</span><span class="ss">:noreply</span><span class="p">,</span><span class="w"> </span><span class="n">socket</span><span class="p" data-group-id="7955457037-2">}</span></code></pre><p>When the exception raises, the client will remount the LiveView. Once you remount,
your code will now notice that there is only one user in the organization and
therefore no longer show the &quot;Leave&quot; button. In other words, by remounting,
we often update the state of the page, allowing exceptions to be automatically
handled.</p><p>Note that the choice between conditionally checking on the result of the <code class="inline">leave</code>
function with an <code class="inline">if</code>, or simply asserting it returns <code class="inline">true</code>, is completely
up to you. If the likelihood of everyone leaving the organization at the same
time is low, then you may as well treat it as an unexpected scenario. Although
other developers will be more comfortable by explicitly handling those cases.
In both scenarios, LiveView has you covered.</p><p>Finally, if your LiveView crashes, its current state will be lost. Luckily,
LiveView has a series of mechanisms and best practices you can follow to ensure
the user is shown the same page as before during reconnections. See the
<a href="deployments.xhtml">&quot;Deployments and recovery&quot;</a> guide for more information.</p>

  </body>
</html>
