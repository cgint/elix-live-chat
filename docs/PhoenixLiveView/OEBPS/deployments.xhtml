<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Deployments and recovery - Phoenix LiveView v1.1.2</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Deployments and recovery</h1>
<p>One of the questions that arise from LiveView stateful model is what considerations are necessary when deploying a new version of LiveView (or when recovering from an error).</p><p>First off, whenever LiveView disconnects, it will automatically attempt to reconnect to the server using exponential back-off. This means it will try immediately, then wait 2s and try again, then 5s and so on. If you are deploying, this typically means the next reconnection will immediately succeed and your load balancer will automatically redirect to the new servers.</p><p>However, your LiveView <em>may</em> still have state that will be lost in this transition. How to deal with it? The good news is that there are a series of practices you can follow that will not only help with deployments but it will improve your application in general.</p><ol><li><p>Keep state in the query parameters when appropriate. For example, if your application has tabs and the user clicked a tab, instead of using <code class="inline">phx-click</code> and <a href="Phoenix.LiveView.xhtml#c:handle_event/3"><code class="inline">Phoenix.LiveView.handle_event/3</code></a> to manage it, you should implement it using <code class="inline">&lt;.link patch={...}&gt;</code> passing the tab name as parameter. You will then receive the new tab name <a href="Phoenix.LiveView.xhtml#c:handle_params/3"><code class="inline">Phoenix.LiveView.handle_params/3</code></a> which will set the relevant assign to choose which tab to display. You can even define specific URLs for each tab in your application router. By doing this, you will reduce the amount of server state, make tab navigation shareable via links, improving search engine indexing, and more.</p></li><li><p>Consider storing other relevant state in the database. For example, if you are building a chat app and you want to store which messages have been read, you can store so in the database. Once the page is loaded, you retrieve the index of the last read message. This makes the application more robust, allow data to be synchronized across devices, etc.</p></li><li><p>If your application uses forms (which is most likely the case), keep in mind that Phoenix performs automatic form recovery: in case of disconnections, Phoenix will collect the form data and resubmit it on reconnection. This mechanism works out of the box for most forms but you may want to customize it or test it for your most complex forms. See the relevant section <a href="form-bindings.xhtml">in the &quot;Form bindings&quot; document</a> to learn more.</p></li></ol><p>The idea is that: if you follow the practices above, most of your state is already handled within your app and therefore deployments should not bring additional concerns. Not only that, it will bring overall benefits to your app such as indexing, link sharing, device sharing, and so on.</p><p>If you really have complex state that cannot be immediately handled, then you may need to resort to special strategies. This may be persisting &quot;old&quot; state to Redis/S3/Database and loading the new state on the new connections. Or you may take special care when migrating connections (for example, if you are building a game, you may want to wait for on-going sessions to finish before turning down the old server while routing new sessions to the new ones). Such cases will depend on your requirements (and they would likely exist regardless of which application stack you are using).</p>

  </body>
</html>
