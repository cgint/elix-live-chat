<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Assigns and HEEx templates - Phoenix LiveView v1.1.2</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Assigns and HEEx templates</h1>
<p>All of the data in a LiveView is stored in the socket, which is a server
side struct called <a href="Phoenix.LiveView.Socket.xhtml"><code class="inline">Phoenix.LiveView.Socket</code></a>. Your own data is stored
under the <code class="inline">assigns</code> key of said struct. The server data is never shared
with the client beyond what your template renders.</p><p>Phoenix template language is called HEEx (HTML+EEx). EEx is Embedded
Elixir, an Elixir string template engine. Those templates
are either files with the <code class="inline">.heex</code> extension or they are created
directly in source files via the <code class="inline">~H</code> sigil. You can learn more about
the HEEx syntax by checking the docs for <a href="Phoenix.Component.xhtml#sigil_H/2">the <code class="inline">~H</code> sigil</a>.</p><p>The <a href="Phoenix.Component.xhtml#assign/2"><code class="inline">Phoenix.Component.assign/2</code></a> and <a href="Phoenix.Component.xhtml#assign/3"><code class="inline">Phoenix.Component.assign/3</code></a>
functions help store those values. Those values can be accessed
in the LiveView as <code class="inline">socket.assigns.name</code> but they are accessed
inside HEEx templates as <code class="inline">@name</code>.</p><p>In this section, we are going to cover how LiveView minimizes
the payload over the wire by understanding the interplay between
assigns and templates.</p><h2 id="change-tracking">Change tracking</h2><p>When you first render a <code class="inline">.heex</code> template, it will send all of the
static and dynamic parts of the template to the client. Imagine the
following template:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="p" data-group-id="7587224750-1">{</span><span class="n">expand_title</span><span class="p" data-group-id="7587224750-ex-1">(</span><span class="na">@title</span><span class="p" data-group-id="7587224750-ex-1">)</span><span class="p" data-group-id="7587224750-1">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span></code></pre><p>It has two static parts, <code class="inline">&lt;h1&gt;</code> and <code class="inline">&lt;/h1&gt;</code> and one dynamic part
made of <code class="inline">expand_title(@title)</code>. Further rendering of this template
won't resend the static parts and it will only resend the dynamic
part if it changes.</p><p>The tracking of changes is done via assigns. If the <code class="inline">@title</code> assign
changes, then LiveView will execute the dynamic parts of the template,
<code class="inline">expand_title(@title)</code>, and send the new content. If <code class="inline">@title</code> is the same,
nothing is executed and nothing is sent.</p><p>Change tracking also works when accessing map/struct fields.
Take this template:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">id</span><span class="p">=</span><span class="p" data-group-id="4187143229-1">{</span><span class="s">&quot;user_</span><span class="si" data-group-id="4187143229-ex-1">#{</span><span class="na">@user</span><span class="o">.</span><span class="n">id</span><span class="si" data-group-id="4187143229-ex-1">}</span><span class="s">&quot;</span><span class="p" data-group-id="4187143229-1">}</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p" data-group-id="4187143229-2">{</span><span class="na">@user</span><span class="o">.</span><span class="n">name</span><span class="p" data-group-id="4187143229-2">}</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span></code></pre><p>If the <code class="inline">@user.name</code> changes but <code class="inline">@user.id</code> doesn't, then LiveView
will re-render only <code class="inline">@user.name</code> and it will not execute or resend <code class="inline">@user.id</code>
at all.</p><p>The change tracking also works when rendering other templates as
long as they are also <code class="inline">.heex</code> templates:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="9466752688-1">{</span><span class="n">render</span><span class="p" data-group-id="9466752688-ex-1">(</span><span class="s">&quot;child_template.html&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">assigns</span><span class="p" data-group-id="9466752688-ex-1">)</span><span class="p" data-group-id="9466752688-1">}</span></code></pre><p>Or when using function components:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nf">.show_name</span><span class="w"> </span><span class="na">name</span><span class="p">=</span><span class="p" data-group-id="4539887573-1">{</span><span class="na">@user</span><span class="o">.</span><span class="n">name</span><span class="p" data-group-id="4539887573-1">}</span><span class="w"> </span><span class="p">/&gt;</span></code></pre><p>The assign tracking feature also implies that you MUST avoid performing
direct operations in the template. For example, if you perform a database
query in your template:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="5860123848-1">&lt;%=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nc">Repo</span><span class="o">.</span><span class="n">all</span><span class="p" data-group-id="5860123848-ex-1">(</span><span class="nc">User</span><span class="p" data-group-id="5860123848-ex-1">)</span><span class="w"> </span><span class="k" data-group-id="5860123848-ex-2">do</span><span class="w"> </span><span class="p" data-group-id="5860123848-1">%&gt;</span><span class="w">
</span><span class="w">  </span><span class="p" data-group-id="5860123848-2">{</span><span class="n">user</span><span class="o">.</span><span class="n">name</span><span class="p" data-group-id="5860123848-2">}</span><span class="w">
</span><span class="p" data-group-id="5860123848-3">&lt;%</span><span class="w"> </span><span class="k" data-group-id="5860123848-ex-2">end</span><span class="w"> </span><span class="p" data-group-id="5860123848-3">%&gt;</span></code></pre><p>Then Phoenix will never re-render the section above, even if the number of
users in the database changes. Instead, you need to store the users as
assigns in your LiveView before it renders the template:</p><pre><code class="makeup elixir" translate="no"><span class="n">assign</span><span class="p" data-group-id="8694427714-1">(</span><span class="n">socket</span><span class="p">,</span><span class="w"> </span><span class="ss">:users</span><span class="p">,</span><span class="w"> </span><span class="nc">Repo</span><span class="o">.</span><span class="n">all</span><span class="p" data-group-id="8694427714-2">(</span><span class="nc">User</span><span class="p" data-group-id="8694427714-2">)</span><span class="p" data-group-id="8694427714-1">)</span></code></pre><p>Generally speaking, <strong>data loading should never happen inside the template</strong>,
regardless if you are using LiveView or not. The difference is that LiveView
enforces this best practice.</p><h2 id="common-pitfalls">Common pitfalls</h2><p>There are some common pitfalls to keep in mind when using the <code class="inline">~H</code> sigil
or <code class="inline">.heex</code> templates inside LiveViews.</p><h3 id="variables">Variables</h3><p>Due to the scope of variables, LiveView has to disable change tracking
whenever variables are used in the template, with the exception of
variables introduced by Elixir block constructs such as <code class="inline">case</code>,
<code class="inline">for</code>, <code class="inline">if</code>, and others. Therefore, you <strong>must avoid</strong> code like
this in your HEEx templates:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="1801553714-1">&lt;%</span><span class="w"> </span><span class="n">some_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="na">@x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="na">@y</span><span class="w"> </span><span class="p" data-group-id="1801553714-1">%&gt;</span><span class="w">
</span><span class="p" data-group-id="1801553714-2">{</span><span class="n">some_var</span><span class="p" data-group-id="1801553714-2">}</span></code></pre><p>Instead, use a function:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="1432424113-1">{</span><span class="n">sum</span><span class="p" data-group-id="1432424113-ex-1">(</span><span class="na">@x</span><span class="p">,</span><span class="w"> </span><span class="na">@y</span><span class="p" data-group-id="1432424113-ex-1">)</span><span class="p" data-group-id="1432424113-1">}</span></code></pre><p>Similarly, <strong>do not</strong> define variables at the top of your <code class="inline">render</code> function
for LiveViews or LiveComponents. Since LiveView cannot track <code class="inline">sum</code> or <code class="inline">title</code>,
if either value changes, both must be re-rendered by LiveView.</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">render</span><span class="p" data-group-id="0435949170-1">(</span><span class="n">assigns</span><span class="p" data-group-id="0435949170-1">)</span><span class="w"> </span><span class="k" data-group-id="0435949170-2">do</span><span class="w">
  </span><span class="n">sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assigns</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">assigns</span><span class="o">.</span><span class="n">y</span><span class="w">
  </span><span class="n">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assigns</span><span class="o">.</span><span class="n">title</span><span class="w">

  </span><span class="sx">~H&quot;&quot;&quot;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="p" data-group-id="1963171585-1">{</span><span class="n">title</span><span class="p" data-group-id="1963171585-1">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="p" data-group-id="1963171585-2">{</span><span class="n">sum</span><span class="p" data-group-id="1963171585-2">}</span><span class="w">
</span><span class="w">  </span><span class="sx">&quot;&quot;&quot;</span><span class="w">
</span><span class="k" data-group-id="0435949170-2">end</span></code></pre><p>Instead use the <code class="inline">assign/2</code>, <code class="inline">assign/3</code>, <code class="inline">assign_new/3</code>, and <code class="inline">update/3</code>
functions to compute it. Any assign defined or updated this way will be marked as
changed, while other assigns like <code class="inline">@title</code> will still be tracked by LiveView.</p><pre><code class="makeup elixir" translate="no"><span class="n">assign</span><span class="p" data-group-id="2794036057-1">(</span><span class="n">assigns</span><span class="p">,</span><span class="w"> </span><span class="ss">sum</span><span class="p">:</span><span class="w"> </span><span class="n">assigns</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">assigns</span><span class="o">.</span><span class="n">y</span><span class="p" data-group-id="2794036057-1">)</span></code></pre><p>The same functions can be used inside function components too:</p><pre><code class="makeup elixir" translate="no"><span class="n">attr</span><span class="w"> </span><span class="ss">:x</span><span class="p">,</span><span class="w"> </span><span class="ss">:integer</span><span class="p">,</span><span class="w"> </span><span class="ss">required</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="n">attr</span><span class="w"> </span><span class="ss">:y</span><span class="p">,</span><span class="w"> </span><span class="ss">:integer</span><span class="p">,</span><span class="w"> </span><span class="ss">required</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="n">attr</span><span class="w"> </span><span class="ss">:title</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="ss">required</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">sum_component</span><span class="p" data-group-id="7262492320-1">(</span><span class="n">assigns</span><span class="p" data-group-id="7262492320-1">)</span><span class="w"> </span><span class="k" data-group-id="7262492320-2">do</span><span class="w">
  </span><span class="n">assigns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">assign</span><span class="p" data-group-id="7262492320-3">(</span><span class="n">assigns</span><span class="p">,</span><span class="w"> </span><span class="ss">sum</span><span class="p">:</span><span class="w"> </span><span class="n">assigns</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">assigns</span><span class="o">.</span><span class="n">y</span><span class="p" data-group-id="7262492320-3">)</span><span class="w">

  </span><span class="sx">~H&quot;&quot;&quot;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="p" data-group-id="6872971841-1">{</span><span class="na">@title</span><span class="p" data-group-id="6872971841-1">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span><span class="w">
</span><span class="w">
</span><span class="w">  </span><span class="p" data-group-id="6872971841-2">{</span><span class="na">@sum</span><span class="p" data-group-id="6872971841-2">}</span><span class="w">
</span><span class="w">  </span><span class="sx">&quot;&quot;&quot;</span><span class="w">
</span><span class="k" data-group-id="7262492320-2">end</span></code></pre><p>Generally speaking, avoid accessing variables inside <code class="inline">HEEx</code> templates, as code that
access variables is always executed on every render. The exception are variables
introduced by Elixir's block constructs, such as <code class="inline">if</code> and <code class="inline">for</code> comprehensions.
For example, accessing the <code class="inline">post</code> variable defined by the comprehension below
works as expected:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="8307058471-1">&lt;%=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">post</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="na">@posts</span><span class="w"> </span><span class="k" data-group-id="8307058471-ex-1">do</span><span class="w"> </span><span class="p" data-group-id="8307058471-1">%&gt;</span><span class="w">
</span><span class="n">  ...
</span><span class="p" data-group-id="8307058471-2">&lt;%</span><span class="w"> </span><span class="k" data-group-id="8307058471-ex-1">end</span><span class="w"> </span><span class="p" data-group-id="8307058471-2">%&gt;</span></code></pre><h3 id="the-assigns-variable">The <code class="inline">assigns</code> variable</h3><p>When talking about variables, it is also worth discussing the <code class="inline">assigns</code>
special variable. Every time you use the <code class="inline">~H</code> sigil, you must define an
<code class="inline">assigns</code> variable, which is also available on every <code class="inline">.heex</code> template.
However, we must avoid accessing this variable directly inside templates
and instead use <code class="inline">@</code> for accessing specific keys. This also applies to
function components. Let's see some examples.</p><p>Sometimes you might want to pass all assigns from one function component to
another. For example, imagine you have a complex <code class="inline">card</code> component with
header, content and footer section. You might refactor your component
into three smaller components internally:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">card</span><span class="p" data-group-id="8984090086-1">(</span><span class="n">assigns</span><span class="p" data-group-id="8984090086-1">)</span><span class="w"> </span><span class="k" data-group-id="8984090086-2">do</span><span class="w">
  </span><span class="sx">~H&quot;&quot;&quot;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">class</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">c</span><span class="s2">a</span><span class="s2">r</span><span class="s2">d</span><span class="p">&quot;</span><span class="p">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nf">.card_header</span><span class="w"> </span><span class="p" data-group-id="7381879739-1">{</span><span class="n">assigns</span><span class="p" data-group-id="7381879739-1">}</span><span class="w"> </span><span class="p">/&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nf">.card_body</span><span class="w"> </span><span class="p" data-group-id="7381879739-2">{</span><span class="n">assigns</span><span class="p" data-group-id="7381879739-2">}</span><span class="w"> </span><span class="p">/&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nf">.card_footer</span><span class="w"> </span><span class="p" data-group-id="7381879739-3">{</span><span class="n">assigns</span><span class="p" data-group-id="7381879739-3">}</span><span class="w"> </span><span class="p">/&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="sx">&quot;&quot;&quot;</span><span class="w">
</span><span class="k" data-group-id="8984090086-2">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">card_header</span><span class="p" data-group-id="8984090086-3">(</span><span class="n">assigns</span><span class="p" data-group-id="8984090086-3">)</span><span class="w"> </span><span class="k" data-group-id="8984090086-4">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="8984090086-4">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">card_body</span><span class="p" data-group-id="8984090086-5">(</span><span class="n">assigns</span><span class="p" data-group-id="8984090086-5">)</span><span class="w"> </span><span class="k" data-group-id="8984090086-6">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="8984090086-6">end</span><span class="w">

</span><span class="kd">defp</span><span class="w"> </span><span class="nf">card_footer</span><span class="p" data-group-id="8984090086-7">(</span><span class="n">assigns</span><span class="p" data-group-id="8984090086-7">)</span><span class="w"> </span><span class="k" data-group-id="8984090086-8">do</span><span class="w">
  </span><span class="n">...</span><span class="w">
</span><span class="k" data-group-id="8984090086-8">end</span></code></pre><p>Because of the way function components handle attributes, the above code will
not perform change tracking and it will always re-render all three components
on every change.</p><p>Generally, you should avoid passing all assigns and instead be explicit about
which assigns the child components need:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">card</span><span class="p" data-group-id="4820197610-1">(</span><span class="n">assigns</span><span class="p" data-group-id="4820197610-1">)</span><span class="w"> </span><span class="k" data-group-id="4820197610-2">do</span><span class="w">
  </span><span class="sx">~H&quot;&quot;&quot;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">class</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">c</span><span class="s2">a</span><span class="s2">r</span><span class="s2">d</span><span class="p">&quot;</span><span class="p">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nf">.card_header</span><span class="w"> </span><span class="na">title</span><span class="p">=</span><span class="p" data-group-id="4513480802-1">{</span><span class="na">@title</span><span class="p" data-group-id="4513480802-1">}</span><span class="w"> </span><span class="na">class</span><span class="p">=</span><span class="p" data-group-id="4513480802-2">{</span><span class="na">@title_class</span><span class="p" data-group-id="4513480802-2">}</span><span class="w"> </span><span class="p">/&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nf">.card_body</span><span class="p">&gt;</span><span class="w">
</span><span class="w">      </span><span class="p" data-group-id="4513480802-3">{</span><span class="n">render_slot</span><span class="p" data-group-id="4820197610-3">(</span><span class="na">@inner_block</span><span class="p" data-group-id="4820197610-3">)</span><span class="p" data-group-id="4513480802-3">}</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;/</span><span class="nf">.card_body</span><span class="p">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nf">.card_footer</span><span class="w"> </span><span class="na">on_close</span><span class="p">=</span><span class="p" data-group-id="4513480802-4">{</span><span class="na">@on_close</span><span class="p" data-group-id="4513480802-4">}</span><span class="w"> </span><span class="p">/&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="sx">&quot;&quot;&quot;</span><span class="w">
</span><span class="k" data-group-id="4820197610-2">end</span></code></pre><p>If you really need to pass all assigns you should instead use the regular
function call syntax. This is the only case where accessing <code class="inline">assigns</code> inside
templates is acceptable:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">card</span><span class="p" data-group-id="9887716247-1">(</span><span class="n">assigns</span><span class="p" data-group-id="9887716247-1">)</span><span class="w"> </span><span class="k" data-group-id="9887716247-2">do</span><span class="w">
  </span><span class="sx">~H&quot;&quot;&quot;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">class</span><span class="p">=</span><span class="p">&quot;</span><span class="s2">c</span><span class="s2">a</span><span class="s2">r</span><span class="s2">d</span><span class="p">&quot;</span><span class="p">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p" data-group-id="1299532730-1">{</span><span class="n">card_header</span><span class="p" data-group-id="9887716247-3">(</span><span class="n">assigns</span><span class="p" data-group-id="9887716247-3">)</span><span class="p" data-group-id="1299532730-1">}</span><span class="w">
</span><span class="w">    </span><span class="p" data-group-id="1299532730-2">{</span><span class="n">card_body</span><span class="p" data-group-id="9887716247-4">(</span><span class="n">assigns</span><span class="p" data-group-id="9887716247-4">)</span><span class="p" data-group-id="1299532730-2">}</span><span class="w">
</span><span class="w">    </span><span class="p" data-group-id="1299532730-3">{</span><span class="n">card_footer</span><span class="p" data-group-id="9887716247-5">(</span><span class="n">assigns</span><span class="p" data-group-id="9887716247-5">)</span><span class="p" data-group-id="1299532730-3">}</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="sx">&quot;&quot;&quot;</span><span class="w">
</span><span class="k" data-group-id="9887716247-2">end</span></code></pre><p>This ensures that the change tracking information from the parent component
is passed to each child component, only re-rendering what is necessary.
However, generally speaking, it is best to avoid passing <code class="inline">assigns</code> altogether
and instead let LiveView figure out the best way to track changes.</p><h3 id="comprehensions">Comprehensions</h3><p>HEEx supports comprehensions in templates, which is a way to traverse lists
and collections. For example:</p><pre><code class="makeup heex" translate="no"><span class="p" data-group-id="3758905649-1">&lt;%=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">post</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="na">@posts</span><span class="w"> </span><span class="k" data-group-id="3758905649-ex-1">do</span><span class="w"> </span><span class="p" data-group-id="3758905649-1">%&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">section</span><span class="p">&gt;</span><span class="w">
</span><span class="w">    </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="p" data-group-id="3758905649-2">{</span><span class="n">expand_title</span><span class="p" data-group-id="3758905649-ex-2">(</span><span class="n">post</span><span class="o">.</span><span class="n">title</span><span class="p" data-group-id="3758905649-ex-2">)</span><span class="p" data-group-id="3758905649-2">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span><span class="w">
</span><span class="p" data-group-id="3758905649-3">&lt;%</span><span class="w"> </span><span class="k" data-group-id="3758905649-ex-1">end</span><span class="w"> </span><span class="p" data-group-id="3758905649-3">%&gt;</span></code></pre><p>Or using the special <code class="inline">:for</code> attribute:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">section</span><span class="w"> </span><span class="na">:for</span><span class="p">=</span><span class="p" data-group-id="0145586275-1">{</span><span class="n">post</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="na">@posts</span><span class="p" data-group-id="0145586275-1">}</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="p" data-group-id="0145586275-2">{</span><span class="n">expand_title</span><span class="p" data-group-id="0145586275-ex-1">(</span><span class="n">post</span><span class="o">.</span><span class="n">title</span><span class="p" data-group-id="0145586275-ex-1">)</span><span class="p" data-group-id="0145586275-2">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span></code></pre><p>Comprehensions in templates are optimized so the static parts of
a comprehension are only sent once, regardless of the number of items.
Furthermore, LiveView tracks changes within the collection given to the
comprehension. In the ideal case, if only a single entry in <code class="inline">@posts</code>
changes, only this entry is sent again. By default, the index is used
to track changes. This means that if an entry is appended, most items
will be considered changed and sent again. To optimize this, you can
also pass a <code class="inline">:key</code> on tags in HEEx:</p><pre><code class="makeup heex" translate="no"><span class="p">&lt;</span><span class="nt">section</span><span class="w"> </span><span class="na">:for</span><span class="p">=</span><span class="p" data-group-id="7275992412-1">{</span><span class="n">post</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="na">@posts</span><span class="p" data-group-id="7275992412-1">}</span><span class="w"> </span><span class="na">:key</span><span class="p">=</span><span class="p" data-group-id="7275992412-2">{</span><span class="n">post</span><span class="o">.</span><span class="n">id</span><span class="p" data-group-id="7275992412-2">}</span><span class="p">&gt;</span><span class="w">
</span><span class="w">  </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="p" data-group-id="7275992412-3">{</span><span class="n">expand_title</span><span class="p" data-group-id="7275992412-ex-1">(</span><span class="n">post</span><span class="o">.</span><span class="n">title</span><span class="p" data-group-id="7275992412-ex-1">)</span><span class="p" data-group-id="7275992412-3">}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span><span class="w">
</span><span class="p">&lt;/</span><span class="nt">section</span><span class="p">&gt;</span></code></pre><p>You can read more about <code class="inline">:key</code> in the <a href="Phoenix.Component.html#sigil_H/2-special-attributes">documentation for <code class="inline">sigil_H/2</code></a>.</p><p>To track changes in comprehensions, LiveView needs to perform additional
bookkeeping, which requires extra memory on the server. If memory usage is a
concern, you should also consider to use <a href="Phoenix.LiveView.xhtml#stream/4"><code class="inline">Phoenix.LiveView.stream/4</code></a>, which
allows you to manage collections without keeping them in memory.</p><h3 id="summary">Summary</h3><p>To sum up:</p><ol><li><p>Avoid defining local variables inside HEEx templates, except within Elixir's constructs</p></li><li><p>Avoid passing or accessing the <code class="inline">assigns</code> variable inside HEEx templates</p></li></ol>

  </body>
</html>
