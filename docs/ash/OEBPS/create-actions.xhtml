<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Create Actions - ash v3.5.33</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Create Actions</h1>
<p>Create actions are used to create new records in the data layer. For example:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># on a ticket resource</span><span class="w">
</span><span class="n">create</span><span class="w"> </span><span class="ss">:open</span><span class="w"> </span><span class="k" data-group-id="8735649510-1">do</span><span class="w">
  </span><span class="n">accept</span><span class="w"> </span><span class="p" data-group-id="8735649510-2">[</span><span class="ss">:title</span><span class="p" data-group-id="8735649510-2">]</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">set_attribute</span><span class="p" data-group-id="8735649510-3">(</span><span class="ss">:status</span><span class="p">,</span><span class="w"> </span><span class="ss">:open</span><span class="p" data-group-id="8735649510-3">)</span><span class="w">
</span><span class="k" data-group-id="8735649510-1">end</span></code></pre><p>Here we have a create action called <code class="inline">:open</code> that allows setting the <code class="inline">title</code>, and sets the <code class="inline">status</code> to <code class="inline">:open</code>. It could be called like so:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ticket</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Changeset</span><span class="o">.</span><span class="n">for_create</span><span class="p" data-group-id="1958464303-1">(</span><span class="ss">:open</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="1958464303-2">%{</span><span class="ss">title</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Need help!&quot;</span><span class="p" data-group-id="1958464303-2">}</span><span class="p" data-group-id="1958464303-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">create!</span><span class="p" data-group-id="1958464303-3">(</span><span class="p" data-group-id="1958464303-3">)</span></code></pre><p>For a full list of all of the available options for configuring create actions, see <a href="dsl-ash-resource.html#actions-create">the Ash.Resource.Dsl documentation</a>.</p><p>See the <a href="code-interfaces.xhtml">Code Interface guide</a> for creating an interface to call the action more elegantly, like so:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Support</span><span class="o">.</span><span class="n">open_ticket!</span><span class="p" data-group-id="5747506792-1">(</span><span class="s">&quot;Need help!&quot;</span><span class="p" data-group-id="5747506792-1">)</span></code></pre><h2 id="bulk-creates">Bulk creates</h2><p>Bulk creates take a list or stream of inputs for a given action, and batches calls to the underlying data layer.</p><p>Given our example above, you could call <code class="inline">Ash.bulk_create</code> like so:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ash</span><span class="o">.</span><span class="n">bulk_create</span><span class="p" data-group-id="4304765133-1">(</span><span class="p" data-group-id="4304765133-2">[</span><span class="p" data-group-id="4304765133-3">%{</span><span class="ss">title</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Foo&quot;</span><span class="p" data-group-id="4304765133-3">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4304765133-4">%{</span><span class="ss">title</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Bar&quot;</span><span class="p" data-group-id="4304765133-4">}</span><span class="p" data-group-id="4304765133-2">]</span><span class="p">,</span><span class="w"> </span><span class="nc">Ticket</span><span class="p">,</span><span class="w"> </span><span class="ss">:open</span><span class="p" data-group-id="4304765133-1">)</span></code></pre><section role="note" class="admonition warning"><h3 id="check-the-docs" class="admonition-title warning">Check the docs!</h3><p>Make sure to thoroughly read and understand the documentation in <a href="Ash.xhtml#bulk_create/4"><code class="inline">Ash.bulk_create/4</code></a> before using. Read each option and note the default values. By default, bulk creates don't return records or errors, and don't emit notifications.</p></section><h2 id="performance">Performance</h2><p>Generally speaking, all regular Ash create actions are compatible (or can be made to be compatible) with bulk create actions. However, there are some important considerations.</p><ul><li><p><a href="Ash.Resource.Change.xhtml"><code class="inline">Ash.Resource.Change</code></a> modules can be optimized for bulk actions by implementing <code class="inline">batch_change/3</code>, <code class="inline">before_batch/3</code> and <code class="inline">after_batch/3</code>. If you implement <code class="inline">batch_change/3</code>, the <code class="inline">change</code> function will no longer be called, and you should swap any behavior implemented with <code class="inline">before_action</code> and <code class="inline">after_action</code> hooks to logic in the <code class="inline">before_batch</code> and <code class="inline">after_batch</code> callbacks.</p></li><li><p>Actions that reference arguments in changes, i.e <code class="inline">change set_attribute(:attr, ^arg(:arg))</code> will prevent us from using the <code class="inline">batch_change/3</code> behavior. This is usually not a problem, for instance that change is lightweight and would not benefit from being optimized with <code class="inline">batch_change/3</code></p></li><li><p>If your action uses <code class="inline">after_action</code> hooks, or has <code class="inline">after_batch/3</code> logic defined for any of its changes, then we <em>must</em> ask the data layer to return the records it inserted. Again, this is not generally a problem because we throw away the results of each batch by default. If you are using <code class="inline">return_records?: true</code> then you are already requesting all of the results anyway.</p></li></ul><h2 id="returning-a-stream">Returning a Stream</h2><p>Returning a stream allows you to work with a bulk action as an Elixir Stream. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">input_stream</span><span class="p" data-group-id="1089039874-1">(</span><span class="p" data-group-id="1089039874-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">bulk_create</span><span class="p" data-group-id="1089039874-2">(</span><span class="nc">Resource</span><span class="p">,</span><span class="w"> </span><span class="ss">:action</span><span class="p">,</span><span class="w"> </span><span class="ss">return_stream?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">return_records?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="1089039874-2">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Stream</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="1089039874-3">(</span><span class="k" data-group-id="1089039874-4">fn</span><span class="w"> </span><span class="p" data-group-id="1089039874-5">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="1089039874-5">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="c1"># process results</span><span class="w">
  </span><span class="p" data-group-id="1089039874-6">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p" data-group-id="1089039874-6">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="c1"># process errors</span><span class="w">
</span><span class="k" data-group-id="1089039874-4">end</span><span class="p" data-group-id="1089039874-3">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p" data-group-id="1089039874-7">(</span><span class="p" data-group-id="1089039874-8">%{</span><span class="p" data-group-id="1089039874-8">}</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="1089039874-9">fn</span><span class="w"> </span><span class="p" data-group-id="1089039874-10">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p" data-group-id="1089039874-10">}</span><span class="p">,</span><span class="w"> </span><span class="n">acc</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
   </span><span class="c1"># process results</span><span class="w">
   </span><span class="p" data-group-id="1089039874-11">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p" data-group-id="1089039874-11">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
   </span><span class="c1"># process errors</span><span class="w">
</span><span class="k" data-group-id="1089039874-9">end</span><span class="p" data-group-id="1089039874-7">)</span></code></pre><section role="note" class="admonition warning"><h3 id="be-careful-with-streams" class="admonition-title warning">Be careful with streams</h3><p>Because streams are lazily evaluated, if you were to do something like this:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="9318529467-1">[</span><span class="n">input1</span><span class="p">,</span><span class="w"> </span><span class="n">input2</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="9318529467-1">]</span><span class="w"> </span><span class="c1"># has 300 things in it</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">bulk_create</span><span class="p" data-group-id="9318529467-2">(</span><span class="w">
  </span><span class="nc">Resource</span><span class="p">,</span><span class="w">
  </span><span class="ss">:action</span><span class="p">,</span><span class="w">
  </span><span class="ss">return_stream?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">
  </span><span class="ss">return_records?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w">
  </span><span class="ss">batch_size</span><span class="p">:</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="c1">#  default is 100</span><span class="w">
</span><span class="p" data-group-id="9318529467-2">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">take</span><span class="p" data-group-id="9318529467-3">(</span><span class="mi">150</span><span class="p" data-group-id="9318529467-3">)</span><span class="w"> </span><span class="c1"># stream has 300, but we only take 150</span></code></pre><p>What would happen is that we would insert 200 records. The stream would end after we process the first two batches of 100. Be sure you aren't using things like <code class="inline">Stream.take</code> or <code class="inline">Enum.take</code> to limit the amount of things pulled from the stream, unless you actually want to limit the number of records created.</p></section><h2 id="upserts">Upserts</h2><p>Upserting is the process of &quot;creating or updating&quot; a record, modeled with a single simple create. Both bulk creates and regular creates support upserts. Upserts can be declared in the action, like so:</p><pre><code class="makeup elixir" translate="no"><span class="n">create</span><span class="w"> </span><span class="ss">:create_user</span><span class="w"> </span><span class="k" data-group-id="4733834213-1">do</span><span class="w">
  </span><span class="n">accept</span><span class="w"> </span><span class="p" data-group-id="4733834213-2">[</span><span class="ss">:email</span><span class="p" data-group-id="4733834213-2">]</span><span class="w">
  </span><span class="n">upsert?</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="n">upsert_identity</span><span class="w"> </span><span class="ss">:unique_email</span><span class="w">
</span><span class="k" data-group-id="4733834213-1">end</span></code></pre><p>Or they can be done with options when calling the create action.</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ash</span><span class="o">.</span><span class="n">create!</span><span class="p" data-group-id="6672274012-1">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="ss">upsert?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">upsert_identity</span><span class="p">:</span><span class="w"> </span><span class="ss">:unique_email</span><span class="p" data-group-id="6672274012-1">)</span></code></pre><section role="note" class="admonition warning"><h3 id="upserts-do-not-use-an-update-action" class="admonition-title warning">Upserts do not use an update action</h3><p>While an upsert is conceptually a &quot;create or update&quot; operation, it does not result in an update action being called.
The data layer contains the upsert implementation. This means that if you have things like global changes that are only run on update,
they will not be run on upserts that result in an update. Additionally, notifications for updates will not be emitted from upserts.
Most importantly, there are no <em>read</em> or <em>update</em> policies applied! You must take care that an upsert can only target records that
the user has permission to update.</p></section><h4>Targeting Upserts</h4><p>Lets imagine that you want a user to upsert an article by its slug, but only if it is their article:</p><p>If your action looked like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">create</span><span class="w"> </span><span class="ss">:upsert_article_by_slug</span><span class="w"> </span><span class="k" data-group-id="0928803636-1">do</span><span class="w">
  </span><span class="n">upsert?</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="n">accept</span><span class="w"> </span><span class="p" data-group-id="0928803636-2">[</span><span class="ss">:slug</span><span class="p">,</span><span class="w"> </span><span class="ss">:title</span><span class="p">,</span><span class="w"> </span><span class="ss">:body</span><span class="p" data-group-id="0928803636-2">]</span><span class="w">
  </span><span class="n">upsert_identity</span><span class="w"> </span><span class="ss">:unique_slug</span><span class="w">
</span><span class="k" data-group-id="0928803636-1">end</span></code></pre><p>And one way it could be called is like so:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Article</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Changeset</span><span class="o">.</span><span class="n">for_create</span><span class="p" data-group-id="8446310629-1">(</span><span class="w">
  </span><span class="ss">:upsert_article_by_slug</span><span class="p">,</span><span class="w"> 
  </span><span class="p" data-group-id="8446310629-2">%{</span><span class="ss">slug</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">title</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;new title&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">slug</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;new slug&quot;</span><span class="p" data-group-id="8446310629-2">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">actor</span><span class="p">:</span><span class="w"> </span><span class="n">current_user</span><span class="w">
</span><span class="p" data-group-id="8446310629-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">create!</span><span class="p" data-group-id="8446310629-3">(</span><span class="p" data-group-id="8446310629-3">)</span></code></pre><p>This would create an article, unless there is an article with a matching slug in which case it would
update the title and the body to match the provided input. Let's add the &quot;only if it is their article&quot;
functionality.</p><p>For this we use a <code class="inline">filter</code> change to further scope the upsert:</p><pre><code class="makeup elixir" translate="no"><span class="n">create</span><span class="w"> </span><span class="ss">:upsert_article_by_slug</span><span class="w"> </span><span class="k" data-group-id="8050099177-1">do</span><span class="w">
  </span><span class="n">upsert?</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="n">accept</span><span class="w"> </span><span class="p" data-group-id="8050099177-2">[</span><span class="ss">:slug</span><span class="p">,</span><span class="w"> </span><span class="ss">:title</span><span class="p">,</span><span class="w"> </span><span class="ss">:body</span><span class="p" data-group-id="8050099177-2">]</span><span class="w">
  </span><span class="n">upsert_identity</span><span class="w"> </span><span class="ss">:unique_slug</span><span class="w">
  </span><span class="n">upsert_condition</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="8050099177-3">(</span><span class="n">user_id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="8050099177-4">(</span><span class="ss">:id</span><span class="p" data-group-id="8050099177-4">)</span><span class="p" data-group-id="8050099177-3">)</span><span class="w">
</span><span class="k" data-group-id="8050099177-1">end</span></code></pre><section role="note" class="admonition info"><h3 id="what-is-actor-id" class="admonition-title info">What is <code class="inline">^actor(:id)</code> ?</h3><p>Many places in Ash that support expression support <em>templates</em>. These are ways to refer
to certain things that are commonly available, like the actor, or action argument values.</p><p>For more information, see <a href="expressions.xhtml#templates">the expressions guide</a></p></section><p>Now, when we perform this upsert, there are three possible outcomes:</p><ul><li>There is no article with that <code class="inline">slug</code>, in which case the article is created</li><li>There is an article with that <code class="inline">slug</code>, and the <code class="inline">user_id</code> matches the provided actor's <code class="inline">id</code>, so
it is updated with the new title and body.</li><li>There is an article with that <code class="inline">slug</code>, and the <code class="inline">user_id</code>  does not match the provided actor's,
<code class="inline">id</code>, in which case the action results in a <a href="Ash.Error.Changes.StaleRecord.xhtml"><code class="inline">Ash.Error.Changes.StaleRecord</code></a> error. This is
the same error that would occur if the actor attempted to update something that had changed
in some unexpected way in the database.</li></ul><section role="note" class="admonition info"><h3 id="improving-the-stale-record-error" class="admonition-title info">Improving the stale record error</h3><p>You may wish to transform this into an error message that can be displayed to the user, using
the <code class="inline">d:actions.create.error_handler</code> option. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">create</span><span class="w"> </span><span class="ss">:upsert_article_by_slug</span><span class="w"> </span><span class="k" data-group-id="9635305715-1">do</span><span class="w">
  </span><span class="n">upsert?</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="n">accept</span><span class="w"> </span><span class="p" data-group-id="9635305715-2">[</span><span class="ss">:slug</span><span class="p">,</span><span class="w"> </span><span class="ss">:title</span><span class="p">,</span><span class="w"> </span><span class="ss">:body</span><span class="p" data-group-id="9635305715-2">]</span><span class="w">
  </span><span class="n">upsert_identity</span><span class="w"> </span><span class="ss">:unique_slug</span><span class="w">
  </span><span class="n">upsert_condition</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="9635305715-3">(</span><span class="n">user_id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="9635305715-4">(</span><span class="ss">:id</span><span class="p" data-group-id="9635305715-4">)</span><span class="p" data-group-id="9635305715-3">)</span><span class="w">
  </span><span class="n">error_handler</span><span class="w"> </span><span class="k" data-group-id="9635305715-5">fn</span><span class="w"> 
    </span><span class="c">_changeset</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9635305715-6">%</span><span class="nc" data-group-id="9635305715-6">Ash.Error.Changes.StaleRecord</span><span class="p" data-group-id="9635305715-6">{</span><span class="p" data-group-id="9635305715-6">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="nc">Ash.Error.Changes.InvalidChanges</span><span class="o">.</span><span class="n">exception</span><span class="p" data-group-id="9635305715-7">(</span><span class="ss">field</span><span class="p">:</span><span class="w"> </span><span class="ss">:slug</span><span class="p">,</span><span class="w"> </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;has already been taken&quot;</span><span class="p" data-group-id="9635305715-7">)</span><span class="err">&quot;</span><span class="w">

    </span><span class="bp">_</span><span class="w"> </span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="c1"># leave other errors untouched</span><span class="w">
      </span><span class="n">other</span><span class="w">
  </span><span class="k" data-group-id="9635305715-5">end</span><span class="w">
</span><span class="k" data-group-id="9635305715-1">end</span></code></pre></section><h3 id="atomic-updates">Atomic Updates</h3><p>Upserts support atomic updates. These atomic updates <em>do not apply to the data being created</em>. They are only applied in the case of an update. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">create</span><span class="w"> </span><span class="ss">:create_game</span><span class="w"> </span><span class="k" data-group-id="8976715878-1">do</span><span class="w">
  </span><span class="n">accept</span><span class="w"> </span><span class="p" data-group-id="8976715878-2">[</span><span class="ss">:identifier</span><span class="p" data-group-id="8976715878-2">]</span><span class="w">
  </span><span class="n">upsert?</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="n">upsert_identity</span><span class="w"> </span><span class="ss">:identifier</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">set_attribute</span><span class="p" data-group-id="8976715878-3">(</span><span class="ss">:score</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="8976715878-3">)</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">atomic_update</span><span class="p" data-group-id="8976715878-4">(</span><span class="ss">:score</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="8976715878-5">(</span><span class="n">score</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="8976715878-5">)</span><span class="p" data-group-id="8976715878-4">)</span><span class="w">
</span><span class="k" data-group-id="8976715878-1">end</span></code></pre><p>This will result in creating a game with a score of 0, and if the game already exists, it will increment the score by 1.</p><p>For information on options configured in the action, see <code class="inline">d:Ash.Resource.Dsl.actions.create</code>.
For information on options when calling the action, see <a href="Ash.xhtml#create/2"><code class="inline">Ash.create/2</code></a>.</p><h2 id="what-happens-when-you-run-a-create-action">What happens when you run a create Action</h2><p>All actions are run in a transaction if the data layer supports it. You can opt out of this behavior by supplying <code class="inline">transaction?: false</code> when creating the action. When an action is being run in a transaction, all steps inside of it are serialized because transactions cannot be split across processes.</p><ul><li>Authorization is performed on the changes</li><li>A before action hook is added to set up belongs_to relationships that are managed. This means potentially creating/modifying the destination of the relationship, and then changing the <code class="inline">destination_attribute</code> of the relationship.</li><li><code class="inline">before_transaction</code> and <code class="inline">around_transaction</code> hooks are called (<a href="Ash.Changeset.xhtml#before_transaction/2"><code class="inline">Ash.Changeset.before_transaction/2</code></a>). Keep in mind, any validations that are marked as <code class="inline">before_action? true</code> (or all global validations if your action has <code class="inline">delay_global_validations? true</code>) will not have happened at this point.</li><li>A transaction is opened if the action is configured for it (by default they are) and the data layer supports transactions</li><li><code class="inline">before_action</code> hooks are performed in order</li><li>The main action is sent to the data layer</li><li><code class="inline">after_action</code> hooks are performed in order</li><li>Non-belongs-to relationships are managed, creating/updating/destroying related records.</li><li>The transaction is closed, if one was opened</li><li><code class="inline">after_transaction</code> hooks are invoked with the result of the transaction (even if it was an error)</li></ul>

  </body>
</html>
