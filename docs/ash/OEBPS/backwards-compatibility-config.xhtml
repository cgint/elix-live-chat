<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Backwards Compatibility Config - ash v3.5.33</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Backwards Compatibility Config</h1>
<p>All of these configurations are potentially breaking changes when applied
to your application. However, we <em>highly</em> encourage setting as many of
them as possible. In 4.0, some will be removed entirely, and any that remain
will have their defaults changed to the new value.</p><p>The ash installer automatically sets all of these.</p><h2 id="allow_forbidden_field_for_relationships_by_default">allow_forbidden_field_for_relationships_by_default?</h2><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">allow_forbidden_field_for_relationships_by_default?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span></code></pre><h3 id="old-behavior">Old Behavior</h3><p>Loaded relationships that produced a <code class="inline">Forbidden</code> error would fail the entire
request. i.e in <code class="inline">Ash.load(post, [:comments, :author])</code>, if <code class="inline">author</code> returned
a <code class="inline">Forbidden</code> error, the entire request would fail with a forbidden error.</p><h3 id="new-behavior">New Behavior</h3><p>Now the relationships that produced a forbidden error are instead populated
with <code class="inline">%Ash.ForbiddenField{}</code>.</p><h2 id="include_embedded_source_by_default">include_embedded_source_by_default?</h2><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">include_embedded_source_by_default?</span><span class="p">:</span><span class="w"> </span><span class="no">false</span></code></pre><h3 id="old-behavior-1">Old Behavior</h3><p>When working with embedded types, the <code class="inline">__source__</code> constraint is populated with
the original changeset. This can be very costly in terms of memory when working with
large sets of embedded resources.</p><h3 id="new-behavior-1">New Behavior</h3><p>Now, the source is only included when you say <code class="inline">constraints: [include_source?: true]</code> on
the embedded resource's usage.</p><h2 id="show_keysets_for_all_actions">show_keysets_for_all_actions?</h2><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">show_keysets_for_all_actions?</span><span class="p">:</span><span class="w"> </span><span class="no">false</span></code></pre><h3 id="old-behavior-2">Old Behavior</h3><p>For all actions, the records would be returned with <code class="inline">__metadata__.keyset</code> populated
with a keyset computed for the <code class="inline">sort</code> that was used to produce those records. This
is expensive as it requires loading all things that are used by the sort.</p><h3 id="new-behavior-2">New Behavior</h3><p>Only when actually performing keyset pagination will the <code class="inline">__metadata__.keyset</code> be
computed.</p><h2 id="default_page_type">default_page_type</h2><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">default_page_type</span><span class="p">:</span><span class="w"> </span><span class="ss">:keyset</span></code></pre><h3 id="old-behavior-3">Old Behavior</h3><p>When an action supports both <code class="inline">offset</code> and <code class="inline">keyset</code> pagination, and a page is requested
with only <code class="inline">limit</code> set (i.e., <code class="inline">page: [limit: 10]</code>), Ash defaulted to offset pagination
and returned an <code class="inline">%Ash.Page.Offset{}</code>.</p><h3 id="new-behavior-3">New Behavior</h3><p>With the current default configuration, Ash will now return an <code class="inline">%Ash.Page.Keyset{}</code> when the pagination
type is ambiguous (only <code class="inline">limit</code> is provided).</p><p>For detailed pagination behavior documentation, see the <a href="pagination.xhtml#default-pagination-behavior-when-both-types-are-supported">pagination guide</a>.</p><h2 id="policies-no_filter_static_forbidden_reads">policies.no_filter_static_forbidden_reads?</h2><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">policies</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4352107181-1">[</span><span class="ss">no_filter_static_forbidden_reads?</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="4352107181-1">]</span></code></pre><h3 id="old-behavior-4">Old Behavior</h3><p>On read action policies, we can often tell statically that they cannot pass, for example:</p><pre><code class="makeup elixir" translate="no"><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="9729926045-1">(</span><span class="ss">:read</span><span class="p" data-group-id="9729926045-1">)</span><span class="w"> </span><span class="k" data-group-id="9729926045-2">do</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">actor_attribute_equals</span><span class="p" data-group-id="9729926045-3">(</span><span class="ss">:active</span><span class="p">,</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9729926045-3">)</span><span class="w">
</span><span class="k" data-group-id="9729926045-2">end</span></code></pre><p>In these cases, you would get an <a href="Ash.Error.Forbidden.xhtml"><code class="inline">Ash.Error.Forbidden</code></a>, despite the fact that the
default <code class="inline">access_type</code> for a policy is <code class="inline">:filter</code>. If you instead had:</p><pre><code class="makeup elixir" translate="no"><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="5532140229-1">(</span><span class="ss">:read</span><span class="p" data-group-id="5532140229-1">)</span><span class="w"> </span><span class="k" data-group-id="5532140229-2">do</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="5532140229-3">(</span><span class="n">private</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="5532140229-3">)</span><span class="w">
</span><span class="k" data-group-id="5532140229-2">end</span></code></pre><p>You would get a filter. This made it difficult to predict when you would get a forbidden
error and when the query results would  be filtered.</p><h3 id="new-behavior-4">New Behavior</h3><p>Now, we always filter the query even if we know statically that the request would be
forbidden. For example the following policy:</p><pre><code class="makeup elixir" translate="no"><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="7765343087-1">(</span><span class="ss">:read</span><span class="p" data-group-id="7765343087-1">)</span><span class="w"> </span><span class="k" data-group-id="7765343087-2">do</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">actor_attribute_equals</span><span class="p" data-group-id="7765343087-3">(</span><span class="ss">:active</span><span class="p">,</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="7765343087-3">)</span><span class="w">
</span><span class="k" data-group-id="7765343087-2">end</span></code></pre><p>would yield <code class="inline">filter: false</code>. This makes the behavior consistent and predictable.
You can always annotate that a given policy should result in a forbidden error
by setting <code class="inline">access_type :strict</code> in the policy.</p><h2 id="keep_read_action_loads_when_loading">keep_read_action_loads_when_loading?</h2><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">keep_read_action_loads_when_loading?</span><span class="p">:</span><span class="w"> </span><span class="no">false</span></code></pre><h3 id="old-behavior-5">Old Behavior</h3><p>If you had an action with a preparation, or a global preparation that loaded data, i.e</p><pre><code class="makeup elixir" translate="no"><span class="n">prepare</span><span class="w"> </span><span class="n">build</span><span class="p" data-group-id="0702323770-1">(</span><span class="ss">load</span><span class="p">:</span><span class="w"> </span><span class="ss">:comments</span><span class="p" data-group-id="0702323770-1">)</span></code></pre><p>this wold be applied when using <code class="inline">Ash.load</code>, because we build a query for the primary
read action as a basis for loading data. This could be expensive because now you are always
loading <code class="inline">:comments</code> even if you only intended to load something else, and could also be
unpredictable because it could &quot;overwrite&quot; the already loaded <code class="inline">comments</code> on the data you
passed in.</p><h3 id="new-behavior-5">New Behavior</h3><p>When using <code class="inline">Ash.load</code> <em>only</em> the explicitly provided load statement is applied.</p><h2 id="default_actions_require_atomic">default_actions_require_atomic?</h2><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">default_actions_require_atomic?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span></code></pre><h3 id="old-behavior-6">Old Behavior</h3><p>When building actions like so: <code class="inline">defaults [:read, create: :*, update: :*]</code> the default
action is generated with <code class="inline">require_atomic? false</code>. This could make it difficult to spot
actions that cannot safely be done asynchronously.</p><h3 id="new-behavior-6">New Behavior</h3><p>The default generated actions are generated with <code class="inline">require_atomic? true</code></p><h2 id="read_action_after_action_hooks_in_order">read_action_after_action_hooks_in_order?</h2><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">read_action_after_action_hooks_in_order?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span></code></pre><h3 id="old-behavior-7">Old Behavior</h3><p>In 3.0, we modified hooks on changesets to always be added in order instead of in
reverse order. This was missed for <a href="Ash.Query.xhtml"><code class="inline">Ash.Query</code></a>. Meaning if you had something like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">read</span><span class="w"> </span><span class="ss">:read</span><span class="w"> </span><span class="k" data-group-id="1118623068-1">do</span><span class="w">
  </span><span class="n">prepare</span><span class="w"> </span><span class="k" data-group-id="1118623068-2">fn</span><span class="w"> </span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">after_action</span><span class="p" data-group-id="1118623068-3">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="1118623068-4">fn</span><span class="w"> </span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="1118623068-5">(</span><span class="s">&quot;hook 1&quot;</span><span class="p" data-group-id="1118623068-5">)</span><span class="w">
      </span><span class="p" data-group-id="1118623068-6">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">results</span><span class="p" data-group-id="1118623068-6">}</span><span class="w">
    </span><span class="k" data-group-id="1118623068-4">end</span><span class="p" data-group-id="1118623068-3">)</span><span class="w">
  </span><span class="k" data-group-id="1118623068-2">end</span><span class="w">

  </span><span class="n">prepare</span><span class="w"> </span><span class="k" data-group-id="1118623068-7">fn</span><span class="w"> </span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">after_action</span><span class="p" data-group-id="1118623068-8">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="1118623068-9">fn</span><span class="w"> </span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="nc">IO</span><span class="o">.</span><span class="n">puts</span><span class="p" data-group-id="1118623068-10">(</span><span class="s">&quot;hook 2&quot;</span><span class="p" data-group-id="1118623068-10">)</span><span class="w">
      </span><span class="p" data-group-id="1118623068-11">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">results</span><span class="p" data-group-id="1118623068-11">}</span><span class="w">
    </span><span class="k" data-group-id="1118623068-9">end</span><span class="p" data-group-id="1118623068-8">)</span><span class="w">
  </span><span class="k" data-group-id="1118623068-7">end</span><span class="w">
</span><span class="k" data-group-id="1118623068-1">end</span></code></pre><p>running that action would print <code class="inline">hook 2</code> before <code class="inline">hook 1</code>.</p><h3 id="new-behavior-7">New Behavior</h3><p>Read action hooks are now run in the order they were added</p><h2 id="bulk_actions_default_to_errors">bulk_actions_default_to_errors?</h2><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">bulk_actions_default_to_errors?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span></code></pre><h3 id="old-behavior-8">Old Behavior</h3><p>Bulk action options defaulted to <code class="inline">return_errors?: false</code>, and <code class="inline">stop_on_error?: false</code>,
which was often a footgun for users unfamiliar to bulk actions, wondering &quot;why did I not
get an error even though nothing was created?&quot;</p><h3 id="new-behavior-8">New Behavior</h3><p>Now, <code class="inline">return_errors?</code> and <code class="inline">stop_on_error?</code> default to <code class="inline">true</code></p>

  </body>
</html>
