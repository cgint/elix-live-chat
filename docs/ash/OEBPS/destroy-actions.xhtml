<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Destroy Actions - ash v3.5.33</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Destroy Actions</h1>
<p>Destroy actions are comparatively simple. They expect to remove a given record, and by default return <code class="inline">:ok</code> in the successful case.</p><p>Most destroy actions are one-liners, for example:</p><pre><code class="makeup elixir" translate="no"><span class="n">destroy</span><span class="w"> </span><span class="ss">:destroy</span><span class="w">
</span><span class="c1"># Can be added with the defaults</span><span class="w">
</span><span class="n">defaults</span><span class="w"> </span><span class="p" data-group-id="5319051001-1">[</span><span class="ss">:read</span><span class="p">,</span><span class="w"> </span><span class="ss">:destroy</span><span class="p" data-group-id="5319051001-1">]</span></code></pre><h2 id="soft-destroy">Soft Destroy</h2><p>You can mark a destroy action as <code class="inline">soft? true</code>, in which case it is handled by the <a href="update-actions.xhtml"><code class="inline">update</code> action</a> logic.</p><p>For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">destroy</span><span class="w"> </span><span class="ss">:archive</span><span class="w"> </span><span class="k" data-group-id="7576198346-1">do</span><span class="w">
  </span><span class="n">soft?</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">set_attribute</span><span class="p" data-group-id="7576198346-2">(</span><span class="ss">:archived_at</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">DateTime</span><span class="o">.</span><span class="n">utc_now</span><span class="o">/</span><span class="mi">0</span><span class="p" data-group-id="7576198346-2">)</span><span class="w">
</span><span class="k" data-group-id="7576198346-1">end</span></code></pre><p>For a full list of all of the available options for configuring destroy actions, see <a href="dsl-ash-resource.html#actions-destroy">the Ash.Resource.Dsl documentation</a>.</p><h2 id="calling-destroy-actions">Calling Destroy Actions</h2><p>The basic formula for calling a destroy action looks like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">record</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Changeset</span><span class="o">.</span><span class="n">for_destroy</span><span class="p" data-group-id="9071214001-1">(</span><span class="ss">:action_name</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9071214001-2">%{</span><span class="ss">argument</span><span class="p">:</span><span class="w"> </span><span class="ss">:value</span><span class="p" data-group-id="9071214001-2">}</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="n">opts</span><span class="p" data-group-id="9071214001-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">destroy!</span><span class="p" data-group-id="9071214001-3">(</span><span class="p" data-group-id="9071214001-3">)</span></code></pre><p>See below for variations on action calling, and see the <a href="code-interfaces.xhtml">code interface guide</a> guide for how to
define idiomatic and convenient functions that call your actions.</p><h2 id="returning-the-destroyed-record">Returning the destroyed record</h2><p>You can use the <code class="inline">return_destroyed?</code> option to return the destroyed record.</p><pre><code class="makeup elixir" translate="no"><span class="c1"># when a resource is passed, or a query w/ no action, the primary destroy action is used.</span><span class="w">
</span><span class="n">ticket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="6403355419-1">(</span><span class="nc">Ticket</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p" data-group-id="6403355419-1">)</span><span class="w">
</span><span class="nc">Ash</span><span class="o">.</span><span class="n">destroy!</span><span class="p" data-group-id="6403355419-2">(</span><span class="n">ticket</span><span class="p" data-group-id="6403355419-2">)</span><span class="w">
</span><span class="c1"># =&gt; :ok</span><span class="w">
</span><span class="n">ticket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="6403355419-3">(</span><span class="nc">Ticket</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="6403355419-3">)</span><span class="w">
</span><span class="nc">Ash</span><span class="o">.</span><span class="n">destroy!</span><span class="p" data-group-id="6403355419-4">(</span><span class="n">ticket</span><span class="p">,</span><span class="w"> </span><span class="ss">return_destroyed?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="6403355419-4">)</span><span class="w">
</span><span class="c1"># =&gt; {:ok, %Ticket{}}</span></code></pre><section role="note" class="admonition warning"><h3 id="loading-on-destroyed-records" class="admonition-title warning">Loading on destroyed records</h3><p>Keep in mind that using <code class="inline">Ash.load</code> on destroyed data will produced mixed results. Relationships may appear as empty, or may be loaded as expected (depending on the data layer/relationship implementation) and calculations/aggregates may show as <code class="inline">nil</code> if they must be run in the data layer.</p></section><h2 id="bulk-destroys">Bulk Destroys</h2><p>There are three strategies for bulk destroying data. They are, in order of preference: <code class="inline">:atomic</code>, <code class="inline">:atomic_batches</code>, and <code class="inline">:stream</code>. When calling <a href="Ash.xhtml#bulk_destroy/4"><code class="inline">Ash.bulk_destroy/4</code></a>, you can provide a strategy or strategies that can be used, and Ash will choose the best one available. The capabilities of the data layer determine what strategies can be used.</p><h2 id="atomic">Atomic</h2><p>Atomic bulk destroys are used when the subject of the bulk destroy is a query and the data layer supports destroying a query. They map to a single statement to the data layer to destroy all matching records.</p><h3 id="example">Example</h3><pre><code class="makeup elixir" translate="no"><span class="nc">Ticket</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="6033857160-1">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:open</span><span class="p" data-group-id="6033857160-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash</span><span class="o">.</span><span class="n">bulk_destroy!</span><span class="p" data-group-id="6033857160-2">(</span><span class="ss">:close</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6033857160-3">%{</span><span class="p" data-group-id="6033857160-3">}</span><span class="p" data-group-id="6033857160-2">)</span></code></pre><p>If using a SQL data layer, this would produce a query along the lines of</p><pre><code class="sql">DELETE FROM tickets
WHERE status = 'open';</code></pre><h2 id="atomic-batches">Atomic Batches</h2><p>Atomic batches are used when the subject of the bulk destroy is an enumerable (i.e list or stream) of records and the data layer supports destroying a query. The records are pulled out in batches, and then each batch follows the logic described <a href="#atomic">above</a>. The batch size is controllable by the <code class="inline">batch_size</code> option.</p><h3 id="example-1">Example</h3><pre><code class="makeup elixir" translate="no"><span class="w">
</span><span class="nc">Ash</span><span class="o">.</span><span class="n">bulk_destroy!</span><span class="p" data-group-id="8838756989-1">(</span><span class="n">one_hundred_tickets</span><span class="p">,</span><span class="w"> </span><span class="ss">:close</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="8838756989-2">%{</span><span class="p" data-group-id="8838756989-2">}</span><span class="p">,</span><span class="w"> </span><span class="ss">batch_size</span><span class="p">:</span><span class="w"> </span><span class="mi">10</span><span class="p" data-group-id="8838756989-1">)</span></code></pre><p>If using a SQL data layer, this would produce ten queries along the lines of</p><pre><code class="sql">DELETE FROM tickets
WHERE id IN (...ids)</code></pre><h2 id="stream">Stream</h2><p>Stream is used when the data layer does not support destroying a query. If a query is given, it is run and the records are used as an enumerable of inputs. If an enumerable of inputs is given, each one is destroyed individually. There is nothing inherently wrong with doing this kind of destroy, but it will naturally be slower than the other two strategies.
The benefit of having a single interface (<a href="Ash.xhtml#bulk_destroy/4"><code class="inline">Ash.bulk_destroy/4</code></a>) is that the caller doesn't need to change based on the performance implications of the action.</p><section role="note" class="admonition warning"><h3 id="check-the-docs" class="admonition-title warning">Check the docs!</h3><p>Make sure to thoroughly read and understand the documentation in <a href="Ash.xhtml#bulk_destroy/4"><code class="inline">Ash.bulk_destroy/4</code></a> before using. Read each option and note the default values. By default, bulk destroys don't return records or errors, and don't emit notifications.</p></section><h3 id="destroying-records">Destroying records</h3><p>If you provide an enumerable of records, they will be destroyed in batches. For example:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ash</span><span class="o">.</span><span class="n">bulk_destroy</span><span class="p" data-group-id="7056370388-1">(</span><span class="p" data-group-id="7056370388-2">[</span><span class="p" data-group-id="7056370388-3">%</span><span class="nc" data-group-id="7056370388-3">Ticket</span><span class="p" data-group-id="7056370388-3">{</span><span class="p" data-group-id="7056370388-3">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7056370388-4">%</span><span class="nc" data-group-id="7056370388-4">Ticket</span><span class="p" data-group-id="7056370388-4">{</span><span class="p" data-group-id="7056370388-4">}</span><span class="p" data-group-id="7056370388-2">]</span><span class="p">,</span><span class="w"> </span><span class="ss">:destroy</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7056370388-5">%{</span><span class="p" data-group-id="7056370388-5">}</span><span class="p" data-group-id="7056370388-1">)</span></code></pre><h3 id="destroying">Destroying</h3><h2 id="running-the-destroy-action">Running the Destroy Action</h2><p>All actions are run in a transaction if the data layer supports it. You can opt out of this behavior by supplying <code class="inline">transaction?: false</code> when creating the action. When an action is being run in a transaction, all steps inside of it are serialized because transactions cannot be split across processes.</p><ul><li>Authorization is performed on the changes</li><li>A before action hook is added to set up belongs_to relationships that are managed. This means potentially creating/modifying the destination of the relationship, and then changing the <code class="inline">destination_attribute</code> of the relationship.</li><li><code class="inline">before_transaction</code> and <code class="inline">around_transaction</code> hooks are called (<a href="Ash.Changeset.xhtml#before_transaction/2"><code class="inline">Ash.Changeset.before_transaction/2</code></a>). Keep in mind, any validations that are marked as <code class="inline">before_action? true</code> (or all global validations if your action has <code class="inline">delay_global_validations? true</code>) will not have happened at this point.</li><li>A transaction is opened if the action is configured for it (by default they are) and the data layer supports transactions</li><li><code class="inline">before_action</code> hooks are performed in order</li><li>The main action is sent to the data layer</li><li><code class="inline">after_action</code> hooks are performed in order</li><li>Non-belongs-to relationships are managed, creating/updating/destroying related records.</li><li>The transaction is closed, if one was opened</li><li><code class="inline">after_transaction</code> hooks are invoked with the result of the transaction (even if it was an error)</li></ul>

  </body>
</html>
