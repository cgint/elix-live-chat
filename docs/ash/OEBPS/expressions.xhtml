<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Expressions - ash v3.5.33</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Expressions</h1>
<p>Ash expressions are used in various places like calculations, filters, and policies, and are meant to be portable representations of elixir expressions. You can create an expression using the <a href="Ash.Expr.xhtml#expr/1"><code class="inline">Ash.Expr.expr/1</code></a> macro, like so:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ash.Expr</span><span class="o">.</span><span class="n">expr</span><span class="p" data-group-id="3335263681-1">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p" data-group-id="3335263681-1">)</span><span class="w">
</span><span class="nc">Ash.Expr</span><span class="o">.</span><span class="n">expr</span><span class="p" data-group-id="3335263681-2">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p" data-group-id="3335263681-2">)</span><span class="w">
</span><span class="nc">Ash.Expr</span><span class="o">.</span><span class="n">expr</span><span class="p" data-group-id="3335263681-3">(</span><span class="n">post</span><span class="o">.</span><span class="n">title</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s">&quot; | &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">post</span><span class="o">.</span><span class="n">subtitle</span><span class="p" data-group-id="3335263681-3">)</span></code></pre><section role="note" class="admonition info"><h3 id="ash-expressions-are-sql-ish" class="admonition-title info">Ash Expressions are SQL-ish</h3><p>Ash expressions have some interesting properties in their evaluation, primarily because they are made to be
portable, i.e executable in some data layer (like SQL) or executable in Elixir. In general, these expressions
will behave the same way they do in Elixir. The primary difference is how <code class="inline">nil</code> values work. They behave the way
that <code class="inline">NULL</code> values behave in SQL. This is primarily because this pattern is easier to replicate to various popular
data layers, and is generally safer when using expressions for things like authentication. The practical
implications of this are that <code class="inline">nil</code> values will &quot;poison&quot; many expressions, and cause them to return <code class="inline">nil</code>.
For example, <code class="inline">x + nil</code> would always evaluate to <code class="inline">nil</code>. Additionally, <code class="inline">true and nil</code> will always result in
<code class="inline">nil</code>, <em>this is also true with or and not</em>, i.e <code class="inline">true or nil</code> will return <code class="inline">nil</code>, and <code class="inline">not nil</code> will return <code class="inline">nil</code>.</p><p>Additionally, atoms and strings compare as if the atom was a string. This is because most external data layers
do not know about atoms, and so they are converted to strings before comparison.</p></section><h2 id="operators">Operators</h2><p>The following operators are available and they behave the same as they do in Elixir, except for the <code class="inline">nil</code> addendum above.</p><ul><li><code class="inline">==</code></li><li><code class="inline">!=</code></li><li><code class="inline">&gt;</code></li><li><code class="inline">&gt;=</code></li><li><code class="inline">&lt;</code></li><li><code class="inline">&lt;=</code></li><li><code class="inline">in</code></li><li><code class="inline">*</code></li><li><code class="inline">-</code></li><li><code class="inline">/</code></li><li><code class="inline">&lt;&gt;</code></li><li><code class="inline">and</code> - Boolean and operator</li><li><code class="inline">or</code> - Boolean or operator</li><li><code class="inline">||</code> - Elixir-ish or operator, if left is not <code class="inline">nil</code> or <code class="inline">false</code>, then left. Othewise right.</li><li><code class="inline">&amp;&amp;</code> - Elixir-ish and operator, if left is not <code class="inline">nil</code> or <code class="inline">false</code>, then right. Otherwise left.</li><li><p><code class="inline">is_nil</code> | Only works as an operator in maps/keyword list syntax. i.e <code class="inline">[x: [is_nil: true]]</code></p></li></ul><h3 id="elixir-ish-operators">Elixir-ish operators</h3><p>Prefer to use <code class="inline">and</code> and <code class="inline">or</code> if you are dealing with booleans, as they will typically perform much
better in SQL data layers. <code class="inline">&amp;&amp;</code> and <code class="inline">||</code> should only be used when you want to deal with more than boolaens.</p><p>For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">calculate</span><span class="w"> </span><span class="ss">:identifier</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="5816386855-1">(</span><span class="n">manual_identifier</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">employee_id</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">location_code</span><span class="p" data-group-id="5816386855-1">)</span></code></pre><h2 id="functions">Functions</h2><p>The following functions are built in. Data Layers can add their own functions to expressions. For example, <code class="inline">AshPostgres</code> adds <code class="inline">trigram_similarity</code> function.</p><p>The following functions are built in:</p><ul><li><p><code class="inline">if</code> | Works like elixir's <code class="inline">if</code>.</p></li><li><p><a href="https://hexdocs.pm/elixir/Kernel.html#is_nil/1"><code class="inline">is_nil/1</code></a> | Works like elixir's <code class="inline">is_nil</code></p></li><li><p><code class="inline">get_path/2</code> | i.e <code class="inline">get_path(value, [&quot;foo&quot;, &quot;bar&quot;])</code>. This is what expressions like <code class="inline">value[:foo][&quot;bar&quot;]</code> are turned into under the hood.</p></li><li><p><code class="inline">contains/2</code> | if one string contains another string, i.e <code class="inline">contains(&quot;fred&quot;, &quot;red&quot;)</code></p></li><li><p><a href="https://hexdocs.pm/elixir/Kernel.html#length/1"><code class="inline">length/1</code></a> | the length of a list, i.e. <code class="inline">length([:foo, :bar])</code></p></li><li><p><code class="inline">type/2</code> | Cast a given value to a specific type, i.e <code class="inline">type(^arg(:id), :uuid)</code> or <code class="inline">type(integer_field, :string)</code></p></li><li><p><code class="inline">string_downcase/1</code> | Downcases a string</p></li><li><p><code class="inline">string_join/1</code> | Concatenates a list of strings, and ignores any nil values</p></li><li><p><code class="inline">string_join/2</code> | As above, but with a joiner</p></li><li><p><code class="inline">string_position/2</code> | Returns the zero-based position of a substring within a string, or nil, i.e. <code class="inline">string_position(&quot;fred&quot;, &quot;red&quot;) == 1</code></p></li><li><p><code class="inline">string_split/1</code> | Splits a string on spaces</p></li><li><p><code class="inline">string_split/2</code> | As above, but with a specific delimiter</p></li><li><p><code class="inline">string_split/3</code> | As above, but with options. See the function for the available options.</p></li><li><p><code class="inline">string_length/1</code> | Returns the length of a given string, as reported by <a href="https://hexdocs.pm/elixir/String.html#length/1"><code class="inline">String.length/1</code></a></p></li><li><p><code class="inline">string_trim/1</code> | Trims unicode whitespace from the beginning and the end of a string</p></li><li><p><code class="inline">at/2</code> | Get an element from a list, i.e <code class="inline">at(list, 1)</code></p></li><li><p><a href="https://hexdocs.pm/elixir/Kernel.html#round/1"><code class="inline">round/1</code></a> | Round a float, decimal or int to 0 precision, i.e <code class="inline">round(num)</code></p></li><li><p><code class="inline">round/2</code> | Round a float, decimal or int to the provided precision or less, i.e <code class="inline">round(1.1234, 3) == 1.1234</code> and <code class="inline">round(1.12, 3) == 1.12</code></p></li><li><p>String interpolation | <code class="inline">&quot;#{first_name} #{last_name}&quot;</code>, is remapped to the equivalent usage of <code class="inline">&lt;&gt;</code></p></li><li><p><code class="inline">fragment/*</code> | Creates a fragment of a data layer expression. See the section on fragments below.</p></li><li><p><code class="inline">error/2</code> | Raises an error with a given exception module and parameters. See the section on error expressions below.</p></li></ul><h2 id="fragments">Fragments</h2><p>Fragments come in two forms.</p><h2 id="string-fragments">String Fragments</h2><p>For SQL/query-backed data layers, they will be a string with question marks for interpolation. For example: <code class="inline">fragment(&quot;(? + ?)&quot;, foo, bar)</code>.</p><h2 id="function-fragments">Function Fragments</h2><p>For elixir-backed data layers, they will be a function or an MFA that will be called with the provided arguments. For example: <code class="inline">fragment(&amp;Module.add/2, foo, bar)</code> or <code class="inline">fragment({Module, :add, []}, foo, bar)</code>. When using anonymous functions, you can <em>only</em> use the format <code class="inline">&amp;Module.function/arity</code>. <code class="inline">&amp;Module.add/2</code> is okay, but <code class="inline">fn a, b -&gt; Module.add(a, b) end</code> is not.</p><h2 id="sub-expressions">Sub-expressions</h2><ul><li><p><code class="inline">exists/2</code> | <code class="inline">exists(foo.bar, name == &quot;fred&quot;)</code> takes an expression scoped to the destination resource, and checks if any related entry matches. See the section on <code class="inline">exists</code> below.</p></li><li><p><code class="inline">path.exists/2</code> | Same as <code class="inline">exists</code> but the source of the relationship is itself a nested relationship. See the section on <code class="inline">exists</code> below.</p></li><li><p><code class="inline">parent/1</code> | Allows an expression scoped to a resource to refer to the &quot;outer&quot; context. Used in relationship filters and <code class="inline">exists</code></p></li></ul><h2 id="datetime-functions">DateTime Functions</h2><ul><li><p><code class="inline">now/0</code> | Evaluates to the current time when the expression is evaluated</p></li><li><p><code class="inline">today/0</code> | Evaluates to the current date when the expression is evaluated</p></li><li><p><code class="inline">ago/2</code> | i.e <code class="inline">deleted_at &gt; ago(7, :day)</code>. The available time intervals are documented in <a href="Ash.Type.DurationName.xhtml"><code class="inline">Ash.Type.DurationName</code></a></p></li><li><p><code class="inline">from_now/2</code> | Same as <code class="inline">ago</code> but adds instead of subtracting</p></li><li><p><code class="inline">datetime_add/3</code> | add an interval to a datetime, i.e <code class="inline">datetime_add(^datetime, 10, :hour)</code></p></li><li><p><code class="inline">date_add/3</code> | add an interval to a date, i.e <code class="inline">date_add(^date, 3, :day)</code></p></li><li><p><code class="inline">start_of_day/1-2</code> | Converts a date or a datetime to the correspond start of its day (at 00:00 time).</p></li></ul><h2 id="primitives">Primitives</h2><ul><li><code class="inline">cond</code> - <code class="inline">cond</code> is transformed to a series of <code class="inline">if</code> expressions under the hood</li><li><code class="inline">item[:key] or item[&quot;key&quot;]</code> - accesses keys in a map. In both cases, it prefers a matching atom key, falling back to a matching string key. This is to aid with data stores that store embeds as JSON with string keys (like AshPostgres), so that this expression behaves the same in the data layer as it does in Elixir.</li></ul><h2 id="escape-hatches">Escape Hatches</h2><ul><li><code class="inline">lazy/1</code> - Takes an MFA and evaluates it just before running the query. This is important for calculations, because the <code class="inline">expression/2</code> callback should be <em>stable</em> (returns the same value given the same input). For example <code class="inline">lazy({ULID, :generate, [timestamp_input]})</code></li></ul><h2 id="inline-aggregates">Inline Aggregates</h2><p>Aggregates can be referenced in-line, with their relationship path specified and any options provided that match the options given to <a href="Ash.Query.Aggregate.xhtml#new/4"><code class="inline">Ash.Query.Aggregate.new/4</code></a>. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">calculate</span><span class="w"> </span><span class="ss">:grade</span><span class="p">,</span><span class="w"> </span><span class="ss">:decimal</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="2781719107-1">(</span><span class="w">
  </span><span class="n">count</span><span class="p" data-group-id="2781719107-2">(</span><span class="n">answers</span><span class="p">,</span><span class="w"> </span><span class="ss">query</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2781719107-3">[</span><span class="ss">filter</span><span class="p">:</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="2781719107-4">(</span><span class="n">correct</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="2781719107-4">)</span><span class="p" data-group-id="2781719107-3">]</span><span class="p" data-group-id="2781719107-2">)</span><span class="w"> </span><span class="o">/</span><span class="w">
  </span><span class="n">count</span><span class="p" data-group-id="2781719107-5">(</span><span class="n">answers</span><span class="p">,</span><span class="w"> </span><span class="ss">query</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2781719107-6">[</span><span class="ss">filter</span><span class="p">:</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="2781719107-7">(</span><span class="n">correct</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="2781719107-7">)</span><span class="p" data-group-id="2781719107-6">]</span><span class="p" data-group-id="2781719107-5">)</span><span class="w">
</span><span class="p" data-group-id="2781719107-1">)</span></code></pre><p>The available aggregate kinds can also be seen in the <a href="Ash.Query.Aggregate.xhtml"><code class="inline">Ash.Query.Aggregate</code></a> module documentation.</p><h2 id="templates">Templates</h2><p>Most of the time, when you are using an expression, you will actually be creating a <em>template</em>. In this template, you have a few references that can be used, which will be replaced before the expression is evaluated. The following references are available:</p><pre><code class="makeup elixir" translate="no"><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="1091369404-1">(</span><span class="ss">:key</span><span class="p" data-group-id="1091369404-1">)</span><span class="w"> </span><span class="c1"># equivalent to `get_in(actor || %{}, [:key])`</span><span class="w">
</span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="1091369404-2">(</span><span class="p" data-group-id="1091369404-3">[</span><span class="ss">:key1</span><span class="p">,</span><span class="w"> </span><span class="ss">:key2</span><span class="p" data-group-id="1091369404-3">]</span><span class="p" data-group-id="1091369404-2">)</span><span class="w"> </span><span class="c1"># equivalent to `get_in(actor || %{}, [:key, :key2])`</span><span class="w">
</span><span class="o">^</span><span class="n">arg</span><span class="p" data-group-id="1091369404-4">(</span><span class="ss">:arg_name</span><span class="p" data-group-id="1091369404-4">)</span><span class="w"> </span><span class="c1"># equivalent to `Map.get(arguments, :arg_name)`</span><span class="w">
</span><span class="o">^</span><span class="n">context</span><span class="p" data-group-id="1091369404-5">(</span><span class="ss">:key</span><span class="p" data-group-id="1091369404-5">)</span><span class="w"> </span><span class="c1"># equivalent to `get_in(context, :key)`</span><span class="w">
</span><span class="o">^</span><span class="n">context</span><span class="p" data-group-id="1091369404-6">(</span><span class="p" data-group-id="1091369404-7">[</span><span class="ss">:key1</span><span class="p">,</span><span class="w"> </span><span class="ss">:key2</span><span class="p" data-group-id="1091369404-7">]</span><span class="p" data-group-id="1091369404-6">)</span><span class="w"> </span><span class="c1"># equivalent to `get_in(context, [:key1, :key2])`</span><span class="w">
</span><span class="o">^</span><span class="n">ref</span><span class="p" data-group-id="1091369404-8">(</span><span class="ss">:key</span><span class="p" data-group-id="1091369404-8">)</span><span class="w"> </span><span class="c1"># equivalent to referring to `key`. Allows for dynamic references</span><span class="w">
</span><span class="o">^</span><span class="n">ref</span><span class="p" data-group-id="1091369404-9">(</span><span class="p" data-group-id="1091369404-10">[</span><span class="ss">:path</span><span class="p" data-group-id="1091369404-10">]</span><span class="p">,</span><span class="w"> </span><span class="ss">:key</span><span class="p" data-group-id="1091369404-9">)</span><span class="w"> </span><span class="c1"># equivalent to referring to `path.key`. Allows for dynamic references with dynamic (or static) paths.</span></code></pre><h2 id="custom-expressions">Custom Expressions</h2><p>Custom expressions allow you to extend Ash's expression language with your own expressions. To see more, see <a href="Ash.CustomExpression.xhtml"><code class="inline">Ash.CustomExpression</code></a>. To add a custom expression, configure it and recompile ash. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">:custom_expressions</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3013290856-1">[</span><span class="w">
  </span><span class="nc">MyApp.CustomExpression</span><span class="w">
</span><span class="p" data-group-id="3013290856-1">]</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="n">mix</span><span class="w"> </span><span class="n">deps</span><span class="o">.</span><span class="n">compile</span><span class="w"> </span><span class="n">ash</span><span class="w"> </span><span class="o">--</span><span class="n">force</span></code></pre><p>These expressions will be available across all usages of Ash expressions within your application.</p><h2 id="filter-semantics-joins">Filter semantics &amp; joins</h2><p>The semantics of Ash filters are probably slightly different than what you are used to, and they are important to understand. Every filter expression is always talking about a single row, potentially &quot;joined&quot; to single related rows. By referencing relationships, you are implicitly doing a join. For those familiar with SQL terminology, it is equivalent to a left join, although AshPostgres can detect when it is safe to do an inner join (for performance reasons). Lets use an example of <code class="inline">posts</code> and <code class="inline">comments</code>.</p><p>Given a filter like the following:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="7572649013-1">(</span><span class="nc">Post</span><span class="p">,</span><span class="w"> </span><span class="n">comments</span><span class="o">.</span><span class="n">points</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">comments</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;elixir&quot;</span><span class="p" data-group-id="7572649013-1">)</span></code></pre><p>The filter refers to a <em>single post/comment/tag combination</em>. So in english, this is &quot;posts where they have a comment with more than 10 points and <em>that same comment</em> has a tag with the name <code class="inline">elixir</code>&quot;. What this also means is that filters like the above do not compose nicely when new filters are added. For example:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">has_comment_with_more_points_than</span><span class="p" data-group-id="1800034982-1">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">score</span><span class="p" data-group-id="1800034982-1">)</span><span class="w"> </span><span class="k" data-group-id="1800034982-2">do</span><span class="w">
  </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="1800034982-3">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">comments</span><span class="o">.</span><span class="n">points</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">^</span><span class="n">score</span><span class="p" data-group-id="1800034982-3">)</span><span class="w">
</span><span class="k" data-group-id="1800034982-2">end</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">has_comment_tagged</span><span class="p" data-group-id="1800034982-4">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p" data-group-id="1800034982-4">)</span><span class="w"> </span><span class="k" data-group-id="1800034982-5">do</span><span class="w">
  </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="1800034982-6">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">comments</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">tag</span><span class="p" data-group-id="1800034982-6">)</span><span class="w">
</span><span class="k" data-group-id="1800034982-5">end</span><span class="w">

</span><span class="nc">Post</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">has_comment_with_more_points_than</span><span class="p" data-group-id="1800034982-7">(</span><span class="mi">10</span><span class="p" data-group-id="1800034982-7">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">has_comment_tagged</span><span class="p" data-group-id="1800034982-8">(</span><span class="s">&quot;elixir&quot;</span><span class="p" data-group-id="1800034982-8">)</span></code></pre><p>That code <em>seems</em> like it ought to produce a filter over <code class="inline">Post</code> that would give us any post with a comment having more than 10 points, <em>and</em> with a comment tagged <code class="inline">elixir</code>. That is not the same thing as having a <em>single</em> comment that meets both those criteria. So how do we make this better?</p><h3 id="many-to-many-relationships">Many-to-many relationships</h3><p>When working with expressions that join many-to-many relationships, there may be cases that you wish to refer to &quot;the join row that connects these two things&quot;. For example, to sort a many-to-many relationship by the <code class="inline">position</code> on the join row. For this, we have special-cased references to
<code class="inline">parent(join_relationship_name)</code> to refer to <em>specifically</em> the join row that connects the two records.</p><p>This allows for things like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">many_to_many</span><span class="w"> </span><span class="ss">:tags</span><span class="p">,</span><span class="w"> </span><span class="nc">MyDomain.Tag</span><span class="w"> </span><span class="k" data-group-id="2125469792-1">do</span><span class="w">
  </span><span class="n">through</span><span class="w"> </span><span class="nc">MyDomain.PostTag</span><span class="w">
  </span><span class="n">join_relationship</span><span class="w"> </span><span class="ss">:post_tags</span><span class="w">
  </span><span class="n">sort</span><span class="w"> </span><span class="p" data-group-id="2125469792-2">[</span><span class="n">calc</span><span class="p" data-group-id="2125469792-3">(</span><span class="n">parent</span><span class="p" data-group-id="2125469792-4">(</span><span class="n">post_tags</span><span class="o">.</span><span class="n">position</span><span class="p" data-group-id="2125469792-4">)</span><span class="p" data-group-id="2125469792-3">)</span><span class="p" data-group-id="2125469792-2">]</span><span class="w">
</span><span class="k" data-group-id="2125469792-1">end</span></code></pre><h3 id="exists">Exists</h3><p>Lets rewrite the above using exists:</p><pre><code class="makeup elixir" translate="no"><span class="kd">def</span><span class="w"> </span><span class="nf">has_comment_with_more_points_than</span><span class="p" data-group-id="6035312465-1">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">score</span><span class="p" data-group-id="6035312465-1">)</span><span class="w"> </span><span class="k" data-group-id="6035312465-2">do</span><span class="w">
  </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="6035312465-3">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">exists</span><span class="p" data-group-id="6035312465-4">(</span><span class="n">comments</span><span class="p">,</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">^</span><span class="n">score</span><span class="p" data-group-id="6035312465-4">)</span><span class="p" data-group-id="6035312465-3">)</span><span class="w">
</span><span class="k" data-group-id="6035312465-2">end</span><span class="w">

</span><span class="kd">def</span><span class="w"> </span><span class="nf">has_comment_tagged</span><span class="p" data-group-id="6035312465-5">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p" data-group-id="6035312465-5">)</span><span class="w"> </span><span class="k" data-group-id="6035312465-6">do</span><span class="w">
  </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="6035312465-7">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">exists</span><span class="p" data-group-id="6035312465-8">(</span><span class="n">comments</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">tag</span><span class="p" data-group-id="6035312465-8">)</span><span class="p" data-group-id="6035312465-7">)</span><span class="w">
</span><span class="k" data-group-id="6035312465-6">end</span><span class="w">

</span><span class="nc">Post</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">has_comment_with_more_points_than</span><span class="p" data-group-id="6035312465-9">(</span><span class="mi">10</span><span class="p" data-group-id="6035312465-9">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="n">has_comment_tagged</span><span class="p" data-group-id="6035312465-10">(</span><span class="s">&quot;elixir&quot;</span><span class="p" data-group-id="6035312465-10">)</span></code></pre><p>Now, they will compose properly! Generally speaking, you should use exists when you are filtering across any relationships that are <code class="inline">to_many</code> relationships *even if you don't expect your filter to be composed. Currently, the filter syntax does not minimize(combine) these <code class="inline">exists/2</code> statements, but doing so is not complex and can be added. While unlikely, please lodge an issue if you see any performance issues with <code class="inline">exists</code>.</p><h3 id="exists-at-path">Exists at path</h3><p>Sometimes, you want the ability to say that some given row must have an existing related entry matching a filter. For example:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="2992552932-1">(</span><span class="nc">Post</span><span class="p">,</span><span class="w"> </span><span class="n">author</span><span class="o">.</span><span class="n">exists</span><span class="p" data-group-id="2992552932-2">(</span><span class="n">roles</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:admin</span><span class="p" data-group-id="2992552932-2">)</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">author</span><span class="o">.</span><span class="n">active</span><span class="p" data-group-id="2992552932-1">)</span></code></pre><p>While the above is not common, it can be useful in some specific circumstances, and is used under the hood by the policy authorizer when combining the filters of various resources to create a single filter.</p><h2 id="portability">Portability</h2><p>Ash expressions being portable is more important than it sounds. For example, if you were using AshPostgres and had the following calculation, which is an expression capable of being run in elixir or translated to SQL:</p><pre><code class="makeup elixir" translate="no"><span class="n">calculate</span><span class="w"> </span><span class="ss">:full_name</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="5854096208-1">(</span><span class="n">first_name</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">last_name</span><span class="p" data-group-id="5854096208-1">)</span></code></pre><p>And you did something like the following:</p><pre><code class="makeup elixir" translate="no"><span class="nc">User</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">load</span><span class="p" data-group-id="3469794496-1">(</span><span class="ss">:full_name</span><span class="p" data-group-id="3469794496-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">sort</span><span class="p" data-group-id="3469794496-2">(</span><span class="ss">:full_name</span><span class="p" data-group-id="3469794496-2">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Accounts</span><span class="o">.</span><span class="n">read!</span><span class="p" data-group-id="3469794496-3">(</span><span class="p" data-group-id="3469794496-3">)</span></code></pre><p>You would see that it ran a SQL query with the <code class="inline">full_name</code> calculation as SQL. This allows for sorting on that value. However, if you had something like this:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># data can be loaded in the query like above, or on demand later</span><span class="w">
</span><span class="nc">Accounts</span><span class="o">.</span><span class="n">load!</span><span class="p" data-group-id="9372600184-1">(</span><span class="n">user</span><span class="p">,</span><span class="w"> </span><span class="ss">:full_name</span><span class="p">,</span><span class="w"> </span><span class="ss">reuse_values?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9372600184-1">)</span></code></pre><p>you would see that no SQL queries are run. The calculation is run directly in Elixir without needing to visit the database.</p><h2 id="parent">Parent</h2><p><code class="inline">Parent</code> is a way to &quot;jump out&quot; of a scoped expression. Here are some examples:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="7736024239-1">(</span><span class="n">exists</span><span class="p" data-group-id="7736024239-2">(</span><span class="n">open_tickets</span><span class="p">,</span><span class="w"> </span><span class="n">severity</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">parent</span><span class="p" data-group-id="7736024239-3">(</span><span class="n">severity_threshold</span><span class="p" data-group-id="7736024239-3">)</span><span class="p" data-group-id="7736024239-2">)</span><span class="p" data-group-id="7736024239-1">)</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="n">has_many</span><span class="w"> </span><span class="ss">:relevant_tickets</span><span class="p">,</span><span class="w"> </span><span class="nc">Ticket</span><span class="w"> </span><span class="k" data-group-id="3182644733-1">do</span><span class="w">
  </span><span class="n">no_attributes?</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="c1"># this says that there is no matching source_attribute and destination_attribute on this relationship</span><span class="w">
  </span><span class="n">filter</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="3182644733-2">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:open</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">severity</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">parent</span><span class="p" data-group-id="3182644733-3">(</span><span class="n">severity_threshold</span><span class="p" data-group-id="3182644733-3">)</span><span class="p" data-group-id="3182644733-2">)</span><span class="w">
</span><span class="k" data-group-id="3182644733-1">end</span></code></pre><pre><code class="makeup elixir" translate="no"><span class="n">count</span><span class="w"> </span><span class="ss">:count_of_relevant_tickets</span><span class="p">,</span><span class="w"> </span><span class="ss">:open_tickets</span><span class="w"> </span><span class="k" data-group-id="8889687951-1">do</span><span class="w">
  </span><span class="n">filter</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="8889687951-2">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:open</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">severity</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">parent</span><span class="p" data-group-id="8889687951-3">(</span><span class="n">severity_threshold</span><span class="p" data-group-id="8889687951-3">)</span><span class="p" data-group-id="8889687951-2">)</span><span class="w">
</span><span class="k" data-group-id="8889687951-1">end</span></code></pre><h3 id="referencing-related-values">Referencing related values</h3><p>Related values can be references using dot delimiters, i.e <code class="inline">Ash.Query.filter(user.first_name == &quot;fred&quot;)</code>.
When referencing related values in filters, if the reference is a <code class="inline">has_one</code> or <code class="inline">belongs_to</code>, the filter does exactly what it looks like (matches if the related value matches). If it is a <code class="inline">has_many</code> or a <code class="inline">many_to_many</code>, it matches if any of the related records match.</p><h3 id="referencing-aggregates-and-calculations">Referencing aggregates and calculations</h3><p>Aggregates are simple, as all aggregates can be referenced in filter expressions (if you are using a data layer that supports aggregates).</p><p>For calculations, only those that define an expression can be referenced in other expressions.</p><p>Here are some examples:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># given a `full_name` calculation</span><span class="w">

</span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="3543485732-1">(</span><span class="nc">User</span><span class="p">,</span><span class="w"> </span><span class="n">full_name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;Hob Goblin&quot;</span><span class="p" data-group-id="3543485732-1">)</span><span class="w">

</span><span class="c1"># given a `full_name` calculation that accepts an argument called `delimiter`</span><span class="w">

</span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="3543485732-2">(</span><span class="nc">User</span><span class="p">,</span><span class="w"> </span><span class="n">full_name</span><span class="p" data-group-id="3543485732-3">(</span><span class="ss">delimiter</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;~&quot;</span><span class="p" data-group-id="3543485732-3">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;Hob~Goblin&quot;</span><span class="p" data-group-id="3543485732-2">)</span></code></pre><h2 id="case-vs-cond-expressions">Case vs Cond Expressions</h2><p>When working with conditional expressions in Ash, you should use <code class="inline">cond</code> instead of <code class="inline">case</code> statements. Here's an example:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># This works - using cond</span><span class="w">
</span><span class="n">calculations</span><span class="w"> </span><span class="k" data-group-id="6518047544-1">do</span><span class="w">
  </span><span class="n">calculate</span><span class="w"> </span><span class="ss">:user_order</span><span class="p">,</span><span class="w"> </span><span class="ss">:integer</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="6518047544-2">(</span><span class="w">
    </span><span class="k">cond</span><span class="w"> </span><span class="k" data-group-id="6518047544-3">do</span><span class="w">
      </span><span class="n">role</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:principal</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
      </span><span class="n">role</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:teacher</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w">
      </span><span class="n">role</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:student</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w">
    </span><span class="k" data-group-id="6518047544-3">end</span><span class="w">
  </span><span class="p" data-group-id="6518047544-2">)</span><span class="w">
</span><span class="k" data-group-id="6518047544-1">end</span><span class="w">

</span><span class="c1"># This doesn&#39;t work - using case</span><span class="w">
</span><span class="n">calculations</span><span class="w"> </span><span class="k" data-group-id="6518047544-4">do</span><span class="w">
  </span><span class="n">calculate</span><span class="w"> </span><span class="ss">:user_order</span><span class="p">,</span><span class="w"> </span><span class="ss">:integer</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="6518047544-5">(</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="n">role</span><span class="w"> </span><span class="k" data-group-id="6518047544-6">do</span><span class="w">
      </span><span class="ss">:principal</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w">
      </span><span class="ss">:teacher</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">2</span><span class="w">
      </span><span class="ss">:student</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w">
    </span><span class="k" data-group-id="6518047544-6">end</span><span class="w">
  </span><span class="p" data-group-id="6518047544-5">)</span><span class="w">
</span><span class="k" data-group-id="6518047544-4">end</span></code></pre><p>The <code class="inline">cond</code> expression is the correct way to handle conditional logic in Ash expressions.</p><h2 id="error-expressions">Error Expressions</h2><p>The <code class="inline">error/2</code> function is used within atomic validations, changes, and calculations to conditionally raise errors. It takes two arguments:</p><ol><li>An exception module (typically an Ash error module)</li><li>A map of parameters for the exception</li></ol><h3 id="basic-usage">Basic Usage</h3><pre><code class="makeup elixir" translate="no"><span class="n">error</span><span class="p" data-group-id="4172199496-1">(</span><span class="nc">Ash.Error.Changes.InvalidAttribute</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4172199496-2">%{</span><span class="w">
  </span><span class="ss">field</span><span class="p">:</span><span class="w"> </span><span class="ss">:price</span><span class="p">,</span><span class="w">
  </span><span class="ss">value</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="n">atomic_ref</span><span class="p" data-group-id="4172199496-3">(</span><span class="ss">:price</span><span class="p" data-group-id="4172199496-3">)</span><span class="p">,</span><span class="w">
  </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;must be greater than 0&quot;</span><span class="w">
</span><span class="p" data-group-id="4172199496-2">}</span><span class="p" data-group-id="4172199496-1">)</span></code></pre><h3 id="common-pattern-in-validations">Common Pattern in Validations</h3><p>The <code class="inline">error/2</code> function is commonly used in atomic validations to produce errors when conditions are not met:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># In an atomic validation</span><span class="w">
</span><span class="p" data-group-id="9049623652-1">{</span><span class="ss">:atomic</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9049623652-2">[</span><span class="ss">:price</span><span class="p" data-group-id="9049623652-2">]</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="9049623652-3">(</span><span class="o">^</span><span class="n">atomic_ref</span><span class="p" data-group-id="9049623652-4">(</span><span class="ss">:price</span><span class="p" data-group-id="9049623652-4">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="9049623652-3">)</span><span class="p">,</span><span class="w">
 </span><span class="n">expr</span><span class="p" data-group-id="9049623652-5">(</span><span class="w">
   </span><span class="n">error</span><span class="p" data-group-id="9049623652-6">(</span><span class="o">^</span><span class="nc">InvalidAttribute</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9049623652-7">%{</span><span class="w">
     </span><span class="ss">field</span><span class="p">:</span><span class="w"> </span><span class="ss">:price</span><span class="p">,</span><span class="w">
     </span><span class="ss">value</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="n">atomic_ref</span><span class="p" data-group-id="9049623652-8">(</span><span class="ss">:price</span><span class="p" data-group-id="9049623652-8">)</span><span class="p">,</span><span class="w">
     </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;must be greater than 0&quot;</span><span class="w">
   </span><span class="p" data-group-id="9049623652-7">}</span><span class="p" data-group-id="9049623652-6">)</span><span class="w">
 </span><span class="p" data-group-id="9049623652-5">)</span><span class="p" data-group-id="9049623652-1">}</span></code></pre><h3 id="usage-in-calculations-for-unreachable-branches">Usage in Calculations for Unreachable Branches</h3><p>The <code class="inline">error/2</code> function is useful in calculations to handle cases that should never occur, making unreachable code paths explicit:</p><pre><code class="makeup elixir" translate="no"><span class="n">calculate</span><span class="w"> </span><span class="ss">:status_label</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="3700472588-1">(</span><span class="w">
  </span><span class="k">cond</span><span class="w"> </span><span class="k" data-group-id="3700472588-2">do</span><span class="w">
    </span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:active</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Active&quot;</span><span class="w">
    </span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:inactive</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Inactive&quot;</span><span class="w">
    </span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:pending</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;Pending&quot;</span><span class="w">
    </span><span class="no">true</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">error</span><span class="p" data-group-id="3700472588-3">(</span><span class="nc">Ash.Error.Framework.AssumptionFailed</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3700472588-4">%{</span><span class="w">
      </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;Unexpected status value: %{status}&quot;</span><span class="p">,</span><span class="w">
      </span><span class="ss">vars</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3700472588-5">%{</span><span class="ss">status</span><span class="p">:</span><span class="w"> </span><span class="n">status</span><span class="p" data-group-id="3700472588-5">}</span><span class="w">
    </span><span class="p" data-group-id="3700472588-4">}</span><span class="p" data-group-id="3700472588-3">)</span><span class="w">
  </span><span class="k" data-group-id="3700472588-2">end</span><span class="w">
</span><span class="p" data-group-id="3700472588-1">)</span></code></pre><h3 id="example-with-variables">Example with Variables</h3><p>You can include variables for message interpolation:</p><pre><code class="makeup elixir" translate="no"><span class="n">error</span><span class="p" data-group-id="5641782907-1">(</span><span class="nc">Ash.Error.Changes.InvalidChanges</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="5641782907-2">%{</span><span class="w">
  </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;must be less than or equal to %{max}&quot;</span><span class="p">,</span><span class="w">
  </span><span class="ss">vars</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="5641782907-3">%{</span><span class="ss">max</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="n">max</span><span class="p" data-group-id="5641782907-3">}</span><span class="w">
</span><span class="p" data-group-id="5641782907-2">}</span><span class="p" data-group-id="5641782907-1">)</span></code></pre><h3 id="common-error-modules">Common Error Modules</h3><ul><li><a href="Ash.Error.Changes.InvalidAttribute.xhtml"><code class="inline">Ash.Error.Changes.InvalidAttribute</code></a> - Used for attribute validation errors</li><li><a href="Ash.Error.Changes.InvalidChanges.xhtml"><code class="inline">Ash.Error.Changes.InvalidChanges</code></a> - Used for general change validation errors</li><li><a href="Ash.Error.Changes.StaleRecord.xhtml"><code class="inline">Ash.Error.Changes.StaleRecord</code></a> - Used for optimistic locking violations</li><li><a href="Ash.Error.Framework.AssumptionFailed.xhtml"><code class="inline">Ash.Error.Framework.AssumptionFailed</code></a> - Used for unreachable code or violated assumptions</li></ul><h3 id="usage-in-atomic-operations">Usage in Atomic Operations</h3><p>The <code class="inline">error/2</code> function is essential for atomic operations, allowing you to specify exactly what error should be raised when validation conditions fail:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># In a compare validation</span><span class="w">
</span><span class="n">atomic_update</span><span class="p" data-group-id="7241044588-1">(</span><span class="ss">:status</span><span class="p">,</span><span class="w"> 
  </span><span class="n">expr</span><span class="p" data-group-id="7241044588-2">(</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="o">^</span><span class="n">atomic_ref</span><span class="p" data-group-id="7241044588-3">(</span><span class="ss">:score</span><span class="p" data-group-id="7241044588-3">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k" data-group-id="7241044588-4">do</span><span class="w">
      </span><span class="n">error</span><span class="p" data-group-id="7241044588-5">(</span><span class="o">^</span><span class="nc">InvalidAttribute</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7241044588-6">%{</span><span class="w">
        </span><span class="ss">field</span><span class="p">:</span><span class="w"> </span><span class="ss">:score</span><span class="p">,</span><span class="w">
        </span><span class="ss">value</span><span class="p">:</span><span class="w"> </span><span class="o">^</span><span class="n">atomic_ref</span><span class="p" data-group-id="7241044588-7">(</span><span class="ss">:score</span><span class="p" data-group-id="7241044588-7">)</span><span class="p">,</span><span class="w">
        </span><span class="ss">message</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;score cannot exceed 100&quot;</span><span class="w">
      </span><span class="p" data-group-id="7241044588-6">}</span><span class="p" data-group-id="7241044588-5">)</span><span class="w">
    </span><span class="k" data-group-id="7241044588-4">else</span><span class="w">
      </span><span class="ss">:valid</span><span class="w">
    </span><span class="k" data-group-id="7241044588-4">end</span><span class="w">
  </span><span class="p" data-group-id="7241044588-2">)</span><span class="w">
</span><span class="p" data-group-id="7241044588-1">)</span></code></pre><p>For more information about error handling in Ash, see the <a href="error-handling.xhtml">Error Handling guide</a>.</p>

  </body>
</html>
