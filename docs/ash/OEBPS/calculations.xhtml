<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Calculations - ash v3.5.33</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Calculations</h1>
<p>Calculations in Ash allow for displaying complex values as a top level value of a resource.</p><h2 id="primer">Primer</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/oxaqpDlI-Hk?si=leaR-xQ5SD7PKOXo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen"></iframe><h2 id="declaring-calculations-on-a-resource">Declaring calculations on a resource</h2><h3 id="expression-calculations">Expression Calculations</h3><p>The simplest kind of calculation refers to an Ash expression. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">calculations</span><span class="w"> </span><span class="k" data-group-id="6461386696-1">do</span><span class="w">
  </span><span class="n">calculate</span><span class="w"> </span><span class="ss">:full_name</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="6461386696-2">(</span><span class="n">first_name</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">last_name</span><span class="p" data-group-id="6461386696-2">)</span><span class="w">
</span><span class="k" data-group-id="6461386696-1">end</span></code></pre><p>See the <a href="expressions.xhtml">Expressions guide</a> for more.</p><h3 id="module-calculations">Module Calculations</h3><p>When calculations require more complex code or can't be pushed down into the data layer, a module that uses <a href="Ash.Resource.Calculation.xhtml"><code class="inline">Ash.Resource.Calculation</code></a> can be used.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">Concat</span><span class="w"> </span><span class="k" data-group-id="9898179110-1">do</span><span class="w">
  </span><span class="c1"># An example concatenation calculation, that accepts the delimiter as an argument,</span><span class="w">
  </span><span class="c1">#and the fields to concatenate as options</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Ash.Resource.Calculation</span><span class="w">

  </span><span class="c1"># Optional callback that verifies the passed in options (and optionally transforms them)</span><span class="w">
  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p" data-group-id="9898179110-2">(</span><span class="n">opts</span><span class="p" data-group-id="9898179110-2">)</span><span class="w"> </span><span class="k" data-group-id="9898179110-3">do</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="9898179110-4">[</span><span class="ss">:keys</span><span class="p" data-group-id="9898179110-4">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">is_list</span><span class="p" data-group-id="9898179110-5">(</span><span class="n">opts</span><span class="p" data-group-id="9898179110-6">[</span><span class="ss">:keys</span><span class="p" data-group-id="9898179110-6">]</span><span class="p" data-group-id="9898179110-5">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nc">Enum</span><span class="o">.</span><span class="n">all?</span><span class="p" data-group-id="9898179110-7">(</span><span class="n">opts</span><span class="p" data-group-id="9898179110-8">[</span><span class="ss">:keys</span><span class="p" data-group-id="9898179110-8">]</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_atom</span><span class="o">/</span><span class="mi">1</span><span class="p" data-group-id="9898179110-7">)</span><span class="w"> </span><span class="k" data-group-id="9898179110-9">do</span><span class="w">
      </span><span class="p" data-group-id="9898179110-10">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="9898179110-10">}</span><span class="w">
    </span><span class="k" data-group-id="9898179110-9">else</span><span class="w">
      </span><span class="p" data-group-id="9898179110-11">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Expected a `keys` option for which keys to concat&quot;</span><span class="p" data-group-id="9898179110-11">}</span><span class="w">
    </span><span class="k" data-group-id="9898179110-9">end</span><span class="w">
  </span><span class="k" data-group-id="9898179110-3">end</span><span class="w">

  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="c1"># A callback to tell Ash what keys must be loaded/selected when running this calculation</span><span class="w">
  </span><span class="c1"># you can include related data here, but be sure to include the attributes you need from said related data</span><span class="w">
  </span><span class="c1"># i.e `posts: [:title, :body]`.</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">load</span><span class="p" data-group-id="9898179110-12">(</span><span class="c">_query</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="c">_context</span><span class="p" data-group-id="9898179110-12">)</span><span class="w"> </span><span class="k" data-group-id="9898179110-13">do</span><span class="w">
    </span><span class="n">opts</span><span class="p" data-group-id="9898179110-14">[</span><span class="ss">:keys</span><span class="p" data-group-id="9898179110-14">]</span><span class="w">
  </span><span class="k" data-group-id="9898179110-13">end</span><span class="w">

  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">calculate</span><span class="p" data-group-id="9898179110-15">(</span><span class="n">records</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9898179110-16">%{</span><span class="ss">arguments</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9898179110-17">%{</span><span class="ss">separator</span><span class="p">:</span><span class="w"> </span><span class="n">separator</span><span class="p" data-group-id="9898179110-17">}</span><span class="p" data-group-id="9898179110-16">}</span><span class="p" data-group-id="9898179110-15">)</span><span class="w"> </span><span class="k" data-group-id="9898179110-18">do</span><span class="w">
    </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="9898179110-19">(</span><span class="n">records</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="9898179110-20">fn</span><span class="w"> </span><span class="n">record</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
      </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map_join</span><span class="p" data-group-id="9898179110-21">(</span><span class="n">opts</span><span class="p" data-group-id="9898179110-22">[</span><span class="ss">:keys</span><span class="p" data-group-id="9898179110-22">]</span><span class="p">,</span><span class="w"> </span><span class="n">separator</span><span class="p">,</span><span class="w"> </span><span class="k" data-group-id="9898179110-23">fn</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="n">to_string</span><span class="p" data-group-id="9898179110-24">(</span><span class="nc">Map</span><span class="o">.</span><span class="n">get</span><span class="p" data-group-id="9898179110-25">(</span><span class="n">record</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p" data-group-id="9898179110-25">)</span><span class="p" data-group-id="9898179110-24">)</span><span class="w">
      </span><span class="k" data-group-id="9898179110-23">end</span><span class="p" data-group-id="9898179110-21">)</span><span class="w">
    </span><span class="k" data-group-id="9898179110-20">end</span><span class="p" data-group-id="9898179110-19">)</span><span class="w">
  </span><span class="k" data-group-id="9898179110-18">end</span><span class="w">

  </span><span class="c1"># You can implement this callback to make this calculation possible in the data layer</span><span class="w">
  </span><span class="c1"># *and* in elixir. Ash expressions are already executable in Elixir or in the data layer, but this gives you fine grain control over how it is done</span><span class="w">
  </span><span class="c1"># See the expressions guide for more.</span><span class="w">
  </span><span class="c1"># @impl true</span><span class="w">
  </span><span class="c1"># def expression(opts, context) do</span><span class="w">
  </span><span class="c1">#   expr(your_expression_here)</span><span class="w">
  </span><span class="c1"># end</span><span class="w">
</span><span class="k" data-group-id="9898179110-1">end</span><span class="w">

</span><span class="c1"># Usage in a resource</span><span class="w">
</span><span class="n">calculations</span><span class="w"> </span><span class="k" data-group-id="9898179110-26">do</span><span class="w">
  </span><span class="n">calculate</span><span class="w"> </span><span class="ss">:full_name</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9898179110-27">{</span><span class="nc">Concat</span><span class="p">,</span><span class="w"> </span><span class="ss">keys</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9898179110-28">[</span><span class="ss">:first_name</span><span class="p">,</span><span class="w"> </span><span class="ss">:last_name</span><span class="p" data-group-id="9898179110-28">]</span><span class="p" data-group-id="9898179110-27">}</span><span class="w"> </span><span class="k" data-group-id="9898179110-29">do</span><span class="w">
    </span><span class="c1"># You need to use the [allow_empty?: true, trim?: false] constraints here.</span><span class="w">
    </span><span class="c1"># The separator could be an empty string or require a leading or trailing space,</span><span class="w">
    </span><span class="c1"># but would be trimmed or even set to `nil` without the constraints shown below.</span><span class="w">
    </span><span class="n">argument</span><span class="w"> </span><span class="ss">:separator</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="w"> </span><span class="k" data-group-id="9898179110-30">do</span><span class="w">
      </span><span class="n">allow_nil?</span><span class="w"> </span><span class="no">false</span><span class="w">
      </span><span class="n">constraints</span><span class="w"> </span><span class="p" data-group-id="9898179110-31">[</span><span class="ss">allow_empty?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p">,</span><span class="w"> </span><span class="ss">trim?</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="9898179110-31">]</span><span class="w">
      </span><span class="n">default</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w">
    </span><span class="k" data-group-id="9898179110-30">end</span><span class="w">
  </span><span class="k" data-group-id="9898179110-29">end</span><span class="w">
</span><span class="k" data-group-id="9898179110-26">end</span></code></pre><p>See the documentation for the calculations section in <a href="dsl-ash-resource.html#calculations">Resource DSL docs</a> and the <a href="Ash.Resource.Calculation.xhtml"><code class="inline">Ash.Resource.Calculation</code></a> docs for more information.</p><p>The calculations declared on a resource allow for declaring a set of named calculations that can be used by extensions.
They can also be loaded in the query using <a href="Ash.Query.xhtml#load/2"><code class="inline">Ash.Query.load/2</code></a>, or after the fact using <a href="Ash.xhtml#load/3"><code class="inline">Ash.load/3</code></a>. Calculations declared on the resource will be keys in the resource's struct.</p><h2 id="custom-calculations-in-the-query">Custom calculations in the query</h2><p>Example:</p><pre><code class="makeup elixir" translate="no"><span class="nc">User</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">calculate</span><span class="p" data-group-id="9901478429-1">(</span><span class="ss">:full_name</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9901478429-2">{</span><span class="nc">Concat</span><span class="p">,</span><span class="w"> </span><span class="ss">keys</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9901478429-3">[</span><span class="ss">:first_name</span><span class="p">,</span><span class="w"> </span><span class="ss">:last_name</span><span class="p" data-group-id="9901478429-3">]</span><span class="p" data-group-id="9901478429-2">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9901478429-4">%{</span><span class="ss">separator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="9901478429-4">}</span><span class="p" data-group-id="9901478429-1">)</span></code></pre><p>See the documentation for <a href="Ash.Query.xhtml#calculate/4"><code class="inline">Ash.Query.calculate/4</code></a> for more information.</p><h2 id="arguments-in-calculations">Arguments in calculations</h2><p>Using the above example with arguments, you can load a calculation with arguments like so:</p><pre><code class="makeup elixir" translate="no"><span class="n">load</span><span class="p" data-group-id="9941917162-1">(</span><span class="ss">full_name</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9941917162-2">[</span><span class="ss">separator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="9941917162-2">]</span><span class="p" data-group-id="9941917162-1">)</span></code></pre><p>If the calculation uses an expression, you can also filter and sort on it like so:</p><pre><code class="makeup elixir" translate="no"><span class="n">query</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="6990323989-1">(</span><span class="n">full_name</span><span class="p" data-group-id="6990323989-2">(</span><span class="ss">separator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p" data-group-id="6990323989-2">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;Zach Daniel&quot;</span><span class="p" data-group-id="6990323989-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">sort</span><span class="p" data-group-id="6990323989-3">(</span><span class="ss">full_name</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6990323989-4">{</span><span class="p" data-group-id="6990323989-5">%{</span><span class="ss">separator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p" data-group-id="6990323989-5">}</span><span class="p">,</span><span class="w"> </span><span class="ss">:asc</span><span class="p" data-group-id="6990323989-4">}</span><span class="p" data-group-id="6990323989-3">)</span></code></pre><h2 id="loading-calculations">Loading Calculations</h2><p>When loading calculations, you specify them in the load statement just like relationships and aggregates.</p><pre><code class="makeup elixir" translate="no"><span class="c1"># load</span><span class="w">
</span><span class="nc">Ash</span><span class="o">.</span><span class="n">load!</span><span class="p" data-group-id="3001712519-1">(</span><span class="n">user</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="3001712519-2">[</span><span class="ss">full_name</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="3001712519-3">%{</span><span class="ss">separator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p" data-group-id="3001712519-3">}</span><span class="p" data-group-id="3001712519-2">]</span><span class="p" data-group-id="3001712519-1">)</span><span class="w">
</span><span class="c1"># =&gt; %User{full_name: &quot;Zach,Daniel&quot;}</span></code></pre><h3 id="loading-with-a-custom-name">Loading with a custom name</h3><p>Every record in Ash also has a <code class="inline">calculations</code> field, where arbitrarily named calculations can live.
See <a href="Ash.Query.xhtml#calculate/4"><code class="inline">Ash.Query.calculate/4</code></a> for more. To do this with <code class="inline">load</code> statements, you use the reserved
<code class="inline">as</code> key in the calculation arguments.</p><pre><code class="makeup elixir" translate="no"><span class="c1"># load</span><span class="w">
</span><span class="nc">Ash</span><span class="o">.</span><span class="n">load!</span><span class="p" data-group-id="6559042499-1">(</span><span class="n">user</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6559042499-2">[</span><span class="w">
  </span><span class="ss">full_name</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6559042499-3">%{</span><span class="ss">separator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="ss">:full_name_with_spaces</span><span class="p" data-group-id="6559042499-3">}</span><span class="p">,</span><span class="w">
  </span><span class="ss">full_name</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6559042499-4">%{</span><span class="ss">separator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">,</span><span class="w"> </span><span class="ss">as</span><span class="p">:</span><span class="w"> </span><span class="ss">:full_name_with_commas</span><span class="p" data-group-id="6559042499-4">}</span><span class="w">
</span><span class="p" data-group-id="6559042499-2">]</span><span class="p" data-group-id="6559042499-1">)</span><span class="w">
</span><span class="c1"># =&gt; %User{calculations: %{full_name_with_spaces: &quot;Zach Daniel&quot;, full_name_with_commas: &quot;Zach,Daniel&quot;}}</span></code></pre><h3 id="loading-through-calculations">Loading &quot;through&quot; calculations</h3><p>If you have calculations that produce records, or loadable types like <a href="Ash.Type.Map.xhtml"><code class="inline">Ash.Type.Map</code></a> and <a href="Ash.Type.Struct.xhtml"><code class="inline">Ash.Type.Struct</code></a>
you can load further things on those records by providing a tuple of calculation input and further load statements.</p><pre><code class="makeup elixir" translate="no"><span class="c1"># here is a map type that contains a user and a status</span><span class="w">
</span><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.Types.UserAndStatus</span><span class="w"> </span><span class="k" data-group-id="6181986471-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Ash.Type.NewType</span><span class="p">,</span><span class="w"> </span><span class="ss">subtype_of</span><span class="p">:</span><span class="w"> </span><span class="ss">:map</span><span class="p">,</span><span class="w"> </span><span class="ss">constraints</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6181986471-2">[</span><span class="w">
    </span><span class="ss">fields</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6181986471-3">[</span><span class="w">
      </span><span class="ss">user</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6181986471-4">[</span><span class="w">
        </span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="ss">:struct</span><span class="p">,</span><span class="w">
        </span><span class="ss">instance_of</span><span class="p">:</span><span class="w"> </span><span class="nc">MyApp.User</span><span class="w">
      </span><span class="p" data-group-id="6181986471-4">]</span><span class="p">,</span><span class="w">
      </span><span class="ss">status</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6181986471-5">[</span><span class="w">
        </span><span class="ss">type</span><span class="p">:</span><span class="w"> </span><span class="ss">:atom</span><span class="p">,</span><span class="w">
        </span><span class="ss">constraints</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6181986471-6">[</span><span class="ss">one_of</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="6181986471-7">[</span><span class="ss">:active</span><span class="p">,</span><span class="w"> </span><span class="ss">:inactive</span><span class="p" data-group-id="6181986471-7">]</span><span class="p" data-group-id="6181986471-6">]</span><span class="w">
      </span><span class="p" data-group-id="6181986471-5">]</span><span class="w">
    </span><span class="p" data-group-id="6181986471-3">]</span><span class="w">
  </span><span class="p" data-group-id="6181986471-2">]</span><span class="w">
</span><span class="k" data-group-id="6181986471-1">end</span><span class="w">

</span><span class="c1"># on our organization resource, we might have a calculation that returns a user and their status</span><span class="w">
</span><span class="n">calculate</span><span class="w"> </span><span class="ss">:user_statuses</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="6181986471-8">{</span><span class="ss">:array</span><span class="p">,</span><span class="w"> </span><span class="nc">MyApp.Types.UserAndStatus</span><span class="p" data-group-id="6181986471-8">}</span><span class="p">,</span><span class="w"> </span><span class="nc">GetUsersAndTheirStatuses</span></code></pre><p>You could then load this calculation like so:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ash</span><span class="o">.</span><span class="n">load!</span><span class="p" data-group-id="6490416550-1">(</span><span class="n">organization</span><span class="p">,</span><span class="w"> </span><span class="ss">:user_statuses</span><span class="p" data-group-id="6490416550-1">)</span><span class="w">
</span><span class="c1"># =&gt; [%{user: %User{}, status: :active}, %{user: %User{}, status: :inactive}]</span></code></pre><p>But what if you wanted additional fields from the calculated user? To do this, we provide
a tuple of additional loads alongside their arguments. Maps support loading &quot;through&quot;
fields by using the configured fields in the map and providing further loads.</p><pre><code class="makeup elixir" translate="no"><span class="c1"># {arguments, additional_load_statement}</span><span class="w">
</span><span class="nc">Ash</span><span class="o">.</span><span class="n">load!</span><span class="p" data-group-id="9255129517-1">(</span><span class="n">organization</span><span class="p">,</span><span class="w"> </span><span class="ss">user_statuses</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9255129517-2">{</span><span class="p" data-group-id="9255129517-3">%{</span><span class="p" data-group-id="9255129517-3">}</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9255129517-4">[</span><span class="ss">user</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9255129517-5">[</span><span class="ss">full_name</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="9255129517-6">%{</span><span class="ss">separator</span><span class="p">:</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p" data-group-id="9255129517-6">}</span><span class="p" data-group-id="9255129517-5">]</span><span class="p" data-group-id="9255129517-4">]</span><span class="p" data-group-id="9255129517-2">}</span><span class="p" data-group-id="9255129517-1">)</span><span class="p">,</span><span class="w">
</span><span class="c1"># =&gt; [%{user: %User{full_name: &quot;Zach Daniel&quot;}, status: :active}, %{user: %User{full_name: &quot;Tobey Maguire&quot;}, status: :inactive}]</span></code></pre>

  </body>
</html>
