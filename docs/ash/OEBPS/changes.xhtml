<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Changes - ash v3.5.33</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Changes</h1>
<p>Changes are the primary way of customizing create/update/destroy action behavior. If you are familiar with <a href="https://hexdocs.pm/plug/1.18.1/Plug.html"><code class="inline">Plug</code></a>, you can think of an <a href="Ash.Resource.Change.xhtml"><code class="inline">Ash.Resource.Change</code></a> as the equivalent of a <a href="https://hexdocs.pm/plug/1.18.1/Plug.html"><code class="inline">Plug</code></a> for changesets. At its most basic, a change will take a changeset and return a new changeset. Changes can be simple, like setting or modifying an attribute value, or more complex, attaching hooks to be executed within the lifecycle of the action.</p><h2 id="builtin-changes">Builtin Changes</h2><p>There are a number of builtin changes that can be used, and are automatically imported into your resources. See <a href="Ash.Resource.Change.Builtins.xhtml"><code class="inline">Ash.Resource.Change.Builtins</code></a> for more.</p><p>Some examples of usage of builtin changes</p><pre><code class="makeup elixir" translate="no"><span class="c1"># set the `owner` to the current actor</span><span class="w">
</span><span class="n">change</span><span class="w"> </span><span class="n">relate_actor</span><span class="p" data-group-id="0563169383-1">(</span><span class="ss">:owner</span><span class="p" data-group-id="0563169383-1">)</span><span class="w">

</span><span class="c1"># set `commited_at` to the current timestamp when the action is called</span><span class="w">
</span><span class="n">change</span><span class="w"> </span><span class="n">set_attribute</span><span class="p" data-group-id="0563169383-2">(</span><span class="ss">:committed_at</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">DateTime</span><span class="o">.</span><span class="n">utc_now</span><span class="o">/</span><span class="mi">0</span><span class="p" data-group-id="0563169383-2">)</span><span class="w">

</span><span class="c1"># optimistic lock using the `version` attribute</span><span class="w">
</span><span class="n">change</span><span class="w"> </span><span class="n">optimistic_lock</span><span class="p" data-group-id="0563169383-3">(</span><span class="ss">:version</span><span class="p" data-group-id="0563169383-3">)</span></code></pre><h2 id="custom-changes">Custom Changes</h2><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.Changes.Slugify</span><span class="w"> </span><span class="k" data-group-id="4002061735-1">do</span><span class="w">

  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Ash.Resource.Change</span><span class="w">

  </span><span class="c1"># transform and validate opts</span><span class="w">
  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p" data-group-id="4002061735-2">(</span><span class="n">opts</span><span class="p" data-group-id="4002061735-2">)</span><span class="w"> </span><span class="k" data-group-id="4002061735-3">do</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="n">is_atom</span><span class="p" data-group-id="4002061735-4">(</span><span class="n">opts</span><span class="p" data-group-id="4002061735-5">[</span><span class="ss">:attribute</span><span class="p" data-group-id="4002061735-5">]</span><span class="p" data-group-id="4002061735-4">)</span><span class="w"> </span><span class="k" data-group-id="4002061735-6">do</span><span class="w">
      </span><span class="p" data-group-id="4002061735-7">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="4002061735-7">}</span><span class="w">
    </span><span class="k" data-group-id="4002061735-6">else</span><span class="w">
      </span><span class="p" data-group-id="4002061735-8">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;attribute must be an atom!&quot;</span><span class="p" data-group-id="4002061735-8">}</span><span class="w">
    </span><span class="k" data-group-id="4002061735-6">end</span><span class="w">
  </span><span class="k" data-group-id="4002061735-3">end</span><span class="w">

  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">change</span><span class="p" data-group-id="4002061735-9">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="c">_context</span><span class="p" data-group-id="4002061735-9">)</span><span class="w"> </span><span class="k" data-group-id="4002061735-10">do</span><span class="w">
    </span><span class="k">case</span><span class="w"> </span><span class="nc">Ash.Changeset</span><span class="o">.</span><span class="n">fetch_change</span><span class="p" data-group-id="4002061735-11">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="4002061735-12">[</span><span class="ss">:attribute</span><span class="p" data-group-id="4002061735-12">]</span><span class="p" data-group-id="4002061735-11">)</span><span class="w"> </span><span class="k" data-group-id="4002061735-13">do</span><span class="w">
      </span><span class="p" data-group-id="4002061735-14">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">new_value</span><span class="p" data-group-id="4002061735-14">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="n">slug</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nc">String</span><span class="o">.</span><span class="n">replace</span><span class="p" data-group-id="4002061735-15">(</span><span class="n">new_value</span><span class="p">,</span><span class="w"> </span><span class="sr">~r/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-&quot;</span><span class="p" data-group-id="4002061735-15">)</span><span class="w">
        </span><span class="nc">Ash.Changeset</span><span class="o">.</span><span class="n">force_change_attribute</span><span class="p" data-group-id="4002061735-16">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="4002061735-17">[</span><span class="ss">:attribute</span><span class="p" data-group-id="4002061735-17">]</span><span class="p">,</span><span class="w"> </span><span class="n">slug</span><span class="p" data-group-id="4002061735-16">)</span><span class="w">
      </span><span class="ss">:error</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
        </span><span class="n">changeset</span><span class="w">
    </span><span class="k" data-group-id="4002061735-13">end</span><span class="w">
  </span><span class="k" data-group-id="4002061735-10">end</span><span class="w">
</span><span class="k" data-group-id="4002061735-1">end</span></code></pre><p>This could then be used in a resource via:</p><pre><code class="makeup elixir" translate="no"><span class="n">change</span><span class="w"> </span><span class="p" data-group-id="2614521659-1">{</span><span class="nc">MyApp.Changes.Slugify</span><span class="p">,</span><span class="w"> </span><span class="ss">attribute</span><span class="p">:</span><span class="w"> </span><span class="ss">:foo</span><span class="p" data-group-id="2614521659-1">}</span></code></pre><h2 id="anonymous-function-changes">Anonymous Function Changes</h2><p>You can also use anonymous functions for changes. Keep in mind, these cannot be made atomic, or support batching. This is great for prototyping, but we generally recommend using a module, both for organizational purposes, and to allow adding atomic/batch behavior.</p><pre><code class="makeup elixir" translate="no"><span class="n">change</span><span class="w"> </span><span class="k" data-group-id="1445234806-1">fn</span><span class="w"> </span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="c">_context</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="c1"># put your code here</span><span class="w">
</span><span class="k" data-group-id="1445234806-1">end</span></code></pre><h2 id="where">Where</h2><p>The <code class="inline">where</code> can be used to perform changes conditionally. This functions by running the validations in the <code class="inline">where</code>, and if the validation returns an error, we discard the error and skip the operation. This means that even custom validations can be used in conditions.</p><p>For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">change</span><span class="w"> </span><span class="p" data-group-id="9199321383-1">{</span><span class="nc">Slugify</span><span class="p">,</span><span class="w"> </span><span class="ss">attribute</span><span class="p">:</span><span class="w"> </span><span class="ss">:foo</span><span class="p" data-group-id="9199321383-1">}</span><span class="w"> </span><span class="k" data-group-id="9199321383-2">do</span><span class="w">
  </span><span class="n">where</span><span class="w"> </span><span class="p" data-group-id="9199321383-3">[</span><span class="n">attribute_equals</span><span class="p" data-group-id="9199321383-4">(</span><span class="ss">:slugify</span><span class="p">,</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9199321383-4">)</span><span class="p" data-group-id="9199321383-3">]</span><span class="w">
</span><span class="k" data-group-id="9199321383-2">end</span></code></pre><h2 id="action-vs-global-changes">Action vs Global Changes</h2><p>You can place a change on any create, update, or destroy action. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">actions</span><span class="w"> </span><span class="k" data-group-id="1799677732-1">do</span><span class="w">
  </span><span class="n">create</span><span class="w"> </span><span class="ss">:create</span><span class="w"> </span><span class="k" data-group-id="1799677732-2">do</span><span class="w">
    </span><span class="n">change</span><span class="w"> </span><span class="p" data-group-id="1799677732-3">{</span><span class="nc">Slugify</span><span class="p">,</span><span class="w"> </span><span class="ss">attribute</span><span class="p">:</span><span class="w"> </span><span class="ss">:name</span><span class="p" data-group-id="1799677732-3">}</span><span class="w">
  </span><span class="k" data-group-id="1799677732-2">end</span><span class="w">
</span><span class="k" data-group-id="1799677732-1">end</span></code></pre><p>Or you can use the global changes block to apply to all actions of a given type. Where statements can be used in both cases. Use <code class="inline">on</code> to determine the types of actions the validation runs on. By default, it only runs on create and update actions.</p><pre><code class="makeup elixir" translate="no"><span class="n">changes</span><span class="w"> </span><span class="k" data-group-id="0046847709-1">do</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="p" data-group-id="0046847709-2">{</span><span class="nc">Slugify</span><span class="p">,</span><span class="w"> </span><span class="ss">attribute</span><span class="p">:</span><span class="w"> </span><span class="ss">:name</span><span class="p" data-group-id="0046847709-2">}</span><span class="w"> </span><span class="k" data-group-id="0046847709-3">do</span><span class="w">
    </span><span class="n">on</span><span class="w"> </span><span class="p" data-group-id="0046847709-4">[</span><span class="ss">:create</span><span class="p" data-group-id="0046847709-4">]</span><span class="w">
  </span><span class="k" data-group-id="0046847709-3">end</span><span class="w">
</span><span class="k" data-group-id="0046847709-1">end</span></code></pre><p>The changes section allows you to add changes across multiple actions of a resource.</p><section role="note" class="admonition warning"><h3 id="running-on-destroy-actions" class="admonition-title warning">Running on destroy actions</h3><p>By default, changes in the global <code class="inline">changes</code> block will run on create and update only. Many changes don't make sense in the context of destroys. To make them run on destroy, use <code class="inline">on: [:create, :update, :destroy]</code></p></section><h3 id="examples">Examples</h3><pre><code class="makeup elixir" translate="no"><span class="n">changes</span><span class="w"> </span><span class="k" data-group-id="7184057470-1">do</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">relate_actor</span><span class="p" data-group-id="7184057470-2">(</span><span class="ss">:owner</span><span class="p" data-group-id="7184057470-2">)</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">set_attribute</span><span class="p" data-group-id="7184057470-3">(</span><span class="ss">:committed_at</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="nc">DateTime</span><span class="o">.</span><span class="n">utc_now</span><span class="o">/</span><span class="mi">0</span><span class="p" data-group-id="7184057470-3">)</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="n">optimistic_lock</span><span class="p" data-group-id="7184057470-4">(</span><span class="ss">:version</span><span class="p" data-group-id="7184057470-4">)</span><span class="p">,</span><span class="w"> </span><span class="ss">on</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7184057470-5">[</span><span class="ss">:create</span><span class="p">,</span><span class="w"> </span><span class="ss">:update</span><span class="p">,</span><span class="w"> </span><span class="ss">:destroy</span><span class="p" data-group-id="7184057470-5">]</span><span class="w">
  </span><span class="n">change</span><span class="w"> </span><span class="p" data-group-id="7184057470-6">{</span><span class="nc">Slugify</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="7184057470-7">[</span><span class="ss">attribute</span><span class="p">:</span><span class="w"> </span><span class="ss">:foo</span><span class="p" data-group-id="7184057470-7">]</span><span class="p" data-group-id="7184057470-6">}</span><span class="p">,</span><span class="w"> </span><span class="ss">on</span><span class="p">:</span><span class="w"> </span><span class="ss">:create</span><span class="w">
</span><span class="k" data-group-id="7184057470-1">end</span></code></pre><h2 id="atomic-changes">Atomic Changes</h2><p>To make a change atomic, you have to implement the <a href="Ash.Resource.Change.xhtml#c:atomic/3"><code class="inline">Ash.Resource.Change.atomic/3</code></a> callback. This callback returns a map of changes to attributes that should be changed atomically. We will also honor any <a href="Ash.Resource.Change.xhtml#c:after_batch/3"><code class="inline">Ash.Resource.Change.after_batch/3</code></a> functionality to run code after atomic changes have been applied (only if <code class="inline">atomic/3</code> callback has also been defined). Note that <a href="Ash.Resource.Change.xhtml#c:before_batch/3"><code class="inline">Ash.Resource.Change.before_batch/3</code></a> is not supported in this scenario and will be ignored.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.Changes.Slugify</span><span class="w"> </span><span class="k" data-group-id="9537572998-1">do</span><span class="w">
  </span><span class="c1"># transform and validate opts</span><span class="w">

  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Ash.Resource.Change</span><span class="w">

  </span><span class="n">...</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">atomic</span><span class="p" data-group-id="9537572998-2">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p" data-group-id="9537572998-2">)</span><span class="w"> </span><span class="k" data-group-id="9537572998-3">do</span><span class="w">
    </span><span class="p" data-group-id="9537572998-4">{</span><span class="ss">:atomic</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="9537572998-5">%{</span><span class="w">
      </span><span class="n">opts</span><span class="p" data-group-id="9537572998-6">[</span><span class="ss">:attribute</span><span class="p" data-group-id="9537572998-6">]</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="9537572998-7">(</span><span class="w">
        </span><span class="n">fragment</span><span class="p" data-group-id="9537572998-8">(</span><span class="s">&quot;regexp_replace(?, ?, ?)&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">^</span><span class="n">ref</span><span class="p" data-group-id="9537572998-9">(</span><span class="n">opts</span><span class="p" data-group-id="9537572998-10">[</span><span class="ss">:attribute</span><span class="p" data-group-id="9537572998-10">]</span><span class="p" data-group-id="9537572998-9">)</span><span class="p">,</span><span class="w"> </span><span class="sr">~r/</span><span class="se">\s</span><span class="sr">+/</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-&quot;</span><span class="p" data-group-id="9537572998-8">)</span><span class="w">
      </span><span class="p" data-group-id="9537572998-7">)</span><span class="w">
    </span><span class="p" data-group-id="9537572998-5">}</span><span class="p" data-group-id="9537572998-4">}</span><span class="w">
  </span><span class="k" data-group-id="9537572998-3">end</span><span class="w">
</span><span class="k" data-group-id="9537572998-1">end</span></code></pre><p>In some cases, changes operate only on arguments or context, or otherwise can do their work regardless of atomicity. In these cases, you can make your atomic callback call the <code class="inline">change/3</code> function</p><pre><code class="makeup elixir" translate="no"><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">atomic</span><span class="p" data-group-id="9279371929-1">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p" data-group-id="9279371929-1">)</span><span class="w"> </span><span class="k" data-group-id="9279371929-2">do</span><span class="w">
  </span><span class="p" data-group-id="9279371929-3">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">change</span><span class="p" data-group-id="9279371929-4">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p" data-group-id="9279371929-4">)</span><span class="p" data-group-id="9279371929-3">}</span><span class="w">
</span><span class="k" data-group-id="9279371929-2">end</span></code></pre><p>In other cases, a change may not be necessary in a fully atomic action. For this, you can simply return <code class="inline">:ok</code></p><pre><code class="makeup elixir" translate="no"><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">atomic</span><span class="p" data-group-id="5291243953-1">(</span><span class="c">_changeset</span><span class="p">,</span><span class="w"> </span><span class="c">_opts</span><span class="p">,</span><span class="w"> </span><span class="c">_context</span><span class="p" data-group-id="5291243953-1">)</span><span class="w"> </span><span class="k" data-group-id="5291243953-2">do</span><span class="w">
  </span><span class="ss">:ok</span><span class="w">
</span><span class="k" data-group-id="5291243953-2">end</span></code></pre><h2 id="batches">Batches</h2><p>Changes can support being run on batches of changesets, using the <a href="Ash.Resource.Change.xhtml#c:batch_change/3"><code class="inline">Ash.Resource.Change.batch_change/3</code></a>, <a href="Ash.Resource.Change.xhtml#c:before_batch/3"><code class="inline">Ash.Resource.Change.before_batch/3</code></a>, and <a href="Ash.Resource.Change.xhtml#c:after_batch/3"><code class="inline">Ash.Resource.Change.after_batch/3</code></a> callbacks.</p><section role="note" class="admonition warning"><h3 id="when-do-we-use-batch-callbacks" class="admonition-title warning">When do we use batch callbacks?</h3><p><a href="Ash.Resource.Change.xhtml#c:batch_change/3"><code class="inline">Ash.Resource.Change.batch_change/3</code></a> must be defined for <a href="Ash.Resource.Change.xhtml#c:before_batch/3"><code class="inline">Ash.Resource.Change.before_batch/3</code></a> and <a href="Ash.Resource.Change.xhtml#c:after_batch/3"><code class="inline">Ash.Resource.Change.after_batch/3</code></a> to be called!</p><p>The one exception is that <code class="inline">after_batch/3</code> is called after atomic changes as well as batches, so it will be called in cases that <code class="inline">atomic/3</code> is defined. <code class="inline">before_batch/3</code> is ignored when calling changes atomically.</p></section><p>For some changes, this may not be necessary at all, i.e the <code class="inline">Slugify</code> example has no benefit from batching. If no batch callbacks are added, your change will be run on a loop over the changesets. For the sake of example, however, we will show what it might look like to implement batching for our <code class="inline">Slugify</code> example.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.Changes.Slugify</span><span class="w"> </span><span class="k" data-group-id="1206297894-1">do</span><span class="w">
  </span><span class="c1"># transform and validate opts</span><span class="w">

  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Ash.Resource.Change</span><span class="w">

  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">init</span><span class="p" data-group-id="1206297894-2">(</span><span class="n">opts</span><span class="p" data-group-id="1206297894-2">)</span><span class="w"> </span><span class="k" data-group-id="1206297894-3">do</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="n">is_atom</span><span class="p" data-group-id="1206297894-4">(</span><span class="n">opts</span><span class="p" data-group-id="1206297894-5">[</span><span class="ss">:attribute</span><span class="p" data-group-id="1206297894-5">]</span><span class="p" data-group-id="1206297894-4">)</span><span class="w"> </span><span class="k" data-group-id="1206297894-6">do</span><span class="w">
      </span><span class="p" data-group-id="1206297894-7">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p" data-group-id="1206297894-7">}</span><span class="w">
    </span><span class="k" data-group-id="1206297894-6">else</span><span class="w">
      </span><span class="p" data-group-id="1206297894-8">{</span><span class="ss">:error</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;attribute must be an atom!&quot;</span><span class="p" data-group-id="1206297894-8">}</span><span class="w">
    </span><span class="k" data-group-id="1206297894-6">end</span><span class="w">
  </span><span class="k" data-group-id="1206297894-3">end</span><span class="w">

  </span><span class="na">@impl</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">batch_change</span><span class="p" data-group-id="1206297894-9">(</span><span class="n">changeset</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p" data-group-id="1206297894-9">)</span><span class="w"> </span><span class="k" data-group-id="1206297894-10">do</span><span class="w">
    </span><span class="c1"># here we could run queries or do common work required</span><span class="w">
    </span><span class="c1"># for a given batch of changesets.</span><span class="w">
    </span><span class="c1"># in this example, however, we just return the changesets with</span><span class="w">
    </span><span class="c1"># the change logic applied.</span><span class="w">
    </span><span class="nc">Enum</span><span class="o">.</span><span class="n">map</span><span class="p" data-group-id="1206297894-11">(</span><span class="n">changesets</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">change</span><span class="p" data-group-id="1206297894-12">(</span><span class="ni">&amp;1</span><span class="p">,</span><span class="w"> </span><span class="n">opts</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p" data-group-id="1206297894-12">)</span><span class="p" data-group-id="1206297894-11">)</span><span class="w">
  </span><span class="k" data-group-id="1206297894-10">end</span><span class="w">
</span><span class="k" data-group-id="1206297894-1">end</span></code></pre>

  </body>
</html>
