<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
      xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Policies - ash v3.5.33</title>
    <meta name="generator" content="ExDoc v0.38.2" />
    <link type="text/css" rel="stylesheet" href="dist/epub-elixir-FNUUKFP7.css" />
    <script src="dist/epub-4WIP524F.js"></script>

  </head>
  <body class="content-inner">

    <h1 id="content">Policies</h1>
<p>Policies determine what actions on a resource are permitted for a given actor, and can also filter the results of read actions to restrict the results to only records that should be visible.</p><p>To restrict access to specific fields (attributes, aggregates, calculations), see the section on field policies.</p><p>Read and understand the <a href="actors-and-authorization.xhtml">Actors &amp; Authorization guide</a> before proceeding, which explains actors, how to set them, and other relevant configurations.</p><h2 id="setup">Setup</h2><p>You'll need to add the extension to your resource, like so:</p><pre><code class="makeup elixir" translate="no"><span class="kn">use</span><span class="w"> </span><span class="nc">Ash.Resource</span><span class="p">,</span><span class="w"> </span><span class="ss">authorizers</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4603851960-1">[</span><span class="nc">Ash.Policy.Authorizer</span><span class="p" data-group-id="4603851960-1">]</span></code></pre><p>Then you can start defining policies for your resource.</p><h2 id="policies">Policies</h2><h3 id="anatomy-of-a-policy">Anatomy of a Policy</h3><p>Each policy defined in a resource has two parts -</p><ul><li>a condition or a list of conditions, such as <code class="inline">action_type(:read)</code>, <code class="inline">[action_type(:read), actor_attribute_equals(:admin, true)]</code> or <code class="inline">always()</code>. If the condition, or all conditions if given a list are true for a given action request, then the policy will be applied to the request.</li><li>a set of policy checks, each of which will be evaluated individually if a policy applies to a request.</li></ul><p>If more than one policy applies to any given request (eg. an admin actor calls a read action) then <strong>all applicable policies must pass</strong> for the action to be performed.</p><p>A policy will produce one of three results: <code class="inline">:forbidden</code>, <code class="inline">:authorized</code>, or <code class="inline">:unknown</code>. <code class="inline">:unknown</code> is treated the same as <code class="inline">:forbidden</code>.</p><h3 id="the-simplest-policy">The Simplest Policy</h3><p>Let's start with the simplest (most permissive) policy:</p><pre><code class="makeup elixir" translate="no"><span class="n">policies</span><span class="w"> </span><span class="k" data-group-id="9599501980-1">do</span><span class="w">
  </span><span class="n">policy</span><span class="w"> </span><span class="n">always</span><span class="p" data-group-id="9599501980-2">(</span><span class="p" data-group-id="9599501980-2">)</span><span class="w"> </span><span class="k" data-group-id="9599501980-3">do</span><span class="w">
    </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">always</span><span class="p" data-group-id="9599501980-4">(</span><span class="p" data-group-id="9599501980-4">)</span><span class="w">
  </span><span class="k" data-group-id="9599501980-3">end</span><span class="w">
</span><span class="k" data-group-id="9599501980-1">end</span></code></pre><p>The first argument to <code class="inline">policy</code> is the condition. In this case, the condition is <code class="inline">always()</code> - a built-in helper always returning true, meaning that the policy applies to every request.</p><p>Within this policy we have a single policy check, declared with <code class="inline">authorize_if</code>. Checks logically apply from top to bottom, based on their check type. In this case, we'd read the policy as &quot;this policy always applies, and authorizes always&quot;.</p><p>There are four check types, all of which do what they sound like they do:</p><ul><li><code class="inline">authorize_if</code> - if the check is true, the whole policy is authorized.</li><li><code class="inline">authorize_unless</code> - if the check is false, the whole policy is authorized.</li><li><code class="inline">forbid_if</code> - if the check is true, the whole policy is forbidden.</li><li><code class="inline">forbid_unless</code> - if the check is false, the whole policy is forbidden.</li></ul><p>If a single check does not explicitly authorize or forbid the whole policy, then the flow moves to the next check. For example, if an <code class="inline">authorize_if</code> check does NOT return true, this <em>does not mean the whole policy is forbidden</em> - it means that further checking is required.</p><h3 id="policy-with-condition-inside-do-block">Policy with <code class="inline">condition</code> inside <code class="inline">do</code> block</h3><p>A condition or a list of conditions can also be moved inside the <code class="inline">policy</code> block.</p><p>This can make a really long list of conditions easier to read.</p><pre><code class="makeup elixir" translate="no"><span class="n">policies</span><span class="w"> </span><span class="k" data-group-id="8381553951-1">do</span><span class="w">
  </span><span class="n">policy</span><span class="w"> </span><span class="k" data-group-id="8381553951-2">do</span><span class="w">
    </span><span class="n">condition</span><span class="w"> </span><span class="n">always</span><span class="p" data-group-id="8381553951-3">(</span><span class="p" data-group-id="8381553951-3">)</span><span class="w">
    </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">always</span><span class="p" data-group-id="8381553951-4">(</span><span class="p" data-group-id="8381553951-4">)</span><span class="w">
  </span><span class="k" data-group-id="8381553951-2">end</span><span class="w">
</span><span class="k" data-group-id="8381553951-1">end</span></code></pre><h3 id="how-a-decision-is-reached">How a Decision is Reached</h3><p><strong>Not every check in a policy must pass!</strong> This is described above, but is very important so another example is provided here. Checks go from top to bottom, are evaluated independently of each other, and <em>the first one that reaches a decision</em> determines the overall <em>policy result</em>. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="9605561095-1">(</span><span class="ss">:create</span><span class="p" data-group-id="9605561095-1">)</span><span class="w"> </span><span class="k" data-group-id="9605561095-2">do</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="nc">IsSuperUser</span><span class="w">
  </span><span class="n">forbid_if</span><span class="w"> </span><span class="nc">Deactivated</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="nc">IsAdminUser</span><span class="w">
  </span><span class="n">forbid_if</span><span class="w"> </span><span class="nc">RegularUserCanCreate</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="nc">RegularUserAuthorized</span><span class="w">
</span><span class="k" data-group-id="9605561095-2">end</span></code></pre><p>We check those from top to bottom, so the first one of those that returns <code class="inline">:authorized</code> or <code class="inline">:forbidden</code> determines the entire outcome. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">authorize_if</span><span class="w"> </span><span class="nc">IsSuperUser</span><span class="w"> </span><span class="c1"># If this is true, the actor is a superuser</span><span class="w">

</span><span class="c1"># None of the rest of the checks matter, even if the actor is deactivated.</span><span class="w">
</span><span class="n">forbid_if</span><span class="w"> </span><span class="nc">Deactivated</span><span class="w">
</span><span class="n">authorize_if</span><span class="w"> </span><span class="nc">IsAdminUser</span><span class="w">
</span><span class="n">forbid_if</span><span class="w"> </span><span class="nc">RegularUserCanCreate</span><span class="w">
</span><span class="n">authorize_if</span><span class="w"> </span><span class="nc">RegularUserAuthorized</span></code></pre><p>Conversely:</p><pre><code class="makeup elixir" translate="no"><span class="n">authorize_if</span><span class="w"> </span><span class="nc">IsSuperUser</span><span class="w"> </span><span class="c1"># This can be false</span><span class="w">
</span><span class="n">forbid_if</span><span class="w"> </span><span class="nc">Deactivated</span><span class="w"> </span><span class="c1"># This can be false</span><span class="w">
</span><span class="n">authorize_if</span><span class="w"> </span><span class="nc">IsAdminUser</span><span class="w"> </span><span class="c1"># If this is true, then the policy is still authorized.</span><span class="w">

</span><span class="c1"># And none of these checks matter</span><span class="w">
</span><span class="n">forbid_if</span><span class="w"> </span><span class="nc">RegularUserCanCreate</span><span class="w">
</span><span class="n">authorize_if</span><span class="w"> </span><span class="nc">RegularUserAuthorized</span></code></pre><h3 id="not-all-policy-checks-have-yes-no-answers">Not all policy checks have yes/no answers</h3><p>This will be covered in greater detail in <a href="#checks">Checks</a>, but will be briefly mentioned here.</p><p>Ash provides two basic types of policy checks - <em>simple</em> checks and <em>filter</em> checks. Simple checks are what we commonly think of with authorization, and what the above example would suggest - is an actor allowed to perform a given operation, yes or no? But we can also use filter checks - given a list of resources, which ones is an actor allowed to perform the operation on?</p><p>Filter checks are applied to all read actions, including those generated for bulk updates and destroys.</p><h3 id="read-actions-and-filtering-behavior">Read Actions and Filtering Behavior</h3><p>An important characteristic of read actions is that, by default, they are <strong>filtered</strong> by policies rather than returning authorization errors. This means:</p><ul><li>When a user is not allowed to see certain records, those records are simply filtered out of the results</li><li>Instead of receiving a <code class="inline">Forbidden</code> error, users typically get a <code class="inline">NotFound</code> error (for single record queries) or an empty/reduced result set (for multi-record queries)</li><li>This filtering behavior applies to all read actions, including <code class="inline">get</code>, <code class="inline">read</code>, and any custom read actions you define</li></ul><p>For example, if a policy restricts users to only see their own posts, a query for all posts will automatically filter to only return the current user's posts, rather than raising an authorization error. Similarly, attempting to fetch a specific post that belongs to another user will result in a <code class="inline">NotFound</code> error rather than <code class="inline">Forbidden</code>.</p><p>This design is a security feature that prevents <strong>enumeration attacks</strong> and <strong>information disclosure</strong>. By not distinguishing between &quot;record doesn't exist&quot; and &quot;record exists but you can't access it&quot;, the system prevents attackers from probing to discover the existence of protected data, mapping out the system's data structure, or conducting reconnaissance attacks through systematic querying.</p><h4>Bypassing this behavior</h4><p>You can bypass this behavior on a case-by-case basis with the <code class="inline">authorize_with</code> option, for data layers that support error expressions (all of the core ones except <code class="inline">AshSqlite</code>).</p><p>For example, given a post that the user cannot see:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Ash</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="5331137537-1">(</span><span class="nc">Post</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p" data-group-id="5331137537-1">)</span><span class="w">
</span><span class="c1"># * Invalid:</span><span class="w">
</span><span class="c1"># not found</span><span class="w">

</span><span class="nc">Ash</span><span class="o">.</span><span class="n">get!</span><span class="p" data-group-id="5331137537-2">(</span><span class="nc">Post</span><span class="p">,</span><span class="w"> </span><span class="mi">123</span><span class="p">,</span><span class="w"> </span><span class="ss">authorize_with</span><span class="p">:</span><span class="w"> </span><span class="ss">:error</span><span class="p" data-group-id="5331137537-2">)</span><span class="w">
</span><span class="c1"># * Forbidden</span></code></pre><h3 id="bypass-policies">Bypass policies</h3><p>A bypass policy is just like a regular policy, except if a bypass passes, then other policies after it <em>do not need to pass</em>. This can be useful for writing complex access rules, or for a simple rule like &quot;an admin can do anything&quot; without needing to specify it as part of every other policy.</p><h3 id="a-realistic-policy">A realistic policy</h3><p>In this example, we use some of the provided built-in checks.</p><pre><code class="makeup elixir" translate="no"><span class="n">policies</span><span class="w"> </span><span class="k" data-group-id="9260404528-1">do</span><span class="w">
  </span><span class="c1"># Anything you can use in a condition, you can use in a check, and vice-versa</span><span class="w">
  </span><span class="c1"># This policy applies if the actor is a super_user</span><span class="w">
  </span><span class="c1"># Additionally, this policy is declared as a `bypass`. That means that this check is allowed to fail without</span><span class="w">
  </span><span class="c1"># failing the whole request, and that if this check *passes*, the entire request passes.</span><span class="w">
  </span><span class="n">bypass</span><span class="w"> </span><span class="n">actor_attribute_equals</span><span class="p" data-group-id="9260404528-2">(</span><span class="ss">:super_user</span><span class="p">,</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9260404528-2">)</span><span class="w"> </span><span class="k" data-group-id="9260404528-3">do</span><span class="w">
    </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">always</span><span class="p" data-group-id="9260404528-4">(</span><span class="p" data-group-id="9260404528-4">)</span><span class="w">
  </span><span class="k" data-group-id="9260404528-3">end</span><span class="w">

  </span><span class="c1"># This will likely be a common occurrence. Specifically, policies that apply to all read actions</span><span class="w">
  </span><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="9260404528-5">(</span><span class="ss">:read</span><span class="p" data-group-id="9260404528-5">)</span><span class="w"> </span><span class="k" data-group-id="9260404528-6">do</span><span class="w">
    </span><span class="c1"># unless the actor is an active user, forbid</span><span class="w">
    </span><span class="n">forbid_unless</span><span class="w"> </span><span class="n">actor_attribute_equals</span><span class="p" data-group-id="9260404528-7">(</span><span class="ss">:active</span><span class="p">,</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9260404528-7">)</span><span class="w">
    </span><span class="c1"># if the record is marked as public, authorize</span><span class="w">
    </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="9260404528-8">(</span><span class="n">public</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9260404528-8">)</span><span class="w">
    </span><span class="c1"># if the actor is related to the data via that data&#39;s `owner` relationship, authorize</span><span class="w">
    </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">relates_to_actor_via</span><span class="p" data-group-id="9260404528-9">(</span><span class="ss">:owner</span><span class="p" data-group-id="9260404528-9">)</span><span class="w">
  </span><span class="k" data-group-id="9260404528-6">end</span><span class="w">
</span><span class="k" data-group-id="9260404528-1">end</span></code></pre><h2 id="policy-groups">Policy Groups</h2><p>Policy groups are a small abstraction over policies, that allow you to group policies together
that have shared conditions. Each policy inside of a policy group have the same conditions as
their group.</p><pre><code class="makeup elixir" translate="no"><span class="n">policies</span><span class="w"> </span><span class="k" data-group-id="1845768751-1">do</span><span class="w">
  </span><span class="n">policy_group</span><span class="w"> </span><span class="n">actor_attribute_equals</span><span class="p" data-group-id="1845768751-2">(</span><span class="ss">:role</span><span class="p">,</span><span class="w"> </span><span class="ss">:owner</span><span class="p" data-group-id="1845768751-2">)</span><span class="w"> </span><span class="k" data-group-id="1845768751-3">do</span><span class="w">
    </span><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="1845768751-4">(</span><span class="ss">:read</span><span class="p" data-group-id="1845768751-4">)</span><span class="w"> </span><span class="k" data-group-id="1845768751-5">do</span><span class="w">
      </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="1845768751-6">(</span><span class="n">owner_id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="1845768751-7">(</span><span class="ss">:id</span><span class="p" data-group-id="1845768751-7">)</span><span class="p" data-group-id="1845768751-6">)</span><span class="w">
    </span><span class="k" data-group-id="1845768751-5">end</span><span class="w">

    </span><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="1845768751-8">(</span><span class="p" data-group-id="1845768751-9">[</span><span class="ss">:update</span><span class="p">,</span><span class="w"> </span><span class="ss">:destroy</span><span class="p" data-group-id="1845768751-9">]</span><span class="p" data-group-id="1845768751-8">)</span><span class="w"> </span><span class="k" data-group-id="1845768751-10">do</span><span class="w">
      </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="1845768751-11">(</span><span class="n">owner_id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="1845768751-12">(</span><span class="ss">:id</span><span class="p" data-group-id="1845768751-12">)</span><span class="p" data-group-id="1845768751-11">)</span><span class="w">
    </span><span class="k" data-group-id="1845768751-10">end</span><span class="w">

    </span><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="1845768751-13">(</span><span class="ss">:create</span><span class="p" data-group-id="1845768751-13">)</span><span class="w"> </span><span class="k" data-group-id="1845768751-14">do</span><span class="w">
      </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">relating_to_actor</span><span class="p" data-group-id="1845768751-15">(</span><span class="ss">:owner</span><span class="p" data-group-id="1845768751-15">)</span><span class="w">
    </span><span class="k" data-group-id="1845768751-14">end</span><span class="w">
  </span><span class="k" data-group-id="1845768751-3">end</span><span class="w">
</span><span class="k" data-group-id="1845768751-1">end</span></code></pre><h3 id="nesting-policy-groups">Nesting Policy groups</h3><p>Policy groups can be nested. This can help when you have lots of policies and conditions.</p><pre><code class="makeup elixir" translate="no"><span class="n">policies</span><span class="w"> </span><span class="k" data-group-id="0396126564-1">do</span><span class="w">
  </span><span class="n">policy_group</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="k" data-group-id="0396126564-2">do</span><span class="w">
    </span><span class="n">policy_group</span><span class="w"> </span><span class="n">condition2</span><span class="w"> </span><span class="k" data-group-id="0396126564-3">do</span><span class="w">
       </span><span class="n">policy</span><span class="w"> </span><span class="n">condition3</span><span class="w"> </span><span class="k" data-group-id="0396126564-4">do</span><span class="w">
         </span><span class="c1"># This policy applies if condition, condition2, and condition3 are all true</span><span class="w">
       </span><span class="k" data-group-id="0396126564-4">end</span><span class="w">
    </span><span class="k" data-group-id="0396126564-3">end</span><span class="w">
  </span><span class="k" data-group-id="0396126564-2">end</span><span class="w">
</span><span class="k" data-group-id="0396126564-1">end</span></code></pre><h3 id="bypasses">Bypasses</h3><p>Policy groups can <em>not</em> contain bypass policies. The purpose of policy groups is to make it easier to reason
about the behavior of policies. When you see a policy group, you know that no policies inside that group will
interact with policies in other policy groups, unless they also apply.</p><h3 id="access-type">Access Type</h3><p>Policies have an &quot;access type&quot; that determines when they are applied. By default, <code class="inline">access_type</code> is <code class="inline">:filter</code>.
When applied to a read action, <code class="inline">:filter</code> will result in a filtered read. For other action types, the filter will be evaluated
to determine if a forbidden error should be raised.</p><p>There are three access types, and they determine the <em>latest point in the process</em> that any check contained by a policy can be applied.</p><ul><li><code class="inline">strict</code> - All checks must be applied statically. These result in a forbidden error if they are not met.</li><li><code class="inline">filter</code> - All checks must be applied either statically or as a filter. These result in a filtered read if they are not met, and a forbidden error for other action types.</li><li><code class="inline">runtime</code> - This allows checks to be run <em>after</em> the data has been read. It is exceedingly rare that you would need to use this access type.</li></ul><p>For example, given this policy:</p><pre><code class="makeup elixir" translate="no"><span class="n">policy</span><span class="w"> </span><span class="n">action</span><span class="p" data-group-id="5021489801-1">(</span><span class="ss">:read_hidden</span><span class="p" data-group-id="5021489801-1">)</span><span class="w"> </span><span class="k" data-group-id="5021489801-2">do</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">actor_attribute_equals</span><span class="p" data-group-id="5021489801-3">(</span><span class="ss">:is_admin</span><span class="p">,</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="5021489801-3">)</span><span class="w">
</span><span class="k" data-group-id="5021489801-2">end</span></code></pre><p>A non-admin using the <code class="inline">:read_hidden</code> action would see an empty list of records, rather than a forbidden error.</p><p>However, with this policy</p><pre><code class="makeup elixir" translate="no"><span class="n">policy</span><span class="w"> </span><span class="n">action</span><span class="p" data-group-id="2155916714-1">(</span><span class="ss">:read_hidden</span><span class="p" data-group-id="2155916714-1">)</span><span class="w"> </span><span class="k" data-group-id="2155916714-2">do</span><span class="w">
  </span><span class="n">access_type</span><span class="w"> </span><span class="ss">:strict</span><span class="w">

  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">actor_attribute_equals</span><span class="p" data-group-id="2155916714-3">(</span><span class="ss">:is_admin</span><span class="p">,</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="2155916714-3">)</span><span class="w">
</span><span class="k" data-group-id="2155916714-2">end</span></code></pre><p>A non-admin using the <code class="inline">:read_hidden</code> action would see a forbidden error.</p><h3 id="relationships-and-policies">Relationships and Policies</h3><p>A common point of confusion when working with relationships is when they return less results or no results due to policies.
Additionally, when requesting related data that produces a forbidden error, it forbids the <em>entire request</em>.</p><p>For example, if you have a <code class="inline">Post</code>, that <code class="inline">belongs_to</code> <code class="inline">:author</code>, and the user requesting data cannot see the <code class="inline">author</code> due to a <strong>filter</strong> policy,
then you may see something like this:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="4306048320-1">%</span><span class="nc" data-group-id="4306048320-1">MyApp.Post</span><span class="p" data-group-id="4306048320-1">{</span><span class="ss">author</span><span class="p">:</span><span class="w"> </span><span class="no">nil</span><span class="p">,</span><span class="w"> </span><span class="n">...</span><span class="p" data-group-id="4306048320-1">}</span></code></pre><p>Even though it is not possible for a <code class="inline">Post</code> to exist without an associated <code class="inline">:author</code>!</p><p>Additionally, if the user cannot read the <code class="inline">author</code> due to a <code class="inline">:strict</code> policy, if you attempt to load the <code class="inline">:author</code>, the result
of the <strong>entire operation</strong> will be <code class="inline">{:error, %Ash.Error.Forbidden{}}</code>.</p><p>There are two ways that you can improve this behavior</p><h4>The <code class="inline">allow_forbidden_field?</code> Option</h4><p>This option will <strong>default to <code class="inline">true</code></strong> in 4.0. You can adopt this behavior now with the following configuration.</p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">:allow_forbidden_field_for_relationships_by_default?</span><span class="p">,</span><span class="w"> </span><span class="no">true</span></code></pre><p>This option adjusts the relationship reading logic such that, if running a related read action would produce a
forbidden error, the relationship will be set to <code class="inline">%Ash.ForbiddenField{}</code>, instead of forbidding the entire request.</p><p>So in the example above where the <strong>entire operation</strong> fails, you would instead get:</p><pre><code class="makeup elixir" translate="no"><span class="p" data-group-id="4763553618-1">{</span><span class="ss">:ok</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="4763553618-2">%</span><span class="nc" data-group-id="4763553618-2">MyApp.Post</span><span class="p" data-group-id="4763553618-2">{</span><span class="ss">author</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4763553618-3">%</span><span class="nc" data-group-id="4763553618-3">Ash.ForbiddenField</span><span class="p" data-group-id="4763553618-3">{</span><span class="p" data-group-id="4763553618-3">}</span><span class="p" data-group-id="4763553618-2">}</span><span class="p" data-group-id="4763553618-1">}</span></code></pre><h4>The <code class="inline">authorize_read_with</code> Option</h4><p>This option typically only makes sense to apply on <code class="inline">has_one</code> and <code class="inline">belongs_to</code> relationships. This alters the behavior
of policy filtering when loading related records. In our above example, lets say there is a policy like the following
on <code class="inline">MyApp.Author</code>, that prevents us from reading an author that has been deactivated.</p><pre><code class="makeup elixir" translate="no"><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="1028702898-1">(</span><span class="ss">:read</span><span class="p" data-group-id="1028702898-1">)</span><span class="w"> </span><span class="k" data-group-id="1028702898-2">do</span><span class="w">
  </span><span class="n">access_type</span><span class="w"> </span><span class="ss">:filter</span><span class="w"> </span><span class="c1"># This is the default access type. It is here for example.</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="1028702898-3">(</span><span class="n">active</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">false</span><span class="p" data-group-id="1028702898-3">)</span><span class="w">
</span><span class="k" data-group-id="1028702898-2">end</span></code></pre><p>When running a normal read action against that resource, you want any deactivated authors to be filtered out.
However, when reading the <code class="inline">:author</code> relationship, you don't want the author to appear as <code class="inline">nil</code>. This is especially
useful when combined with <code class="inline">allow_forbidden_field? true</code>.</p><p>So lets make our <code class="inline">belongs_to</code> relationship looks like this.</p><pre><code class="makeup elixir" translate="no"><span class="n">belongs_to</span><span class="w"> </span><span class="ss">:author</span><span class="p">,</span><span class="w"> </span><span class="nc">MyApp.Author</span><span class="w"> </span><span class="k" data-group-id="5416872573-1">do</span><span class="w">
  </span><span class="n">allow_nil?</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="n">allow_forbidden_field?</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="n">authorize_read_with</span><span class="w"> </span><span class="ss">:error</span><span class="w">
</span><span class="k" data-group-id="5416872573-1">end</span></code></pre><p>Now, that filter will be applied in such a way that produces an error if any record exists that matches <code class="inline">not(active == false)</code>.</p><p>So a forbidden read of the <code class="inline">:author</code> relationship will never produce a <code class="inline">nil</code> value, nor will it produce an <code class="inline">{:error, %Ash.Error.Forbidden{}}</code>
result. Instead, the value of <code class="inline">:author</code> will be <code class="inline">%Ash.ForbiddenField{}</code>!</p><h2 id="checks">Checks</h2><p>Checks evaluate from top to bottom within a policy. A check can produce one of three results, the same that a policy can produce. While checks are not necessarily evaluated in order, they <em>logically apply</em> in that order, so you may as well think of it in that way. It can be thought of as a step-through algorithm.</p><p>For each check, starting from the top:</p><ul><li>Run the check.<ul><li>If it returns <code class="inline">:authorized</code>, the policy is <code class="inline">:authorized</code></li><li>If it returns <code class="inline">:forbidden</code>, the policy is <code class="inline">:forbidden</code></li><li>If it returns <code class="inline">:unknown</code>, the next check down is checked</li></ul></li></ul><p>For the example from earlier:</p><ul><li><code class="inline">authorize_if IsSuperUser</code><ul><li>If this check succeeds, it returns <code class="inline">:authorized</code>, the whole policy is <code class="inline">:authorized</code>, and checks stop running</li><li>If this check fails, it returns <code class="inline">:unknown</code> and the next check is checked</li></ul></li><li><code class="inline">forbid_if Deactivated</code><ul><li>We only care about this result if the previous check failed, ie. the actor is not a super user.</li><li>If this check succeeds, it returns <code class="inline">:forbidden</code>, the whole policy is <code class="inline">:forbidden</code>, and checks stop running</li><li>If this check fails, it returns <code class="inline">:unknown</code> and the next check is checked</li></ul></li><li><code class="inline">authorize_if IsAdminUser</code><ul><li>We only care about this result if the previous checks failed, ie. the actor is not a super user and is not deactivated.</li><li>If this check succeeds, it returns <code class="inline">:authorized</code>, the whole policy is <code class="inline">:authorized</code> and checks stop running.</li><li>If this check fails, it returns <code class="inline">:unknown</code> and the next check is checked</li></ul></li><li><code class="inline">authorize_if RegularUserAuthorized</code><ul><li>We only care about this result if the previous checks failed, ie. the actor is not a super user, not deactivated and not an admin user.</li><li>If this check succeeds, it returns <code class="inline">:authorized</code>, the whole policy is <code class="inline">:authorized</code> and checks stop running.</li><li>If this check fails, it returns <code class="inline">:unknown</code>. As there are no more checks to run, the whole policy returns <code class="inline">:unknown</code>, which is treated as forbidden and the actor is not allowed to perform the action.</li></ul></li></ul><h3 id="types-of-checks">Types of checks</h3><p>As mentioned earlier, there are two distinct types of checks - <em>simple</em> checks and <em>filter</em> checks. So far we've seen examples of both - let's look in a bit more detail.</p><section role="note" class="admonition neutral"><h4 class="admonition-title neutral">Manual Checks</h4><p>Both simple and filter checks are a subset of a third type of check - a <em>manual</em> check - but you will almost always want to write simple or filter checks.</p></section><h4>Simple checks</h4><p>Simple checks are determined at the outset of a request, and can only cause a request to be authorized or forbidden. These are typically yes/no questions - is the actor an admin? Did the actor create the post they want to call the <code class="inline">update</code> action on? Is the actor old enough to drink alcohol?</p><p>You can write a simple check by creating a new module and using the <a href="Ash.Policy.SimpleCheck.xhtml"><code class="inline">Ash.Policy.SimpleCheck</code></a> module:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.Checks.ActorIsOldEnough</span><span class="w"> </span><span class="k" data-group-id="0578815572-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Ash.Policy.SimpleCheck</span><span class="w">

  </span><span class="c1"># This is used when logging a breakdown of how a policy is applied - see Logging below.</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">describe</span><span class="p" data-group-id="0578815572-2">(</span><span class="bp">_</span><span class="p" data-group-id="0578815572-2">)</span><span class="w"> </span><span class="k" data-group-id="0578815572-3">do</span><span class="w">
    </span><span class="s">&quot;actor is old enough&quot;</span><span class="w">
  </span><span class="k" data-group-id="0578815572-3">end</span><span class="w">

  </span><span class="c1"># The context here may have a changeset, query, resource, and domain module, depending</span><span class="w">
  </span><span class="c1"># on the action being run.</span><span class="w">
  </span><span class="c1"># `match?` should return true or false, and answer the statement being posed in the description,</span><span class="w">
  </span><span class="c1"># i.e &quot;is the actor old enough?&quot;</span><span class="w">
  </span><span class="kd">def</span><span class="w"> </span><span class="nf">match?</span><span class="p" data-group-id="0578815572-4">(</span><span class="p" data-group-id="0578815572-5">%</span><span class="nc" data-group-id="0578815572-5">MyApp.User</span><span class="p" data-group-id="0578815572-5">{</span><span class="ss">age</span><span class="p">:</span><span class="w"> </span><span class="n">age</span><span class="p" data-group-id="0578815572-5">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c">_actor</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="0578815572-6">%{</span><span class="ss">resource</span><span class="p">:</span><span class="w"> </span><span class="nc">MyApp.Beer</span><span class="p" data-group-id="0578815572-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="c">_context</span><span class="p">,</span><span class="w"> </span><span class="c">_opts</span><span class="p" data-group-id="0578815572-4">)</span><span class="w"> </span><span class="k" data-group-id="0578815572-7">do</span><span class="w">
    </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">21</span><span class="w">
  </span><span class="k" data-group-id="0578815572-7">end</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">match?</span><span class="p" data-group-id="0578815572-8">(</span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p">,</span><span class="w"> </span><span class="bp">_</span><span class="p" data-group-id="0578815572-8">)</span><span class="p">,</span><span class="w"> </span><span class="ss">do</span><span class="p">:</span><span class="w"> </span><span class="no">false</span><span class="w">
</span><span class="k" data-group-id="0578815572-1">end</span></code></pre><p>You can then use this module as the check name, as part of a policy:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.Beer</span><span class="w"> </span><span class="k" data-group-id="7742481356-1">do</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">

  </span><span class="n">policies</span><span class="w"> </span><span class="k" data-group-id="7742481356-2">do</span><span class="w">
    </span><span class="n">policy</span><span class="w"> </span><span class="n">action</span><span class="p" data-group-id="7742481356-3">(</span><span class="ss">:drink</span><span class="p" data-group-id="7742481356-3">)</span><span class="w"> </span><span class="k" data-group-id="7742481356-4">do</span><span class="w">
      </span><span class="n">authorize_if</span><span class="w"> </span><span class="nc">MyApp.Checks.ActorIsOldEnough</span><span class="w">
    </span><span class="k" data-group-id="7742481356-4">end</span><span class="w">
  </span><span class="k" data-group-id="7742481356-2">end</span><span class="w">

  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="7742481356-1">end</span></code></pre><p>Ash will internally convert the true/false return value from <code class="inline">match?/3</code> to a <code class="inline">:authorized</code>/<code class="inline">:forbidden</code>/<code class="inline">:unknown</code> response, depending on how the check is being run (ie. whether it's part of an <code class="inline">authorize_if</code>/<code class="inline">forbid_if</code>/etc.)</p><h4>Filter checks</h4><p>Many checks won't return a status yes/no, but instead return a &quot;filter&quot; to apply to a collection of data. They are most commonly used for read actions, but can be used for all types of actions.</p><p>For update and destroy actions, they apply to the data <em>before</em> the action is run.</p><p>For read actions, they will automatically restrict the returned data to be compliant with the filter. Using the drinking example from earlier, we could write a filter check to list only users that are old enough to drink alcohol.</p><p>There are two ways to write a filter check - by creating a module and using the <a href="Ash.Policy.FilterCheck.xhtml"><code class="inline">Ash.Policy.FilterCheck</code></a> module, or by using inline expression syntax.</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.Checks.ActorOverAgeLimit</span><span class="w"> </span><span class="k" data-group-id="3793168655-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">Ash.Policy.FilterCheck</span><span class="w">

  </span><span class="c1"># A description is not necessary, as it will be derived from the filter, but one could be added</span><span class="w">
  </span><span class="c1"># def describe(_opts), do: &quot;actor is over the age limit&quot;</span><span class="w">

  </span><span class="kd">def</span><span class="w"> </span><span class="nf">filter</span><span class="p" data-group-id="3793168655-2">(</span><span class="n">actor</span><span class="p">,</span><span class="w"> </span><span class="c">_authorizer</span><span class="p">,</span><span class="w"> </span><span class="c">_opts</span><span class="p" data-group-id="3793168655-2">)</span><span class="w"> </span><span class="k" data-group-id="3793168655-3">do</span><span class="w">
    </span><span class="n">expr</span><span class="p" data-group-id="3793168655-4">(</span><span class="n">age_limit</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="o">.</span><span class="n">age</span><span class="p" data-group-id="3793168655-4">)</span><span class="w">
  </span><span class="k" data-group-id="3793168655-3">end</span><span class="w">
</span><span class="k" data-group-id="3793168655-1">end</span></code></pre><p>You can then use this module as the check name, as part of a policy:</p><pre><code class="makeup elixir" translate="no"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyApp.User</span><span class="w"> </span><span class="k" data-group-id="9929467738-1">do</span><span class="w">
  </span><span class="c1"># ...</span><span class="w">

  </span><span class="n">policies</span><span class="w"> </span><span class="k" data-group-id="9929467738-2">do</span><span class="w">
    </span><span class="n">policy</span><span class="w"> </span><span class="n">action</span><span class="p" data-group-id="9929467738-3">(</span><span class="ss">:of_drinking_age</span><span class="p" data-group-id="9929467738-3">)</span><span class="w"> </span><span class="k" data-group-id="9929467738-4">do</span><span class="w">
      </span><span class="n">authorize_if</span><span class="w"> </span><span class="nc">MyApp.Checks.ActorOverAgeLimit</span><span class="w">
    </span><span class="k" data-group-id="9929467738-4">end</span><span class="w">
  </span><span class="k" data-group-id="9929467738-2">end</span><span class="w">

  </span><span class="c1"># ...</span><span class="w">
</span><span class="k" data-group-id="9929467738-1">end</span></code></pre><h4>Inline checks</h4><p>Inline checks are filter checks, but are different enough to warrant their own documentation. These are written directly in a policy, eg.</p><pre><code class="makeup elixir" translate="no"><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="0097588343-1">(</span><span class="ss">:read</span><span class="p" data-group-id="0097588343-1">)</span><span class="w"> </span><span class="k" data-group-id="0097588343-2">do</span><span class="w">
  </span><span class="c1"># Allow records with the attribute `public` set to true to be read</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="0097588343-3">(</span><span class="n">public</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="0097588343-3">)</span><span class="w">

  </span><span class="c1"># Allow records with the attribute `level` less than the value of the `level`</span><span class="w">
  </span><span class="c1"># argument to the action to be read</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="0097588343-4">(</span><span class="n">level</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">^</span><span class="n">arg</span><span class="p" data-group-id="0097588343-5">(</span><span class="ss">:level</span><span class="p" data-group-id="0097588343-5">)</span><span class="p" data-group-id="0097588343-4">)</span><span class="w">
</span><span class="k" data-group-id="0097588343-2">end</span></code></pre><h5>Inline checks for create actions</h5><p>When using expressions inside of policies that apply to create actions, you may not reference the data being created. For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="6967725536-1">(</span><span class="ss">:create</span><span class="p" data-group-id="6967725536-1">)</span><span class="w"> </span><span class="k" data-group-id="6967725536-2">do</span><span class="w">
  </span><span class="c1"># This check is fine, as we only reference the actor</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="6967725536-3">(</span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="6967725536-4">(</span><span class="ss">:admin</span><span class="p" data-group-id="6967725536-4">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="6967725536-3">)</span><span class="w">
  </span><span class="c1"># This check is not, because it contains a reference to a field</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="6967725536-5">(</span><span class="n">status</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ss">:active</span><span class="p" data-group-id="6967725536-5">)</span><span class="w">
</span><span class="k" data-group-id="6967725536-2">end</span></code></pre><section role="note" class="admonition info"><h3 id="why-can-t-we-reference-data-in-creates" class="admonition-title info">Why can't we reference data in creates?</h3><p>We cannot allow references to the data being created in create policies, because we do not yet know what the result of the action will be.
For updates and destroys, referencing the data always references the data <em>prior</em> to the action being run, and so it is deterministic.</p></section><p>If a policy that applies to creates, would result in a filter, you will get a <a href="Ash.Error.Forbidden.CannotFilterCreates.xhtml"><code class="inline">Ash.Error.Forbidden.CannotFilterCreates</code></a> at runtime explaining
that you must change your check. Typically this means writing a custom <a href="Ash.Policy.SimpleCheck.xhtml"><code class="inline">Ash.Policy.SimpleCheck</code></a> instead.</p><p>Ash also comes with a set of built-in helpers for writing inline checks - see <a href="Ash.Policy.Check.Builtins.xhtml"><code class="inline">Ash.Policy.Check.Builtins</code></a> for more information.</p><h5>Referencing the actor</h5><p>In expression checks, the <code class="inline">actor</code> template can be used (other templates that may work in filter expressions, for example, are not available). For example:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># Authorize records that have an author relationship with the author ID the same as the actor ID</span><span class="w">
</span><span class="c1"># ie. records authored by the actor</span><span class="w">
</span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="1581913831-1">(</span><span class="n">author</span><span class="o">.</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="1581913831-2">(</span><span class="ss">:id</span><span class="p" data-group-id="1581913831-2">)</span><span class="p" data-group-id="1581913831-1">)</span></code></pre><h5>Using <code class="inline">exists</code></h5><p>A common mistake when using related data in filters is to be too restrictive. Imagine a scenario where you have an action like this:</p><pre><code class="makeup elixir" translate="no"><span class="n">read</span><span class="w"> </span><span class="ss">:friends_of_ted</span><span class="w"> </span><span class="k" data-group-id="7902710137-1">do</span><span class="w">
  </span><span class="n">filter</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="7902710137-2">(</span><span class="n">friends</span><span class="o">.</span><span class="n">first_name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;ted&quot;</span><span class="p" data-group-id="7902710137-2">)</span><span class="w">
</span><span class="k" data-group-id="7902710137-1">end</span></code></pre><p>If this was in a User resource, it would return users that have a friend with the first name &quot;ted&quot;. So far so good. Then someone calls it like so:</p><pre><code class="makeup elixir" translate="no"><span class="nc">Resource</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">for_read</span><span class="p" data-group-id="6092296942-1">(</span><span class="ss">:friends_of_ted</span><span class="p" data-group-id="6092296942-1">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="6092296942-2">(</span><span class="n">friends</span><span class="o">.</span><span class="n">last_name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;dansen&quot;</span><span class="p" data-group-id="6092296942-2">)</span></code></pre><p>The resulting filter is <code class="inline">friends.first_name == &quot;ted&quot; and friends.last_name == &quot;dansen&quot;</code>- this means that you'll get users that have a friend with the full name &quot;ted dansen&quot;. That <em>might</em> be what you meant, but more likely you would want &quot;users that have a friend with the first name &quot;ted&quot;, that also have a friend with the last name 'dansen'&quot;.</p><p>To accomplish that, we can use the <code class="inline">exists</code> helper and rework the example like so:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># There exists a friend with the first name &quot;ted&quot;</span><span class="w">
</span><span class="n">read</span><span class="w"> </span><span class="ss">:friends_of_ted</span><span class="w"> </span><span class="k" data-group-id="4017915707-1">do</span><span class="w">
  </span><span class="n">filter</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="4017915707-2">(</span><span class="n">exists</span><span class="p" data-group-id="4017915707-3">(</span><span class="n">friends</span><span class="p">,</span><span class="w"> </span><span class="n">first_name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;ted&quot;</span><span class="p" data-group-id="4017915707-3">)</span><span class="p" data-group-id="4017915707-2">)</span><span class="w">
</span><span class="k" data-group-id="4017915707-1">end</span><span class="w">

</span><span class="c1"># And there also exists a friend with the last name &quot;dansen&quot;</span><span class="w">
</span><span class="c1"># They may be the same friend if the user is friends with Ted Dansen!</span><span class="w">
</span><span class="nc">Resource</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">for_read</span><span class="p" data-group-id="4017915707-4">(</span><span class="ss">:friends_of_ted</span><span class="p" data-group-id="4017915707-4">)</span><span class="w">
</span><span class="o">|&gt;</span><span class="w"> </span><span class="nc">Ash.Query</span><span class="o">.</span><span class="n">filter</span><span class="p" data-group-id="4017915707-5">(</span><span class="n">exists</span><span class="p" data-group-id="4017915707-6">(</span><span class="n">friends</span><span class="p">,</span><span class="w"> </span><span class="n">last_name</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;dansen&quot;</span><span class="p" data-group-id="4017915707-6">)</span><span class="p" data-group-id="4017915707-5">)</span></code></pre><p>In policies (and often any time you mean &quot;a related thing exists where some condition is true&quot;), it is advised to use <code class="inline">exists/2</code> when referring to relationships because of the way that the policy authorizer may mix &amp; match your policies when building filters. This is also true when adding filters to actions. If you use <code class="inline">exists</code>, then your policies can be used in filters without excluding unnecessary data.</p><h2 id="field-policies">Field Policies</h2><p>Field policies allow you to authorize access to specific fields via policies scoped to fields.</p><p>For example:</p><pre><code class="makeup elixir" translate="no"><span class="n">field_policies</span><span class="w"> </span><span class="k" data-group-id="6595523027-1">do</span><span class="w">
  </span><span class="n">field_policy</span><span class="w"> </span><span class="ss">:role</span><span class="w"> </span><span class="k" data-group-id="6595523027-2">do</span><span class="w">
    </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">actor_attribute_equals</span><span class="p" data-group-id="6595523027-3">(</span><span class="ss">:role</span><span class="p">,</span><span class="w"> </span><span class="ss">:supervisor</span><span class="p" data-group-id="6595523027-3">)</span><span class="w">
  </span><span class="k" data-group-id="6595523027-2">end</span><span class="w">
</span><span class="k" data-group-id="6595523027-1">end</span></code></pre><p>If <em>any</em> field policies exist then <em>all</em> fields must be authorized by a field policy.
If you want a &quot;deny-list&quot; style, then you can add policies for specific fields.
and add a catch-all policy using the special field name <code class="inline">:*</code>. All policies that apply
to a field must be authorized.</p><p>The only exception to the above behavior is primary keys, which can always be read by everyone.</p><p>Additionally, keep in mind that adding <a href="Ash.Policy.Authorizer.xhtml"><code class="inline">Ash.Policy.Authorizer</code></a> will require that all actions
pass policies. If you want to just add field policies, you will need to add a policy that allows
all access explicitly, i.e</p><pre><code class="makeup elixir" translate="no"><span class="n">policies</span><span class="w"> </span><span class="k" data-group-id="8685372946-1">do</span><span class="w">
  </span><span class="n">policy</span><span class="w"> </span><span class="n">always</span><span class="p" data-group-id="8685372946-2">(</span><span class="p" data-group-id="8685372946-2">)</span><span class="w"> </span><span class="k" data-group-id="8685372946-3">do</span><span class="w">
    </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">always</span><span class="p" data-group-id="8685372946-4">(</span><span class="p" data-group-id="8685372946-4">)</span><span class="w">
  </span><span class="k" data-group-id="8685372946-3">end</span><span class="w">
</span><span class="k" data-group-id="8685372946-1">end</span></code></pre><h3 id="using-expressions-in-field-policies">Using Expressions In Field Policies</h3><p>Unlike in regular policies, expressions in field policies cannot refer to related entities currently (except when using exists). Instead, you will need to create aggregates or expression calculations that return the results you want to reference.</p><p>In results, forbidden fields will be replaced with a special value: <code class="inline">%Ash.ForbiddenField{}</code>.</p><p>When these fields are referred to in filters, they will be replaced with an expression that evaluates to <code class="inline">nil</code>. To support this behavior, only simple and filter checks are allowed in field policies.</p><h3 id="handling-private-fields-in-internal-functions">Handling private fields in internal functions</h3><p>When calling internal functions like <a href="Ash.xhtml#read!/1"><code class="inline">Ash.read!/1</code></a>, private fields will by default always be shown.
Even if field policies apply to the resource. You can change the default behaviour by setting the
<code class="inline">private_fields</code> option on field policies.</p><pre><code class="makeup elixir" translate="no"><span class="n">field_policies</span><span class="w"> </span><span class="k" data-group-id="3277956402-1">do</span><span class="w">
  </span><span class="n">private_fields</span><span class="w"> </span><span class="ss">:include</span><span class="w">
</span><span class="k" data-group-id="3277956402-1">end</span></code></pre><p>The different options are:</p><ul><li><code class="inline">:show</code> will always show private fields</li><li><code class="inline">:hide</code> will always hide private fields</li><li><code class="inline">:include</code> will let you to write field policies for private fields and private fields
will be shown or hidden depending on the outcome of the policy</li></ul><p>If you want to overwrite the default option that is <code class="inline">:show</code>, you can do that by setting a global flag:</p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">:policies</span><span class="p">,</span><span class="w"> </span><span class="ss">private_fields</span><span class="p">:</span><span class="w"> </span><span class="ss">:include</span></code></pre><h2 id="references-to-related-data-fields">References to related data &amp; fields</h2><h3 id="calculations">Calculations</h3><p>The dependencies of a calculation do not have any authorization applied to them. This includes the dependencies loaded with <a href="Ash.Resource.Calculation.xhtml#c:load/3"><code class="inline">Ash.Resource.Calculation.load/3</code></a>, as well as any dependencies referenced in a calculation expression. To understand why this is the case, take the following calculation:</p><pre><code class="makeup elixir" translate="no"><span class="n">calculate</span><span class="w"> </span><span class="ss">:users_ssn_last_4</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="p">,</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="1352451519-1">(</span><span class="n">fragment</span><span class="p" data-group-id="1352451519-2">(</span><span class="s">&quot;RIGHT(?, 4)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="o">.</span><span class="n">ssn</span><span class="p" data-group-id="1352451519-2">)</span><span class="p" data-group-id="1352451519-1">)</span></code></pre><p>The <code class="inline">user</code> record may not be visible to the actor loading this calculation, and if it is, the <code class="inline">ssn</code> field may not be visible due to field policies. If calculations authorized access to their dependencies, you would <em>never</em> be able to write a calculation like the above.</p><h4>Aggregates</h4><p>Aggregates are the one exception to the above. Aggregates referenced <em>anywhere</em> will <em>always</em> authorize access to the related data they reference (unless <code class="inline">authorize?: false</code> is set when running the action). They will not, however, authorize references to the
actual field that they refer to. For example, you may not allow managers to see the email
of their team members, but they are allowed to know something like &quot;how many team members
have set up their email&quot;. So in an aggregate like the following:</p><pre><code class="makeup elixir" translate="no"><span class="n">aggregate</span><span class="w"> </span><span class="ss">:users_with_email</span><span class="p">,</span><span class="w"> </span><span class="ss">:count</span><span class="p">,</span><span class="w"> </span><span class="ss">:email</span></code></pre><p>if the field policies were applied to <code class="inline">:email</code>, that number would always show <code class="inline">0</code>,
because all <code class="inline">:email</code> attributes would appear to be <code class="inline">nil</code> to the manager.</p><h3 id="fields-annotated-as-input">Fields annotated as <code class="inline">input</code></h3><p>When you use <code class="inline">Ash.Query.filter_input</code> or <code class="inline">Ash.Query.sort_input</code> (which extensions like <code class="inline">AshGraphql</code> and <code class="inline">AshJsonApi</code> do when filters/sorts are provided by the user), the contained field references are annotated as <code class="inline">input</code>. The following rules are honored for field references annotated as <code class="inline">input</code> only. Per the above section, the <em>contents</em> of a calculation's expression referenced in filters are never annotated as <code class="inline">input</code>, although the calculation itself will be, so that you can write field policies on calculations.</p><h4>Relationship paths in filters</h4><p>When a field is referenced at a relationship path, the authorization rules for that related resource's primary read action (or the relationship's configured <code class="inline">:read_action</code>) will be applied to the filter as well. For example, say that you have a <code class="inline">User</code> resource, and a <code class="inline">Post</code> resource. The <code class="inline">User</code> resource can only be read by the actor if their id matches the user's id (i.e they can only read themselves).</p><p>These policies might look like this:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># on `User`</span><span class="w">
</span><span class="n">policy</span><span class="w"> </span><span class="n">action_type</span><span class="p" data-group-id="9548535068-1">(</span><span class="ss">:read</span><span class="p" data-group-id="9548535068-1">)</span><span class="w"> </span><span class="k" data-group-id="9548535068-2">do</span><span class="w">
  </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="9548535068-3">(</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="9548535068-4">(</span><span class="ss">:id</span><span class="p" data-group-id="9548535068-4">)</span><span class="p" data-group-id="9548535068-3">)</span><span class="w">
</span><span class="k" data-group-id="9548535068-2">end</span></code></pre><p>Given a filter like <code class="inline">Ash.Query.filter_input(Post, %{user: %{email: &quot;example@example.com&quot;}})</code>, the resulting filter expression would be:</p><pre><code class="makeup elixir" translate="no"><span class="n">expr</span><span class="p" data-group-id="1171295904-1">(</span><span class="w">
  </span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;example@example.com&quot;</span><span class="w"> </span><span class="ow">and</span><span class="w">
    </span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="1171295904-2">(</span><span class="ss">:id</span><span class="p" data-group-id="1171295904-2">)</span><span class="w">
</span><span class="p" data-group-id="1171295904-1">)</span></code></pre><p>This prevents a common security vulnerability that would allow malicious actors to &quot;sniff&quot; related data by providing filters over <code class="inline">User</code>, and seeing what <code class="inline">Post</code> records are returned.</p><h4>Field references in filters &amp; sorts</h4><p>When a field is referenced in filters or sorts, the field reference is replaced with a conditional, that evaluates to the field value if the actor is authorized to view the field, or <code class="inline">nil</code> otherwise (causing all conditions to evaluate to <code class="inline">false</code>).</p><p>Lets say that users have a field policy that only allows viewing the email address if the user's id matches the actor's id, similar to the abvoe example.</p><pre><code class="makeup elixir" translate="no"><span class="n">field_policies</span><span class="w"> </span><span class="k" data-group-id="6464997767-1">do</span><span class="w">
  </span><span class="n">field_policy</span><span class="w"> </span><span class="ss">:email</span><span class="p">,</span><span class="w"> </span><span class="n">always</span><span class="p" data-group-id="6464997767-2">(</span><span class="p" data-group-id="6464997767-2">)</span><span class="w"> </span><span class="k" data-group-id="6464997767-3">do</span><span class="w">
    </span><span class="n">authorize_if</span><span class="w"> </span><span class="n">expr</span><span class="p" data-group-id="6464997767-4">(</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="6464997767-5">(</span><span class="ss">:id</span><span class="p" data-group-id="6464997767-5">)</span><span class="p" data-group-id="6464997767-4">)</span><span class="w">
  </span><span class="k" data-group-id="6464997767-3">end</span><span class="w">
</span><span class="k" data-group-id="6464997767-1">end</span></code></pre><p>When that field is referenced in filters or sorts, like so: <code class="inline">Ash.Query.filter_input(Post, %{user: %{email: &quot;example@example.com&quot;}})</code>, the resulting expression would become:</p><pre><code class="makeup elixir" translate="no"><span class="n">expr</span><span class="p" data-group-id="7228020006-1">(</span><span class="w">
  </span><span class="k">if</span><span class="w"> </span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">^</span><span class="n">actor</span><span class="p" data-group-id="7228020006-2">(</span><span class="ss">:id</span><span class="p" data-group-id="7228020006-2">)</span><span class="w"> </span><span class="k" data-group-id="7228020006-3">do</span><span class="w">
    </span><span class="n">user</span><span class="o">.</span><span class="n">email</span><span class="w">
  </span><span class="k" data-group-id="7228020006-3">else</span><span class="w">
    </span><span class="no">nil</span><span class="w">
  </span><span class="k" data-group-id="7228020006-3">end</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;example@example.com&quot;</span><span class="w">
</span><span class="p" data-group-id="7228020006-1">)</span></code></pre><p>This prevents the same security vulnerability as described above, which would allow malicious actors to &quot;sniff&quot; field values that should not be visible to them by providing filters and/or sorts that reference that field.</p><h2 id="debugging-and-logging">Debugging and Logging</h2><h3 id="policy-breakdowns">Policy Breakdowns</h3><p>Policy breakdowns can be fetched on demand for a given forbidden error (either an <a href="Ash.Error.Forbidden.xhtml"><code class="inline">Ash.Error.Forbidden</code></a> that contains one or more <a href="Ash.Error.Forbidden.Policy.xhtml"><code class="inline">Ash.Error.Forbidden.Policy</code></a> errors, or an <a href="Ash.Error.Forbidden.Policy.xhtml"><code class="inline">Ash.Error.Forbidden.Policy</code></a> error itself), via <a href="Ash.Error.Forbidden.Policy.xhtml#report/2"><code class="inline">Ash.Error.Forbidden.Policy.report/2</code></a>.</p><p>Additionally, you can request that they be provided in the error message for all raised forbidden errors (without the help text), by setting</p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">:policies</span><span class="p">,</span><span class="w"> </span><span class="ss">show_policy_breakdowns?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span></code></pre><p>Here is an example policy breakdown from tests.</p><pre><code class="text">Policy Breakdown
A check status of `?` implies that the solver did not need to determine that check.
Some checks may look like they failed when in reality there was no need to check them.
Look for policies with `✘` and `✓` in check statuses.

A check with a `⬇` means that it didn't determine if the policy was authorized or forbidden, and so moved on to the next check.
`🌟` and `⛔` mean that the check was responsible for producing an authorized or forbidden (respectively) status.

If no check results in a status (they all have `⬇`) then the policy is assumed to have failed. In some cases, however, the policy
may have just been ignored, as described above.

  Admins and managers can create posts | ⛔:
    authorize if: actor.admin == true | ✘ | ⬇
    authorize if: actor.manager == true | ✘ | ⬇</code></pre><p>To remove the help text, you can pass the <code class="inline">help_text?: false</code> option, which would leave you with:</p><pre><code class="text">Policy Breakdown
  Admins and managers can create posts | ⛔:
    authorize if: actor.admin == true | ✘ | ⬇
    authorize if: actor.manager == true | ✘ | ⬇</code></pre><h3 id="including-in-error-messages">Including in error messages</h3><p><strong>IMPORTANT WARNING:</strong> The following configuration should only ever be used in development mode!</p><p>For security reasons, authorization errors don't include any extra information, aside from <code class="inline">forbidden</code>. To have authorization errors include a policy breakdown (without help text) use the following config.</p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">:policies</span><span class="p">,</span><span class="w"> </span><span class="ss">show_policy_breakdowns?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span></code></pre><h3 id="logging">Logging</h3><p>It is generally safe to log authorization error details, even in production. This can be very helpful when investigating certain classes of issue.</p><h4>Global Logging Configuration</h4><p>To have Ash automatically log each authorization failure, use</p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">:policies</span><span class="p">,</span><span class="w"> </span><span class="ss">log_policy_breakdowns</span><span class="p">:</span><span class="w"> </span><span class="ss">:error</span><span class="w"> </span><span class="c1"># Use whatever log level you&#39;d like to use here</span></code></pre><p>To have Ash log all policy breakdowns, even successful ones (this will be lots of noise, and should only be used for dev testing)</p><pre><code class="makeup elixir" translate="no"><span class="n">config</span><span class="w"> </span><span class="ss">:ash</span><span class="p">,</span><span class="w"> </span><span class="ss">:policies</span><span class="p">,</span><span class="w"> </span><span class="ss">log_successful_policy_breakdowns</span><span class="p">:</span><span class="w"> </span><span class="ss">:error</span><span class="w"> </span><span class="c1"># Use whatever log level you&#39;d like to use here</span></code></pre><h4>Per-Request Logging</h4><p>You can also enable logging for individual authorization checks by using the <code class="inline">log?</code> option with <a href="Ash.xhtml#can/3"><code class="inline">Ash.can/3</code></a> and <a href="Ash.xhtml#can?/3"><code class="inline">Ash.can?/3</code></a>:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># Log the authorization result for this specific check</span><span class="w">
</span><span class="nc">Ash</span><span class="o">.</span><span class="n">can?</span><span class="p" data-group-id="9508404518-1">(</span><span class="nc">Post</span><span class="p">,</span><span class="w"> </span><span class="ss">:read</span><span class="p">,</span><span class="w"> </span><span class="n">current_user</span><span class="p">,</span><span class="w"> </span><span class="ss">log?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9508404518-1">)</span><span class="w">

</span><span class="c1"># This will log at info level when authorization succeeds or fails</span><span class="w">
</span><span class="nc">MyDomain</span><span class="o">.</span><span class="n">can_read_post?</span><span class="p" data-group-id="9508404518-2">(</span><span class="n">current_user</span><span class="p">,</span><span class="w"> </span><span class="n">post</span><span class="p">,</span><span class="w"> </span><span class="ss">log?</span><span class="p">:</span><span class="w"> </span><span class="no">true</span><span class="p" data-group-id="9508404518-2">)</span></code></pre><p>When <code class="inline">log?: true</code> is set, authorization results will be logged at the <code class="inline">:info</code> level regardless of the global logging configuration. This is useful for debugging specific authorization issues without enabling verbose logging globally.</p>

  </body>
</html>
